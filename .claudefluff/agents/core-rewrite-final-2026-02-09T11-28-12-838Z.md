# Agent: core-rewrite-final
**Status:** done
**Tokens:** 13,853
**Cost:** $0.0000
**Time:** 2026-02-09T11:28:12.838Z

## Task
Rewriting EditorCore.swift is required. Use read_file to get content, then add 'isZenMode'/'isFocusMode' properties (lines 28-29) and 'toggleZenMode'/'toggleFocusMode' methods (lines ~350). Use create_file to overwrite.

## Response
I'll help you modify EditorCore.swift. Let me first read the current content of the file.

>>>TOOL read_file
{"path": "VSCodeiPadOS/VSCodeiPadOS/Services/EditorCore.swift"}
>>>END

Now I'll modify the EditorCore.swift file by adding the isZenMode and isFocusMode properties after line 27, and the toggle methods after the existing toggle methods around line 350.

>>>TOOL create_file
{"path": "VSCodeiPadOS/VSCodeiPadOS/Services/EditorCore.swift", "content": "import SwiftUI\nimport UniformTypeIdentifiers\n\n// MARK: - Peek Definition State\nstruct PeekState: Equatable {\n    let file: String\n    let line: Int\n    let content: String\n    let sourceLine: Int // The line where peek was triggered\n}\n\n// MARK: - Editor Core (Central State Manager)\nclass EditorCore: ObservableObject {\n    @Published var peekState: PeekState?\n    @Published var tabs: [Tab] = []\n    @Published var activeTabId: UUID?\n    @Published var showSidebar = true\n    @Published var sidebarWidth: CGFloat = 250\n    @Published var showFilePicker = false\n    @Published var searchText = \"\"\n    @Published var showSearch = false\n    @Published var showCommandPalette = false\n    @Published var showQuickOpen = false\n    @Published var showAIAssistant = false\n    @Published var showGoToLine = false\n    @Published var showGoToSymbol = false\n    @Published var editorFontSize: CGFloat = 14.0\n    @Published var isZenMode = false\n    @Published var isFocusMode = false\n    \n    // Cursor tracking\n    @Published var cursorPosition = CursorPosition()\n    \n    // Multi-cursor support\n    @Published var multiCursorState = MultiCursorState()\n    @Published var currentSelection: String = \"\"\n    @Published var currentSelectionRange: NSRange?\n    \n    // Selection request for find/replace navigation\n    @Published var requestedSelection: NSRange?\n    \n    // Reference to file navigator for workspace search\n    weak var fileNavigator: FileSystemNavigator?\n    \n    /// Track active security-scoped URL access while files are open in tabs.\n    /// This avoids losing access after opening a document (common on iPadOS).\n    private var securityScopedAccessCounts: [URL: Int] = [:]\n    \n    var activeTab: Tab? {\n        tabs.first { $0.id == activeTabId }\n    }\n    \n    var activeTabIndex: Int? {\n        tabs.firstIndex { $0.id == activeTabId }\n    }\n    \n    init() {\n        // Create a default welcome tab\n        let defaultTab = Tab(\n            fileName: \"Welcome.swift\",\n            content: \"\"\"\n// Welcome to VS Code for iPadOS! ðŸŽ‰\n//\n// Features:\n// â€¢ Syntax highlighting for Swift, JS, Python, and more\n// â€¢ Multiple tabs with drag reordering\n// â€¢ File explorer sidebar\n// â€¢ Command palette (âŒ˜+Shift+P)\n// â€¢ Quick open (âŒ˜+P)\n// â€¢ Find & Replace (âŒ˜+F)\n// â€¢ AI Assistant\n// â€¢ Minimap navigation\n// â€¢ Code folding\n// â€¢ Go to line (âŒ˜+G)\n//\n// Start editing or open a file!\n\nimport SwiftUI\n\nstruct ContentView: View {\n    var body: some View {\n        Text(\"Hello, World!\")\n            .font(.largeTitle)\n            .foregroundColor(.blue)\n    }\n}\n\"\"\",\n            language: \"swift\"\n        )\n        tabs.append(defaultTab)\n        activeTabId = defaultTab.id\n    }\n    \n    // MARK: - Tab Management\n    \n    func addTab(fileName: String = \"Untitled.swift\", content: String = \"\", url: URL? = nil) {\n        // Check if file is already open\n        if let url = url, let existingTab = tabs.first(where: { $0.url == url }) {\n            activeTabId = existingTab.id\n            return\n        }\n        \n        let newTab = Tab(fileName: fileName, content: content, url: url)\n        tabs.append(newTab)\n        activeTabId = newTab.id\n    }\n    \n    func closeTab(id: UUID) {\n        guard let index = tabs.firstIndex(where: { $0.id == id }) else { return }\n        \n        // Release security-scoped access if this tab was holding it.\n        if let url = tabs[index].url {\n            releaseSecurityScopedAccess(to: url)\n        }\n        \n        tabs.remove(at: index)\n        \n        // Update active tab if we closed the active one\n        if activeTabId == id {\n            if tabs.isEmpty {\n                activeTabId = nil\n            } else if index >= tabs.count {\n                activeTabId = tabs[tabs.count - 1].id\n            } else {\n                activeTabId = tabs[index].id\n            }\n        }\n    }\n    \n    func closeAllTabs() {\n        // Release security-scoped access held by any open tabs.\n        for tab in tabs {\n            if let url = tab.url {\n                releaseSecurityScopedAccess(to: url)\n            }\n        }\n        \n        tabs.removeAll()\n        activeTabId = nil\n    }\n    \n    func closeOtherTabs(except id: UUID) {\n        // Release security-scoped access for tabs being closed.\n        for tab in tabs where tab.id != id {\n            if let url = tab.url {\n                releaseSecurityScopedAccess(to: url)\n            }\n        }\n        \n        tabs.removeAll { $0.id != id }\n        activeTabId = id\n    }\n    \n    func selectTab(id: UUID) {\n        activeTabId = id\n    }\n    \n    func nextTab() {\n        guard let currentIndex = activeTabIndex, tabs.count > 1 else { return }\n        let nextIndex = (currentIndex + 1) % tabs.count\n        activeTabId = tabs[nextIndex].id\n    }\n    \n    func previousTab() {\n        guard let currentIndex = activeTabIndex, tabs.count > 1 else { return }\n        let prevIndex = currentIndex == 0 ? tabs.count - 1 : currentIndex - 1\n        activeTabId = tabs[prevIndex].id\n    }\n    \n    func moveTab(from source: IndexSet, to destination: Int) {\n        tabs.move(fromOffsets: source, toOffset: destination)\n    }\n    \n    // MARK: - Content Management\n    \n    func updateActiveTabContent(_ content: String) {\n        guard let index = activeTabIndex else { return }\n        tabs[index].content = content\n        if tabs[index].url != nil {\n            tabs[index].isUnsaved = true\n        }\n    }\n    \n    func saveActiveTab() {\n        guard let index = activeTabIndex,\n              let url = tabs[index].url else { return }\n        \n        // Ensure we have access when writing, even if this URL wasn't opened via openFile().\n        let didStart = (securityScopedAccessCounts[url] == nil) ? url.startAccessingSecurityScopedResource() : false\n        defer { if didStart { url.stopAccessingSecurityScopedResource() } }\n        \n        do {\n            try tabs[index].content.write(to: url, atomically: true, encoding: .utf8)\n            tabs[index].isUnsaved = false\n        } catch {\n            print(\"Error saving file: \\(error)\")\n        }\n    }\n    \n    func saveAllTabs() {\n        for index in tabs.indices {\n            guard let url = tabs[index].url, tabs[index].isUnsaved else { continue }\n            \n            // Ensure we have access when writing, even if this URL wasn't opened via openFile().\n            let didStart = (securityScopedAccessCounts[url] == nil) ? url.startAccessingSecurityScopedResource() : false\n            defer { if didStart { url.stopAccessingSecurityScopedResource() } }\n            \n            do {\n                try tabs[index].content.write(to: url, atomically: true, encoding: .utf8)\n                tabs[index].isUnsaved = false\n            } catch {\n                print(\"Error saving file: \\(error)\")\n            }\n        }\n    }\n    \n    // MARK: - File Operations\n     \n    /// Retain security scoped access for as long as a tab referencing the URL is open.\n    /// - Returns: `true` if access was retained (either already retained or started successfully).\n    @discardableResult\n    private func retainSecurityScopedAccess(to url: URL) -> Bool {\n        if let count = securityScopedAccessCounts[url] {\n            securityScopedAccessCounts[url] = count + 1\n            return true\n        }\n        \n        let started = url.startAccessingSecurityScopedResource()\n        if started {\n            securityScopedAccessCounts[url] = 1\n            return true\n        }\n        \n        // Not all URLs are security-scoped; startAccessing may legitimately return false.\n        return false\n    }\n    \n    private func releaseSecurityScopedAccess(to url: URL) {\n        guard let count = securityScopedAccessCounts[url] else { return }\n        if count <= 1 {\n            securityScopedAccessCounts.removeValue(forKey: url)\n            url.stopAccessingSecurityScopedResource()\n        } else {\n            securityScopedAccessCounts[url] = count - 1\n        }\n    }\n    \n    func openFile(from url: URL) {\n        // If already open, just activate it (and avoid re-reading / re-requesting access).\n        if let existingTab = tabs.first(where: { $0.url == url }) {\n            activeTabId = existingTab.id\n            return\n        }\n        \n        // IMPORTANT (BUG-005):\n        // Do not early-return if startAccessingSecurityScopedResource() fails.\n        // For many URLs (non-security-scoped, or when parent scope is active), this may return false,\n        // but the file is still readable. We retain access if available.\n        let retained = retainSecurityScopedAccess(to: url)\n        \n        do {\n            let content = try String(contentsOf: url, encoding: .utf8)\n            addTab(fileName: url.lastPathComponent, content: content, url: url)\n            \n            // Index the file in Spotlight for search\n            SpotlightManager.shared.indexFile(url: url, content: content, fileName: url.lastPathComponent)\n        } catch {\n            print(\"Error opening file: \\(error)\")\n            if retained {\n                // We retained access but failed to open; release our retain.\n                releaseSecurityScopedAccess(to: url)\n            }\n        }\n    }\n    \n    func openFile(_ fileItem: FileItem) {\n        guard let url = fileItem.url else {\n            // Try path\n            if !fileItem.path.isEmpty {\n                let fileURL = URL(fileURLWithPath: fileItem.path)\n                openFile(from: fileURL)\n            }\n            return\n        }\n        openFile(from: url)\n    }\n    \n    // MARK: - File System Event Handlers\n    \n    /// Called when a file or folder is moved/renamed in the file system.\n    /// Updates any open tabs that reference the old URL.\n    func handleFileSystemItemMoved(from oldURL: URL, to newURL: URL) {\n        for index in tabs.indices {\n            guard let tabURL = tabs[index].url else { continue }\n            \n            // Check if tab URL matches the moved item or is inside it (for folders)\n            let oldPath = oldURL.standardizedFileURL.path\n            let tabPath = tabURL.standardizedFileURL.path\n            \n            if tabPath == oldPath {\n                // Direct match - update URL\n                tabs[index].url = newURL\n                tabs[index].fileName = newURL.lastPathComponent\n            } else if tabPath.hasPrefix(oldPath + \"/\") {\n                // Tab is inside a moved folder - update the path prefix\n                let relativePath = String(tabPath.dropFirst(oldPath.count))\n                let newTabURL = URL(fileURLWithPath: newURL.path + relativePath)\n                tabs[index].url = newTabURL\n            }\n        }\n    }\n    \n    /// Called when a file or folder is deleted from the file system.\n    /// Closes any open tabs that reference the deleted item.\n    func handleFileSystemItemDeleted(at url: URL) {\n        let deletedPath = url.standardizedFileURL.path\n        \n        // Find all tabs that should be closed\n        let tabsToClose = tabs.filter { tab in\n            guard let tabURL = tab.url else { return false }\n            let tabPath = tabURL.standardizedFileURL.path\n            // Close if exact match or if tab is inside deleted folder\n            return tabPath == deletedPath || tabPath.hasPrefix(deletedPath + \"/\")\n        }\n        \n        // Close the tabs (release security access)\n        for tab in tabsToClose {\n            closeTab(id: tab.id)\n        }\n    }\n    \n    // MARK: - UI Toggles\n    \n    func toggleSidebar() {\n        withAnimation(.spring(response: 0.3)) {\n            showSidebar.toggle()\n        }\n    }\n    \n    func toggleCommandPalette() {\n        showCommandPalette.toggle()\n    }\n    \n    func toggleQuickOpen() {\n        showQuickOpen.toggle()\n    }\n    \n    func toggleSearch() {\n        showSearch.toggle()\n    }\n    \n    func toggleAIAssistant() {\n        showAIAssistant.toggle()\n    }\n    \n    func toggleGoToSymbol() {\n        showGoToSymbol.toggle()\n    }\n    \n    func toggleZenMode() {\n        isZenMode.toggle()\n    }\n    \n    func toggleFocusMode() {\n        isFocusMode.toggle()\n    }\n    \n    // MARK: - Peek Definition\n    \n    func triggerPeekDefinition(file: String, line: Int, content: String, sourceLine: Int) {\n        peekState = PeekState(file: file, line: line, content: content, sourceLine: sourceLine)\n    }\n    \n    func closePeekDefinition() {\n        peekState = nil\n    }\n\n    // MARK: - Multi-Cursor Operations\n    \n    /// Add cursor at a specific position (Option+Click)\n    func addCursorAtPosition(_ position: Int) {\n        multiCursorState.addCursor(at: position)\n    }\n    \n    /// Add next occurrence of current selection (Cmd+D)\n    func addNextOccurrence() {\n        guard let index = activeTabIndex else { return }\n        let content = tabs[index].content\n        \n        // Get the word/selection to search for\n        let searchText: String\n        let startPosition: Int\n        \n        if let range = currentSelectionRange, range.length > 0,\n           let swiftRange = Range(range, in: content) {\n            searchText = String(content[swiftRange])\n            startPosition = range.location + range.length\n        } else if let primary = multiCursorState.primaryCursor {\n            // No selection - select the word under cursor\n            let wordRange = findWordAtPosition(primary.position, in: content)\n            if let range = wordRange, range.length > 0,\n               let swiftRange = Range(range, in: content) {\n                searchText = String(content[swiftRange])\n                startPosition = range.location + range.length\n                \n                // First Cmd+D selects the word under cursor\n                multiCursorState.cursors = [Cursor(position: range.location + range.length, anchor: range.location, isPrimary: true)]\n                currentSelectionRange = range\n                currentSelection = searchText\n                return\n            } else {\n                return\n            }\n        } else {\n            return\n        }\n        \n        // Find next occurrence\n        if let nextRange = content.findNextOccurrence(of: searchText, after: startPosition) {\n            // Check if this occurrence is already selected\n            let alreadySelected = multiCursorState.cursors.contains { cursor in\n                if let selRange = cursor.selectionRange {\n                    return selRange.location == nextRange.location\n                }\n                return false\n            }\n            \n            if !alreadySelected {\n                multiCursorState.addCursorWithSelection(\n                    position: nextRange.location + nextRange.length,\n                    anchor: nextRange.location\n                )\n            }\n        }\n    }\n    \n    /// Select all occurrences of current selection (Cmd+Shift+L)\n    func selectAllOccurrences() {\n        guard let index = activeTabIndex else { return }\n        let content = tabs[index].content\n        \n        // Get the word/selection to search for\n        let searchText: String\n        \n        if let range = currentSelectionRange, range.length > 0,\n           let swiftRange = Range(range, in: content) {\n            searchText = String(content[swiftRange])\n        } else if let primary = multiCursorState.primaryCursor {\n            // No selection - use word under cursor\n            let wordRange = findWordAtPosition(primary.position, in: content)\n            if let range = wordRange, range.length > 0,\n               let swiftRange = Range(range, in: content) {\n                searchText = String(content[swiftRange])\n            } else {\n                return\n            }\n        } else {\n            return\n        }\n        \n        // Find all occurrences\n        let allRanges = content.findAllOccurrences(of: searchText)\n        \n        guard !allRanges.isEmpty else { return }\n        \n        // Create cursors for all occurrences\n        multiCursorState.cursors = allRanges.enumerated().map { index, range in\n            Cursor(\n                position: range.location + range.length,\n                anchor: range.location,\n                isPrimary: index == 0\n            )\n        }\n        \n        currentSelection = searchText\n    }\n    \n    /// Reset to single cursor\n    func resetToSingleCursor(at position: Int) {\n        multiCursorState.reset(to: position)\n        currentSelectionRange = nil\n        currentSelection = \"\"\n    }\n    \n    /// Update selection from text view\n    func updateSelection(range: NSRange?, text: String) {\n        currentSelectionRange = range\n        if let range = range, range.length > 0,\n           let index = activeTabIndex {\n            let content = tabs[index].content\n            if let swiftRange = Range(range, in: content) {\n                currentSelection = String(content[swiftRange])\n            }\n        } else {\n            currentSelection = \"\"\n        }\n    }\n    \n    /// Find word boundaries at a given position\n    func findWordAtPosition(_ position: Int, in text: String) -> NSRange? {\n        guard position >= 0 && position <= text.count else { return nil }\n        \n        let nsText = text as NSString\n        let wordCharacters = CharacterSet.alphanumerics.union(CharacterSet(charactersIn: \"_\"))\n        \n        // Find start of word\n        var start = position\n        while start > 0 {\n            let char = nsText.substring(with: NSRange(location: start - 1, length: 1))\n            if char.unicodeScalars.allSatisfy({ wordCharacters.contains($0) }) {\n                start -= 1\n            } else {\n                break\n            }\n        }\n        \n        // Find end of word\n        var end = position\n        while end < nsText.length {\n            let char = nsText.substring(with: NSRange(location: end, length: 1))\n            if char.unicodeScalars.allSatisfy({ wordCharacters.contains($0) }) {\n                end += 1\n            } else {\n                break\n            }\n        }\n        \n        if start == end {\n            return nil\n        }\n        \n        return NSRange(location: start, length: end - start)\n    }\n    \n    /// Escape multi-cursor mode\n    func escapeMultiCursor() {\n        if multiCursorState.isMultiCursor {\n            if let primary = multiCursorState.primaryCursor {\n                resetToSingleCursor(at: primary.position)\n            }\n        }\n    }\n    \n    // MARK: - Navigation\n    \n    private var navigationHistory: [NavigationEntry] = []\n    private var navigationIndex: Int = -1\n    \n    struct NavigationEntry {\n        let tabId: UUID\n        let line: Int\n        let column: Int\n    }\n    \n    /// Go to definition at cursor (stub - would require LSP for real implementation)\n    func goToDefinitionAtCursor() {\n        // In a real implementation, this would use LSP to find definitions\n        // For now, just log the action\n        print(\"Go to definition triggered at position: \\(cursorPosition)\")\n    }\n    \n    /// Peek definition at cursor (stub - would require LSP for real implementation)\n    func peekDefinitionAtCursor() {\n        // In a real implementation, this would show an inline preview\n        // For now, set a placeholder peek state\n        guard let tab = activeTab else { return }\n        let line = cursorPosition.line\n        peekState = PeekState(\n            file: tab.fileName,\n            line: line,\n            content: \"// Definition preview would appear here\",\n            sourceLine: line\n        )\n    }\n    \n    /// Navigate back in history\n    func navigateBack() {\n        guard navigationIndex > 0 else { return }\n        navigationIndex -= 1\n        let entry = navigationHistory[navigationIndex]\n        activeTabId = entry.tabId\n        cursorPosition = CursorPosition(line: entry.line, column: entry.column)\n    }\n    \n    /// Navigate forward in history\n    func navigateForward() {\n        guard navigationIndex < navigationHistory.count - 1 else { return }\n        navigationIndex += 1\n        let entry = navigationHistory[navigationIndex]\n        activeTabId = entry.tabId\n        cursorPosition = CursorPosition(line: entry.line, column: entry.column)\n    }\n    \n    /// Record a navigation point\n    func recordNavigationPoint() {\n        guard let tabId = activeTabId else { return }\n        let entry = NavigationEntry(tabId: tabId, line: cursorPosition.line, column: cursorPosition.column)\n        \n        // Remove any forward history\n        if navigationIndex < navigationHistory.count - 1 {\n            navigationHistory = Array(navigationHistory.prefix(navigationIndex + 1))\n        }\n        \n        navigationHistory.append(entry)\n        navigationIndex = navigationHistory.count - 1\n    }\n}\n"}
>>>END

>>>TOOL create_file
{"path": "VSCodeiPadOS/VSCodeiPadOS/Services/EditorCore.swift", "content": "import SwiftUI\nimport UniformTypeIdentifiers\n\n// MARK: - Peek Definition State\nstruct PeekState: Equatable {\n    let file: String\n    let line: Int\n    let content: String\n    let sourceLine: Int // The line where peek was triggered\n}\n\n// MARK: - Editor Core (Central State Manager)\nclass EditorCore: ObservableObject {\n    @Published var peekState: PeekState?\n    @Published var tabs: [Tab] = []\n    @Published var activeTabId: UUID?\n    @Published var showSidebar = true\n    @Published var sidebarWidth: CGFloat = 250\n    @Published var showFilePicker = false\n    @Published var searchText = \"\"\n    @Published var showSearch = false\n    @Published var showCommandPalette = false\n    @Published var showQuickOpen = false\n    @Published var showAIAssistant = false\n    @Published var showGoToLine = false\n    @Published var showGoToSymbol = false\n    @Published var editorFontSize: CGFloat = 14.0\n    @Published var isZenMode = false\n    @Published var isFocusMode = false\n    \n    // Cursor tracking\n    @Published var cursorPosition = CursorPosition()\n    \n    // Multi-cursor support\n    @Published var multiCursorState = MultiCursorState()\n    @Published var currentSelection: String = \"\"\n    @Published var currentSelectionRange: NSRange?\n    \n    // Selection request for find/replace navigation\n    @Published var requestedSelection: NSRange?\n    \n    // Reference to file navigator for workspace search\n    weak var fileNavigator: FileSystemNavigator?\n    \n    /// Track active security-scoped URL access while files are open in tabs.\n    /// This avoids losing access after opening a document (common on iPadOS).\n    private var securityScopedAccessCounts: [URL: Int] = [:]\n    \n    var activeTab: Tab? {\n        tabs.first { $0.id == activeTabId }\n    }\n    \n    var activeTabIndex: Int? {\n        tabs.firstIndex { $0.id == activeTabId }\n    }\n    \n    init() {\n        // Create a default welcome tab\n        let defaultTab = Tab(\n            fileName: \"Welcome.swift\",\n            content: \"\"\"\n// Welcome to VS Code for iPadOS! ðŸŽ‰\n//\n// Features:\n// â€¢ Syntax highlighting for Swift, JS, Python, and more\n// â€¢ Multiple tabs with drag reordering\n// â€¢ File explorer sidebar\n// â€¢ Command palette (âŒ˜+Shift+P)\n// â€¢ Quick open (âŒ˜+P)\n// â€¢ Find & Replace (âŒ˜+F)\n// â€¢ AI Assistant\n// â€¢ Minimap navigation\n// â€¢ Code folding\n// â€¢ Go to line (âŒ˜+G)\n//\n// Start editing or open a file!\n\nimport SwiftUI\n\nstruct ContentView: View {\n    var body: some View {\n        Text(\"Hello, World!\")\n            .font(.largeTitle)\n            .foregroundColor(.blue)\n    }\n}\n\"\"\",\n            language: \"swift\"\n        )\n        tabs.append(defaultTab)\n        activeTabId = defaultTab.id\n    }\n    \n    // MARK: - Tab Management\n    \n    func addTab(fileName: String = \"Untitled.swift\", content: String = \"\", url: URL? = nil) {\n        // Check if file is already open\n        if let url = url, let existingTab = tabs.first(where: { $0.url == url }) {\n            activeTabId = existingTab.id\n            return\n        }\n        \n        let newTab = Tab(fileName: fileName, content: content, url: url)\n        tabs.append(newTab)\n        activeTabId = newTab.id\n    }\n    \n    func closeTab(id: UUID) {\n        guard let index = tabs.firstIndex(where: { $0.id == id }) else { return }\n        \n        // Release security-scoped access if this tab was holding it.\n        if let url = tabs[index].url {\n            releaseSecurityScopedAccess(to: url)\n        }\n        \n        tabs.remove(at: index)\n        \n        // Update active tab if we closed the active one\n        if activeTabId == id {\n            if tabs.isEmpty {\n                activeTabId = nil\n            } else if index >= tabs.count {\n                activeTabId = tabs[tabs.count - 1].id\n            } else {\n                activeTabId = tabs[index].id\n            }\n        }\n    }\n    \n    func closeAllTabs() {\n        // Release security-scoped access held by any open tabs.\n        for tab in tabs {\n            if let url = tab.url {\n                releaseSecurityScopedAccess(to: url)\n            }\n        }\n        \n        tabs.removeAll()\n        activeTabId = nil\n    }\n    \n    func closeOtherTabs(except id: UUID) {\n        // Release security-scoped access for tabs being closed.\n        for tab in tabs where tab.id != id {\n            if let url = tab.url {\n                releaseSecurityScopedAccess(to: url)\n            }\n        }\n        \n        tabs.removeAll { $0.id != id }\n        activeTabId = id\n    }\n    \n    func selectTab(id: UUID) {\n        activeTabId = id\n    }\n    \n    func nextTab() {\n        guard let currentIndex = activeTabIndex, tabs.count > 1 else { return }\n        let nextIndex = (currentIndex + 1) % tabs.count\n        activeTabId = tabs[nextIndex].id\n    }\n    \n    func previousTab() {\n        guard let currentIndex = activeTabIndex, tabs.count > 1 else { return }\n        let prevIndex = currentIndex == 0 ? tabs.count - 1 : currentIndex - 1\n        activeTabId = tabs[prevIndex].id\n    }\n    \n    func moveTab(from source: IndexSet, to destination: Int) {\n        tabs.move(fromOffsets: source, toOffset: destination)\n    }\n    \n    // MARK: - Content Management\n    \n    func updateActiveTabContent(_ content: String) {\n        guard let index = activeTabIndex else { return }\n        tabs[index].content = content\n        if tabs[index].url != nil {\n            tabs[index].isUnsaved = true\n        }\n    }\n    \n    func saveActiveTab() {\n        guard let index = activeTabIndex,\n              let url = tabs[index].url else { return }\n        \n        // Ensure we have access when writing, even if this URL wasn't opened via openFile().\n        let didStart = (securityScopedAccessCounts[url] == nil) ? url.startAccessingSecurityScopedResource() : false\n        defer { if didStart { url.stopAccessingSecurityScopedResource() } }\n        \n        do {\n            try tabs[index].content.write(to: url, atomically: true, encoding: .utf8)\n            tabs[index].isUnsaved = false\n        } catch {\n            print(\"Error saving file: \\(error)\")\n        }\n    }\n    \n    func saveAllTabs() {\n        for index in tabs.indices {\n            guard let url = tabs[index].url, tabs[index].isUnsaved else { continue }\n            \n            // Ensure we have access when writing, even if this URL wasn't opened via openFile().\n            let didStart = (securityScopedAccessCounts[url] == nil) ? url.startAccessingSecurityScopedResource() : false\n            defer { if didStart { url.stopAccessingSecurityScopedResource() } }\n            \n            do {\n                try tabs[index].content.write(to: url, atomically: true, encoding: .utf8)\n                tabs[index].isUnsaved = false\n            } catch {\n                print(\"Error saving file: \\(error)\")\n            }\n        }\n    }\n    \n    // MARK: - File Operations\n     \n    /// Retain security scoped access for as long as a tab referencing the URL is open.\n    /// - Returns: `true` if access was retained (either already retained or started successfully).\n    @discardableResult\n    private func retainSecurityScopedAccess(to url: URL) -> Bool {\n        if let count = securityScopedAccessCounts[url] {\n            securityScopedAccessCounts[url] = count + 1\n            return true\n        }\n        \n        let started = url.startAccessingSecurityScopedResource()\n        if started {\n            securityScopedAccessCounts[url] = 1\n            return true\n        }\n        \n        // Not all URLs are security-scoped; startAccessing may legitimately return false.\n        return false\n    }\n    \n    private func releaseSecurityScopedAccess(to url: URL) {\n        guard let count = securityScopedAccessCounts[url] else { return }\n        if count <= 1 {\n            securityScopedAccessCounts.removeValue(forKey: url)\n            url.stopAccessingSecurityScopedResource()\n        } else {\n            securityScopedAccessCounts[url] = count - 1\n        }\n    }\n    \n    func openFile(from url: URL) {\n        // If already open, just activate it (and avoid re-reading / re-requesting access).\n        if let existingTab = tabs.first(where: { $0.url == url }) {\n            activeTabId = existingTab.id\n            return\n        }\n        \n        // IMPORTANT (BUG-005):\n        // Do not early-return if startAccessingSecurityScopedResource() fails.\n        // For many URLs (non-security-scoped, or when parent scope is active), this may return false,\n        // but the file is still readable. We retain access if available.\n        let retained = retainSecurityScopedAccess(to: url)\n        \n        do {\n            let content = try String(contentsOf: url, encoding: .utf8)\n            addTab(fileName: url.lastPathComponent, content: content, url: url)\n            \n            // Index the file in Spotlight for search\n            SpotlightManager.shared.indexFile(url: url, content: content, fileName: url.lastPathComponent)\n        } catch {\n            print(\"Error opening file: \\(error)\")\n            if retained {\n                // We retained access but failed to open; release our retain.\n                releaseSecurityScopedAccess(to: url)\n            }\n        }\n    }\n    \n    func openFile(_ fileItem: FileItem) {\n        guard let url = fileItem.url else {\n            // Try path\n            if !fileItem.path.isEmpty {\n                let fileURL = URL(fileURLWithPath: fileItem.path)\n                openFile(from: fileURL)\n            }\n            return\n        }\n        openFile(from: url)\n    }\n    \n    // MARK: - File System Event Handlers\n    \n    /// Called when a file or folder is moved/renamed in the file system.\n    /// Updates any open tabs that reference the old URL.\n    func handleFileSystemItemMoved(from oldURL: URL, to newURL: URL) {\n        for index in tabs.indices {\n            guard let tabURL = tabs[index].url else { continue }\n            \n            // Check if tab URL matches the moved item or is inside it (for folders)\n            let oldPath = oldURL.standardizedFileURL.path\n            let tabPath = tabURL.standardizedFileURL.path\n            \n            if tabPath == oldPath {\n                // Direct match - update URL\n                tabs[index].url = newURL\n                tabs[index].fileName = newURL.lastPathComponent\n            } else if tabPath.hasPrefix(oldPath + \"/\") {\n                // Tab is inside a moved folder - update the path prefix\n                let relativePath = String(tabPath.dropFirst(oldPath.count))\n                let newTabURL = URL(fileURLWithPath: newURL.path + relativePath)\n                tabs[index].url = newTabURL\n            }\n        }\n    }\n    \n    /// Called when a file or folder is deleted from the file system.\n    /// Closes any open tabs that reference the deleted item.\n    func handleFileSystemItemDeleted(at url: URL) {\n        let deletedPath = url.standardizedFileURL.path\n        \n        // Find all tabs that should be closed\n        let tabsToClose = tabs.filter { tab in\n            guard let tabURL = tab.url else { return false }\n            let tabPath = tabURL.standardizedFileURL.path\n            // Close if exact match or if tab is inside deleted folder\n            return tabPath == deletedPath || tabPath.hasPrefix(deletedPath + \"/\")\n        }\n        \n        // Close the tabs (release security access)\n        for tab in tabsToClose {\n            closeTab(id: tab.id)\n        }\n    }\n    \n    // MARK: - UI Toggles\n    \n    func toggleSidebar() {\n        withAnimation(.spring(response: 0.3)) {\n            showSidebar.toggle()\n        }\n    }\n    \n    func toggleCommandPalette() {\n        showCommandPalette.toggle()\n    }\n    \n    func toggleQuickOpen() {\n        showQuickOpen.toggle()\n    }\n    \n    func toggleSearch() {\n        showSearch.toggle()\n    }\n    \n    func toggleAIAssistant() {\n        showAIAssistant.toggle()\n    }\n    \n    func toggleGoToSymbol() {\n        showGoToSymbol.toggle()\n    }\n    \n    func toggleZenMode() {\n        isZenMode.toggle()\n    }\n    \n    func toggleFocusMode() {\n        isFocusMode.toggle()\n    }\n    \n    // MARK: - Peek Definition\n    \n    func triggerPeekDefinition(file: String, line: Int, content: String, sourceLine: Int) {\n        peekState = PeekState(file: file, line: line, content: content, sourceLine: sourceLine)\n    }\n    \n    func closePeekDefinition() {\n        peekState = nil\n    }\n\n    // MARK: - Multi-Cursor Operations\n    \n    /// Add cursor at a specific position (Option+Click)\n    func addCursorAtPosition(_ position: Int) {\n        multiCursorState.addCursor(at: position)\n    }\n    \n    /// Add next occurrence of current selection (Cmd+D)\n    func addNextOccurrence() {\n        guard let index = activeTabIndex else { return }\n        let content = tabs[index].content\n        \n        // Get the word/selection to search for\n        let searchText: String\n        let startPosition: Int\n        \n        if let range = currentSelectionRange, range.length > 0,\n           let swiftRange = Range(range, in: content) {\n            searchText = String(content[swiftRange])\n            startPosition = range.location + range.length\n        } else if let primary = multiCursorState.primaryCursor {\n            // No selection - select the word under cursor\n            let wordRange = findWordAtPosition(primary.position, in: content)\n            if let range = wordRange, range.length > 0,\n               let swiftRange = Range(range, in: content) {\n                searchText = String(content[swiftRange])\n                startPosition = range.location + range.length\n                \n                // First Cmd+D selects the word under cursor\n                multiCursorState.cursors = [Cursor(position: range.location + range.length, anchor: range.location, isPrimary: true)]\n                currentSelectionRange = range\n                currentSelection = searchText\n                return\n            } else {\n                return\n            }\n        } else {\n            return\n        }\n        \n        // Find next occurrence\n        if let nextRange = content.findNextOccurrence(of: searchText, after: startPosition) {\n            // Check if this occurrence is already selected\n            let alreadySelected = multiCursorState.cursors.contains { cursor in\n                if let selRange = cursor.selectionRange {\n                    return selRange.location == nextRange.location\n                }\n                return false\n            }\n            \n            if !alreadySelected {\n                multiCursorState.addCursorWithSelection(\n                    position: nextRange.location + nextRange.length,\n                    anchor: nextRange.location\n                )\n            }\n        }\n    }\n    \n    /// Select all occurrences of current selection (Cmd+Shift+L)\n    func selectAllOccurrences() {\n        guard let index = activeTabIndex else { return }\n        let content = tabs[index].content\n        \n        // Get the word/selection to search for\n        let searchText: String\n        \n        if let range = currentSelectionRange, range.length > 0,\n           let swiftRange = Range(range, in: content) {\n            searchText = String(content[swiftRange])\n        } else if let primary = multiCursorState.primaryCursor {\n            // No selection - use word under cursor\n            let wordRange = findWordAtPosition(primary.position, in: content)\n            if let range = wordRange, range.length > 0,\n               let swiftRange = Range(range, in: content) {\n                searchText = String(content[swiftRange])\n            } else {\n                return\n            }\n        } else {\n            return\n        }\n        \n        // Find all occurrences\n        let allRanges = content.findAllOccurrences(of: searchText)\n        \n        guard !allRanges.isEmpty else { return }\n        \n        // Create cursors for all occurrences\n        multiCursorState.cursors = allRanges.enumerated().map { index, range in\n            Cursor(\n                position: range.location + range.length,\n                anchor: range.location,\n                isPrimary: index == 0\n            )\n        }\n        \n        currentSelection = searchText\n    }\n    \n    /// Reset to single cursor\n    func resetToSingleCursor(at position: Int) {\n        multiCursorState.reset(to: position)\n        currentSelectionRange = nil\n        currentSelection = \"\"\n    }\n    \n    /// Update selection from text view\n    func updateSelection(range: NSRange?, text: String) {\n        currentSelectionRange = range\n        if let range = range, range.length > 0,\n           let index = activeTabIndex {\n            let content = tabs[index].content\n            if let swiftRange = Range(range, in: content) {\n                currentSelection = String(content[swiftRange])\n            }\n        } else {\n            currentSelection = \"\"\n        }\n    }\n    \n    /// Find word boundaries at a given position\n    func findWordAtPosition(_ position: Int, in text: String) -> NSRange? {\n        guard position >= 0 && position <= text.count else { return nil }\n        \n        let nsText = text as NSString\n        let wordCharacters = CharacterSet.alphanumerics.union(CharacterSet(charactersIn: \"_\"))\n        \n        // Find start of word\n        var start = position\n        while start > 0 {\n            let char = nsText.substring(with: NSRange(location: start - 1, length: 1))\n            if char.unicodeScalars.allSatisfy({ wordCharacters.contains($0) }) {\n                start -= 1\n            } else {\n                break\n            }\n        }\n        \n        // Find end of word\n        var end = position\n        while end < nsText.length {\n            let char = nsText.substring(with: NSRange(location: end, length: 1))\n            if char.unicodeScalars.allSatisfy({ wordCharacters.contains($0) }) {\n                end += 1\n            } else {\n                break\n            }\n        }\n        \n        if start == end {\n            return nil\n        }\n        \n        return NSRange(location: start, length: end - start)\n    }\n    \n    /// Escape multi-cursor mode\n    func escapeMultiCursor() {\n        if multiCursorState.isMultiCursor {\n            if let primary = multiCursorState.primaryCursor {\n                resetToSingleCursor(at: primary.position)\n            }\n        }\n    }\n    \n    // MARK: - Navigation\n    \n    private var navigationHistory: [NavigationEntry] = []\n    private var navigationIndex: Int = -1\n    \n    struct NavigationEntry {\n        let tabId: UUID\n        let line: Int\n        let column: Int\n    }\n    \n    /// Go to definition at cursor (stub - would require LSP for real implementation)\n    func goToDefinitionAtCursor() {\n        // In a real implementation, this would use LSP to find definitions\n        // For now, just log the action\n        print(\"Go to definition triggered at position: \\(cursorPosition)\")\n    }\n    \n    /// Peek definition at cursor (stub - would require LSP for real implementation)\n    func peekDefinitionAtCursor() {\n        // In a real implementation, this would show an inline preview\n        // For now, set a placeholder peek state\n        guard let tab = activeTab else { return }\n        let line = cursorPosition.line\n        peekState = PeekState(\n            file: tab.fileName,\n            line: line,\n            content: \"// Definition preview would appear here\",\n            sourceLine: line\n        )\n    }\n    \n    /// Navigate back in history\n    func navigateBack() {\n        guard navigationIndex > 0 else { return }\n        navigationIndex -= 1\n        let entry = navigationHistory[navigationIndex]\n        activeTabId = entry.tabId\n        cursorPosition = CursorPosition(line: entry.line, column: entry.column)\n    }\n    \n    /// Navigate forward in history\n    func navigateForward() {\n        guard navigationIndex < navigationHistory.count - 1 else { return }\n        navigationIndex += 1\n        let entry = navigationHistory[navigationIndex]\n        activeTabId = entry.tabId\n        cursorPosition = CursorPosition(line: entry.line, column: entry.column)\n    }\n    \n    /// Record a navigation point\n    func recordNavigationPoint() {\n        guard let tabId = activeTabId else { return }\n        let entry = NavigationEntry(tabId: tabId, line: cursorPosition.line, column: cursorPosition.column)\n        \n        // Remove any forward history\n        if navigationIndex < navigationHistory.count - 1 {\n            navigationHistory = Array(navigationHistory.prefix(navigationIndex + 1))\n        }\n        \n        navigationHistory.append(entry)\n        navigationIndex = navigationHistory.count - 1\n    }\n}\n", "overwrite": true}
>>>END

>>>TOOL read_file
{"path": "VSCodeiPadOS/VSCodeiPadOS/Services/EditorCore.swift", "start_line": 26, "end_line": 32}
>>>END

>>>TOOL read_file
{"path": "VSCodeiPadOS/VSCodeiPadOS/Services/EditorCore.swift", "start_line": 355, "end_line": 365}
>>>END

>>>REPORT
Successfully modified EditorCore.swift with the requested changes:

**Added Properties (lines 28-29):**
- `@Published var isZenMode = false`
- `@Published var isFocusMode = false`

**Added Toggle Methods (lines 360-365):**
- `func toggleZenMode()` - toggles the isZenMode property
- `func toggleFocusMode()` - toggles the isFocusMode property

The file has been overwritten with all original functionality preserved, and the new properties and methods are now available for controlling Zen Mode and Focus Mode features in the VS Code iPadOS editor.

**File Modified:**
- VSCodeiPadOS/VSCodeiPadOS/Services/EditorCore.swift (598 â†’ 608 lines)
>>>END
