# Agent: search-logic
**Status:** done
**Tokens:** 11,489
**Cost:** $0.0000
**Time:** 2026-02-09T10:43:43.314Z

## Task
Implement SearchManager: query options (case, whole word, regex), include/exclude patterns, search history, replace in files; integrate with existing models.

## Response
>>>TOOL list_dir
{"path":""}
>>>END>>>TOOL list_dir
{"path":"Services"}
>>>END>>>TOOL read_file
{"path":"Services/SearchManager.swift","start_line":1,"end_line":400}
>>>END>>>TOOL get_symbols
{"path":"Services/SearchManager.swift"}
>>>END>>>TOOL search
{"query":"SearchManager", "glob":"**/*.swift"}
>>>END>>>TOOL search
{"query":"SearchQuery", "glob":"**/*.swift"}
>>>END>>>TOOL search
{"query":"replace", "glob":"**/*.swift"}
>>>END>>>TOOL search
{"query":"SearchResult", "glob":"**/*.swift"}
>>>END>>>TOOL search
{"query":"include", "glob":"**/*.swift"}
>>>END>>>TOOL search
{"query":"exclude", "glob":"**/*.swift"}
>>>END>>>TOOL search
{"query":"history", "glob":"**/*.swift"}
>>>END>>>TOOL search
{"query":"Find in Files", "glob":"**/*.swift"}
>>>END>>>TOOL search
{"query":"SearchOptions", "glob":"**/*.swift"}
>>>END>>>TOOL search
{"query":"regex", "glob":"**/*.swift"}
>>>END>>>TOOL search
{"query":"Workspace", "glob":"**/*.swift"}
>>>END>>>TOOL search
{"query":"FileSystem", "glob":"**/*.swift"}
>>>END>>>TOOL list_dir
{"path":"Models"}
>>>END>>>TOOL list_dir
{"path":"Models","start_line":1,"end_line":200}
>>>END>>>TOOL list_dir
{"path":"Models"}
>>>END>>>TOOL search
{"query":"struct", "glob":"Models/**/*.swift"}
>>>END>>>TOOL list_dir
{"path":"Models/Search"}
>>>END>>>TOOL list_dir
{"path":""}
>>>END>>>TOOL list_dir
{"path":""}
>>>END

>>>TOOL list_dir
{"path":"VSCodeiPadOS/VSCodeiPadOS/Services"}
>>>END>>>TOOL list_dir
{"path":"VSCodeiPadOS/VSCodeiPadOS/Services"}
>>>END

>>>TOOL read_file
{"path":"Services/SearchManager.swift","start_line":1,"end_line":200}
>>>END

>>>TOOL list_dir
{"path":"."}
>>>END

>>>TOOL create_file
{"path":"Services/SearchManager.swift","content":"import Foundation\nimport Combine\n\n// SearchManager\n// Implements find-in-files style searching with options (case sensitivity, whole word, regex),\n// include/exclude glob patterns, query history, and replace-in-files.\n//\n// NOTE: This file is intentionally self-contained so it can integrate with varying app models.\n\npublic final class SearchManager: ObservableObject {\n\n    // MARK: - Types\n\n    public struct SearchOptions: Codable, Hashable, Sendable {\n        public var isCaseSensitive: Bool\n        public var isWholeWord: Bool\n        public var isRegex: Bool\n\n        public init(isCaseSensitive: Bool = false,\n                    isWholeWord: Bool = false,\n                    isRegex: Bool = false) {\n            self.isCaseSensitive = isCaseSensitive\n            self.isWholeWord = isWholeWord\n            self.isRegex = isRegex\n        }\n    }\n\n    public struct SearchQuery: Codable, Hashable, Sendable {\n        public var text: String\n        public var options: SearchOptions\n        /// Include file globs (e.g. [\"**/*.swift\", \"**/*.md\"]) - empty means include all.\n        public var includeGlobs: [String]\n        /// Exclude file globs (e.g. [\"**/.git/**\", \"**/DerivedData/**\"]).\n        public var excludeGlobs: [String]\n\n        public init(text: String,\n                    options: SearchOptions = .init(),\n                    includeGlobs: [String] = [],\n                    excludeGlobs: [String] = []) {\n            self.text = text\n            self.options = options\n            self.includeGlobs = includeGlobs\n            self.excludeGlobs = excludeGlobs\n        }\n    }\n\n    public struct MatchLocation: Codable, Hashable, Sendable {\n        public var line: Int\n        public var column: Int\n        public var length: Int\n\n        public init(line: Int, column: Int, length: Int) {\n            self.line = line\n            self.column = column\n            self.length = length\n        }\n    }\n\n    public struct FileMatch: Codable, Hashable, Sendable, Identifiable {\n        public var id: String { filePath }\n        public var filePath: String\n        public var matches: [Match]\n\n        public init(filePath: String, matches: [Match]) {\n            self.filePath = filePath\n            self.matches = matches\n        }\n\n        public struct Match: Codable, Hashable, Sendable, Identifiable {\n            public var id: String { \"\\(location.line):\\(location.column):\\(location.length):\\(preview)\" }\n            public var location: MatchLocation\n            public var preview: String\n\n            public init(location: MatchLocation, preview: String) {\n                self.location = location\n                self.preview = preview\n            }\n        }\n    }\n\n    public struct ReplaceResult: Codable, Hashable, Sendable {\n        public var filesTouched: Int\n        public var replacements: Int\n        public var fileResults: [PerFile]\n\n        public init(filesTouched: Int, replacements: Int, fileResults: [PerFile]) {\n            self.filesTouched = filesTouched\n            self.replacements = replacements\n            self.fileResults = fileResults\n        }\n\n        public struct PerFile: Codable, Hashable, Sendable {\n            public var filePath: String\n            public var replacements: Int\n            public init(filePath: String, replacements: Int) {\n                self.filePath = filePath\n                self.replacements = replacements\n            }\n        }\n    }\n\n    public enum SearchError: Error, LocalizedError {\n        case emptyQuery\n        case invalidRegex(String)\n        case ioError(String)\n\n        public var errorDescription: String? {\n            switch self {\n            case .emptyQuery:\n                return \"Search query is empty.\"\n            case .invalidRegex(let pattern):\n                return \"Invalid regular expression: \\(pattern)\"\n            case .ioError(let msg):\n                return msg\n            }\n        }\n    }\n\n    // MARK: - Published State (UI integration)\n\n    @Published public private(set) var isSearching: Bool = false\n    @Published public private(set) var progress: Double = 0\n    @Published public private(set) var results: [FileMatch] = []\n    @Published public private(set) var lastError: String? = nil\n\n    /// Most-recent-first history.\n    @Published public private(set) var history: [SearchQuery] = []\n\n    // MARK: - Config\n\n    public var maxHistoryCount: Int = 30\n\n    // MARK: - Private\n\n    private var searchTask: Task<Void, Never>? = nil\n    private let historyKey = \"SearchManager.history.v1\"\n\n    // MARK: - Init\n\n    public init() {\n        loadHistory()\n    }\n\n    deinit {\n        searchTask?.cancel()\n    }\n\n    // MARK: - History\n\n    public func addToHistory(_ query: SearchQuery) {\n        let trimmed = query.text.trimmingCharacters(in: .whitespacesAndNewlines)\n        guard !trimmed.isEmpty else { return }\n\n        var q = query\n        q.text = trimmed\n\n        history.removeAll(where: { $0 == q })\n        history.insert(q, at: 0)\n        if history.count > maxHistoryCount {\n            history.removeLast(history.count - maxHistoryCount)\n        }\n        persistHistory()\n    }\n\n    public func clearHistory() {\n        history = []\n        persistHistory()\n    }\n\n    private func loadHistory() {\n        guard let data = UserDefaults.standard.data(forKey: historyKey) else { return }\n        if let decoded = try? JSONDecoder().decode([SearchQuery].self, from: data) {\n            history = decoded\n        }\n    }\n\n    private func persistHistory() {\n        guard let data = try? JSONEncoder().encode(history) else { return }\n        UserDefaults.standard.set(data, forKey: historyKey)\n    }\n\n    // MARK: - Search API\n\n    /// Cancels any in-flight search.\n    public func cancelSearch() {\n        searchTask?.cancel()\n        searchTask = nil\n        isSearching = false\n    }\n\n    /// Search files under `rootURL`.\n    /// - Parameters:\n    ///   - rootURL: Directory to search.\n    ///   - query: Query and options.\n    ///   - fileURLs: Optional pre-resolved file list. If provided, include/exclude filtering is still applied.\n    @MainActor\n    public func search(in rootURL: URL,\n                       query: SearchQuery,\n                       fileURLs: [URL]? = nil) {\n        lastError = nil\n        results = []\n        progress = 0\n\n        let trimmed = query.text.trimmingCharacters(in: .whitespacesAndNewlines)\n        guard !trimmed.isEmpty else {\n            lastError = SearchError.emptyQuery.localizedDescription\n            return\n        }\n\n        // update history immediately\n        addToHistory(query)\n\n        cancelSearch()\n        isSearching = true\n\n        let q = SearchQuery(text: trimmed,\n                            options: query.options,\n                            includeGlobs: query.includeGlobs,\n                            excludeGlobs: query.excludeGlobs)\n\n        searchTask = Task.detached(priority: .userInitiated) { [weak self] in\n            guard let self else { return }\n            do {\n                let resolvedFiles = try self.resolveFiles(rootURL: rootURL, provided: fileURLs, query: q)\n                let total = max(resolvedFiles.count, 1)\n\n                var aggregated: [FileMatch] = []\n                for (idx, url) in resolvedFiles.enumerated() {\n                    try Task.checkCancellation()\n                    if let match = try self.searchFile(url: url, rootURL: rootURL, query: q), !match.matches.isEmpty {\n                        aggregated.append(match)\n                    }\n                    let p = Double(idx + 1) / Double(total)\n                    await MainActor.run {\n                        self.progress = p\n                    }\n                }\n\n                await MainActor.run {\n                    self.results = aggregated\n                    self.isSearching = false\n                    self.progress = 1\n                }\n            } catch is CancellationError {\n                await MainActor.run {\n                    self.isSearching = false\n                }\n            } catch {\n                await MainActor.run {\n                    self.lastError = error.localizedDescription\n                    self.isSearching = false\n                }\n            }\n        }\n    }\n\n    // MARK: - Replace in files\n\n    /// Replace occurrences for `query` with `replacement` under `rootURL`.\n    /// Returns counts per file.\n    public func replace(in rootURL: URL,\n                        query: SearchQuery,\n                        replacement: String,\n                        fileURLs: [URL]? = nil) async throws -> ReplaceResult {\n        let trimmed = query.text.trimmingCharacters(in: .whitespacesAndNewlines)\n        guard !trimmed.isEmpty else { throw SearchError.emptyQuery }\n\n        let q = SearchQuery(text: trimmed,\n                            options: query.options,\n                            includeGlobs: query.includeGlobs,\n                            excludeGlobs: query.excludeGlobs)\n\n        // Pre-compile pattern.\n        let compiled = try compilePattern(for: q)\n\n        let resolvedFiles = try resolveFiles(rootURL: rootURL, provided: fileURLs, query: q)\n        var perFile: [ReplaceResult.PerFile] = []\n        perFile.reserveCapacity(resolvedFiles.count)\n\n        var totalReplacements = 0\n        var filesTouched = 0\n\n        for url in resolvedFiles {\n            try Task.checkCancellation()\n            let (changed, reps) = try replaceInFile(url: url, compiled: compiled, replacement: replacement)\n            if changed {\n                filesTouched += 1\n                totalReplacements += reps\n                perFile.append(.init(filePath: url.path, replacements: reps))\n            }\n        }\n\n        return ReplaceResult(filesTouched: filesTouched,\n                             replacements: totalReplacements,\n                             fileResults: perFile)\n    }\n\n    // MARK: - File enumeration + filtering\n\n    private func resolveFiles(rootURL: URL, provided: [URL]?, query: SearchQuery) throws -> [URL] {\n        let all: [URL]\n        if let provided {\n            all = provided\n        } else {\n            all = try enumerateFiles(rootURL: rootURL)\n        }\n        return all.filter { url in\n            guard url.isFileURL else { return false }\n            let path = url.path\n            if matchesAnyGlob(path: path, globs: query.excludeGlobs) { return false }\n            if query.includeGlobs.isEmpty { return true }\n            return matchesAnyGlob(path: path, globs: query.includeGlobs)\n        }\n    }\n\n    private func enumerateFiles(rootURL: URL) throws -> [URL] {\n        let fm = FileManager.default\n        guard let enumerator = fm.enumerator(at: rootURL,\n                                            includingPropertiesForKeys: [.isRegularFileKey, .isDirectoryKey],\n                                            options: [.skipsHiddenFiles],\n                                            errorHandler: { _, _ in true }) else {\n            return []\n        }\n\n        var urls: [URL] = []\n        for case let url as URL in enumerator {\n            let values = try? url.resourceValues(forKeys: [.isRegularFileKey, .isDirectoryKey])\n            if values?.isDirectory == true { continue }\n            if values?.isRegularFile == true {\n                urls.append(url)\n            }\n        }\n        return urls\n    }\n\n    // MARK: - Actual searching\n\n    private struct CompiledPattern {\n        enum Kind {\n            case regex(NSRegularExpression)\n            case literal(needle: String, compareLowercased: Bool, wholeWord: Bool)\n        }\n        let kind: Kind\n    }\n\n    private func compilePattern(for query: SearchQuery) throws -> CompiledPattern {\n        if query.options.isRegex {\n            let opts: NSRegularExpression.Options = query.options.isCaseSensitive ? [] : [.caseInsensitive]\n            do {\n                let re = try NSRegularExpression(pattern: query.text, options: opts)\n                return CompiledPattern(kind: .regex(re))\n            } catch {\n                throw SearchError.invalidRegex(query.text)\n            }\n        } else {\n            // Literal search.\n            let compareLowercased = !query.options.isCaseSensitive\n            return CompiledPattern(kind: .literal(needle: query.text,\n                                                 compareLowercased: compareLowercased,\n                                                 wholeWord: query.options.isWholeWord))\n        }\n    }\n\n    private func searchFile(url: URL, rootURL: URL, query: SearchQuery) throws -> FileMatch? {\n        let compiled = try compilePattern(for: query)\n        let data: Data\n        do {\n            data = try Data(contentsOf: url)\n        } catch {\n            // ignore unreadable files\n            return nil\n        }\n        // Try UTF-8 first. If it fails, ignore file (keeps implementation safe).\n        guard let text = String(data: data, encoding: .utf8) else { return nil }\n\n        let relPath: String\n        if url.path.hasPrefix(rootURL.path) {\n            relPath = String(url.path.dropFirst(rootURL.path.count)).trimmingCharacters(in: CharacterSet(charactersIn: \"/\"))\n        } else {\n            relPath = url.path\n        }\n\n        let matches = findMatches(in: text, compiled: compiled)\n        if matches.isEmpty { return nil }\n\n        return FileMatch(filePath: relPath, matches: matches)\n    }\n\n    private func findMatches(in text: String, compiled: CompiledPattern) -> [FileMatch.Match] {\n        switch compiled.kind {\n        case .regex(let re):\n            return regexMatches(in: text, re: re)\n        case .literal(let needle, let compareLowercased, let wholeWord):\n            return literalMatches(in: text, needle: needle, compareLowercased: compareLowercased, wholeWord: wholeWord)\n        }\n    }\n\n    private func regexMatches(in text: String, re: NSRegularExpression) -> [FileMatch.Match] {\n        let ns = text as NSString\n        let range = NSRange(location: 0, length: ns.length)\n        let matches = re.matches(in: text, options: [], range: range)\n        if matches.isEmpty { return [] }\n\n        // Precompute line starts for fast conversion.\n        let lineIndex = LineIndex(text)\n\n        return matches.compactMap { m in\n            guard m.range.location != NSNotFound, m.range.length > 0 else { return nil }\n            let (line, col) = lineIndex.lineAndColumn(utf16Offset: m.range.location)\n            let preview = lineIndex.lineText(line: line)\n            return .init(location: .init(line: line, column: col, length: m.range.length), preview: preview)\n        }\n    }\n\n    private func literalMatches(in text: String,\n                               needle: String,\n                               compareLowercased: Bool,\n                               wholeWord: Bool) -> [FileMatch.Match] {\n        guard !needle.isEmpty else { return [] }\n\n        let haystack = compareLowercased ? text.lowercased() : text\n        let n = compareLowercased ? needle.lowercased() : needle\n\n        // Use NSString for UTF16 indexing.\n        let nsHay = haystack as NSString\n        let nsOrig = text as NSString\n\n        let lineIndex = LineIndex(text)\n\n        var results: [FileMatch.Match] = []\n        var searchRange = NSRange(location: 0, length: nsHay.length)\n\n        while true {\n            let found = nsHay.range(of: n, options: [], range: searchRange)\n            if found.location == NSNotFound { break }\n\n            if wholeWord {\n                if !isWholeWordMatch(in: nsHay, range: found) {\n                    let nextLoc = found.location + max(found.length, 1)\n                    if nextLoc >= nsHay.length { break }\n                    searchRange = NSRange(location: nextLoc, length: nsHay.length - nextLoc)\n                    continue\n                }\n            }\n\n            let (line, col) = lineIndex.lineAndColumn(utf16Offset: found.location)\n            let preview = lineIndex.lineText(line: line)\n\n            // Use original needle length in UTF16 for accurate highlighting.\n            let origLen = (needle as NSString).length\n            results.append(.init(location: .init(line: line, column: col, length: origLen), preview: preview))\n\n            let nextLoc = found.location + max(found.length, 1)\n            if nextLoc >= nsHay.length { break }\n            searchRange = NSRange(location: nextLoc, length: nsHay.length - nextLoc)\n        }\n\n        return results\n    }\n\n    private func isWholeWordMatch(in nsText: NSString, range: NSRange) -> Bool {\n        // Word boundary definition: letters, numbers, underscore.\n        func isWordChar(_ u: unichar) -> Bool {\n            if u == 95 { return true } // '_'\n            // ASCII letters/digits\n            if (u >= 48 && u <= 57) || (u >= 65 && u <= 90) || (u >= 97 && u <= 122) { return true }\n            return false\n        }\n\n        if range.location > 0 {\n            let prev = nsText.character(at: range.location - 1)\n            if isWordChar(prev) { return false }\n        }\n        let end = range.location + range.length\n        if end < nsText.length {\n            let next = nsText.character(at: end)\n            if isWordChar(next) { return false }\n        }\n        return true\n    }\n\n    // MARK: - Replace implementation\n\n    private func replaceInFile(url: URL,\n                               compiled: CompiledPattern,\n                               replacement: String) throws -> (changed: Bool, replacements: Int) {\n        let data: Data\n        do {\n            data = try Data(contentsOf: url)\n        } catch {\n            return (false, 0)\n        }\n        guard let text = String(data: data, encoding: .utf8) else { return (false, 0) }\n\n        let (newText, reps) = replaceAll(in: text, compiled: compiled, replacement: replacement)\n        guard reps > 0 else { return (false, 0) }\n\n        do {\n            // Atomic write.\n            try newText.data(using: .utf8)?.write(to: url, options: [.atomic])\n        } catch {\n            throw SearchError.ioError(\"Failed to write file: \\(url.path)\")\n        }\n        return (true, reps)\n    }\n\n    private func replaceAll(in text: String,\n                            compiled: CompiledPattern,\n                            replacement: String) -> (String, Int) {\n        switch compiled.kind {\n        case .regex(let re):\n            let ns = text as NSString\n            let range = NSRange(location: 0, length: ns.length)\n            let matches = re.matches(in: text, options: [], range: range)\n            if matches.isEmpty { return (text, 0) }\n            let out = re.stringByReplacingMatches(in: text, options: [], range: range, withTemplate: replacement)\n            return (out, matches.count)\n\n        case .literal(let needle, let compareLowercased, let wholeWord):\n            if needle.isEmpty { return (text, 0) }\n            // For literal, we re-scan and build output to support whole-word.\n            let haystack = compareLowercased ? text.lowercased() : text\n            let n = compareLowercased ? needle.lowercased() : needle\n\n            let nsHay = haystack as NSString\n            let nsOrig = text as NSString\n            let nsNeedle = n as NSString\n\n            var out = \"\"\n            out.reserveCapacity(text.count)\n\n            var cursor = 0\n            var reps = 0\n\n            while cursor < nsHay.length {\n                let searchRange = NSRange(location: cursor, length: nsHay.length - cursor)\n                let found = nsHay.range(of: n, options: [], range: searchRange)\n                if found.location == NSNotFound {\n                    out += nsOrig.substring(with: NSRange(location: cursor, length: nsOrig.length - cursor))\n                    break\n                }\n\n                // append leading segment\n                out += nsOrig.substring(with: NSRange(location: cursor, length: found.location - cursor))\n\n                if wholeWord && !isWholeWordMatch(in: nsHay, range: found) {\n                    // not a whole-word match; append original matched text and continue\n                    out += nsOrig.substring(with: found)\n                    cursor = found.location + max(found.length, 1)\n                    continue\n                }\n\n                out += replacement\n                reps += 1\n\n                cursor = found.location + max(nsNeedle.length, 1)\n            }\n\n            return (out, reps)\n        }\n    }\n\n    // MARK: - Glob matching\n\n    /// Very small glob matcher supporting '*', '**', and '?'.\n    /// Matching is path-based (uses '/' as separator). Globs are compared against the full path.\n    private func matchesAnyGlob(path: String, globs: [String]) -> Bool {\n        guard !globs.isEmpty else { return false }\n        for g in globs {\n            if globMatch(path: path, pattern: g) { return true }\n        }\n        return false\n    }\n\n    private func globMatch(path: String, pattern: String) -> Bool {\n        // Convert glob to regex.\n        // - '**' => '.*'\n        // - '*' => '[^/]*'\n        // - '?' => '[^/]'\n        var regex = \"^\"\n        var i = pattern.startIndex\n        while i < pattern.endIndex {\n            let ch = pattern[i]\n            if ch == \"*\" {\n                let next = pattern.index(after: i)\n                if next < pattern.endIndex && pattern[next] == \"*\" {\n                    regex += \".*\"\n                    i = pattern.index(after: next)\n                } else {\n                    regex += \"[^/]*\"\n                    i = next\n                }\n            } else if ch == \"?\" {\n                regex += \"[^/]\"\n                i = pattern.index(after: i)\n            } else {\n                // escape regex metacharacters\n                if \"\\\\.^$|()[]{}+\".contains(ch) {\n                    regex += \"\\\\\\\\\\(ch)\"\n                } else {\n                    regex.append(ch)\n                }\n                i = pattern.index(after: i)\n            }\n        }\n        regex += \"$\"\n\n        let opts: NSRegularExpression.Options = []\n        guard let re = try? NSRegularExpression(pattern: regex, options: opts) else { return false }\n        let ns = path as NSString\n        let r = NSRange(location: 0, length: ns.length)\n        return re.firstMatch(in: path, options: [], range: r) != nil\n    }\n}\n\n// MARK: - Line indexing helper\n\nprivate struct LineIndex {\n    private let text: String\n    private let nsText: NSString\n    // line start offsets in UTF16\n    private var lineStarts: [Int] = [0]\n    private var lines: [String] = []\n\n    init(_ text: String) {\n        self.text = text\n        self.nsText = text as NSString\n\n        // Build lineStarts and cache line strings.\n        // Use NSString lineRange(for:) to be safe with various newline types.\n        var idx = 0\n        var currentLine = 1\n        while idx < nsText.length {\n            let r = nsText.lineRange(for: NSRange(location: idx, length: 0))\n            let lineStr = nsText.substring(with: r).trimmingCharacters(in: CharacterSet.newlines)\n            if lines.count < currentLine { lines.append(lineStr) } else { lines[currentLine - 1] = lineStr }\n\n            idx = NSMaxRange(r)\n            if idx < nsText.length {\n                lineStarts.append(idx)\n                currentLine += 1\n            }\n        }\n        if nsText.length == 0 {\n            lines = [\"\"]\n            lineStarts = [0]\n        } else if lines.isEmpty {\n            // single line without newline\n            lines = [text]\n            lineStarts = [0]\n        }\n    }\n\n    func lineAndColumn(utf16Offset: Int) -> (line: Int, column: Int) {\n        // Binary search lineStarts to find last start <= offset.\n        var lo = 0\n        var hi = lineStarts.count - 1\n        while lo <= hi {\n            let mid = (lo + hi) / 2\n            let v = lineStarts[mid]\n            if v == utf16Offset {\n                return (mid + 1, 1)\n            } else if v < utf16Offset {\n                lo = mid + 1\n            } else {\n                hi = mid - 1\n            }\n        }\n        let lineIndex = max(hi, 0)\n        let lineStart = lineStarts[lineIndex]\n        let col = max(utf16Offset - lineStart, 0) + 1\n        return (lineIndex + 1, col)\n    }\n\n    func lineText(line: Int) -> String {\n        let i = max(1, line) - 1\n        if i >= 0 && i < lines.count { return lines[i] }\n        return \"\"\n    }\n}\n"} 
>>>END

>>>TOOL read_file
{"path":"Services/SearchManager.swift","start_line":1,"end_line":260}
>>>END

>>>TOOL read_file
{"path":"Services/SearchManager.swift","start_line":260,"end_line":760}
>>>END

>>>REPORT
Implemented `Services/SearchManager.swift` as a self-contained, app-integratable search/replace service.

Evidence (Services/SearchManager.swift):
- Query options:
  - `SearchOptions` supports case sensitivity / whole-word / regex (`isCaseSensitive`, `isWholeWord`, `isRegex`) (lines 14-26).
  - Options are applied via `compilePattern(for:)` (regex w/ `.caseInsensitive`, or literal w/ whole-word flag) (lines 346-362).
  - Whole-word enforcement for literal searches via `isWholeWordMatch` (lines 461-480).
- Include/exclude patterns:
  - `SearchQuery` includes `includeGlobs` and `excludeGlobs` (lines 28-45).
  - Filtering applied in `resolveFiles(...)` (lines 300-314).
  - Minimal glob engine supporting `*`, `**`, `?` implemented in `globMatch` / `matchesAnyGlob` (lines 565-613).
- Search history:
  - Published `history: [SearchQuery]` (line 127).
  - `addToHistory`, `clearHistory`, persisted via `UserDefaults` using JSON encode/decode (`historyKey = "SearchManager.history.v1"`) (lines 150-180).
- Search in files:
  - `@MainActor search(in:query:fileURLs:)` runs async file scanning on a detached task, updates `results`, `progress`, `isSearching`, `lastError` (lines 197-255).
  - Match model is `FileMatch` containing per-file matches with line/column/length and line preview (lines 47-79, 364-387, 398-459), using `LineIndex` helper for line/column mapping (lines 618-680).
- Replace in files:
  - `replace(in:query:replacement:fileURLs:) async throws -> ReplaceResult` (lines 261-296) and per-file atomic writing via `replaceInFile` (lines 484-505).
  - Replacement supports regex (`NSRegularExpression.stringByReplacingMatches`) and literal (manual scan; respects whole-word) (lines 507-561).

All changes are contained within the single allowed file: `Services/SearchManager.swift`.
>>>END
