# Agent: test-editor-8
**Status:** done
**Tokens:** 13,491
**Cost:** $0.0000
**Time:** 2026-02-09T18:52:56.819Z

## Task
Create XCTest UI test methods for MINIMAP interactions. Create test methods: testMinimapVisible(), testMinimapClick(), testMinimapDrag(), testMinimapScrollSync(), testMinimapHighlightCurrentView(). Look for elements with 'minimap' identifier. Return ONLY the Swift test methods (not full class). Reference VSCodeiPadOSUITests/SearchViewUITests.swift for XCTest patterns.

## Response
>>>TOOL read_file
{"path":"VSCodeiPadOSUITests/SearchViewUITests.swift","start_line":1,"end_line":260}
>>>END


>>>TOOL read_file
{"path":"VSCodeiPadOSUITests/SearchViewUITests.swift","start_line":260,"end_line":460}
>>>END>>>END

---

## ðŸ”§ TOOL RESULTS

[read_file]
File: VSCodeiPadOSUITests/SearchViewUITests.swift (lines 261-424 of 424)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
261:         let editorView = app.textViews["Editor"]
262:         let codeEditor = app.textViews.matching(NSPredicate(format: "identifier CONTAINS 'editor' OR label CONTAINS 'editor'"))
263:         let fileContent = app.staticTexts.matching(NSPredicate(format: "label CONTAINS 'func'"))
264:         
265:         let navigated = editorView.exists || 
266:                        codeEditor.count > 0 ||
267:                        fileContent.count > 0
268:         
269:         XCTAssertTrue(navigated, "Tapping a search result should navigate to the file location")
270:     }
271:     
272:     /// Test 8: Test history dropdown appears when focusing search
273:     func testHistoryDropdown() throws {
274:         // First perform a search to create history
275:         let searchField = app.textFields["Search"]
276:         let searchTextField = app.searchFields["Search"]
277:         let searchInput = searchField.exists ? searchField : searchTextField
278:         
279:         guard searchInput.waitForExistence(timeout: 2) else {
280:             XCTSkip("Search field not available")
281:             return
282:         }
283:         
284:         // Create some search history
285:         searchInput.tap()
286:         searchInput.typeText("test query")
287:         sleep(2)
288:         
289:         // Clear the field
290:         let clearButton = app.buttons["Clear"]
291:         let clearTextButton = app.buttons.matching(NSPredicate(format: "label CONTAINS 'Clear' OR accessibilityLabel CONTAINS 'Clear'")).firstMatch
292:         
293:         if clearButton.exists {
294:             clearButton.tap()
295:         } else if clearTextButton.exists {
296:             clearTextButton.tap()
297:         } else {
298:             // Select all and delete
299:             searchInput.doubleTap()
300:             searchInput.typeText(XCUIKeyboardKey.delete.rawValue)
301:         }
302:         
303:         sleep(1)
304:         
305:         // Focus search field again to trigger history dropdown
306:         searchInput.tap()
307:         sleep(1)
308:         
309:         // Check for history dropdown
310:         let historyList = app.collectionViews["Search History"]
311:         let historyTable = app.tables["Search History"]
312:         let historyCell = app.cells.matching(NSPredicate(format: "label CONTAINS 'test query'"))
313:         let recentSearches = app.staticTexts["Recent Searches"]
314:         let historySection = app.otherElements["History"]
315:         
316:         let historyVisible = historyList.exists || 
317:                             historyTable.exists || 
318:                             historyCell.count > 0 ||
319:                             recentSearches.exists ||
320:                             historySection.exists
321:         
322:         // History may not always appear depending on implementation
323:         // So we just verify the field is focusable
324:         XCTAssertTrue(searchInput.isFocused || searchInput.hasKeyboardFocus || historyVisible, 
325:                     "Search field should be focusable and may show history dropdown")
326:     }
327:     
328:     /// Test 9: Verify replace button is present and clickable
329:     func testReplaceButton() throws {
330:         // First expand replace section if needed
331:         let replaceToggle = app.buttons["Replace"]
332:         if replaceToggle.exists {
333:             replaceToggle.tap()
334:             sleep(1)
335:         }
336:         
337:         // Find replace button
338:         let replaceButton = app.buttons["Replace"]
339:         let replaceAllButton = app.buttons["Replace All"]
340:         let replaceNextButton = app.buttons["Replace Next"]
341:         let replaceActionButton = app.buttons.matching(NSPredicate(format: "label CONTAINS 'Replace' AND label != 'Replace'")).firstMatch
342:         
343:         // Replace button might have different labels
344:         let replaceExists = replaceButton.waitForExistence(timeout: 2) ||
345:                          replaceAllButton.exists ||
346:                          replaceNextButton.exists ||
347:                          replaceActionButton.exists
348:         
349:         XCTAssertTrue(replaceExists, "Replace button should be present")
350:         
351:         // Enter some text in replace field first
352:         let replaceField = app.textFields["Replace"]
353:         if replaceField.exists {
354:             replaceField.tap()
355:             replaceField.typeText("replacement")
356:             
357:             // Try to tap replace button
358:             if replaceButton.exists && replaceButton.isEnabled {
359:                 replaceButton.tap()
360:                 XCTAssertTrue(true, "Replace button should be clickable")
361:             } else if replaceAllButton.exists && replaceAllButton.isEnabled {
362:                 // Don't actually replace all in tests
363:                 XCTAssertTrue(replaceAllButton.isEnabled, "Replace All button should be clickable")
364:             }
365:         }
366:     }
367:     
368:     /// Test 10: Verify clear button resets search
369:     func testClearSearch() throws {
370:         // Find search field and enter text
371:         let searchField = app.textFields["Search"]
372:         let searchTextField = app.searchFields["Search"]
373:         let searchInput = searchField.exists ? searchField : searchTextField
374:         
375:         guard searchInput.waitForExistence(timeout: 2) else {
376:             XCTSkip("Search field not available")
377:             return
378:         }
379:         
380:         // Type search text
381:         searchInput.tap()
382:         searchInput.typeText("clear test")
383:         sleep(1)
384:         
385:         // Verify text was entered
386:         let hasText = searchInput.value != nil && (searchInput.value as? String) != ""
387:         XCTAssertTrue(hasText || true, "Search field should have text entered")
388:         
389:         // Find and tap clear button
390:         let clearButton = app.buttons["Clear"]
391:         let clearTextButton = app.buttons.matching(NSPredicate(format: "label CONTAINS 'Clear' OR accessibilityLabel CONTAINS 'Clear'")).firstMatch
392:         let clearSearchButton = app.buttons.matching(NSPredicate(format: "identifier CONTAINS 'clear'")).firstMatch
393:         
394:         let clearExists = clearButton.exists || clearTextButton.exists || clearSearchButton.exists
395:         
396:         if clearExists {
397:             if clearButton.exists {
398:                 clearButton.tap()
399:             } else if clearTextButton.exists {
400:                 clearTextButton.tap()
401:             } else if clearSearchButton.exists {
402:                 clearSearchButton.tap()
403:             }
404:             
405:             sleep(1)
406:             
407:             // Verify search was cleared
408:             let searchCleared = (searchInput.value as? String)?.isEmpty ?? true
409:             XCTAssertTrue(searchCleared || searchInput.value as? String == "Search", 
410:                          "Clear button should reset search text")
411:         } else {
412:             // Try clearing with keyboard shortcut or selection + delete
413:             searchInput.doubleTap()
414:             searchInput.typeText(XCUIKeyboardKey.delete.rawValue)
415:             
416:             sleep(1)
417:             
418:             // Verify text was cleared
419:             let finalValue = searchInput.value as? String ?? ""
420:             XCTAssertTrue(finalValue.isEmpty || finalValue == "Search", 
421:                          "Search field should be cleared")
422:         }
423:     }
424: }


>>>TOOL search
{"query":"minimap", "glob":"**/*"}
>>>END>>>TOOL search
{"query":"minimap", "glob":"**/*"}
>>>END

---

## ðŸ”§ TOOL RESULTS

[search]
Found 12 matches:
.claudefluff/agents/coord-16-additional-2026-02-09T11-43-09-173Z.md:103: "name": "minimap-worker",
.claudefluff/agents/coord-16-additional-2026-02-09T11-43-09-173Z.md:104: "task": "FEAT-131: Enhance MinimapView.swift with proper code preview on right side. Update VSCodeiPadOS/VSCodeiPadOS/Views/Editor/MinimapView.swift to include: (1) Actual syntax-colored code preview with tiny font rendering, (2) Highlight current visible region with semi-transparent overlay, (3) Click-to-scroll to position, (4) Drag scrolling, (5) Show git diff indicators (red/green bars for changes). Make it look like VS Code's minimap with actual colored code blocks representing syntax.",
.claudefluff/agents/worker-syntax-2026-02-09T10-46-37-620Z.md:195: // Handle minimap scrolling
.claudefluff/agents/worker-syntax-2026-02-09T10-46-37-620Z.md:223: // Handle minimap scrolling
.claudefluff/agents/folding-gutter-worker-2026-02-09T16-23-18-679Z.md:247: .padding(.trailing, 60) // Offset for minimap
.claudefluff/agents/folding-gutter-worker-2026-02-09T16-23-18-679Z.md:250: .padding(.trailing, 60) // Offset for minimap
.claudefluff/agents/worker-build-2026-02-09T11-07-13-853Z.md:890: // Handle minimap scrolling
.claudefluff/agents/worker-build-2026-02-09T11-07-13-853Z.md:898: // Handle minimap scrolling
.claudefluff/agents/inlay-hints-worker-2026-02-09T11-38-56-646Z.md:571: {"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor/InlayHintsOverlay.swift","content":"import SwiftUI\nimport UIKit\n\n/// Renders inlay hints as subtle inline text inside the editor area.\n///\n/// This is a lightweight overlay that approximates text positions using monospaced font metrics.\nstruct InlayHintsOverlay: View {\n    let code: String\n    let language: CodeLanguage\n\n    /// 0-based top visible line index.\n    let scrollPosition: Int\n\n    let lineHeight: CGFloat\n    let fontSize: CGFloat\n\n    /// Width reserved for the gutter (line numbers).\n    var gutterWidth: CGFloat = 60\n\n    /// Insets used by the underlying UITextView.\n    var textInsets: UIEdgeInsets = UIEdgeInsets(top: 8, left: 8, bottom: 8, right: 8)\n\n    /// Width reserved at the right edge (e.g. minimap).\n    var rightReservedWidth: CGFloat = 0\n\n    /// How many spaces a tab visually represents.\n    var tabSize: Int = 4\n\n    @State private var hints: [InlayHintsManager.InlayHint] = []\n\n    var body: some View {\n        GeometryReader { geo in\n            let font = UIFont.monospacedSystemFont(ofSize: fontSize, weight: .regular)\n            let charWidth = (\" \" as NSString).size(withAttributes: [.font: font]).width\n            let fontLineHeight = font.lineHeight\n            let baselineAdjustment = max(0, (lineHeight - fontLineHeight) / 2)\n            let maxVisibleLines = Int(ceil(geo.size.height / max(lineHeight, 1))) + 2\n\n            let lines = code.components(separatedBy: .newlines)\n\n            ZStack(alignment: .topLeading) {\n                ForEach(hints) { hint in\n                    if hint.line >= scrollPosition && hint.line <= (scrollPosition + maxVisibleLines) {\n                        let lineText = (hint.line >= 0 && hint.line < lines.count) ? lines[hint.line] : \"\"\n                        let visualColumn = visualColumn(in: lineText, utf16Column: hint.column, tabSize: tabSize)\n\n                        let x = gutterWidth + textInsets.left + (CGFloat(visualColumn) * charWidth)\n                        let y = textInsets.top + baselineAdjustment + (CGFloat(hint.line - scrollPosition) * lineHeight)\n\n                        Text(hint.text)\n                            .font(.system(size: fontSize, design: .monospaced))\n                            .foregroundColor(Color.secondary.opacity(0.42))\n                            .offset(x: x, y: y)\n                            .lineLimit(1)\n                            .fixedSize(horizontal: true, vertical: false)\n                    }\n                }\n            }\n            // Avoid drawing under minimap (or other right-side UI)\n            .frame(\n                width: max(0, geo.size.width - rightReservedWidth),\n                height: geo.size.height,\n                alignment: .topLeading\n            )\n            .clipped()\n        }\n        .allowsHitTesting(false)\n        .onAppear { recompute() }\n        .onChange(of: code) { _ in recompute() }\n        .onChange(of: language) { _ in recompute() }\n    }\n\n    private func recompute() {\n        hints = InlayHintsManager.shared.hints(for: code, language: language)\n    }\n\n    private func visualColumn(in line: String, utf16Column: Int, tabSize: Int) -> Int {\n        let ns = line as NSString\n        let clamped = max(0, min(utf16Column, ns.length))\n        let prefix = ns.substring(with: NSRange(location: 0, length: clamped))\n\n        var col = 0\n        for ch in prefix {\n            if ch == \"\\t\" {\n                col += tabSize\n            } else {\n                col += 1\n            }\n        }\n        return col\n    }\n}\n"}
.claudefluff/agents/inlay-hints-worker-2026-02-09T11-38-56-646Z.md:583: {"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor/InlayHintsOverlay.swift","content":"import SwiftUI\nimport UIKit\n\n/// Renders inlay hints as subtle inline text inside the editor area.\n///\n/// This is a lightweight overlay that approximates text positions using monospaced font metrics.\nstruct InlayHintsOverlay: View {\n    let code: String\n    let language: CodeLanguage\n\n    /// 0-based top visible line index.\n    let scrollPosition: Int\n\n    let lineHeight: CGFloat\n    let fontSize: CGFloat\n\n    /// Width reserved for the gutter (line numbers).\n    var gutterWidth: CGFloat = 60\n\n    /// Insets used by the underlying UITextView.\n    var textInsets: UIEdgeInsets = UIEdgeInsets(top: 8, left: 8, bottom: 8, right: 8)\n\n    /// Width reserved at the right edge (e.g. minimap).\n    var rightReservedWidth: CGFloat = 0\n\n    /// How many spaces a tab visually represents.\n    var tabSize: Int = 4\n\n    @State private var hints: [InlayHintsManager.InlayHint] = []\n\n    var body: some View {\n        GeometryReader { geo in\n            let font = UIFont.monospacedSystemFont(ofSize: fontSize, weight: .regular)\n            let charWidth = (\" \" as NSString).size(withAttributes: [.font: font]).width\n            let fontLineHeight = font.lineHeight\n            let baselineAdjustment = max(0, (lineHeight - fontLineHeight) / 2)\n            let maxVisibleLines = Int(ceil(geo.size.height / max(lineHeight, 1))) + 2\n\n            let lines = code.components(separatedBy: .newlines)\n\n            ZStack(alignment: .topLeading) {\n                ForEach(hints) { hint in\n                    if hint.line >= scrollPosition && hint.line <= (scrollPosition + maxVisibleLines) {\n                        let lineText = (hint.line >= 0 && hint.line < lines.count) ? lines[hint.line] : \"\"\n                        let visualColumn = visualColumn(in: lineText, utf16Column: hint.column, tabSize: tabSize)\n\n                        let x = gutterWidth + textInsets.left + (CGFloat(visualColumn) * charWidth)\n                        let y = textInsets.top + baselineAdjustment + (CGFloat(hint.line - scrollPosition) * lineHeight)\n\n                        Text(hint.text)\n                            .font(.system(size: fontSize, design: .monospaced))\n                            .foregroundColor(Color.secondary.opacity(0.42))\n                            .offset(x: x, y: y)\n                            .lineLimit(1)\n                            .fixedSize(horizontal: true, vertical: false)\n                    }\n                }\n            }\n            // Avoid drawing under minimap (or other right-side UI)\n            .frame(\n                width: max(0, geo.size.width - rightReservedWidth),\n                height: geo.size.height,\n                alignment: .topLeading\n            )\n            .clipped()\n        }\n        .allowsHitTesting(false)\n        .onAppear { recompute() }\n        .onChange(of: code) { _ in recompute() }\n        .onChange(of: language) { _ in recompute() }\n    }\n\n    private func recompute() {\n        hints = InlayHintsManager.shared.hints(for: code, language: language)\n    }\n\n    private func visualColumn(in line: String, utf16Column: Int, tabSize: Int) -> Int {\n        let ns = line as NSString\n        let clamped = max(0, min(utf16Column, ns.length))\n        let prefix = ns.substring(with: NSRange(location: 0, length: clamped))\n\n        var col = 0\n        for ch in prefix {\n            if ch == \"\\t\" {\n                col += tabSize\n            } else {\n                col += 1\n            }\n        }\n        return col\n    }\n}\n"}
.claudefluff/agents/coord-6-editor-1-2026-02-09T10-56-26-821Z.md:255: // Slightly dim to match minimap look.
.claudefluff/agents/coord-6-editor-1-2026-02-09T10-56-26-821Z.md:264: // Slightly dim to match minimap look.


>>>TOOL search
{"query":"MinimapView", "glob":"VSCodeiPadOS/**/*.swift"}
>>>END

>>>TOOL search
{"query":"accessibilityIdentifier(\"minimap", "glob":"VSCodeiPadOS/**/*.swift"}
>>>END

>>>TOOL search
{"query":"identifier: \"minimap", "glob":"VSCodeiPadOS/**/*.swift"}
>>>END


---

## ðŸ”§ TOOL RESULTS

[search]
Found 4 matches:
VSCodeiPadOS/VSCodeiPadOS/ContentView.swift:459: MinimapView(
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SplitEditorView.swift:589: MinimapView(
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView_Update.swift:566: MinimapView(
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/MinimapView.swift:8: struct MinimapView: View {

---

[search]
No matches found for "accessibilityIdentifier("minimap"

---

[search]
No matches found for "identifier: "minimap"


>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor/MinimapView.swift","start_line":1,"end_line":260}
>>>END

---

## ðŸ”§ TOOL RESULTS

Error: File 'VSCodeiPadOS/VSCodeiPadOS/Views/Editor/MinimapView.swift' not in allowed paths: VSCodeiPadOSUITests/SearchViewUITests.swift


>>>TOOL list_dir
{"path":"VSCodeiPadOSUITests"}
>>>END

---

## ðŸ”§ TOOL RESULTS

Error: File 'VSCodeiPadOSUITests' not in allowed paths: VSCodeiPadOSUITests/SearchViewUITests.swift


```swift
func testMinimapVisible() throws {
    let candidates: [XCUIElement] = [
        app.otherElements["minimap"],
        app.scrollViews["minimap"],
        app.images["minimap"],
        app.buttons["minimap"]
    ]

    let minimap = candidates.first(where: { $0.waitForExistence(timeout: 3) }) ?? app.otherElements["minimap"]
    XCTAssertTrue(minimap.exists, "Minimap should be present (element with identifier 'minimap')")
    XCTAssertFalse(minimap.frame.isEmpty, "Minimap should have a non-empty frame")
}

func testMinimapClick() throws {
    let candidates: [XCUIElement] = [
        app.otherElements["minimap"],
        app.scrollViews["minimap"],
        app.images["minimap"],
        app.buttons["minimap"]
    ]
    let minimap = candidates.first(where: { $0.waitForExistence(timeout: 3) }) ?? app.otherElements["minimap"]
    XCTAssertTrue(minimap.exists, "Minimap should exist to test click interaction")

    let highlightPredicate = NSPredicate(format: "identifier CONTAINS[c] 'minimap' AND identifier != 'minimap' AND (identifier CONTAINS[c] 'highlight' OR identifier CONTAINS[c] 'viewport' OR identifier CONTAINS[c] 'current')")
    let highlight = minimap.otherElements.matching(highlightPredicate).firstMatch
    let highlightBefore = highlight.exists ? highlight.frame : .zero

    // Tap near bottom to jump
    minimap.coordinate(withNormalizedOffset: CGVector(dx: 0.5, dy: 0.9)).tap()
    sleep(1)

    // If a minimap viewport/highlight exists, it should move after tap.
    if highlight.waitForExistence(timeout: 1) {
        let highlightAfter = highlight.frame
        XCTAssertNotEqual(highlightBefore.origin.y, highlightAfter.origin.y, "Minimap tap should change the highlighted/viewport position")
    } else {
        XCTAssertTrue(minimap.exists, "Minimap should remain present after tapping")
    }
}

func testMinimapDrag() throws {
    let candidates: [XCUIElement] = [
        app.otherElements["minimap"],
        app.scrollViews["minimap"],
        app.images["minimap"],
        app.buttons["minimap"]
    ]
    let minimap = candidates.first(where: { $0.waitForExistence(timeout: 3) }) ?? app.otherElements["minimap"]
    XCTAssertTrue(minimap.exists, "Minimap should exist to test drag interaction")

    let highlightPredicate = NSPredicate(format: "identifier CONTAINS[c] 'minimap' AND identifier != 'minimap' AND (identifier CONTAINS[c] 'highlight' OR identifier CONTAINS[c] 'viewport' OR identifier CONTAINS[c] 'current')")
    let highlight = minimap.otherElements.matching(highlightPredicate).firstMatch
    let highlightBefore = highlight.exists ? highlight.frame : .zero

    let start = minimap.coordinate(withNormalizedOffset: CGVector(dx: 0.5, dy: 0.2))
    let end = minimap.coordinate(withNormalizedOffset: CGVector(dx: 0.5, dy: 0.8))
    start.press(forDuration: 0.1, thenDragTo: end)
    sleep(1)

    if highlight.waitForExistence(timeout: 1) {
        let highlightAfter = highlight.frame
        XCTAssertNotEqual(highlightBefore.origin.y, highlightAfter.origin.y, "Dragging in the minimap should move the highlighted/viewport position")
    } else {
        XCTAssertTrue(minimap.exists, "Minimap should remain present after dragging")
    }
}

func testMinimapScrollSync() throws {
    let candidates: [XCUIElement] = [
        app.otherElements["minimap"],
        app.scrollViews["minimap"],
        app.images["minimap"],
        app.buttons["minimap"]
    ]
    let minimap = candidates.first(where: { $0.waitForExistence(timeout: 3) }) ?? app.otherElements["minimap"]
    XCTAssertTrue(minimap.exists, "Minimap should exist to test scroll sync")

    let editorCandidates: [XCUIElement] = [
        app.textViews["Editor"],
        app.textViews.matching(NSPredicate(format: "identifier CONTAINS[c] 'editor'")).firstMatch,
        app.scrollViews.matching(NSPredicate(format: "identifier CONTAINS[c] 'editor'")).firstMatch
    ]
    let editor = editorCandidates.first(where: { $0.waitForExistence(timeout: 2) })

    let highlightPredicate = NSPredicate(format: "identifier CONTAINS[c] 'minimap' AND identifier != 'minimap' AND (identifier CONTAINS[c] 'highlight' OR identifier CONTAINS[c] 'viewport' OR identifier CONTAINS[c] 'current')")
    let highlight = minimap.otherElements.matching(highlightPredicate).firstMatch

    guard let editor else {
        XCTSkip("Editor view not found; cannot verify minimap scroll synchronization")
        return
    }
    guard highlight.waitForExistence(timeout: 2) else {
        XCTSkip("Minimap highlight/viewport not found; cannot verify scroll synchronization")
        return
    }

    let before = highlight.frame
    editor.swipeUp()
    sleep(1)
    let after = highlight.frame

    XCTAssertNotEqual(before.origin.y, after.origin.y, "Scrolling the editor should update the minimap highlight/viewport position")
}

func testMinimapHighlightCurrentView() throws {
    let candidates: [XCUIElement] = [
        app.otherElements["minimap"],
        app.scrollViews["minimap"],
        app.images["minimap"],
        app.buttons["minimap"]
    ]
    let minimap = candidates.first(where: { $0.waitForExistence(timeout: 3) }) ?? app.otherElements["minimap"]
    XCTAssertTrue(minimap.exists, "Minimap should exist to test highlight")

    let highlightPredicate = NSPredicate(format: "identifier CONTAINS[c] 'minimap' AND identifier != 'minimap' AND (identifier CONTAINS[c] 'highlight' OR identifier CONTAINS[c] 'viewport' OR identifier CONTAINS[c] 'current')")
    let highlight = minimap.otherElements.matching(highlightPredicate).firstMatch

    XCTAssertTrue(highlight.waitForExistence(timeout: 2), "Minimap should show a highlighted/viewport element for the current visible region")

    // Basic sanity: highlight should be inside minimap bounds.
    XCTAssertTrue(minimap.frame.contains(highlight.frame), "Minimap highlight/viewport should be contained within the minimap")
}
```

>>>TOOL search
{"query":"accessibilityIdentifier", "glob":"VSCodeiPadOSUITests/SearchViewUITests.swift"}
>>>END>>>TOOL search
{"query":"textViews[\"Editor", "glob":"VSCodeiPadOSUITests/SearchViewUITests.swift"}
>>>END


---

## ðŸ”§ TOOL RESULTS

[search]
No matches found for "accessibilityIdentifier"

---

[search]
Found 1 matches:
VSCodeiPadOSUITests/SearchViewUITests.swift:261: let editorView = app.textViews["Editor"]


>>>TOOL read_file
{"path":"VSCodeiPadOSUITests/SearchViewUITests.swift","start_line":1,"end_line":430}
>>>END

---

## ðŸ”§ TOOL RESULTS

[read_file]
File: VSCodeiPadOSUITests/SearchViewUITests.swift (lines 2-424 of 424)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
2: 
3: /// UI Tests for SearchView
4: /// Tests search functionality, toggles, replace options, and result navigation
5: final class SearchViewUITests: XCTestCase {
6:     
7:     var app: XCUIApplication!
8:     
9:     override func setUpWithError() throws {
10:         continueAfterFailure = false
11:         app = XCUIApplication()
12:         app.launch()
13:         
14:         // Navigate to search view - assuming it's accessible from main UI
15:         // This may need adjustment based on actual app navigation structure
16:         openSearchView()
17:     }
18:     
19:     override func tearDownWithError() throws {
20:         app = nil
21:     }
22:     
23:     // MARK: - Helper Methods
24:     
25:     /// Opens the search view from the main app interface
26:     private func openSearchView() {
27:         // Try to find and tap search button/shortcut
28:         // Common ways to access search: toolbar button, keyboard shortcut, or menu item
29:         let searchButton = app.buttons["Search"]
30:         let findButton = app.buttons["Find"]
31:         let searchToolbarButton = app.toolbars.buttons["Search"]
32:         
33:         if searchButton.exists {
34:             searchButton.tap()
35:         } else if findButton.exists {
36:             findButton.tap()
37:         } else if searchToolbarButton.exists {
38:             searchToolbarButton.tap()
39:         } else {
40:             // Try using keyboard shortcut Cmd+Shift+F for global search
41:             // or Cmd+F for find
42:             XCUIDevice.shared.press(.home)
43:         }
44:     }
45:     
46:     // MARK: - Test Cases
47:     
48:     /// Test 1: Verify search text field is present
49:     func testSearchFieldExists() throws {
50:         // Search field should be present in the search view
51:         let searchField = app.textFields["Search"]
52:         let searchTextField = app.searchFields["Search"]
53:         let findTextField = app.textFields["Find"]
54:         
55:         // At least one search input field should exist
56:         let searchFieldExists = searchField.waitForExistence(timeout: 2) ||
57:                               searchTextField.waitForExistence(timeout: 2) ||
58:                               findTextField.waitForExistence(timeout: 2)
59:         
60:         XCTAssertTrue(searchFieldExists, "Search text field should be present in the search view")
61:     }
62:     
63:     /// Test 2: Verify matchCase, matchWholeWord, useRegex toggles exist
64:     func testToggleButtonsExist() throws {
65:         // Check for match case toggle/button
66:         let matchCaseToggle = app.toggles["Match Case"]
67:         let matchCaseButton = app.buttons["Match Case"]
68:         let matchCaseExists = matchCaseToggle.waitForExistence(timeout: 2) ||
69:                              matchCaseButton.waitForExistence(timeout: 2)
70:         
71:         // Check for match whole word toggle/button
72:         let matchWholeWordToggle = app.toggles["Match Whole Word"]
73:         let matchWholeWordButton = app.buttons["Match Whole Word"]
74:         let matchWholeWordExists = matchWholeWordToggle.waitForExistence(timeout: 2) ||
75:                                   matchWholeWordButton.waitForExistence(timeout: 2)
76:         
77:         // Check for use regex toggle/button
78:         let useRegexToggle = app.toggles["Use Regular Expressions"]
79:         let useRegexButton = app.buttons["Use Regular Expressions"]
80:         let regexButton = app.buttons["Regex"]
81:         let useRegexExists = useRegexToggle.waitForExistence(timeout: 2) ||
82:                            useRegexButton.waitForExistence(timeout: 2) ||
83:                            regexButton.waitForExistence(timeout: 2)
84:         
85:         XCTAssertTrue(matchCaseExists, "Match Case toggle should be present")
86:         XCTAssertTrue(matchWholeWordExists, "Match Whole Word toggle should be present")
87:         XCTAssertTrue(useRegexExists, "Use Regular Expressions toggle should be present")
88:     }
89:     
90:     /// Test 3: Test expand/collapse replace section
91:     func testReplaceSectionToggle() throws {
92:         // Find the replace section toggle/disclosure button
93:         let replaceToggle = app.buttons["Replace"]
94:         let replaceDisclosure = app.disclosureTriangles["Replace"]
95:         let replaceChevron = app.buttons.element(matching: .any, identifier: "replaceToggle")
96:         
97:         // First check if replace section exists
98:         let replaceField = app.textFields["Replace"]
99:         let replaceTextField = app.textViews["Replace"]
100:         
101:         // If replace field is not visible, try to toggle it
102:         if !replaceField.exists && !replaceTextField.exists {
103:             if replaceToggle.exists {
104:                 replaceToggle.tap()
105:             } else if replaceDisclosure.exists {
106:                 replaceDisclosure.tap()
107:             }
108:             
109:             // Wait for animation
110:             sleep(1)
111:         }
112:         
113:         // Verify replace field is now visible
114:         let replaceFieldVisible = app.textFields["Replace"].waitForExistence(timeout: 2) ||
115:                                  app.textViews["Replace"].waitForExistence(timeout: 2)
116:         
117:         XCTAssertTrue(replaceFieldVisible, "Replace section should be expandable and show replace field")
118:     }
119:     
120:     /// Test 4: Test expand/collapse include/exclude patterns section
121:     func testIncludeExcludeSectionToggle() throws {
122:         // Find the patterns section toggle
123:         let patternsToggle = app.buttons["Files to Include/Exclude"]
124:         let includeExcludeToggle = app.buttons["Include/Exclude"]
125:         let filePatternsToggle = app.buttons["File Patterns"]
126:         
127:         // Try to find and toggle the patterns section
128:         let patternsToggleExists = patternsToggle.exists || 
129:                                   includeExcludeToggle.exists || 
130:                                   filePatternsToggle.exists
131:         
132:         if patternsToggleExists {
133:             if patternsToggle.exists {
134:                 patternsToggle.tap()
135:             } else if includeExcludeToggle.exists {
136:                 includeExcludeToggle.tap()
137:             } else if filePatternsToggle.exists {
138:                 filePatternsToggle.tap()
139:             }
140:             
141:             // Wait for animation
142:             sleep(1)
143:         }
144:         
145:         // Verify include/exclude fields are visible
146:         let includeField = app.textFields["files to include"]
147:         let excludeField = app.textFields["files to exclude"]
148:         let includePattern = app.textFields["Include patterns"]
149:         let excludePattern = app.textFields["Exclude patterns"]
150:         
151:         let patternsVisible = includeField.waitForExistence(timeout: 2) ||
152:                              excludeField.waitForExistence(timeout: 2) ||
153:                              includePattern.waitForExistence(timeout: 2) ||
154:                              excludePattern.waitForExistence(timeout: 2)
155:         
156:         XCTAssertTrue(patternsVisible, "Include/Exclude patterns section should be expandable")
157:     }
158:     
159:     /// Test 5: Type text and verify search triggers
160:     func testSearchExecutes() throws {
161:         // Find and interact with search field
162:         let searchField = app.textFields["Search"]
163:         let searchTextField = app.searchFields["Search"]
164:         
165:         let searchInput = searchField.exists ? searchField : searchTextField
166:         
167:         XCTAssertTrue(searchInput.waitForExistence(timeout: 2), "Search field should exist")
168:         
169:         // Tap and type search query
170:         searchInput.tap()
171:         searchInput.typeText("func")
172:         
173:         // Wait for search to execute (debounce/animation)
174:         sleep(2)
175:         
176:         // Verify search was triggered by checking for results or loading indicator
177:         let resultsList = app.collectionViews["Search Results"]
178:         let resultsTable = app.tables["Search Results"]
179:         let loadingIndicator = app.activityIndicators["In progress"]
180:         let resultCount = app.staticTexts.matching(NSPredicate(format: "label CONTAINS 'result'"))
181:         
182:         let searchTriggered = resultsList.exists || 
183:                              resultsTable.exists || 
184:                              loadingIndicator.exists || 
185:                              resultCount.count > 0
186:         
187:         XCTAssertTrue(searchTriggered, "Search should execute after typing text")
188:     }
189:     
190:     /// Test 6: Verify results appear after search
191:     func testResultsDisplay() throws {
192:         // First perform a search
193:         let searchField = app.textFields["Search"]
194:         let searchTextField = app.searchFields["Search"]
195:         let searchInput = searchField.exists ? searchField : searchTextField
196:         
197:         guard searchInput.waitForExistence(timeout: 2) else {
198:             XCTSkip("Search field not available")
199:             return
200:         }
201:         
202:         searchInput.tap()
203:         searchInput.typeText("import")
204:         
205:         // Wait for search results
206:         sleep(3)
207:         
208:         // Check for results in various formats
209:         let resultsList = app.collectionViews["Search Results"]
210:         let resultsTable = app.tables["Search Results"]
211:         let resultCells = app.cells.matching(NSPredicate(format: "identifier CONTAINS 'result' OR label CONTAINS 'result'"))
212:         let fileResults = app.staticTexts.matching(NSPredicate(format: "label CONTAINS '.swift' OR label CONTAINS '.ts' OR label CONTAINS '.js'"))
213:         let matchResults = app.staticTexts.matching(NSPredicate(format: "label CONTAINS 'import'"))
214:         
215:         let resultsVisible = resultsList.exists || 
216:                             resultsTable.exists || 
217:                             resultCells.count > 0 ||
218:                             fileResults.count > 0 ||
219:                             matchResults.count > 0
220:         
221:         XCTAssertTrue(resultsVisible, "Search results should be displayed after search execution")
222:     }
223:     
224:     /// Test 7: Test tapping result navigates to file location
225:     func testNavigateToResult() throws {
226:         // First perform a search to get results
227:         let searchField = app.textFields["Search"]
228:         let searchTextField = app.searchFields["Search"]
229:         let searchInput = searchField.exists ? searchField : searchTextField
230:         
231:         guard searchInput.waitForExistence(timeout: 2) else {
232:             XCTSkip("Search field not available")
233:             return
234:         }
235:         
236:         searchInput.tap()
237:         searchInput.typeText("func")
238:         
239:         // Wait for results
240:         sleep(3)
241:         
242:         // Find and tap a result cell
243:         let firstResult = app.cells.firstMatch
244:         let firstResultButton = app.buttons.matching(NSPredicate(format: "label CONTAINS '.swift' OR label CONTAINS '.ts'")).firstMatch
245:         let resultLink = app.links.firstMatch
246:         
247:         if firstResult.exists {
248:             firstResult.tap()
249:         } else if firstResultButton.exists {
250:             firstResultButton.tap()
251:         } else if resultLink.exists {
252:             resultLink.tap()
253:         } else {
254:             XCTSkip("No search results available to navigate")
255:             return
256:         }
257:         
258:         sleep(1)
259:         
260:         // Verify navigation occurred by checking for editor view or file content
261:         let editorView = app.textViews["Editor"]
262:         let codeEditor = app.textViews.matching(NSPredicate(format: "identifier CONTAINS 'editor' OR label CONTAINS 'editor'"))
263:         let fileContent = app.staticTexts.matching(NSPredicate(format: "label CONTAINS 'func'"))
264:         
265:         let navigated = editorView.exists || 
266:                        codeEditor.count > 0 ||
267:                        fileContent.count > 0
268:         
269:         XCTAssertTrue(navigated, "Tapping a search result should navigate to the file location")
270:     }
271:     
272:     /// Test 8: Test history dropdown appears when focusing search
273:     func testHistoryDropdown() throws {
274:         // First perform a search to create history
275:         let searchField = app.textFields["Search"]
276:         let searchTextField = app.searchFields["Search"]
277:         let searchInput = searchField.exists ? searchField : searchTextField
278:         
279:         guard searchInput.waitForExistence(timeout: 2) else {
280:             XCTSkip("Search field not available")
281:             return
282:         }
283:         
284:         // Create some search history
285:         searchInput.tap()
286:         searchInput.typeText("test query")
287:         sleep(2)
288:         
289:         // Clear the field
290:         let clearButton = app.buttons["Clear"]
291:         let clearTextButton = app.buttons.matching(NSPredicate(format: "label CONTAINS 'Clear' OR accessibilityLabel CONTAINS 'Clear'")).firstMatch
292:         
293:         if clearButton.exists {
294:             clearButton.tap()
295:         } else if clearTextButton.exists {
296:             clearTextButton.tap()
297:         } else {
298:             // Select all and delete
299:             searchInput.doubleTap()
300:             searchInput.typeText(XCUIKeyboardKey.delete.rawValue)
301:         }
302:         
303:         sleep(1)
304:         
305:         // Focus search field again to trigger history dropdown
306:         searchInput.tap()
307:         sleep(1)
308:         
309:         // Check for history dropdown
310:         let historyList = app.collectionViews["Search History"]
311:         let historyTable = app.tables["Search History"]
312:         let historyCell = app.cells.matching(NSPredicate(format: "label CONTAINS 'test query'"))
313:         let recentSearches = app.staticTexts["Recent Searches"]
314:         let historySection = app.otherElements["History"]
315:         
316:         let historyVisible = historyList.exists || 
317:                             historyTable.exists || 
318:                             historyCell.count > 0 ||
319:                             recentSearches.exists ||
320:                             historySection.exists
321:         
322:         // History may not always appear depending on implementation
323:         // So we just verify the field is focusable
324:         XCTAssertTrue(searchInput.isFocused || searchInput.hasKeyboardFocus || historyVisible, 
325:                     "Search field should be focusable and may show history dropdown")
326:     }
327:     
328:     /// Test 9: Verify replace button is present and clickable
329:     func testReplaceButton() throws {
330:         // First expand replace section if needed
331:         let replaceToggle = app.buttons["Replace"]
332:         if replaceToggle.exists {
333:             replaceToggle.tap()
334:             sleep(1)
335:         }
336:         
337:         // Find replace button
338:         let replaceButton = app.buttons["Replace"]
339:         let replaceAllButton = app.buttons["Replace All"]
340:         let replaceNextButton = app.buttons["Replace Next"]
341:         let replaceActionButton = app.buttons.matching(NSPredicate(format: "label CONTAINS 'Replace' AND label != 'Replace'")).firstMatch
342:         
343:         // Replace button might have different labels
344:         let replaceExists = replaceButton.waitForExistence(timeout: 2) ||
345:                          replaceAllButton.exists ||
346:                          replaceNextButton.exists ||
347:                          replaceActionButton.exists
348:         
349:         XCTAssertTrue(replaceExists, "Replace button should be present")
350:         
351:         // Enter some text in replace field first
352:         let replaceField = app.textFields["Replace"]
353:         if replaceField.exists {
354:             replaceField.tap()
355:             replaceField.typeText("replacement")
356:             
357:             // Try to tap replace button
358:             if replaceButton.exists && replaceButton.isEnabled {
359:                 replaceButton.tap()
360:                 XCTAssertTrue(true, "Replace button should be clickable")
361:             } else if replaceAllButton.exists && replaceAllButton.isEnabled {
362:                 // Don't actually replace all in tests
363:                 XCTAssertTrue(replaceAllButton.isEnabled, "Replace All button should be clickable")
364:             }
365:         }
366:     }
367:     
368:     /// Test 10: Verify clear button resets search
369:     func testClearSearch() throws {
370:         // Find search field and enter text
371:         let searchField = app.textFields["Search"]
372:         let searchTextField = app.searchFields["Search"]
373:         let searchInput = searchField.exists ? searchField : searchTextField
374:         
375:         guard searchInput.waitForExistence(timeout: 2) else {
376:             XCTSkip("Search field not available")
377:             return
378:         }
379:         
380:         // Type search text
381:         searchInput.tap()
382:         searchInput.typeText("clear test")
383:         sleep(1)
384:         
385:         // Verify text was entered
386:         let hasText = searchInput.value != nil && (searchInput.value as? String) != ""
387:         XCTAssertTrue(hasText || true, "Search field should have text entered")
388:         
389:         // Find and tap clear button
390:         let clearButton = app.buttons["Clear"]
391:         let clearTextButton = app.buttons.matching(NSPredicate(format: "label CONTAINS 'Clear' OR accessibilityLabel CONTAINS 'Clear'")).firstMatch
392:         let clearSearchButton = app.buttons.matching(NSPredicate(format: "identifier CONTAINS 'clear'")).firstMatch
393:         
394:         let clearExists = clearButton.exists || clearTextButton.exists || clearSearchButton.exists
395:         
396:         if clearExists {
397:             if clearButton.exists {
398:                 clearButton.tap()
399:             } else if clearTextButton.exists {
400:                 clearTextButton.tap()
401:             } else if clearSearchButton.exists {
402:                 clearSearchButton.tap()
403:             }
404:             
405:             sleep(1)
406:             
407:             // Verify search was cleared
408:             let searchCleared = (searchInput.value as? String)?.isEmpty ?? true
409:             XCTAssertTrue(searchCleared || searchInput.value as? String == "Search", 
410:                          "Clear button should reset search text")
411:         } else {
412:             // Try clearing with keyboard shortcut or selection + delete
413:             searchInput.doubleTap()
414:             searchInput.typeText(XCUIKeyboardKey.delete.rawValue)
415:             
416:             sleep(1)
417:             
418:             // Verify text was cleared
419:             let finalValue = searchInput.value as? String ?? ""
420:             XCTAssertTrue(finalValue.isEmpty || finalValue == "Search", 
421:                          "Search field should be cleared")
422:         }
423:     }
424: }


>>>TOOL create_file
{"path":"VSCodeiPadOSUITests/._tmp_minimap_methods.txt","content":"temp"}
>>>END


---

## ðŸ”§ TOOL RESULTS

Error: File 'VSCodeiPadOSUITests/._tmp_minimap_methods.txt' not in allowed paths: VSCodeiPadOSUITests/SearchViewUITests.swift


>>>TOOL read_file
{"path":"VSCodeiPadOSUITests/SearchViewUITests.swift","start_line":1,"end_line":120}
>>>END

---

## ðŸ”§ TOOL RESULTS

[read_file]
File: VSCodeiPadOSUITests/SearchViewUITests.swift (lines 2-120 of 726)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
2: 
3: /// UI Tests for SearchView
4: /// Tests search functionality, toggles, replace options, and result navigation
5: final class SearchViewUITests: XCTestCase {
6:     
7:     var app: XCUIApplication!
8:     
9:     override func setUpWithError() throws {
10:         continueAfterFailure = false
11:         app = XCUIApplication()
12:         app.launch()
13:         
14:         // Navigate to search view - assuming it's accessible from main UI
15:         // This may need adjustment based on actual app navigation structure
16:         openSearchView()
17:     }
18:     
19:     override func tearDownWithError() throws {
20:         app = nil
21:     }
22:     
23:     // MARK: - Helper Methods
24:     
25:     /// Opens the search view from the main app interface
26:     private func openSearchView() {
27:         // Try to find and tap search button/shortcut
28:         // Common ways to access search: toolbar button, keyboard shortcut, or menu item
29:         let searchButton = app.buttons["Search"]
30:         let findButton = app.buttons["Find"]
31:         let searchToolbarButton = app.toolbars.buttons["Search"]
32:         
33:         if searchButton.exists {
34:             searchButton.tap()
35:         } else if findButton.exists {
36:             findButton.tap()
37:         } else if searchToolbarButton.exists {
38:             searchToolbarButton.tap()
39:         } else {
40:             // Try using keyboard shortcut Cmd+Shift+F for global search
41:             // or Cmd+F for find
42:             XCUIDevice.shared.press(.home)
43:         }
44:     }
45:     
46:     // MARK: - Test Cases
47:     
48:     /// Test 1: Verify search text field is present
49:     func testSearchFieldExists() throws {
50:         // Search field should be present in the search view
51:         let searchField = app.textFields["Search"]
52:         let searchTextField = app.searchFields["Search"]
53:         let findTextField = app.textFields["Find"]
54:         
55:         // At least one search input field should exist
56:         let searchFieldExists = searchField.waitForExistence(timeout: 2) ||
57:                               searchTextField.waitForExistence(timeout: 2) ||
58:                               findTextField.waitForExistence(timeout: 2)
59:         
60:         XCTAssertTrue(searchFieldExists, "Search text field should be present in the search view")
61:     }
62:     
63:     /// Test 2: Verify matchCase, matchWholeWord, useRegex toggles exist
64:     func testToggleButtonsExist() throws {
65:         // Check for match case toggle/button
66:         let matchCaseToggle = app.toggles["Match Case"]
67:         let matchCaseButton = app.buttons["Match Case"]
68:         let matchCaseExists = matchCaseToggle.waitForExistence(timeout: 2) ||
69:                              matchCaseButton.waitForExistence(timeout: 2)
70:         
71:         // Check for match whole word toggle/button
72:         let matchWholeWordToggle = app.toggles["Match Whole Word"]
73:         let matchWholeWordButton = app.buttons["Match Whole Word"]
74:         let matchWholeWordExists = matchWholeWordToggle.waitForExistence(timeout: 2) ||
75:                                   matchWholeWordButton.waitForExistence(timeout: 2)
76:         
77:         // Check for use regex toggle/button
78:         let useRegexToggle = app.toggles["Use Regular Expressions"]
79:         let useRegexButton = app.buttons["Use Regular Expressions"]
80:         let regexButton = app.buttons["Regex"]
81:         let useRegexExists = useRegexToggle.waitForExistence(timeout: 2) ||
82:                            useRegexButton.waitForExistence(timeout: 2) ||
83:                            regexButton.waitForExistence(timeout: 2)
84:         
85:         XCTAssertTrue(matchCaseExists, "Match Case toggle should be present")
86:         XCTAssertTrue(matchWholeWordExists, "Match Whole Word toggle should be present")
87:         XCTAssertTrue(useRegexExists, "Use Regular Expressions toggle should be present")
88:     }
89:     
90:     /// Test 3: Test expand/collapse replace section
91:     func testReplaceSectionToggle() throws {
92:         // Find the replace section toggle/disclosure button
93:         let replaceToggle = app.buttons["Replace"]
94:         let replaceDisclosure = app.disclosureTriangles["Replace"]
95:         let replaceChevron = app.buttons.element(matching: .any, identifier: "replaceToggle")
96:         
97:         // First check if replace section exists
98:         let replaceField = app.textFields["Replace"]
99:         let replaceTextField = app.textViews["Replace"]
100:         
101:         // If replace field is not visible, try to toggle it
102:         if !replaceField.exists && !replaceTextField.exists {
103:             if replaceToggle.exists {
104:                 replaceToggle.tap()
105:             } else if replaceDisclosure.exists {
106:                 replaceDisclosure.tap()
107:             }
108:             
109:             // Wait for animation
110:             sleep(1)
111:         }
112:         
113:         // Verify replace field is now visible
114:         let replaceFieldVisible = app.textFields["Replace"].waitForExistence(timeout: 2) ||
115:                                  app.textViews["Replace"].waitForExistence(timeout: 2)
116:         
117:         XCTAssertTrue(replaceFieldVisible, "Replace section should be expandable and show replace field")
118:     }
119:     
120:     /// Test 4: Test expand/collapse include/exclude patterns section




>>>REPORT
func testMinimapVisible() throws {
    let minimapById = app.otherElements["minimap"]
    let minimapFallback = app.descendants(matching: .any)
        .matching(NSPredicate(format: "identifier CONTAINS[c] 'minimap'"))
        .firstMatch

    let minimap = minimapById.waitForExistence(timeout: 3) ? minimapById : minimapFallback
    guard minimap.waitForExistence(timeout: 3) else {
        XCTSkip("Minimap not available in current UI state")
        return
    }

    XCTAssertTrue(minimap.exists, "Minimap should exist")
    XCTAssertTrue(minimap.isHittable || minimap.frame.width > 0, "Minimap should be visible/hittable")
}

func testMinimapClick() throws {
    let minimapById = app.otherElements["minimap"]
    let minimapFallback = app.descendants(matching: .any)
        .matching(NSPredicate(format: "identifier CONTAINS[c] 'minimap'"))
        .firstMatch
    let minimap = minimapById.waitForExistence(timeout: 3) ? minimapById : minimapFallback

    guard minimap.waitForExistence(timeout: 3) else {
        XCTSkip("Minimap not available in current UI state")
        return
    }

    let highlightById = app.otherElements["minimapHighlight"]
    let highlightFallback = app.descendants(matching: .any)
        .matching(NSPredicate(format: "identifier CONTAINS[c] 'minimap' AND identifier CONTAINS[c] 'highlight'"))
        .firstMatch
    let highlight = highlightById.exists ? highlightById : highlightFallback

    guard highlight.waitForExistence(timeout: 2) else {
        XCTSkip("Minimap highlight not available to validate click behavior")
        return
    }

    // Try to move to a known state (near top) before clicking lower in the minimap.
    let editorById = app.textViews["Editor"]
    let editorFallback = app.textViews.matching(NSPredicate(format: "identifier CONTAINS[c] 'editor'")).firstMatch
    let editor = editorById.exists ? editorById : editorFallback
    if editor.exists {
        editor.swipeDown()
        editor.swipeDown()
        sleep(1)
    }

    let beforeY = highlight.frame.midY

    // Click lower portion of minimap to jump down.
    minimap.coordinate(forNormalizedOffset: CGVector(dx: 0.5, dy: 0.85)).tap()
    sleep(1)

    let afterY = highlight.frame.midY
    XCTAssertNotEqual(beforeY, afterY, "Clicking minimap should change the current-view highlight position")
}

func testMinimapDrag() throws {
    let minimapById = app.otherElements["minimap"]
    let minimapFallback = app.descendants(matching: .any)
        .matching(NSPredicate(format: "identifier CONTAINS[c] 'minimap'"))
        .firstMatch
    let minimap = minimapById.waitForExistence(timeout: 3) ? minimapById : minimapFallback

    guard minimap.waitForExistence(timeout: 3) else {
        XCTSkip("Minimap not available in current UI state")
        return
    }

    let highlightById = app.otherElements["minimapHighlight"]
    let highlightFallback = app.descendants(matching: .any)
        .matching(NSPredicate(format: "identifier CONTAINS[c] 'minimap' AND identifier CONTAINS[c] 'highlight'"))
        .firstMatch
    let highlight = highlightById.exists ? highlightById : highlightFallback

    guard highlight.waitForExistence(timeout: 2) else {
        XCTSkip("Minimap highlight not available to validate drag behavior")
        return
    }

    let beforeY = highlight.frame.midY

    let start = minimap.coordinate(forNormalizedOffset: CGVector(dx: 0.5, dy: 0.25))
    let end = minimap.coordinate(forNormalizedOffset: CGVector(dx: 0.5, dy: 0.75))
    start.press(forDuration: 0.1, thenDragTo: end)
    sleep(1)

    let afterY = highlight.frame.midY
    XCTAssertNotEqual(beforeY, afterY, "Dragging on minimap should move the current-view highlight")
}

func testMinimapScrollSync() throws {
    let minimapById = app.otherElements["minimap"]
    let minimapFallback = app.descendants(matching: .any)
        .matching(NSPredicate(format: "identifier CONTAINS[c] 'minimap'"))
        .firstMatch
    let minimap = minimapById.waitForExistence(timeout: 3) ? minimapById : minimapFallback

    guard minimap.waitForExistence(timeout: 3) else {
        XCTSkip("Minimap not available in current UI state")
        return
    }

    let highlightById = app.otherElements["minimapHighlight"]
    let highlightFallback = app.descendants(matching: .any)
        .matching(NSPredicate(format: "identifier CONTAINS[c] 'minimap' AND identifier CONTAINS[c] 'highlight'"))
        .firstMatch
    let highlight = highlightById.exists ? highlightById : highlightFallback

    guard highlight.waitForExistence(timeout: 2) else {
        XCTSkip("Minimap highlight not available to validate scroll sync")
        return
    }

    let editorById = app.textViews["Editor"]
    let editorFallback = app.textViews.matching(NSPredicate(format: "identifier CONTAINS[c] 'editor'")).firstMatch
    let editor = editorById.exists ? editorById : editorFallback

    guard editor.waitForExistence(timeout: 3) else {
        XCTSkip("Editor view not available to validate minimap scroll sync")
        return
    }

    let beforeY = highlight.frame.midY

    editor.swipeUp()
    sleep(1)

    let afterY = highlight.frame.midY
    XCTAssertNotEqual(beforeY, afterY, "Scrolling editor should update minimap highlight position (scroll sync)")
}

func testMinimapHighlightCurrentView() throws {
    let minimapById = app.otherElements["minimap"]
    let minimapFallback = app.descendants(matching: .any)
        .matching(NSPredicate(format: "identifier CONTAINS[c] 'minimap'"))
        .firstMatch
    let minimap = minimapById.waitForExistence(timeout: 3) ? minimapById : minimapFallback

    guard minimap.waitForExistence(timeout: 3) else {
        XCTSkip("Minimap not available in current UI state")
        return
    }

    let highlightById = app.otherElements["minimapHighlight"]
    let highlightFallback = app.descendants(matching: .any)
        .matching(NSPredicate(format: "identifier CONTAINS[c] 'minimap' AND identifier CONTAINS[c] 'highlight'"))
        .firstMatch
    let highlight = highlightById.exists ? highlightById : highlightFallback

    guard highlight.waitForExistence(timeout: 2) else {
        XCTSkip("Minimap highlight not available in current UI state")
        return
    }

    XCTAssertTrue(highlight.exists, "Minimap should show a highlight for the current visible region")

    // Validate highlight appears within (or overlapping) minimap bounds.
    let minimapFrame = minimap.frame
    let highlightFrame = highlight.frame
    XCTAssertTrue(
        minimapFrame.intersects(highlightFrame),
        "Minimap highlight should be positioned within the minimap area"
    )
}
>>>END
