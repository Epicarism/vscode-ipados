# Agent: check-remote-debugger
**Status:** done
**Tokens:** 17,574
**Cost:** $0.0000
**Time:** 2026-02-09T18:03:01.836Z

## Task
Check if VSCodeiPadOS/VSCodeiPadOS/Services/RemoteDebugger.swift exists. If not, create it with full implementation for debugging via SSH using GDB/LLDB. Include setBreakpoint, removeBreakpoint, continue, stepOver, stepInto, stepOut, evaluateExpression, getStackTrace, getVariables, attach methods.

## Response
>>>TOOL read_file
{"path": "VSCodeiPadOS/VSCodeiPadOS/Services/RemoteDebugger.swift"}
>>>END

>>>TOOL list_dir
{"path": "VSCodeiPadOS/VSCodeiPadOS/Services"}
>>>END

Let me check the existing SSHManager and DebugManager to understand the patterns used in this project:

>>>TOOL read_file
{"path": "VSCodeiPadOS/VSCodeiPadOS/Services/SSHManager.swift"}
>>>END

>>>TOOL read_file
{"path": "VSCodeiPadOS/VSCodeiPadOS/Services/DebugManager.swift"}
>>>END

>>>TOOL read_file
{"path": "VSCodeiPadOS/VSCodeiPadOS/Services/SSHManager.swift"}
>>>END

Now I have a good understanding of the project patterns. I'll create the `RemoteDebugger.swift` with full GDB/LLDB debugging implementation via SSH:

>>>TOOL create_file
{"path": "VSCodeiPadOS/VSCodeiPadOS/Services/RemoteDebugger.swift", "content": "//\n//  RemoteDebugger.swift\n//  VSCodeiPadOS\n//\n//  Remote debugging via SSH using GDB/LLDB\n//  Provides full debugging capabilities over SSH connections\n//\n\nimport Foundation\nimport Combine\n\n// MARK: - Debugger Type\n\nenum DebuggerType: String, Codable, CaseIterable {\n    case gdb = \"gdb\"\n    case lldb = \"lldb\"\n    \n    var displayName: String {\n        switch self {\n        case .gdb: return \"GDB\"\n        case .lldb: return \"LLDB\"\n        }\n    }\n    \n    var executableName: String {\n        rawValue\n    }\n}\n\n// MARK: - Remote Debugger Configuration\n\nstruct RemoteDebuggerConfig: Codable, Identifiable {\n    var id: UUID = UUID()\n    var name: String\n    var sshConnectionId: UUID\n    var debuggerType: DebuggerType\n    var debuggerPath: String?  // Custom path to debugger executable\n    var programPath: String\n    var programArguments: [String]\n    var workingDirectory: String?\n    var environmentVariables: [String: String]\n    var attachToPID: Int?  // If set, attach instead of launching\n    var remoteTarget: String?  // For remote debugging (host:port)\n    \n    init(\n        name: String,\n        sshConnectionId: UUID,\n        debuggerType: DebuggerType = .lldb,\n        programPath: String,\n        programArguments: [String] = [],\n        workingDirectory: String? = nil,\n        environmentVariables: [String: String] = [:],\n        attachToPID: Int? = nil,\n        remoteTarget: String? = nil\n    ) {\n        self.name = name\n        self.sshConnectionId = sshConnectionId\n        self.debuggerType = debuggerType\n        self.programPath = programPath\n        self.programArguments = programArguments\n        self.workingDirectory = workingDirectory\n        self.environmentVariables = environmentVariables\n        self.attachToPID = attachToPID\n        self.remoteTarget = remoteTarget\n    }\n}\n\n// MARK: - Debugger State\n\nenum RemoteDebuggerState: Equatable {\n    case disconnected\n    case connecting\n    case connected\n    case launching\n    case running\n    case stopped(reason: StopReason)\n    case terminated\n    \n    enum StopReason: Equatable {\n        case breakpoint(id: Int)\n        case step\n        case signal(name: String)\n        case exception(description: String)\n        case watchpoint(id: Int)\n        case unknown\n    }\n    \n    var isActive: Bool {\n        switch self {\n        case .running, .stopped: return true\n        default: return false\n        }\n    }\n    \n    var canStep: Bool {\n        if case .stopped = self { return true }\n        return false\n    }\n    \n    var canContinue: Bool {\n        if case .stopped = self { return true }\n        return false\n    }\n}\n\n// MARK: - Breakpoint Model\n\nstruct RemoteBreakpoint: Identifiable, Equatable, Hashable {\n    let id: Int  // Debugger-assigned ID\n    var file: String\n    var line: Int\n    var condition: String?\n    var hitCount: Int\n    var isEnabled: Bool\n    var isPending: Bool  // Not yet resolved by debugger\n    \n    init(id: Int, file: String, line: Int, condition: String? = nil, isEnabled: Bool = true) {\n        self.id = id\n        self.file = file\n        self.line = line\n        self.condition = condition\n        self.hitCount = 0\n        self.isEnabled = isEnabled\n        self.isPending = true\n    }\n}\n\n// MARK: - Stack Frame Model\n\nstruct RemoteStackFrame: Identifiable, Equatable {\n    let id: Int  // Frame index\n    var function: String\n    var file: String?\n    var line: Int?\n    var address: String\n    var module: String?\n    var arguments: [RemoteVariable]\n    \n    var displayLocation: String {\n        if let file = file, let line = line {\n            return \"\\(file):\\(line)\"\n        } else if let module = module {\n            return \"\\(module) @ \\(address)\"\n        }\n        return address\n    }\n}\n\n// MARK: - Variable Model\n\nstruct RemoteVariable: Identifiable, Equatable {\n    let id: String\n    var name: String\n    var value: String\n    var type: String\n    var numChildren: Int\n    var children: [RemoteVariable]\n    var isExpandable: Bool { numChildren > 0 }\n    var hasLoadedChildren: Bool\n    \n    init(id: String = UUID().uuidString, name: String, value: String, type: String, numChildren: Int = 0) {\n        self.id = id\n        self.name = name\n        self.value = value\n        self.type = type\n        self.numChildren = numChildren\n        self.children = []\n        self.hasLoadedChildren = false\n    }\n}\n\n// MARK: - Expression Result\n\nstruct ExpressionResult: Equatable {\n    var expression: String\n    var value: String\n    var type: String\n    var error: String?\n    \n    var isError: Bool { error != nil }\n}\n\n// MARK: - Debugger Events\n\nenum RemoteDebuggerEvent {\n    case stateChanged(RemoteDebuggerState)\n    case breakpointHit(RemoteBreakpoint, RemoteStackFrame)\n    case breakpointAdded(RemoteBreakpoint)\n    case breakpointRemoved(Int)\n    case breakpointModified(RemoteBreakpoint)\n    case stackUpdated([RemoteStackFrame])\n    case variablesUpdated([RemoteVariable])\n    case output(String, OutputType)\n    case error(String)\n    case terminated(exitCode: Int?)\n    \n    enum OutputType {\n        case stdout\n        case stderr\n        case debugger\n        case target\n    }\n}\n\n// MARK: - Remote Debugger Protocol\n\nprotocol RemoteDebuggerDelegate: AnyObject {\n    func debugger(_ debugger: RemoteDebugger, didReceiveEvent event: RemoteDebuggerEvent)\n}\n\n// MARK: - Remote Debugger\n\n@MainActor\nfinal class RemoteDebugger: ObservableObject {\n    \n    // MARK: - Published State\n    \n    @Published private(set) var state: RemoteDebuggerState = .disconnected\n    @Published private(set) var breakpoints: [Int: RemoteBreakpoint] = [:]\n    @Published private(set) var callStack: [RemoteStackFrame] = []\n    @Published private(set) var currentFrameIndex: Int = 0\n    @Published private(set) var localVariables: [RemoteVariable] = []\n    @Published private(set) var globalVariables: [RemoteVariable] = []\n    @Published private(set) var registers: [RemoteVariable] = []\n    @Published private(set) var consoleOutput: [String] = []\n    \n    // MARK: - Properties\n    \n    weak var delegate: RemoteDebuggerDelegate?\n    \n    private var config: RemoteDebuggerConfig?\n    private var sshManager: SSHManager?\n    private var debuggerType: DebuggerType = .lldb\n    private var nextBreakpointId: Int = 1\n    private var pendingCommands: [String: CheckedContinuation<String, Error>] = [:]\n    private var outputBuffer: String = \"\"\n    private var isProcessingOutput: Bool = false\n    private var commandQueue: [(command: String, continuation: CheckedContinuation<String, Error>)] = []\n    private var isExecutingCommand: Bool = false\n    \n    // MARK: - Prompt Detection\n    \n    private var lldbPrompt = \"(lldb) \"\n    private var gdbPrompt = \"(gdb) \"\n    \n    private var currentPrompt: String {\n        debuggerType == .lldb ? lldbPrompt : gdbPrompt\n    }\n    \n    // MARK: - Initialization\n    \n    init() {}\n    \n    // MARK: - Connection\n    \n    /// Connect to remote debugger via SSH\n    func connect(config: RemoteDebuggerConfig, sshConfig: SSHConnectionConfig) async throws {\n        self.config = config\n        self.debuggerType = config.debuggerType\n        \n        state = .connecting\n        emitEvent(.stateChanged(.connecting))\n        \n        // Create and configure SSH manager\n        let ssh = SSHManager()\n        self.sshManager = ssh\n        \n        // Set up SSH delegate to receive output\n        let outputHandler = SSHOutputHandler(debugger: self)\n        ssh.delegate = outputHandler\n        \n        // Connect via SSH\n        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<Void, Error>) in\n            ssh.connect(config: sshConfig) { result in\n                switch result {\n                case .success:\n                    continuation.resume()\n                case .failure(let error):\n                    continuation.resume(throwing: error)\n                }\n            }\n        }\n        \n        state = .connected\n        emitEvent(.stateChanged(.connected))\n        \n        // Start the debugger\n        try await startDebugger()\n    }\n    \n    /// Disconnect from remote debugger\n    func disconnect() async {\n        // Send quit command if connected\n        if state.isActive {\n            let quitCmd = debuggerType == .lldb ? \"quit\" : \"quit\"\n            try? await sendCommand(quitCmd)\n        }\n        \n        sshManager?.disconnect()\n        sshManager = nil\n        \n        state = .disconnected\n        emitEvent(.stateChanged(.disconnected))\n        \n        // Clear state\n        breakpoints.removeAll()\n        callStack.removeAll()\n        localVariables.removeAll()\n        consoleOutput.removeAll()\n    }\n    \n    // MARK: - Debugger Lifecycle\n    \n    private func startDebugger() async throws {\n        guard let config = config else {\n            throw RemoteDebuggerError.notConfigured\n        }\n        \n        state = .launching\n        emitEvent(.stateChanged(.launching))\n        \n        // Build debugger launch command\n        let debuggerPath = config.debuggerPath ?? config.debuggerType.executableName\n        var launchCommand = debuggerPath\n        \n        // Add program to debug\n        if config.attachToPID == nil && config.remoteTarget == nil {\n            launchCommand += \" \\\"\\(config.programPath)\\\"\"\n        }\n        \n        // Send command to start debugger\n        sshManager?.send(command: launchCommand)\n        \n        // Wait for debugger prompt\n        try await waitForPrompt(timeout: 10)\n        \n        // Configure debugger settings\n        try await configureDebugger()\n        \n        // Handle attach or remote target if specified\n        if let pid = config.attachToPID {\n            try await attach(toPID: pid)\n        } else if let target = config.remoteTarget {\n            try await connectToRemoteTarget(target)\n        } else {\n            // Set program arguments if any\n            if !config.programArguments.isEmpty {\n                try await setProgramArguments(config.programArguments)\n            }\n            \n            // Set environment variables\n            for (key, value) in config.environmentVariables {\n                try await setEnvironmentVariable(key: key, value: value)\n            }\n            \n            // Set working directory\n            if let workDir = config.workingDirectory {\n                try await setWorkingDirectory(workDir)\n            }\n        }\n        \n        state = .stopped(reason: .unknown)\n        emitEvent(.stateChanged(.stopped(reason: .unknown)))\n    }\n    \n    private func configureDebugger() async throws {\n        if debuggerType == .lldb {\n            // LLDB configuration\n            _ = try await sendCommand(\"settings set stop-line-count-after 0\")\n            _ = try await sendCommand(\"settings set stop-line-count-before 0\")\n            _ = try await sendCommand(\"settings set frame-format \\\"frame #${frame.index}: ${frame.pc}{ ${module.file.basename}{`${function.name-with-args}{${frame.no-debug}${function.pc-offset}}}}{ at ${line.file.basename}:${line.number}}\\\\n\\\"\")\n        } else {\n            // GDB configuration\n            _ = try await sendCommand(\"set pagination off\")\n            _ = try await sendCommand(\"set print pretty on\")\n            _ = try await sendCommand(\"set print array on\")\n        }\n    }\n    \n    // MARK: - Breakpoint Management\n    \n    /// Set a breakpoint at file:line\n    @discardableResult\n    func setBreakpoint(file: String, line: Int, condition: String? = nil) async throws -> RemoteBreakpoint {\n        let command: String\n        if debuggerType == .lldb {\n            command = \"breakpoint set --file \\\"\\(file)\\\" --line \\(line)\"\n        } else {\n            command = \"break \\(file):\\(line)\"\n        }\n        \n        let response = try await sendCommand(command)\n        \n        // Parse breakpoint ID from response\n        let breakpointId = parseBreakpointId(from: response)\n        \n        var breakpoint = RemoteBreakpoint(\n            id: breakpointId,\n            file: file,\n            line: line,\n            condition: condition\n        )\n        \n        // Set condition if provided\n        if let condition = condition {\n            try await setBreakpointCondition(id: breakpointId, condition: condition)\n            breakpoint.condition = condition\n        }\n        \n        breakpoint.isPending = false\n        breakpoints[breakpointId] = breakpoint\n        \n        emitEvent(.breakpointAdded(breakpoint))\n        return breakpoint\n    }\n    \n    /// Set a breakpoint at a function name\n    @discardableResult\n    func setBreakpoint(function: String, condition: String? = nil) async throws -> RemoteBreakpoint {\n        let command: String\n        if debuggerType == .lldb {\n            command = \"breakpoint set --name \\\"\\(function)\\\"\"\n        } else {\n            command = \"break \\(function)\"\n        }\n        \n        let response = try await sendCommand(command)\n        let breakpointId = parseBreakpointId(from: response)\n        \n        var breakpoint = RemoteBreakpoint(\n            id: breakpointId,\n            file: \"\",\n            line: 0,\n            condition: condition\n        )\n        breakpoint.isPending = false\n        \n        if let condition = condition {\n            try await setBreakpointCondition(id: breakpointId, condition: condition)\n        }\n        \n        breakpoints[breakpointId] = breakpoint\n        emitEvent(.breakpointAdded(breakpoint))\n        return breakpoint\n    }\n    \n    /// Set a breakpoint at an address\n    @discardableResult\n    func setBreakpoint(address: String) async throws -> RemoteBreakpoint {\n        let command: String\n        if debuggerType == .lldb {\n            command = \"breakpoint set --address \\(address)\"\n        } else {\n            command = \"break *\\(address)\"\n        }\n        \n        let response = try await sendCommand(command)\n        let breakpointId = parseBreakpointId(from: response)\n        \n        var breakpoint = RemoteBreakpoint(\n            id: breakpointId,\n            file: \"\",\n            line: 0\n        )\n        breakpoint.isPending = false\n        \n        breakpoints[breakpointId] = breakpoint\n        emitEvent(.breakpointAdded(breakpoint))\n        return breakpoint\n    }\n    \n    /// Remove a breakpoint by ID\n    func removeBreakpoint(id: Int) async throws {\n        let command: String\n        if debuggerType == .lldb {\n            command = \"breakpoint delete \\(id)\"\n        } else {\n            command = \"delete \\(id)\"\n        }\n        \n        _ = try await sendCommand(command)\n        breakpoints.removeValue(forKey: id)\n        emitEvent(.breakpointRemoved(id))\n    }\n    \n    /// Remove breakpoint at file:line\n    func removeBreakpoint(file: String, line: Int) async throws {\n        // Find breakpoint matching file:line\n        guard let bp = breakpoints.values.first(where: { $0.file == file && $0.line == line }) else {\n            return\n        }\n        try await removeBreakpoint(id: bp.id)\n    }\n    \n    /// Enable a breakpoint\n    func enableBreakpoint(id: Int) async throws {\n        let command: String\n        if debuggerType == .lldb {\n            command = \"breakpoint enable \\(id)\"\n        } else {\n            command = \"enable \\(id)\"\n        }\n        \n        _ = try await sendCommand(command)\n        breakpoints[id]?.isEnabled = true\n        if let bp = breakpoints[id] {\n            emitEvent(.breakpointModified(bp))\n        }\n    }\n    \n    /// Disable a breakpoint\n    func disableBreakpoint(id: Int) async throws {\n        let command: String\n        if debuggerType == .lldb {\n            command = \"breakpoint disable \\(id)\"\n        } else {\n            command = \"disable \\(id)\"\n        }\n        \n        _ = try await sendCommand(command)\n        breakpoints[id]?.isEnabled = false\n        if let bp = breakpoints[id] {\n            emitEvent(.breakpointModified(bp))\n        }\n    }\n    \n    /// Set breakpoint condition\n    func setBreakpointCondition(id: Int, condition: String) async throws {\n        let command: String\n        if debuggerType == .lldb {\n            command = \"breakpoint modify -c \\\"\\(condition)\\\" \\(id)\"\n        } else {\n            command = \"condition \\(id) \\(condition)\"\n        }\n        \n        _ = try await sendCommand(command)\n        breakpoints[id]?.condition = condition\n    }\n    \n    /// List all breakpoints\n    func listBreakpoints() async throws -> [RemoteBreakpoint] {\n        let command = debuggerType == .lldb ? \"breakpoint list\" : \"info breakpoints\"\n        let response = try await sendCommand(command)\n        \n        // Parse and update breakpoints from response\n        let parsedBreakpoints = parseBreakpointList(from: response)\n        for bp in parsedBreakpoints {\n            breakpoints[bp.id] = bp\n        }\n        \n        return Array(breakpoints.values)\n    }\n    \n    // MARK: - Execution Control\n    \n    /// Run/continue the program\n    func `continue`() async throws {\n        guard state.canContinue else {\n            throw RemoteDebuggerError.invalidState\n        }\n        \n        let command = debuggerType == .lldb ? \"continue\" : \"continue\"\n        \n        state = .running\n        emitEvent(.stateChanged(.running))\n        \n        let response = try await sendCommandAsync(command)\n        handleStopResponse(response)\n    }\n    \n    /// Run the program from the beginning\n    func run() async throws {\n        let command = debuggerType == .lldb ? \"run\" : \"run\"\n        \n        state = .running\n        emitEvent(.stateChanged(.running))\n        \n        let response = try await sendCommandAsync(command)\n        handleStopResponse(response)\n    }\n    \n    /// Step over (next line)\n    func stepOver() async throws {\n        guard state.canStep else {\n            throw RemoteDebuggerError.invalidState\n        }\n        \n        let command = debuggerType == .lldb ? \"next\" : \"next\"\n        \n        state = .running\n        emitEvent(.stateChanged(.running))\n        \n        let response = try await sendCommand(command)\n        handleStopResponse(response)\n        \n        // Update stack and variables\n        try await refreshState()\n    }\n    \n    /// Step into function\n    func stepInto() async throws {\n        guard state.canStep else {\n            throw RemoteDebuggerError.invalidState\n        }\n        \n        let command = debuggerType == .lldb ? \"step\" : \"step\"\n        \n        state = .running\n        emitEvent(.stateChanged(.running))\n        \n        let response = try await sendCommand(command)\n        handleStopResponse(response)\n        \n        try await refreshState()\n    }\n    \n    /// Step out of current function\n    func stepOut() async throws {\n        guard state.canStep else {\n            throw RemoteDebuggerError.invalidState\n        }\n        \n        let command = debuggerType == .lldb ? \"finish\" : \"finish\"\n        \n        state = .running\n        emitEvent(.stateChanged(.running))\n        \n        let response = try await sendCommand(command)\n        handleStopResponse(response)\n        \n        try await refreshState()\n    }\n    \n    /// Step one instruction\n    func stepInstruction() async throws {\n        guard state.canStep else {\n            throw RemoteDebuggerError.invalidState\n        }\n        \n        let command = debuggerType == .lldb ? \"si\" : \"stepi\"\n        \n        state = .running\n        emitEvent(.stateChanged(.running))\n        \n        let response = try await sendCommand(command)\n        handleStopResponse(response)\n        \n        try await refreshState()\n    }\n    \n    /// Pause/interrupt the running program\n    func pause() async throws {\n        guard state == .running else {\n            throw RemoteDebuggerError.invalidState\n        }\n        \n        // Send Ctrl+C to interrupt\n        sshManager?.sendInterrupt()\n        \n        // Wait for stop\n        try await waitForPrompt(timeout: 5)\n        \n        state = .stopped(reason: .signal(name: \"SIGINT\"))\n        emitEvent(.stateChanged(.stopped(reason: .signal(name: \"SIGINT\"))))\n        \n        try await refreshState()\n    }\n    \n    /// Stop/kill the debugged program\n    func stop() async throws {\n        let command = debuggerType == .lldb ? \"process kill\" : \"kill\"\n        _ = try await sendCommand(command)\n        \n        state = .terminated\n        emitEvent(.stateChanged(.terminated))\n        emitEvent(.terminated(exitCode: nil))\n    }\n    \n    // MARK: - Attach\n    \n    /// Attach to a running process by PID\n    func attach(toPID pid: Int) async throws {\n        let command: String\n        if debuggerType == .lldb {\n            command = \"process attach --pid \\(pid)\"\n        } else {\n            command = \"attach \\(pid)\"\n        }\n        \n        state = .running\n        emitEvent(.stateChanged(.running))\n        \n        let response = try await sendCommand(command)\n        \n        if response.contains(\"error\") || response.contains(\"failed\") {\n            throw RemoteDebuggerError.attachFailed(response)\n        }\n        \n        state = .stopped(reason: .unknown)\n        emitEvent(.stateChanged(.stopped(reason: .unknown)))\n        \n        try await refreshState()\n    }\n    \n    /// Attach to a process by name\n    func attach(toProcessName name: String, waitForLaunch: Bool = false) async throws {\n        let command: String\n        if debuggerType == .lldb {\n            if waitForLaunch {\n                command = \"process attach --name \\\"\\(name)\\\" --waitfor\"\n            } else {\n                command = \"process attach --name \\\"\\(name)\\\"\"\n            }\n        } else {\n            // GDB doesn't have direct name attach, need pidof first\n            command = \"attach $(pidof \\(name))\"\n        }\n        \n        state = .running\n        emitEvent(.stateChanged(.running))\n        \n        let response = try await sendCommandAsync(command)\n        \n        if response.contains(\"error\") || response.contains(\"failed\") {\n            throw RemoteDebuggerError.attachFailed(response)\n        }\n        \n        state = .stopped(reason: .unknown)\n        emitEvent(.stateChanged(.stopped(reason: .unknown)))\n        \n        try await refreshState()\n    }\n    \n    /// Connect to a remote debug server\n    func connectToRemoteTarget(_ target: String) async throws {\n        let command: String\n        if debuggerType == .lldb {\n            command = \"gdb-remote \\(target)\"\n        } else {\n            command = \"target remote \\(target)\"\n        }\n        \n        let response = try await sendCommand(command)\n        \n        if response.contains(\"error\") || response.contains(\"failed\") {\n            throw RemoteDebuggerError.connectionFailed(response)\n        }\n        \n        state = .stopped(reason: .unknown)\n        emitEvent(.stateChanged(.stopped(reason: .unknown)))\n    }\n    \n    /// Detach from the current process\n    func detach() async throws {\n        let command = debuggerType == .lldb ? \"process detach\" : \"detach\"\n        _ = try await sendCommand(command)\n        \n        state = .connected\n        emitEvent(.stateChanged(.connected))\n    }\n    \n    // MARK: - Expression Evaluation\n    \n    /// Evaluate an expression\n    func evaluateExpression(_ expression: String) async throws -> ExpressionResult {\n        let command: String\n        if debuggerType == .lldb {\n            command = \"expression -- \\(expression)\"\n        } else {\n            command = \"print \\(expression)\"\n        }\n        \n        let response = try await sendCommand(command)\n        return parseExpressionResult(from: response, expression: expression)\n    }\n    \n    /// Evaluate expression and get result as a specific type\n    func evaluateExpression<T>(_ expression: String, as type: T.Type) async throws -> T? where T: LosslessStringConvertible {\n        let result = try await evaluateExpression(expression)\n        if result.isError {\n            return nil\n        }\n        return T(result.value)\n    }\n    \n    /// Execute a debugger command directly\n    func executeCommand(_ command: String) async throws -> String {\n        let response = try await sendCommand(command)\n        appendConsoleOutput(\"(cmd) \\(command)\")\n        appendConsoleOutput(response)\n        return response\n    }\n    \n    // MARK: - Stack Trace\n    \n    /// Get the current call stack\n    func getStackTrace(maxFrames: Int = 100) async throws -> [RemoteStackFrame] {\n        let command: String\n        if debuggerType == .lldb {\n            command = \"thread backtrace -c \\(maxFrames)\"\n        } else {\n            command = \"backtrace \\(maxFrames)\"\n        }\n        \n        let response = try await sendCommand(command)\n        let frames = parseStackTrace(from: response)\n        \n        callStack = frames\n        emitEvent(.stackUpdated(frames))\n        \n        return frames\n    }\n    \n    /// Select a specific stack frame\n    func selectFrame(index: Int) async throws {\n        let command: String\n        if debuggerType == .lldb {\n            command = \"frame select \\(index)\"\n        } else {\n            command = \"frame \\(index)\"\n        }\n        \n        _ = try await sendCommand(command)\n        currentFrameIndex = index\n        \n        // Refresh variables for the new frame\n        _ = try await getVariables()\n    }\n    \n    // MARK: - Variables\n    \n    /// Get local variables for the current frame\n    func getVariables(frame: Int? = nil) async throws -> [RemoteVariable] {\n        if let frameIndex = frame {\n            try await selectFrame(index: frameIndex)\n        }\n        \n        let command: String\n        if debuggerType == .lldb {\n            command = \"frame variable\"\n        } else {\n            command = \"info locals\"\n        }\n        \n        let response = try await sendCommand(command)\n        let variables = parseVariables(from: response)\n        \n        localVariables = variables\n        emitEvent(.variablesUpdated(variables))\n        \n        return variables\n    }\n    \n    /// Get global variables\n    func getGlobalVariables() async throws -> [RemoteVariable] {\n        let command: String\n        if debuggerType == .lldb {\n            command = \"target variable\"\n        } else {\n            command = \"info variables\"\n        }\n        \n        let response = try await sendCommand(command)\n        let variables = parseVariables(from: response)\n        \n        globalVariables = variables\n        return variables\n    }\n    \n    /// Get function arguments for the current frame\n    func getArguments() async throws -> [RemoteVariable] {\n        let command: String\n        if debuggerType == .lldb {\n            command = \"frame variable -a\"\n        } else {\n            command = \"info args\"\n        }\n        \n        let response = try await sendCommand(command)\n        return parseVariables(from: response)\n    }\n    \n    /// Get CPU registers\n    func getRegisters() async throws -> [RemoteVariable] {\n        let command: String\n        if debuggerType == .lldb {\n            command = \"register read\"\n        } else {\n            command = \"info registers\"\n        }\n        \n        let response = try await sendCommand(command)\n        let regs = parseRegisters(from: response)\n        \n        registers = regs\n        return regs\n    }\n    \n    /// Expand a variable to get its children\n    func expandVariable(path: String) async throws -> [RemoteVariable] {\n        let command: String\n        if debuggerType == .lldb {\n            command = \"frame variable \\(path)\"\n        } else {\n            command = \"print \\(path)\"\n        }\n        \n        let response = try await sendCommand(command)\n        return parseVariables(from: response)\n    }\n    \n    /// Set a variable's value\n    func setVariable(name: String, value: String) async throws {\n        let command: String\n        if debuggerType == .lldb {\n            command = \"expression \\(name) = \\(value)\"\n        } else {\n            command = \"set var \\(name) = \\(value)\"\n        }\n        \n        let response = try await sendCommand(command)\n        \n        if response.contains(\"error\") {\n            throw RemoteDebuggerError.evaluationFailed(response)\n        }\n        \n        // Refresh variables\n        _ = try await getVariables()\n    }\n    \n    // MARK: - Memory\n    \n    /// Read memory at address\n    func readMemory(address: String, count: Int, format: String = \"x\") async throws -> String {\n        let command: String\n        if debuggerType == .lldb {\n            command = \"memory read -c \\(count) -f \\(format) \\(address)\"\n        } else {\n            command = \"x/\\(count)\\(format) \\(address)\"\n        }\n        \n        return try await sendCommand(command)\n    }\n    \n    /// Write memory at address\n    func writeMemory(address: String, value: String) async throws {\n        let command: String\n        if debuggerType == .lldb {\n            command = \"memory write \\(address) \\(value)\"\n        } else {\n            command = \"set {int}\\(address) = \\(value)\"\n        }\n        \n        _ = try await sendCommand(command)\n    }\n    \n    // MARK: - Threads\n    \n    /// Get all threads\n    func getThreads() async throws -> [(id: Int, name: String, isCurrent: Bool)] {\n        let command: String\n        if debuggerType == .lldb {\n            command = \"thread list\"\n        } else {\n            command = \"info threads\"\n        }\n        \n        let response = try await sendCommand(command)\n        return parseThreadList(from: response)\n    }\n    \n    /// Select a thread\n    func selectThread(id: Int) async throws {\n        let command: String\n        if debuggerType == .lldb {\n            command = \"thread select \\(id)\"\n        } else {\n            command = \"thread \\(id)\"\n        }\n        \n        _ = try await sendCommand(command)\n        try await refreshState()\n    }\n    \n    // MARK: - Configuration\n    \n    private func setProgramArguments(_ args: [String]) async throws {\n        if debuggerType == .lldb {\n            let argsString = args.map { \"\\\"\\($0)\\\"\" }.joined(separator: \" \")\n            _ = try await sendCommand(\"settings set target.run-args \\(argsString)\")\n        } else {\n            let argsString = args.joined(separator: \" \")\n            _ = try await sendCommand(\"set args \\(argsString)\")\n        }\n    }\n    \n    private func setEnvironmentVariable(key: String, value: String) async throws {\n        if debuggerType == .lldb {\n            _ = try await sendCommand(\"settings set target.env-vars \\(key)=\\\"\\(value)\\\"\")\n        } else {\n            _ = try await sendCommand(\"set environment \\(key)=\\(value)\")\n        }\n    }\n    \n    private func setWorkingDirectory(_ path: String) async throws {\n        if debuggerType == .lldb {\n            _ = try await sendCommand(\"settings set target.process.working-directory \\\"\\(path)\\\"\")\n        } else {\n            _ = try await sendCommand(\"cd \\(path)\")\n        }\n    }\n    \n    // MARK: - State Refresh\n    \n    private func refreshState() async throws {\n        _ = try await getStackTrace()\n        if !callStack.isEmpty {\n            _ = try await getVariables()\n        }\n    }\n    \n    // MARK: - Command Execution\n    \n    private func sendCommand(_ command: String) async throws -> String {\n        return try await withCheckedThrowingContinuation { continuation in\n            Task { @MainActor in\n                commandQueue.append((command: command, continuation: continuation))\n                processNextCommand()\n            }\n        }\n    }\n    \n    private func sendCommandAsync(_ command: String) async throws -> String {\n        // For commands that may take a long time (run, continue)\n        return try await sendCommand(command)\n    }\n    \n    private func processNextCommand() {\n        guard !isExecutingCommand, !commandQueue.isEmpty else { return }\n        \n        isExecutingCommand = true\n        let (command, continuation) = commandQueue.removeFirst()\n        \n        outputBuffer = \"\"\n        sshManager?.send(command: command)\n        \n        // Set up timeout and response handling\n        Task {\n            do {\n                let response = try await waitForResponse(timeout: 30)\n                continuation.resume(returning: response)\n            } catch {\n                continuation.resume(throwing: error)\n            }\n            \n            await MainActor.run {\n                isExecutingCommand = false\n                processNextCommand()\n            }\n        }\n    }\n    \n    private func waitForResponse(timeout: TimeInterval) async throws -> String {\n        let startTime = Date()\n        \n        while Date().timeIntervalSince(startTime) < timeout {\n            try await Task.sleep(nanoseconds: 50_000_000) // 50ms\n            \n            if outputBuffer.contains(currentPrompt) {\n                // Remove the prompt from the output\n                var response = outputBuffer\n                if let promptRange = response.range(of: currentPrompt, options: .backwards) {\n                    response = String(response[..<promptRange.lowerBound])\n                }\n                return response.trimmingCharacters(in: .whitespacesAndNewlines)\n            }\n        }\n        \n        throw RemoteDebuggerError.timeout\n    }\n    \n    private func waitForPrompt(timeout: TimeInterval) async throws {\n        _ = try await waitForResponse(timeout: timeout)\n    }\n    \n    // MARK: - Output Handling\n    \n    func handleSSHOutput(_ text: String) {\n        Task { @MainActor in\n            outputBuffer += text\n            appendConsoleOutput(text)\n            emitEvent(.output(text, .debugger))\n        }\n    }\n    \n    private func appendConsoleOutput(_ text: String) {\n        let lines = text.split(separator: \"\\n\", omittingEmptySubsequences: false)\n        for line in lines {\n            consoleOutput.append(String(line))\n        }\n        // Keep console output manageable\n        if consoleOutput.count > 10000 {\n            consoleOutput.removeFirst(consoleOutput.count - 10000)\n        }\n    }\n    \n    // MARK: - Response Parsing\n    \n    private func parseBreakpointId(from response: String) -> Int {\n        // LLDB: \"Breakpoint 1: where = ...\"\n        // GDB: \"Breakpoint 1 at 0x...\"\n        \n        let patterns = [\n            \"Breakpoint (\\\\d+)\",\n            \"breakpoint (\\\\d+)\"\n        ]\n        \n        for pattern in patterns {\n            if let regex = try? NSRegularExpression(pattern: pattern, options: .caseInsensitive),\n               let match = regex.firstMatch(in: response, options: [], range: NSRange(response.startIndex..., in: response)),\n               let range = Range(match.range(at: 1), in: response) {\n                if let id = Int(response[range]) {\n                    return id\n                }\n            }\n        }\n        \n        // Fallback: assign next ID\n        let id = nextBreakpointId\n        nextBreakpointId += 1\n        return id\n    }\n    \n    private func parseBreakpointList(from response: String) -> [RemoteBreakpoint] {\n        var breakpoints: [RemoteBreakpoint] = []\n        let lines = response.split(separator: \"\\n\")\n        \n        for line in lines {\n            // Parse LLDB format: \"1: file = 'path', line = 123, ...\"\n            // Parse GDB format: \"Num Type Disp Enb Address What\"\n            \n            if let bp = parseBreakpointLine(String(line)) {\n                breakpoints.append(bp)\n            }\n        }\n        \n        return breakpoints\n    }\n    \n    private func parseBreakpointLine(_ line: String) -> RemoteBreakpoint? {\n        // LLDB format parsing\n        if let regex = try? NSRegularExpression(pattern: \"^(\\\\d+):\", options: []),\n           let match = regex.firstMatch(in: line, options: [], range: NSRange(line.startIndex..., in: line)),\n           let idRange = Range(match.range(at: 1), in: line),\n           let id = Int(line[idRange]) {\n            \n            var file = \"\"\n            var lineNum = 0\n            \n            // Extract file\n            if let fileRegex = try? NSRegularExpression(pattern: \"file = '([^']+)'\", options: []),\n               let fileMatch = fileRegex.firstMatch(in: line, options: [], range: NSRange(line.startIndex..., in: line)),\n               let fileRange = Range(fileMatch.range(at: 1), in: line) {\n                file = String(line[fileRange])\n            }\n            \n            // Extract line\n            if let lineRegex = try? NSRegularExpression(pattern: \"line = (\\\\d+)\", options: []),\n               let lineMatch = lineRegex.firstMatch(in: line, options: [], range: NSRange(line.startIndex..., in: line)),\n               let lineRange = Range(lineMatch.range(at: 1), in: line) {\n                lineNum = Int(line[lineRange]) ?? 0\n            }\n            \n            return RemoteBreakpoint(id: id, file: file, line: lineNum)\n        }\n        \n        return nil\n    }\n    \n    private func parseStackTrace(from response: String) -> [RemoteStackFrame] {\n        var frames: [RemoteStackFrame] = []\n        let lines = response.split(separator: \"\\n\")\n        \n        for line in lines {\n            if let frame = parseStackFrameLine(String(line)) {\n                frames.append(frame)\n            }\n        }\n        \n        return frames\n    }\n    \n    private func parseStackFrameLine(_ line: String) -> RemoteStackFrame? {\n        // LLDB format: \"frame #0: 0x00001234 module`function at file.c:123\"\n        // GDB format: \"#0  function (args) at file.c:123\"\n        \n        let patterns: [(pattern: String, groups: (frame: Int, addr: Int, func: Int, file: Int, line: Int))] = [\n            // LLDB\n            (\"frame #(\\\\d+): (0x[0-9a-fA-F]+) .*`(.+?) at (.+):(\\\\d+)\", (1, 2, 3, 4, 5)),\n            (\"frame #(\\\\d+): (0x[0-9a-fA-F]+) .*`(.+?)$\", (1, 2, 3, -1, -1)),\n            // GDB\n            (\"#(\\\\d+)\\\\s+(.+?) \\\\(.*\\\\) at (.+):(\\\\d+)\", (1, -1, 2, 3, 4)),\n            (\"#(\\\\d+)\\\\s+(0x[0-9a-fA-F]+) in (.+?) \\\\(\", (1, 2, 3, -1, -1))\n        ]\n        \n        for (pattern, groups) in patterns {\n            guard let regex = try? NSRegularExpression(pattern: pattern, options: []),\n                  let match = regex.firstMatch(in: line, options: [], range: NSRange(line.startIndex..., in: line)) else {\n                continue\n            }\n            \n            func extractGroup(_ index: Int) -> String? {\n                guard index > 0 && index < match.numberOfRanges,\n                      let range = Range(match.range(at: index), in: line) else {\n                    return nil\n                }\n                return String(line[range])\n            }\n            \n            guard let frameIndexStr = extractGroup(groups.frame),\n                  let frameIndex = Int(frameIndexStr) else {\n                continue\n            }\n            \n            let address = extractGroup(groups.addr) ?? \"0x0\"\n            let function = extractGroup(groups.func) ?? \"<unknown>\"\n            let file = extractGroup(groups.file)\n            let lineNum = extractGroup(groups.line).flatMap { Int($0) }\n            \n            return RemoteStackFrame(\n                id: frameIndex,\n                function: function,\n                file: file,\n                line: lineNum,\n                address: address,\n                module: nil,\n                arguments: []\n            )\n        }\n        \n        return nil\n    }\n    \n    private func parseVariables(from response: String) -> [RemoteVariable] {\n        var variables: [RemoteVariable] = []\n        let lines = response.split(separator: \"\\n\")\n        \n        for line in lines {\n            if let variable = parseVariableLine(String(line)) {\n                variables.append(variable)\n            }\n        }\n        \n        return variables\n    }\n    \n    private func parseVariableLine(_ line: String) -> RemoteVariable? {\n        // LLDB format: \"(type) name = value\"\n        // GDB format: \"name = value\"\n        \n        // Try LLDB format first\n        if let regex = try? NSRegularExpression(pattern: \"\\\\(([^)]+)\\\\)\\\\s+(\\\\w+)\\\\s*=\\\\s*(.+)\", options: []),\n           let match = regex.firstMatch(in: line, options: [], range: NSRange(line.startIndex..., in: line)) {\n            \n            func extract(_ index: Int) -> String? {\n                guard let range = Range(match.range(at: index), in: line) else { return nil }\n                return String(line[range])\n            }\n            \n            if let type = extract(1), let name = extract(2), let value = extract(3) {\n                return RemoteVariable(name: name, value: value, type: type)\n            }\n        }\n        \n        // Try GDB format\n        if let regex = try? NSRegularExpression(pattern: \"(\\\\w+)\\\\s*=\\\\s*(.+)\", options: []),\n           let match = regex.firstMatch(in: line, options: [], range: NSRange(line.startIndex..., in: line)) {\n            \n            func extract(_ index: Int) -> String? {\n                guard let range = Range(match.range(at: index), in: line) else { return nil }\n                return String(line[range])\n            }\n            \n            if let name = extract(1), let value = extract(2) {\n                return RemoteVariable(name: name, value: value, type: \"\")\n            }\n        }\n        \n        return nil\n    }\n    \n    private func parseRegisters(from response: String) -> [RemoteVariable] {\n        var registers: [RemoteVariable] = []\n        let lines = response.split(separator: \"\\n\")\n        \n        for line in lines {\n            // Format: \"rax = 0x0000000000000000\"\n            if let regex = try? NSRegularExpression(pattern: \"(\\\\w+)\\\\s*=\\\\s*(0x[0-9a-fA-F]+)\", options: []),\n               let match = regex.firstMatch(in: String(line), options: [], range: NSRange(line.startIndex..., in: line)) {\n                \n                let lineStr = String(line)\n                if let nameRange = Range(match.range(at: 1), in: lineStr),\n                   let valueRange = Range(match.range(at: 2), in: lineStr) {\n                    let name = String(lineStr[nameRange])\n                    let value = String(lineStr[valueRange])\n                    registers.append(RemoteVariable(name: name, value: value, type: \"register\"))\n                }\n            }\n        }\n        \n        return registers\n    }\n    \n    private func parseExpressionResult(from response: String, expression: String) -> ExpressionResult {\n        // Check for error\n        if response.lowercased().contains(\"error:\") {\n            return ExpressionResult(\n                expression: expression,\n                value: \"\",\n                type: \"\",\n                error: response\n            )\n        }\n        \n        // LLDB format: \"(type) $0 = value\"\n        // GDB format: \"$1 = value\"\n        \n        var value = response\n        var type = \"\"\n        \n        if let regex = try? NSRegularExpression(pattern: \"\\\\(([^)]+)\\\\).*=\\\\s*(.+)\", options: [.dotMatchesLineSeparators]),\n           let match = regex.firstMatch(in: response, options: [], range: NSRange(response.startIndex..., in: response)) {\n            \n            if let typeRange = Range(match.range(at: 1), in: response) {\n                type = String(response[typeRange])\n            }\n            if let valueRange = Range(match.range(at: 2), in: response) {\n                value = String(response[valueRange]).trimmingCharacters(in: .whitespacesAndNewlines)\n            }\n        } else if let regex = try? NSRegularExpression(pattern: \"=\\\\s*(.+)\", options: [.dotMatchesLineSeparators]),\n                  let match = regex.firstMatch(in: response, options: [], range: NSRange(response.startIndex..., in: response)),\n                  let valueRange = Range(match.range(at: 1), in: response) {\n            value = String(response[valueRange]).trimmingCharacters(in: .whitespacesAndNewlines)\n        }\n        \n        return ExpressionResult(\n            expression: expression,\n            value: value,\n            type: type,\n            error: nil\n        )\n    }\n    \n    private func parseThreadList(from response: String) -> [(id: Int, name: String, isCurrent: Bool)] {\n        var threads: [(id: Int, name: String, isCurrent: Bool)] = []\n        let lines = response.split(separator: \"\\n\")\n        \n        for line in lines {\n            let lineStr = String(line)\n            let isCurrent = lineStr.contains(\"*\")\n            \n            // LLDB: \"* thread #1, name = 'main', ...\"\n            // GDB: \"* 1 Thread 0x... \\\"name\\\"\"\n            \n            if let regex = try? NSRegularExpression(pattern: \"thread #?(\\\\d+)\", options: .caseInsensitive),\n               let match = regex.firstMatch(in: lineStr, options: [], range: NSRange(lineStr.startIndex..., in: lineStr)),\n               let idRange = Range(match.range(at: 1), in: lineStr),\n               let id = Int(lineStr[idRange]) {\n                \n                var name = \"Thread \\(id)\"\n                if let nameRegex = try? NSRegularExpression(pattern: \"name\\\\s*=\\\\s*'([^']+)'\", options: []),\n                   let nameMatch = nameRegex.firstMatch(in: lineStr, options: [], range: NSRange(lineStr.startIndex..., in: lineStr)),\n                   let nameRange = Range(nameMatch.range(at: 1), in: lineStr) {\n                    name = String(lineStr[nameRange])\n                }\n                \n                threads.append((id: id, name: name, isCurrent: isCurrent))\n            }\n        }\n        \n        return threads\n    }\n    \n    private func handleStopResponse(_ response: String) {\n        // Determine stop reason from response\n        var reason: RemoteDebuggerState.StopReason = .unknown\n        \n        if response.contains(\"breakpoint\") {\n            // Extract breakpoint ID\n            if let regex = try? NSRegularExpression(pattern: \"breakpoint (\\\\d+)\", options: .caseInsensitive),\n               let match = regex.firstMatch(in: response, options: [], range: NSRange(response.startIndex..., in: response)),\n               let idRange = Range(match.range(at: 1), in: response),\n               let id = Int(response[idRange]) {\n                reason = .breakpoint(id: id)\n            }\n        } else if response.contains(\"signal\") || response.contains(\"SIGINT\") || response.contains(\"SIGSEGV\") {\n            let signalPattern = \"SIG[A-Z]+\"\n            if let regex = try? NSRegularExpression(pattern: signalPattern, options: []),\n               let match = regex.firstMatch(in: response, options: [], range: NSRange(response.startIndex..., in: response)),\n               let signalRange = Range(match.range, in: response) {\n                reason = .signal(name: String(response[signalRange]))\n            }\n        } else if response.contains(\"step\") {\n            reason = .step\n        } else if response.contains(\"watchpoint\") {\n            if let regex = try? NSRegularExpression(pattern: \"watchpoint (\\\\d+)\", options: .caseInsensitive),\n               let match = regex.firstMatch(in: response, options: [], range: NSRange(response.startIndex..., in: response)),\n               let idRange = Range(match.range(at: 1), in: response),\n               let id = Int(response[idRange]) {\n                reason = .watchpoint(id: id)\n            }\n        } else if response.contains(\"exited\") || response.contains(\"terminated\") {\n            state = .terminated\n            emitEvent(.stateChanged(.terminated))\n            return\n        }\n        \n        state = .stopped(reason: reason)\n        emitEvent(.stateChanged(.stopped(reason: reason)))\n    }\n    \n    // MARK: - Event Emission\n    \n    private func emitEvent(_ event: RemoteDebuggerEvent) {\n        delegate?.debugger(self, didReceiveEvent: event)\n    }\n}\n\n// MARK: - SSH Output Handler\n\nprivate class SSHOutputHandler: SSHManagerDelegate {\n    weak var debugger: RemoteDebugger?\n    \n    init(debugger: RemoteDebugger) {\n        self.debugger = debugger\n    }\n    \n    func sshManagerDidConnect(_ manager: SSHManager) {}\n    \n    func sshManagerDidDisconnect(_ manager: SSHManager, error: Error?) {\n        Task { @MainActor in\n            await debugger?.disconnect()\n        }\n    }\n    \n    func sshManager(_ manager: SSHManager, didReceiveOutput text: String) {\n        debugger?.handleSSHOutput(text)\n    }\n    \n    func sshManager(_ manager: SSHManager, didReceiveError text: String) {\n        debugger?.handleSSHOutput(text)\n    }\n}\n\n// MARK: - Errors\n\nenum RemoteDebuggerError: Error, LocalizedError {\n    case notConfigured\n    case notConnected\n    case connectionFailed(String)\n    case attachFailed(String)\n    case invalidState\n    case timeout\n    case evaluationFailed(String)\n    case breakpointFailed(String)\n    case commandFailed(String)\n    \n    var errorDescription: String? {\n        switch self {\n        case .notConfigured:\n            return \"Debugger not configured\"\n        case .notConnected:\n            return \"Not connected to remote debugger\"\n        case .connectionFailed(let reason):\n            return \"Connection failed: \\(reason)\"\n        case .attachFailed(let reason):\n            return \"Failed to attach: \\(reason)\"\n        case .invalidState:\n            return \"Invalid debugger state for this operation\"\n        case .timeout:\n            return \"Debugger command timed out\"\n        case .evaluationFailed(let reason):\n            return \"Expression evaluation failed: \\(reason)\"\n        case .breakpointFailed(let reason):\n            return \"Breakpoint operation failed: \\(reason)\"\n        case .commandFailed(let reason):\n            return \"Command failed: \\(reason)\"\n        }\n    }\n}\n\n// MARK: - SSH Command Extensions for RemoteDebugger\n\nextension SSHClientError {\n    static func commandExecutionFailed(_ reason: String) -> SSHClientError {\n        return .connectionFailed(reason)\n    }\n}\n\n// MARK: - Command Output Types\n\nenum SSHCommandOutput {\n    case stdout(String)\n    case stderr(String)\n    case exit(Int)\n    case error(Error)\n    case timeout\n}\n\nstruct SSHCommandResult {\n    let stdout: String\n    let stderr: String\n    let exitCode: Int\n    let isTimedOut: Bool\n    \n    var isSuccess: Bool {\n        exitCode == 0 && !isTimedOut\n    }\n    \n    var combinedOutput: String {\n        if stderr.isEmpty {\n            return stdout\n        } else if stdout.isEmpty {\n            return stderr\n        }\n        return stdout + \"\\n\" + stderr\n    }\n}\n"}
>>>END

>>>TOOL read_file
{"path": "VSCodeiPadOS/VSCodeiPadOS/Services/RemoteDebugger.swift", "start_line": 1, "end_line": 100}
>>>END

>>>TOOL read_file
{"path": "VSCodeiPadOS/VSCodeiPadOS/Services/RemoteDebugger.swift", "start_line": 400, "end_line": 600}
>>>END

>>>TOOL read_file
{"path": "VSCodeiPadOS/VSCodeiPadOS/Services/RemoteDebugger.swift", "start_line": 600, "end_line": 800}
>>>END

>>>REPORT
## Task Completed: Created RemoteDebugger.swift

**File Created:** `VSCodeiPadOS/VSCodeiPadOS/Services/RemoteDebugger.swift` (1529 lines)

### Implementation Summary

The `RemoteDebugger.swift` file provides full remote debugging capabilities via SSH using GDB/LLDB. It follows the existing project patterns from `SSHManager.swift` and `DebugManager.swift`.

### Key Features Implemented:

**1. Debugger Configuration:**
- `DebuggerType` enum supporting both GDB and LLDB
- `RemoteDebuggerConfig` struct for configuring debug sessions
- Support for custom debugger paths, program arguments, environment variables

**2. Breakpoint Management (lines 380-551):**
- `setBreakpoint(file:line:condition:)` - Set breakpoint at file:line
- `setBreakpoint(function:condition:)` - Set breakpoint at function name  
- `setBreakpoint(address:)` - Set breakpoint at memory address
- `removeBreakpoint(id:)` - Remove by debugger ID
- `removeBreakpoint(file:line:)` - Remove by location
- `enableBreakpoint(id:)` / `disableBreakpoint(id:)` - Toggle breakpoints
- `setBreakpointCondition(id:condition:)` - Conditional breakpoints
- `listBreakpoints()` - Get all breakpoints

**3. Execution Control (lines 554-677):**
- `continue()` - Resume execution
- `run()` - Start program from beginning
- `stepOver()` - Step over (next line)
- `stepInto()` - Step into function
- `stepOut()` - Step out of current function
- `stepInstruction()` - Single instruction step
- `pause()` - Interrupt running program (Ctrl+C)
- `stop()` - Kill debugged program

**4. Process Attachment (lines 679-760):**
- `attach(toPID:)` - Attach to process by PID
- `attach(toProcessName:waitForLaunch:)` - Attach by process name
- `connectToRemoteTarget(_:)` - Connect to gdbserver/lldb-server
- `detach()` - Detach from process

**5. Expression Evaluation (lines 762-791):**
- `evaluateExpression(_:)` - Evaluate any expression
- `evaluateExpression(_:as:)` - Type-safe evaluation
- `executeCommand(_:)` - Execute raw debugger commands

**6. Stack Trace (lines 794-838):**
- `getStackTrace(maxFrames:)` - Get call stack
- `selectFrame(index:)` - Switch stack frame context

**7. Variables (lines 840-930):**
- `getVariables(frame:)` - Get local variables
- `getGlobalVariables()` - Get global variables  
- `getArguments()` - Get function arguments
- `getRegisters()` - Get CPU registers
- `expandVariable(path:)` - Expand complex types
- `setVariable(name:value:)` - Modify variable values

**8. Additional Features:**
- Memory read/write operations
- Thread listing and selection
- Comprehensive response parsing for both GDB and LLDB output formats
- Event-driven architecture with `RemoteDebuggerDelegate`
- Published state properties for SwiftUI integration
- Proper error handling with `RemoteDebuggerError` enum

### Integration Points:
- Uses existing `SSHManager` for SSH connectivity
- Compatible with existing `DebugManager` UI state model
- Follows `@MainActor` pattern consistent with other services
- Includes `SSHOutputHandler` delegate for receiving debugger output
>>>END
