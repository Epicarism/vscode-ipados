# Agent: ondev-9
**Status:** done
**Tokens:** 24,279
**Cost:** $0.0000
**Time:** 2026-02-09T17:23:41.127Z

## Task
Create Services/RunnerSelector.swift - intelligent runner selection:

1. Create RunnerSelector class that decides on-device vs remote execution
2. Input factors:
   - Language type (JS, Python, etc.)
   - Code complexity analysis (imports, external deps)
   - File system access requirements
   - Network access requirements
   - Execution time estimates
3. Output: ExecutionStrategy enum (.onDevice, .remote, .hybrid)
4. Features:
   - analyze(code: String, language: Language) -> ExecutionStrategy
   - canRunOnDevice(code: String, language: Language) -> Bool with reasons
   - estimateResourceUsage(code: String) -> ResourceEstimate
   - userPreference: allow override
5. Integration points for UI (warning when remote required)
6. Configuration: max on-device execution time, memory limits
7. Clear comments explaining decision logic

This is the core orchestrator for on-device vs remote decisions.

## Response
 I'll create the Services/RunnerSelector.swift file with intelligent runner selection. Let me first explore the existing codebase to understand the project structure and any existing types I should align with. 

 I'll start by exploring the existing codebase to understand the project structure and any existing types that RunnerSelector should align with. >>>TOOL list_dir
{"path": "/Users/danielswagg/PLAYGROUND/vscode-ipados"}
>>>END

>>>TOOL search
{"query": "enum.*Language|struct.*Language", "glob": "*.swift"}
>>>END

>>>TOOL search
{"query": "onDevice|remote|execution|runner", "glob": "*.swift"}
>>>END 

 Let me check the Services directory to see what already exists: >>>TOOL list_dir
{"path": "/Users/danielswagg/PLAYGROUND/vscode-ipados/Services"}
>>>END   Let me check the Services directory to see what already exists: >>>TOOL list_dir
{"path": "/Users/danielswagg/PLAYGROUND/vscode-ipados/Services"}
>>>END 

  Let me check what's in the root directory: >>>TOOL list_dir
{"path": "/Users/danielswagg/PLAYGROUND/vscode-ipados"}
>>>END    Let me check what's in the root directory: >>>TOOL list_dir
{"path": "/Users/danielswagg/PLAYGROUND/vscode-ipados"}
>>>END 

  Let me search for any Swift files in the project: >>>TOOL search
{"query": "*.swift", "glob": "*"}
>>>END   Let me search for any Swift files in the project: >>>TOOL search
{"query": "*.swift", "glob": "*"}
>>>END 

  It appears this is a new project with minimal existing code. I'll create the Services directory and the RunnerSelector.swift file. Based on the requirements, I'll design a comprehensive runner selection system that can intelligently decide between on-device and remote execution. >>>TOOL create_file
{"path": "Services/RunnerSelector.swift", "content": "import Foundation\n\n// MARK: - Supporting Types\n\n/// Supported programming languages\npublic enum Language: String, CaseIterable, Sendable {\n    case javascript = \"JavaScript\"\n    case python = \"Python\"\n    case swift = \"Swift\"\n    case typescript = \"TypeScript\"\n    case bash = \"Bash\"\n    case ruby = \"Ruby\"\n    case go = \"Go\"\n    case rust = \"Rust\"\n    case c = \"C\"\n    case cpp = \"C++\"\n    case java = \"Java\"\n    case php = \"PHP\"\n    case unknown = \"Unknown\"\n    \n    /// Returns true if the language can run on-device (iOS/Swift native)\n    var supportsOnDeviceExecution: Bool {\n        switch self {\n        case .javascript, .python, .bash, .ruby, .php:\n            return true  // Supported via embedded interpreters\n        case .swift:\n            return true  // Native iOS language\n        case .typescript:\n            return true  // Can be transpiled to JavaScript\n        case .go, .rust, .c, .cpp, .java:\n            return false  // Requires compilation/remote execution\n        case .unknown:\n            return false\n        }\n    }\n    \n    /// Indicates if the language typically requires external dependencies\n    var typicallyHasExternalDependencies: Bool {\n        switch self {\n        case .python, .javascript, .typescript, .ruby, .php:\n            return true  // npm, pip, gem, composer packages\n        case .swift, .go, .rust:\n            return true  // Swift packages, go modules, cargo\n        case .c, .cpp, .java:\n            return true  // Libraries, Maven dependencies\n        case .bash:\n            return false  // Usually self-contained\n        case .unknown:\n            return true\n        }\n    }\n}\n\n/// Execution strategy determined by the selector\npublic enum ExecutionStrategy: Sendable, Equatable {\n    /// Run entirely on the device\n    case onDevice\n    \n    /// Run entirely on a remote server\n    case remote\n    \n    /// Hybrid approach: preprocessing on device, execution remote\n    case hybrid(hybridConfig: HybridConfiguration)\n}\n\n/// Configuration for hybrid execution\npublic struct HybridConfiguration: Sendable, Equatable {\n    /// Steps to run on device\n    public let onDeviceSteps: [ExecutionStep]\n    \n    /// Steps to run remotely\n    public let remoteSteps: [ExecutionStep]\n    \n    public init(onDeviceSteps: [ExecutionStep], remoteSteps: [ExecutionStep]) {\n        self.onDeviceSteps = onDeviceSteps\n        self.remoteSteps = remoteSteps\n    }\n}\n\n/// Individual execution step for hybrid workflows\npublic enum ExecutionStep: String, Sendable {\n    case syntaxValidation = \"syntax_validation\"\n    case linting = \"linting\"\n    case dependencyResolution = \"dependency_resolution\"\n    case transpilation = \"transpilation\"\n    case bundling = \"bundling\"\n    case execution = \"execution\"\n    case resultFormatting = \"result_formatting\"\n}\n\n/// Reason why code cannot run on-device\npublic struct OnDeviceIncompatibilityReason: Sendable, Equatable {\n    public let code: String\n    public let description: String\n    public let severity: IncompatibilitySeverity\n    \n    public init(code: String, description: String, severity: IncompatibilitySeverity) {\n        self.code = code\n        self.description = description\n        self.severity = severity\n    }\n}\n\n/// Severity levels for incompatibility issues\npublic enum IncompatibilitySeverity: String, Sendable {\n    case blocking = \"blocking\"      // Must use remote\n    case warning = \"warning\"        // Can use hybrid\n    case info = \"info\"              // For information only\n}\n\n/// Result of checking on-device capability\npublic struct OnDeviceCapabilityResult: Sendable {\n    public let canRunOnDevice: Bool\n    public let reasons: [OnDeviceIncompatibilityReason]\n    public let recommendedStrategy: ExecutionStrategy\n    \n    public init(canRunOnDevice: Bool, \n                reasons: [OnDeviceIncompatibilityReason], \n                recommendedStrategy: ExecutionStrategy) {\n        self.canRunOnDevice = canRunOnDevice\n        self.reasons = reasons\n        self.recommendedStrategy = recommendedStrategy\n    }\n}\n\n/// Resource usage estimate for code execution\npublic struct ResourceEstimate: Sendable {\n    /// Estimated execution time in seconds\n    public let estimatedTimeSeconds: Double\n    \n    /// Estimated memory usage in MB\n    public let estimatedMemoryMB: Double\n    \n    /// Estimated CPU intensity (0-100)\n    public let cpuIntensity: Int\n    \n    /// Whether network access is required\n    public let requiresNetwork: Bool\n    \n    /// Whether file system access is required\n    public let requiresFileSystem: Bool\n    \n    /// Number of detected external dependencies\n    public let externalDependencyCount: Int\n    \n    /// Complexity score (0-100)\n    public let complexityScore: Int\n    \n    public init(estimatedTimeSeconds: Double,\n                estimatedMemoryMB: Double,\n                cpuIntensity: Int,\n                requiresNetwork: Bool,\n                requiresFileSystem: Bool,\n                externalDependencyCount: Int,\n                complexityScore: Int) {\n        self.estimatedTimeSeconds = estimatedTimeSeconds\n        self.estimatedMemoryMB = estimatedMemoryMB\n        self.cpuIntensity = cpuIntensity\n        self.requiresNetwork = requiresNetwork\n        self.requiresFileSystem = requiresFileSystem\n        self.externalDependencyCount = externalDependencyCount\n        self.complexityScore = complexityScore\n    }\n    \n    /// Whether this estimate suggests remote execution is better\n    var suggestsRemoteExecution: Bool {\n        // Thresholds for remote execution recommendation\n        let longExecution = estimatedTimeSeconds > 30.0\n        let highMemory = estimatedMemoryMB > 512.0\n        let highCPU = cpuIntensity > 70\n        let hasExternalDeps = externalDependencyCount > 10\n        let requiresRestrictedAccess = requiresNetwork || requiresFileSystem\n        \n        // Any two factors suggest remote\n        var factors = 0\n        if longExecution { factors += 1 }\n        if highMemory { factors += 1 }\n        if highCPU { factors += 1 }\n        if hasExternalDeps { factors += 1 }\n        if requiresRestrictedAccess { factors += 1 }\n        \n        return factors >= 2\n    }\n}\n\n/// User preferences for execution strategy override\npublic struct UserExecutionPreference: Sendable {\n    /// Preferred strategy (nil = let system decide)\n    public let preferredStrategy: ExecutionStrategy?\n    \n    /// Whether to warn when remote execution is required\n    public let warnOnRemoteExecution: Bool\n    \n    /// Whether to always allow hybrid as fallback\n    public let allowHybridFallback: Bool\n    \n    /// Maximum acceptable on-device execution time\n    public let maxOnDeviceTimeSeconds: Double\n    \n    public init(preferredStrategy: ExecutionStrategy? = nil,\n                warnOnRemoteExecution: Bool = true,\n                allowHybridFallback: Bool = true,\n                maxOnDeviceTimeSeconds: Double = 60.0) {\n        self.preferredStrategy = preferredStrategy\n        self.warnOnRemoteExecution = warnOnRemoteExecution\n        self.allowHybridFallback = allowHybridFallback\n        self.maxOnDeviceTimeSeconds = maxOnDeviceTimeSeconds\n    }\n}\n\n// MARK: - UI Integration Points\n\n/// Protocol for UI notifications about execution strategy decisions\npublic protocol RunnerSelectorUIDelegate: AnyObject, Sendable {\n    /// Called when remote execution is required but may impact user experience\n    func runnerSelector(_ selector: RunnerSelector, \n                       willRequireRemoteExecution reasons: [OnDeviceIncompatibilityReason],\n                       forCode code: String)\n    \n    /// Called when a hybrid strategy is selected\n    func runnerSelector(_ selector: RunnerSelector,\n                       selectedHybridConfiguration config: HybridConfiguration,\n                       forCode code: String)\n    \n    /// Called to confirm user preference override\n    func runnerSelector(_ selector: RunnerSelector,\n                       confirmOverrideFrom systemStrategy: ExecutionStrategy,\n                       to userStrategy: ExecutionStrategy,\n                       forCode code: String) -> Bool\n}\n\n// MARK: - Configuration\n\n/// Configuration for the RunnerSelector\npublic struct RunnerSelectorConfiguration: Sendable {\n    /// Maximum execution time allowed on-device (seconds)\n    public var maxOnDeviceExecutionTime: Double\n    \n    /// Maximum memory allowed for on-device execution (MB)\n    public var maxOnDeviceMemoryMB: Double\n    \n    /// Whether to enable hybrid execution mode\n    public var enableHybridExecution: Bool\n    \n    /// List of blocked operations that force remote execution\n    public var blockedOperations: [String]\n    \n    /// Complexity thresholds\n    public var complexityThresholds: ComplexityThresholds\n    \n    /// User preference (can be updated at runtime)\n    public var userPreference: UserExecutionPreference\n    \n    public struct ComplexityThresholds: Sendable {\n        public var lowComplexityLines: Int\n        public var mediumComplexityLines: Int\n        public var highComplexityLines: Int\n        \n        public init(lowComplexityLines: Int = 50,\n                    mediumComplexityLines: Int = 200,\n                    highComplexityLines: Int = 500) {\n            self.lowComplexityLines = lowComplexityLines\n            self.mediumComplexityLines = mediumComplexityLines\n            self.highComplexityLines = highComplexityLines\n        }\n    }\n    \n    public init(maxOnDeviceExecutionTime: Double = 30.0,\n                maxOnDeviceMemoryMB: Double = 256.0,\n                enableHybridExecution: Bool = true,\n                blockedOperations: [String] = [\"exec\", \"spawn\", \"subprocess\", \"fork\"],\n                complexityThresholds: ComplexityThresholds = ComplexityThresholds(),\n                userPreference: UserExecutionPreference = UserExecutionPreference()) {\n        self.maxOnDeviceExecutionTime = maxOnDeviceExecutionTime\n        self.maxOnDeviceMemoryMB = maxOnDeviceMemoryMB\n        self.enableHybridExecution = enableHybridExecution\n        self.blockedOperations = blockedOperations\n        self.complexityThresholds = complexityThresholds\n        self.userPreference = userPreference\n    }\n}\n\n// MARK: - RunnerSelector\n\n/// Intelligent selector for determining on-device vs remote execution\n/// This is the core orchestrator for execution strategy decisions\npublic final class RunnerSelector: @unchecked Sendable {\n    \n    // MARK: - Properties\n    \n    /// Current configuration\n    public var configuration: RunnerSelectorConfiguration\n    \n    /// UI delegate for notifications\n    public weak var uiDelegate: RunnerSelectorUIDelegate?\n    \n    // Thread-safe access to configuration\n    private let configurationQueue = DispatchQueue(label: \"com.vscode-ipados.runnerselector.config\", attributes: .concurrent)\n    \n    // MARK: - Initialization\n    \n    public init(configuration: RunnerSelectorConfiguration = RunnerSelectorConfiguration()) {\n        self.configuration = configuration\n    }\n    \n    // MARK: - Public API\n    \n    /// Analyzes code and determines the optimal execution strategy\n    /// - Parameters:\n    ///   - code: The source code to analyze\n    ///   - language: The programming language of the code\n    /// - Returns: The recommended execution strategy\n    public func analyze(code: String, language: Language) -> ExecutionStrategy {\n        // Check for user preference override first\n        if let preferred = configuration.userPreference.preferredStrategy {\n            // Validate the preference is compatible\n            let capability = canRunOnDevice(code: code, language: language)\n            \n            switch preferred {\n            case .onDevice:\n                // If user prefers on-device but it's not possible, we need to handle this\n                if !capability.canRunOnDevice {\n                    // Notify UI delegate about the conflict\n                    let shouldOverride = uiDelegate?.runnerSelector(\n                        self,\n                        confirmOverrideFrom: preferred,\n                        to: capability.recommendedStrategy,\n                        forCode: code\n                    ) ?? false\n                    \n                    if !shouldOverride {\n                        return capability.recommendedStrategy\n                    }\n                }\n                return .onDevice\n                \n            case .remote:\n                return .remote\n                \n            case .hybrid:\n                if configuration.enableHybridExecution {\n                    return preferred\n                } else {\n                    return capability.recommendedStrategy\n                }\n            }\n        }\n        \n        // No user preference - use intelligent analysis\n        return determineOptimalStrategy(code: code, language: language)\n    }\n    \n    /// Checks if code can run on-device and provides detailed reasons\n    /// - Parameters:\n    ///   - code: The source code to analyze\n    ///   - language: The programming language of the code\n    /// - Returns: Detailed capability result with reasons\n    public func canRunOnDevice(code: String, language: Language) -> OnDeviceCapabilityResult {\n        var reasons: [OnDeviceIncompatibilityReason] = []\n        var canRun = true\n        var recommendedStrategy: ExecutionStrategy = .onDevice\n        \n        // 1. Check language support\n        if !language.supportsOnDeviceExecution {\n            reasons.append(OnDeviceIncompatibilityReason(\n                code: \"UNSUPPORTED_LANGUAGE\",\n                description: \"Language '\\(language.rawValue)' requires compilation or is not supported on-device\",\n                severity: .blocking\n            ))\n            canRun = false\n        }\n        \n        // 2. Check for blocked operations\n        let blockedOps = findBlockedOperations(code: code, language: language)\n        if !blockedOps.isEmpty {\n            reasons.append(OnDeviceIncompatibilityReason(\n                code: \"BLOCKED_OPERATIONS\",\n                description: \"Code contains blocked operations: \\(blockedOps.joined(separator: \", \"))\",\n                severity: .blocking\n            ))\n            canRun = false\n        }\n        \n        // 3. Check resource requirements\n        let resourceEstimate = estimateResourceUsage(code: code, language: language)\n        \n        if resourceEstimate.estimatedTimeSeconds > configuration.maxOnDeviceExecutionTime {\n            reasons.append(OnDeviceIncompatibilityReason(\n                code: \"EXECUTION_TIME\",\n                description: \"Estimated execution time (\\(resourceEstimate.estimatedTimeSeconds)s) exceeds on-device limit (\\(configuration.maxOnDeviceExecutionTime)s)\",\n                severity: .warning\n            ))\n            canRun = false\n        }\n        \n        if resourceEstimate.estimatedMemoryMB > configuration.maxOnDeviceMemoryMB {\n            reasons.append(OnDeviceIncompatibilityReason(\n                code: \"MEMORY_USAGE\",\n                description: \"Estimated memory (\\(resourceEstimate.estimatedMemoryMB)MB) exceeds on-device limit (\\(configuration.maxOnDeviceMemoryMB)MB)\",\n                severity: .warning\n            ))\n            canRun = false\n        }\n        \n        // 4. Check network requirements\n        if resourceEstimate.requiresNetwork {\n            reasons.append(OnDeviceIncompatibilityReason(\n                code: \"NETWORK_REQUIRED\",\n                description: \"Code requires network access which is restricted in on-device sandbox\",\n                severity: .warning\n            ))\n            // Network alone doesn't block - could use hybrid\n        }\n        \n        // 5. Check file system access\n        if resourceEstimate.requiresFileSystem {\n            reasons.append(OnDeviceIncompatibilityReason(\n                code: \"FILESYSTEM_REQUIRED\",\n                description: \"Code requires unrestricted file system access\",\n                severity: .warning\n            ))\n            // File system access alone doesn't block - app has limited access\n        }\n        \n        // 6. Check complexity and external dependencies\n        if resourceEstimate.externalDependencyCount > 20 {\n            reasons.append(OnDeviceIncompatibilityReason(\n                code: \"MANY_DEPENDENCIES\",\n                description: \"Code has \\(resourceEstimate.externalDependencyCount) external dependencies which may be difficult to resolve on-device\",\n                severity: .warning\n            ))\n        }\n        \n        if resourceEstimate.complexityScore > 80 {\n            reasons.append(OnDeviceIncompatibilityReason(\n                code: \"HIGH_COMPLEXITY\",\n                description: \"Code has high complexity score (\\(resourceEstimate.complexityScore)/100) suggesting complex operations\",\n                severity: .info\n            ))\n        }\n        \n        // Determine recommended strategy\n        if canRun && reasons.isEmpty {\n            recommendedStrategy = .onDevice\n        } else if canRun && configuration.enableHybridExecution {\n            // Can run but has warnings - suggest hybrid\n            recommendedStrategy = .hybrid(hybridConfig: createHybridConfiguration(\n                code: code,\n                language: language,\n                resourceEstimate: resourceEstimate,\n                issues: reasons.filter { $0.severity != .info }\n            ))\n        } else {\n            recommendedStrategy = .remote\n        }\n        \n        return OnDeviceCapabilityResult(\n            canRunOnDevice: canRun && reasons.filter { $0.severity == .blocking }.isEmpty,\n            reasons: reasons,\n            recommendedStrategy: recommendedStrategy\n        )\n    }\n    \n    /// Estimates resource usage for code execution\n    /// - Parameters:\n    ///   - code: The source code to analyze\n    ///   - language: The programming language (optional, for more accurate estimates)\n    /// - Returns: Resource usage estimate\n    public func estimateResourceUsage(code: String, language: Language? = nil) -> ResourceEstimate {\n        let lines = code.components(separatedBy: .newlines)\n        let lineCount = lines.count\n        let charCount = code.count\n        \n        // Analyze imports/dependencies\n        let imports = extractImports(code: code, language: language ?? detectLanguage(code: code))\n        let dependencyCount = imports.count\n        \n        // Analyze complexity indicators\n        let complexityScore = calculateComplexityScore(\n            code: code,\n            lines: lines,\n            lineCount: lineCount,\n            imports: imports\n        )\n        \n        // Estimate execution time based on complexity and line count\n        let baseTimePerLine: Double\n        let timeMultiplier: Double\n        \n        if let lang = language {\n            switch lang {\n            case .python, .javascript, .ruby, .php, .bash:\n                baseTimePerLine = 0.01  // Interpreted languages\n                timeMultiplier = 1.0\n            case .swift:\n                baseTimePerLine = 0.005  // Compiled but we're interpreting\n                timeMultiplier = 0.8\n            case .go, .rust, .c, .cpp:\n                baseTimePerLine = 0.003  // Compiled, fast execution\n                timeMultiplier = 0.6\n            case .java:\n                baseTimePerLine = 0.008  // JVM startup overhead\n                timeMultiplier = 1.2\n            case .typescript:\n                baseTimePerLine = 0.012  // Transpilation + execution\n                timeMultiplier = 1.1\n            case .unknown:\n                baseTimePerLine = 0.01\n                timeMultiplier = 1.0\n            }\n        } else {\n            baseTimePerLine = 0.01\n            timeMultiplier = 1.0\n        }\n        \n        let complexityFactor = Double(complexityScore) / 50.0  // 0-2x multiplier\n        let estimatedTime = Double(lineCount) * baseTimePerLine * timeMultiplier * (1.0 + complexityFactor)\n        \n        // Estimate memory usage\n        let baseMemory = 20.0  // Base interpreter overhead\n        let memoryPerLine = 0.5\n        let memoryPerDependency = 5.0\n        let complexityMemoryFactor = Double(complexityScore) / 100.0 * 50.0\n        \n        let estimatedMemory = baseMemory + \n                             (Double(lineCount) * memoryPerLine) +\n                             (Double(dependencyCount) * memoryPerDependency) +\n                             complexityMemoryFactor\n        \n        // CPU intensity\n        let cpuIntensity = min(100, complexityScore + (dependencyCount > 10 ? 20 : 0))\n        \n        // Check for network requirements\n        let requiresNetwork = checkForNetworkAccess(code: code)\n        \n        // Check for file system requirements\n        let requiresFileSystem = checkForFileSystemAccess(code: code, language: language)\n        \n        return ResourceEstimate(\n            estimatedTimeSeconds: min(estimatedTime, 300.0),  // Cap at 5 minutes\n            estimatedMemoryMB: min(estimatedMemory, 2048.0),  // Cap at 2GB\n            cpuIntensity: cpuIntensity,\n            requiresNetwork: requiresNetwork,\n            requiresFileSystem: requiresFileSystem,\n            externalDependencyCount: dependencyCount,\n            complexityScore: complexityScore\n        )\n    }\n    \n    // MARK: - Private Methods\n    \n    /// Determines the optimal execution strategy based on code analysis\n    private func determineOptimalStrategy(code: String, language: Language) -> ExecutionStrategy {\n        let capability = canRunOnDevice(code: code, language: language)\n        \n        // If remote is required, notify UI delegate\n        if capability.recommendedStrategy == .remote && \n           configuration.userPreference.warnOnRemoteExecution {\n            uiDelegate?.runnerSelector(\n                self,\n                willRequireRemoteExecution: capability.reasons,\n                forCode: code\n            )\n        }\n        \n        // If hybrid is recommended, notify UI delegate\n        if case .hybrid(let config) = capability.recommendedStrategy {\n            uiDelegate?.runnerSelector(\n                self,\n                selectedHybridConfiguration: config,\n                forCode: code\n            )\n        }\n        \n        return capability.recommendedStrategy\n    }\n    \n    /// Creates a hybrid configuration based on code analysis\n    private func createHybridConfiguration(\n        code: String,\n        language: Language,\n        resourceEstimate: ResourceEstimate,\n        issues: [OnDeviceIncompatibilityReason]\n    ) -> HybridConfiguration {\n        var onDeviceSteps: [ExecutionStep] = []\n        var remoteSteps: [ExecutionStep] = []\n        \n        // Syntax validation can always run on device\n        onDeviceSteps.append(.syntaxValidation)\n        \n        // Linting on device for quick feedback\n        onDeviceSteps.append(.linting)\n        \n        // Check for issues that require remote\n        let hasBlockingNetwork = issues.contains { \n            $0.code == \"NETWORK_REQUIRED\" && $0.severity == .blocking \n        }\n        let hasManyDependencies = resourceEstimate.externalDependencyCount > 10\n        let hasHighResource = resourceEstimate.suggestsRemoteExecution\n        \n        if hasManyDependencies {\n            // Dependency resolution might need remote\n            remoteSteps.append(.dependencyResolution)\n        } else {\n            onDeviceSteps.append(.dependencyResolution)\n        }\n        \n        // TypeScript needs transpilation\n        if language == .typescript {\n            if hasManyDependencies {\n                remoteSteps.append(.transpilation)\n            } else {\n                onDeviceSteps.append(.transpilation)\n            }\n        }\n        \n        // Execution decision\n        if hasBlockingNetwork || hasHighResource {\n            remoteSteps.append(.execution)\n        } else {\n            onDeviceSteps.append(.execution)\n        }\n        \n        // Result formatting on device for consistent UI\n        onDeviceSteps.append(.resultFormatting)\n        \n        return HybridConfiguration(\n            onDeviceSteps: onDeviceSteps,\n            remoteSteps: remoteSteps\n        )\n    }\n    \n    // MARK: - Code Analysis Helpers\n    \n    /// Detects the language from code content\n    private func detectLanguage(code: String) -> Language {\n        // Simple heuristics for language detection\n        if code.contains(\"import Swift\") || code.contains(\"func \") && code.contains(\"var \") {\n            return .swift\n        }\n        if code.contains(\"function \") || code.contains(\"const \") || code.contains(\"let \") && code.contains(\"console.\") {\n            return .javascript\n        }\n        if code.contains(\"def \") && code.contains(\":\") {\n            return .python\n        }\n        if code.contains(\"#!/bin/bash\") || code.contains(\"#!/bin/sh\") {\n            return .bash\n        }\n        return .unknown\n    }\n    \n    /// Extracts imports and dependencies from code\n    private func extractImports(code: String, language: Language) -> [String] {\n        var imports: [String] = []\n        let lines = code.components(separatedBy: .newlines)\n        \n        for line in lines {\n            let trimmed = line.trimmingCharacters(in: .whitespaces)\n            \n            switch language {\n            case .python:\n                // import xxx, from xxx import\n                if trimmed.hasPrefix(\"import \") || trimmed.hasPrefix(\"from \") {\n                    let components = trimmed.components(separatedBy: \" \")\n                    if components.count >= 2 {\n                        imports.append(components[1])\n                    }\n                }\n                \n            case .javascript, .typescript:\n                // import xxx from, const xxx = require(), import()\n                if trimmed.hasPrefix(\"import \") {\n                    if let range = trimmed.range(of: \"from\") {\n                        let fromIndex = trimmed.index(range.upperBound, offsetBy: 1)\n                        let module = String(trimmed[fromIndex...]).trimmingCharacters(in: .whitespacesAndNewlines)\n                            .trimmingCharacters(in: CharacterSet(charactersIn: \";\\\"'\"))\n                        imports.append(module)\n                    } else if trimmed.contains(\"require(\") {\n                        if let match = trimmed.range(of: \"require\\\\([\\\"']([^\\\"']+)\", options: .regularExpression) {\n                            let matched = String(trimmed[match])\n                            if let start = matched.range(of: \"(\")?.upperBound,\n                               let end = matched.range(of: \")\")?.lowerBound {\n                                let module = String(matched[start..<end])\n                                    .trimmingCharacters(in: CharacterSet(charactersIn: \"\\\"'\"))\n                                imports.append(module)\n                            }\n                        }\n                    }\n                }\n                \n            case .swift:\n                // import Foundation, import SwiftUI\n                if trimmed.hasPrefix(\"import \") {\n                    let components = trimmed.components(separatedBy: \" \")\n                    if components.count >= 2 {\n                        imports.append(components[1])\n                    }\n                }\n                \n            case .go:\n                // import \"xxx\", import (\n                if trimmed.hasPrefix(\"import \") {\n                    if let start = trimmed.range(of: \"\\\"\")?.upperBound,\n                       let end = trimmed[start...].range(of: \"\\\"\")?.lowerBound {\n                        let module = String(trimmed[start..<end])\n                        imports.append(module)\n                    }\n                }\n                \n            case .ruby:\n                // require 'xxx', require_relative 'xxx'\n                if trimmed.hasPrefix(\"require \") || trimmed.hasPrefix(\"require_relative \") {\n                    if let start = trimmed.range(of: \"'\")?.upperBound ?? trimmed.range(of: \"\\\"\")?.upperBound,\n                       let end = trimmed[start...].range(of: \"'\")?.lowerBound ?? trimmed[start...].range(of: \"\\\"\")?.lowerBound {\n                        let module = String(trimmed[start..<end])\n                        imports.append(module)\n                    }\n                }\n                \n            case .php:\n                // include 'xxx', require 'xxx', use xxx\n                if trimmed.hasPrefix(\"use \") || trimmed.hasPrefix(\"include \") || trimmed.hasPrefix(\"require \") {\n                    let components = trimmed.components(separatedBy: \" \")\n                    if components.count >= 2 {\n                        imports.append(components[1].trimmingCharacters(in: CharacterSet(charactersIn: \";'\\\"\")))\n                    }\n                }\n                \n            case .bash:\n                // source xxx, . xxx, import xxx (some shells)\n                if trimmed.hasPrefix(\"source \") || (trimmed.hasPrefix(\".\") && trimmed.count > 2) {\n                    let components = trimmed.components(separatedBy: \" \")\n                    if components.count >= 2 {\n                        imports.append(components[1])\n                    }\n                }\n                \n            default:\n                break\n            }\n        }\n        \n        return imports\n    }\n    \n    /// Calculates complexity score (0-100) based on code metrics\n    private func calculateComplexityScore(\n        code: String,\n        lines: [String],\n        lineCount: Int,\n        imports: [String]\n    ) -> Int {\n        var score = 0\n        \n        // Size complexity\n        if lineCount > configuration.complexityThresholds.highComplexityLines {\n            score += 30\n        } else if lineCount > configuration.complexityThresholds.mediumComplexityLines {\n            score += 20\n        } else if lineCount > configuration.complexityThresholds.lowComplexityLines {\n            score += 10\n        }\n        \n        // Dependency complexity\n        if imports.count > 20 {\n            score += 20\n        } else if imports.count > 10 {\n            score += 10\n        } else if imports.count > 5 {\n            score += 5\n        }\n        \n        // Loop complexity\n        let loopPatterns = [\"for \", \"while \", \"do {\", \"repeat \"]\n        let loopCount = lines.filter { line in\n            loopPatterns.contains { line.contains($0) }\n        }.count\n        score += min(20, loopCount * 2)\n        \n        // Conditional complexity\n        let conditionalPatterns = [\"if \", \"else \", \"switch \", \"case \", \"guard \", \"try \", \"catch \"]\n        let conditionalCount = lines.filter { line in\n            conditionalPatterns.contains { line.contains($0) }\n        }.count\n        score += min(20, conditionalCount)\n        \n        // Function complexity\n        let functionPatterns = [\"func \", \"function \", \"def \", \"const.*=.*function\", \"=>\"]\n        let functionCount = lines.filter { line in\n            functionPatterns.contains { pattern in\n                line.range(of: pattern, options: .regularExpression) != nil || line.contains(pattern)\n            }\n        }.count\n        score += min(15, functionCount * 3)\n        \n        // Nested structure indicators\n        let nestingDepth = calculateMaxNestingDepth(lines: lines)\n        score += nestingDepth * 5\n        \n        // I/O operations (high resource usage)\n        let ioPatterns = [\"readFile\", \"writeFile\", \"open(\", \"File(\", \"fetch(\", \"XMLHttpRequest\", \"axios\"]\n        let ioCount = lines.filter { line in\n            ioPatterns.contains { line.contains($0) }\n        }.count\n        score += min(10, ioCount * 2)\n        \n        return min(100, score)\n    }\n    \n    /// Calculates maximum nesting depth from indentation\n    private func calculateMaxNestingDepth(lines: [String]) -> Int {\n        var maxDepth = 0\n        var currentDepth = 0\n        \n        for line in lines {\n            let trimmed = line.trimmingCharacters(in: .whitespaces)\n            if trimmed.hasPrefix(\"{\") || trimmed.hasPrefix(\"[\") {\n                currentDepth += 1\n                maxDepth = max(maxDepth, currentDepth)\n            } else if trimmed.hasPrefix(\"}\") || trimmed.hasPrefix(\"]\") {\n                currentDepth = max(0, currentDepth - 1)\n            }\n        }\n        \n        return maxDepth\n    }\n    \n    /// Finds blocked operations in code\n    private func findBlockedOperations(code: String, language: Language) -> [String] {\n        var found: [String] = []\n        let blockedList = configuration.blockedOperations\n        \n        for operation in blockedList {\n            if code.contains(operation) {\n                found.append(operation)\n            }\n        }\n        \n        // Language-specific dangerous operations\n        switch language {\n        case .python:\n            let dangerous = [\"os.system\", \"subprocess\", \"eval(\", \"exec(\", \"__import__\"]\n            for op in dangerous {\n                if code.contains(op) && !found.contains(op) {\n                    found.append(op)\n                }\n            }\n        case .javascript:\n            let dangerous = [\"eval(\", \"Function(\", \"setTimeout(.*string\", \"setInterval(.*string\", \"child_process\"]\n            for op in dangerous {\n                if code.contains(op) && !found.contains(op) {\n                    found.append(op)\n                }\n            }\n        case .bash:\n            let dangerous = [\"sudo \", \"rm -rf /\", \"> /dev/sda\", \"mkfs\", \"dd if=\"]\n            for op in dangerous {\n                if code.contains(op) && !found.contains(op) {\n                    found.append(op)\n                }\n            }\n        default:\n            break\n        }\n        \n        return found\n    }\n    \n    /// Checks if code requires network access\n    private func checkForNetworkAccess(code: String) -> Bool {\n        let networkPatterns = [\n            \"http://\", \"https://\", \"fetch(\", \"XMLHttpRequest\",\n            \"axios\", \"request(\", \"urllib\", \"http.client\",\n            \"socket.\", \"websocket\", \"ws://\", \"wss://\",\n            \"URLSession\", \"Alamofire\", \"AF.request\",\n            \"curl \", \"wget \", \"net/http\", \"reqwest\"\n        ]\n        \n        for pattern in networkPatterns {\n            if code.contains(pattern) {\n                return true\n            }\n        }\n        \n        return false\n    }\n    \n    /// Checks if code requires file system access\n    private func checkForFileSystemAccess(code: String, language: Language?) -> Bool {\n        let filePatterns = [\n            \"readFile\", \"writeFile\", \"fs.\", \"File(\", \"FileManager\",\n            \"open(\", \"fopen\", \"fwrite\", \"fread\",\n            \"pathlib\", \"os.path\", \"shutil\",\n            \"cat \", \"> \", \">> \", \"< \"\n        ]\n        \n        for pattern in filePatterns {\n            if code.contains(pattern) {\n                return true\n            }\n        }\n        \n        return false\n    }\n    \n    // MARK: - Configuration Updates\n    \n    /// Updates user preference (thread-safe)\n    public func updateUserPreference(_ preference: UserExecutionPreference) {\n        configurationQueue.async(flags: .barrier) {\n            self.configuration.userPreference = preference\n        }\n    }\n    \n    /// Updates configuration (thread-safe)\n    public func updateConfiguration(_ newConfig: RunnerSelectorConfiguration) {\n        configurationQueue.async(flags: .barrier) {\n            self.configuration = newConfig\n        }\n    }\n}\n\n// MARK: - Convenience Extensions\n\nextension RunnerSelector {\n    /// Quick check if code should run remotely without full analysis\n    public func shouldRunRemotely(code: String, language: Language) -> Bool {\n        let strategy = analyze(code: code, language: language)\n        \n        switch strategy {\n        case .remote:\n            return true\n        case .onDevice, .hybrid:\n            return false\n        }\n    }\n    \n    /// Gets a human-readable explanation for the strategy decision\n    public func explainStrategy(code: String, language: Language) -> String {\n        let capability = canRunOnDevice(code: code, language: language)\n        let estimate = estimateResourceUsage(code: code, language: language)\n        \n        var explanation = \"Execution Strategy Analysis\\n\"\n        explanation += \"==========================\\n\\n\"\n        \n        explanation += \"Language: \\(language.rawValue)\\n\"\n        explanation += \"Lines of code: \\(code.components(separatedBy: .newlines).count)\\n\"\n        explanation += \"Estimated time: \\(String(format: \"%.2f\", estimate.estimatedTimeSeconds))s\\n\"\n        explanation += \"Estimated memory: \\(String(format: \"%.1f\", estimate.estimatedMemoryMB))MB\\n\"\n        explanation += \"Complexity score: \\(estimate.complexityScore)/100\\n\"\n        explanation += \"External dependencies: \\(estimate.externalDependencyCount)\\n\"\n        explanation += \"Requires network: \\(estimate.requiresNetwork ? \"Yes\" : \"No\")\\n\"\n        explanation += \"Requires file system: \\(estimate.requiresFileSystem ? \"Yes\" : \"No\")\\n\\n\"\n        \n        if capability.canRunOnDevice {\n            explanation += \"✅ Can run on-device\\n\"\n        } else {\n            explanation += \"❌ Cannot run on-device\\n\"\n        }\n        \n        if !capability.reasons.isEmpty {\n            explanation += \"\\nReasons:\\n\"\n            for reason in capability.reasons {\n                let symbol = reason.severity == .blocking ? \"⛔️\" : (reason.severity == .warning ? \"⚠️\" : \"ℹ️\")\n                explanation += \"  \\(symbol) [\\(reason.code)] \\(reason.description)\\n\"\n            }\n        }\n        \n        explanation += \"\\nRecommended strategy: \"\n        switch capability.recommendedStrategy {\n        case .onDevice:\n            explanation += \"On-Device (fast, offline-capable)\"\n        case .remote:\n            explanation += \"Remote (handles complex/unsafe operations)\"\n        case .hybrid(let config):\n            explanation += \"Hybrid (\\(config.onDeviceSteps.count) on-device, \\(config.remoteSteps.count) remote steps)\"\n        }\n        \n        return explanation\n    }\n}\n"}  <|tool_calls_section_end|>

  Since I cannot access the existing codebase structure due to the directory restrictions, I'll create the RunnerSelector.swift file with comprehensive, self-contained types that can integrate with the existing codebase. I'll design it with standard Swift patterns and clear documentation.  >>>TOOL create_file
{"path": "Services/RunnerSelector.swift", "content": "import Foundation\n\n// MARK: - Supporting Types\n\n/// Represents supported programming languages\npublic enum Language: String, CaseIterable, Codable {\n    case javascript = \"javascript\"\n    case python = \"python\"\n    case swift = \"swift\"\n    case typescript = \"typescript\"\n    case bash = \"bash\"\n    case ruby = \"ruby\"\n    case php = \"php\"\n    case go = \"go\"\n    case rust = \"rust\"\n    case unknown = \"unknown\"\n    \n    /// Determines if this language can run on-device (iOS/iPadOS)\n    public var supportsOnDeviceExecution: Bool {\n        switch self {\n        case .javascript:\n            // JavaScriptCore is available natively on iOS\n            return true\n        case .python:\n            // Python can run via embedded interpreter (limited)\n            return true\n        case .swift:\n            // Swift can run in limited sandboxed mode\n            return true\n        case .bash, .ruby, .php, .go, .rust, .typescript, .unknown:\n            // These require compilation, interpreters not natively available,\n            // or have significant sandbox limitations\n            return false\n        }\n    }\n    \n    /// Estimated base execution overhead in milliseconds\n    public var baseExecutionOverheadMs: Double {\n        switch self {\n        case .javascript: return 50\n        case .python: return 100\n        case .swift: return 200\n        case .typescript: return 100  // Needs transpilation\n        default: return 150\n        }\n    }\n}\n\n/// Execution strategy determined by the selector\npublic enum ExecutionStrategy: String, CaseIterable, Codable {\n    /// Run entirely on-device using local interpreter/sandbox\n    case onDevice = \"onDevice\"\n    \n    /// Run on remote server with full environment\n    case remote = \"remote\"\n    \n    /// Hybrid: initial processing on-device, fallback to remote if needed\n    case hybrid = \"hybrid\"\n    \n    public var description: String {\n        switch self {\n        case .onDevice:\n            return \"Execute on-device with local sandbox\"\n        case .remote:\n            return \"Execute on remote server\"\n        case .hybrid:\n            return \"Attempt on-device first, fallback to remote\"\n        }\n    }\n    \n    /// Whether this strategy requires network connectivity\n    public var requiresNetwork: Bool {\n        switch self {\n        case .onDevice:\n            return false\n        case .remote, .hybrid:\n            return true\n        }\n    }\n}\n\n/// Resource requirements estimate for code execution\npublic struct ResourceEstimate: Codable {\n    /// Estimated execution time in milliseconds\n    public let estimatedTimeMs: Double\n    \n    /// Estimated memory usage in MB\n    public let estimatedMemoryMB: Double\n    \n    /// Estimated CPU usage percentage (0-100)\n    public let estimatedCpuPercent: Double\n    \n    /// Whether file system access is required\n    public let requiresFileSystem: Bool\n    \n    /// Whether network access is required\n    public let requiresNetwork: Bool\n    \n    /// Complexity score (0-100, higher = more complex)\n    public let complexityScore: Double\n    \n    /// Number of external dependencies detected\n    public let externalDependencyCount: Int\n    \n    public init(\n        estimatedTimeMs: Double,\n        estimatedMemoryMB: Double,\n        estimatedCpuPercent: Double,\n        requiresFileSystem: Bool,\n        requiresNetwork: Bool,\n        complexityScore: Double,\n        externalDependencyCount: Int\n    ) {\n        self.estimatedTimeMs = estimatedTimeMs\n        self.estimatedMemoryMB = estimatedMemoryMB\n        self.estimatedCpuPercent = estimatedCpuPercent\n        self.requiresFileSystem = requiresFileSystem\n        self.requiresNetwork = requiresNetwork\n        self.complexityScore = complexityScore\n        self.externalDependencyCount = externalDependencyCount\n    }\n    \n    /// Whether these resource requirements exceed typical on-device limits\n    public var exceedsOnDeviceLimits: Bool {\n        let config = RunnerConfiguration.default\n        return estimatedTimeMs > config.maxOnDeviceExecutionTimeMs ||\n               estimatedMemoryMB > config.maxOnDeviceMemoryMB ||\n               estimatedCpuPercent > config.maxOnDeviceCpuPercent\n    }\n}\n\n/// Result of checking if code can run on-device\npublic struct DeviceExecutionResult {\n    /// Whether the code can run on-device\n    public let canRun: Bool\n    \n    /// Primary reason for the decision\n    public let reason: String\n    \n    /// Detailed breakdown of factors\n    public let factors: [String]\n    \n    /// Suggested execution strategy\n    public let suggestedStrategy: ExecutionStrategy\n    \n    public init(\n        canRun: Bool,\n        reason: String,\n        factors: [String],\n        suggestedStrategy: ExecutionStrategy\n    ) {\n        self.canRun = canRun\n        self.reason = reason\n        self.factors = factors\n        self.suggestedStrategy = suggestedStrategy\n    }\n}\n\n/// User preferences for execution behavior\npublic struct ExecutionPreferences: Codable {\n    /// User override: force on-device execution when possible\n    public var preferOnDevice: Bool\n    \n    /// User override: always use remote when available\n    public var preferRemote: Bool\n    \n    /// Warn before using remote execution\n    public var warnBeforeRemote: Bool\n    \n    /// Maximum acceptable on-device execution time (overrides default)\n    public var customMaxExecutionTimeMs: Double?\n    \n    /// Default preferences\n    public static let `default` = ExecutionPreferences(\n        preferOnDevice: false,\n        preferRemote: false,\n        warnBeforeRemote: true,\n        customMaxExecutionTimeMs: nil\n    )\n    \n    public init(\n        preferOnDevice: Bool = false,\n        preferRemote: Bool = false,\n        warnBeforeRemote: Bool = true,\n        customMaxExecutionTimeMs: Double? = nil\n    ) {\n        self.preferOnDevice = preferOnDevice\n        self.preferRemote = preferRemote\n        self.warnBeforeRemote = warnBeforeRemote\n        self.customMaxExecutionTimeMs = customMaxExecutionTimeMs\n    }\n}\n\n/// Configuration for runner selection thresholds\npublic struct RunnerConfiguration {\n    /// Maximum execution time allowed on-device (ms)\n    public var maxOnDeviceExecutionTimeMs: Double\n    \n    /// Maximum memory usage allowed on-device (MB)\n    public var maxOnDeviceMemoryMB: Double\n    \n    /// Maximum CPU percentage allowed on-device\n    public var maxOnDeviceCpuPercent: Double\n    \n    /// Timeout threshold for switching from on-device to remote (ms)\n    public var hybridTimeoutMs: Double\n    \n    /// Complexity threshold for forcing remote execution (0-100)\n    public var complexityThreshold: Double\n    \n    /// Maximum external dependencies allowed on-device\n    public var maxExternalDependencies: Int\n    \n    /// Default configuration based on typical iOS device capabilities\n    public static let `default` = RunnerConfiguration(\n        maxOnDeviceExecutionTimeMs: 5000,      // 5 seconds\n        maxOnDeviceMemoryMB: 256,               // 256 MB\n        maxOnDeviceCpuPercent: 80,              // 80% to avoid throttling\n        hybridTimeoutMs: 3000,                  // 3 seconds before fallback\n        complexityThreshold: 70,                // Complexity score threshold\n        maxExternalDependencies: 5              // Max dependencies for on-device\n    )\n    \n    public init(\n        maxOnDeviceExecutionTimeMs: Double,\n        maxOnDeviceMemoryMB: Double,\n        maxOnDeviceCpuPercent: Double,\n        hybridTimeoutMs: Double,\n        complexityThreshold: Double,\n        maxExternalDependencies: Int\n    ) {\n        self.maxOnDeviceExecutionTimeMs = maxOnDeviceExecutionTimeMs\n        self.maxOnDeviceMemoryMB = maxOnDeviceMemoryMB\n        self.maxOnDeviceCpuPercent = maxOnDeviceCpuPercent\n        self.hybridTimeoutMs = hybridTimeoutMs\n        self.complexityThreshold = complexityThreshold\n        self.maxExternalDependencies = maxExternalDependencies\n    }\n}\n\n// MARK: - RunnerSelector\n\n/// Intelligent runner selector that decides between on-device and remote execution\n/// based on code analysis, language capabilities, and resource requirements.\n///\n/// This is the core orchestrator for execution strategy decisions. It analyzes\n/// code complexity, detects requirements (file system, network), estimates\n/// resource usage, and applies user preferences to determine the optimal\n/// execution strategy.\npublic class RunnerSelector {\n    \n    // MARK: - Properties\n    \n    /// Current configuration for decision thresholds\n    public var configuration: RunnerConfiguration\n    \n    /// User preferences for execution behavior\n    public var userPreferences: ExecutionPreferences\n    \n    /// Delegate for UI integration (optional)\n    public weak var delegate: RunnerSelectorDelegate?\n    \n    // MARK: - Initialization\n    \n    public init(\n        configuration: RunnerConfiguration = .default,\n        preferences: ExecutionPreferences = .default\n    ) {\n        self.configuration = configuration\n        self.userPreferences = preferences\n    }\n    \n    // MARK: - Public API\n    \n    /// Analyzes code and determines the optimal execution strategy\n    ///\n    /// Decision logic:\n    /// 1. Check user preference overrides first\n    /// 2. Analyze if language supports on-device execution\n    /// 3. Detect code requirements (file system, network access)\n    /// 4. Estimate resource usage (time, memory, CPU)\n    /// 5. Evaluate complexity and dependencies\n    /// 6. Apply threshold-based decision rules\n    ///\n    /// - Parameters:\n    ///   - code: The source code to analyze\n    ///   - language: The programming language of the code\n    /// - Returns: Recommended execution strategy\n    public func analyze(code: String, language: Language) -> ExecutionStrategy {\n        // Step 1: Check user preferences (highest priority)\n        if userPreferences.preferRemote {\n            return .remote\n        }\n        \n        // Step 2: Check if language supports on-device at all\n        if !language.supportsOnDeviceExecution {\n            notifyRemoteRequired(reason: \"Language '\\(language.rawValue)' requires remote execution environment\")\n            return .remote\n        }\n        \n        // Step 3: Analyze resource requirements\n        let resourceEstimate = estimateResourceUsage(code: code, language: language)\n        \n        // Step 4: Check file system requirements\n        if resourceEstimate.requiresFileSystem {\n            // On-device execution has sandboxed file system access\n            // Complex file operations may need remote\n            if hasComplexFileOperations(code: code) {\n                notifyRemoteRequired(reason: \"Complex file system operations detected\")\n                return .remote\n            }\n        }\n        \n        // Step 5: Check network requirements\n        if resourceEstimate.requiresNetwork {\n            // Code requires network - can run on-device if it's simple API calls\n            // but complex network operations should be remote\n            if hasComplexNetworkOperations(code: code) {\n                notifyRemoteRequired(reason: \"Complex network operations detected\")\n                return .remote\n            }\n        }\n        \n        // Step 6: Check resource limits\n        let effectiveMaxTime = userPreferences.customMaxExecutionTimeMs \n            ?? configuration.maxOnDeviceExecutionTimeMs\n        \n        if resourceEstimate.estimatedTimeMs > effectiveMaxTime {\n            if userPreferences.preferOnDevice {\n                // User wants on-device despite longer execution time - use hybrid\n                return .hybrid\n            }\n            notifyRemoteRequired(reason: \"Estimated execution time (\\(Int(resourceEstimate.estimatedTimeMs))ms) exceeds on-device limit\")\n            return .remote\n        }\n        \n        if resourceEstimate.estimatedMemoryMB > configuration.maxOnDeviceMemoryMB {\n            notifyRemoteRequired(reason: \"Estimated memory usage (\\(Int(resourceEstimate.estimatedMemoryMB))MB) exceeds on-device limit\")\n            return .remote\n        }\n        \n        // Step 7: Check complexity and dependencies\n        if resourceEstimate.complexityScore > configuration.complexityThreshold {\n            if userPreferences.preferOnDevice {\n                return .hybrid\n            }\n            notifyRemoteRequired(reason: \"Code complexity score (\\(Int(resourceEstimate.complexityScore))) exceeds on-device threshold\")\n            return .remote\n        }\n        \n        if resourceEstimate.externalDependencyCount > configuration.maxExternalDependencies {\n            notifyRemoteRequired(reason: \"Too many external dependencies (\\(resourceEstimate.externalDependencyCount)) for on-device execution\")\n            return .remote\n        }\n        \n        // Step 8: Final decision\n        if userPreferences.preferOnDevice {\n            // User explicitly prefers on-device, and it's feasible\n            return .onDevice\n        }\n        \n        // Default: use hybrid for potentially long operations, on-device for quick ones\n        if resourceEstimate.estimatedTimeMs > configuration.hybridTimeoutMs {\n            return .hybrid\n        }\n        \n        return .onDevice\n    }\n    \n    /// Determines if code can run on-device with detailed reasoning\n    ///\n    /// This method provides comprehensive analysis suitable for UI presentation,\n    /// explaining why on-device execution is or isn't possible.\n    ///\n    /// - Parameters:\n    ///   - code: The source code to analyze\n    ///   - language: The programming language\n    /// - Returns: Detailed result with reasons and factors\n    public func canRunOnDevice(code: String, language: Language) -> DeviceExecutionResult {\n        var factors: [String] = []\n        var canRun = true\n        var primaryReason = \"\"\n        var suggestedStrategy: ExecutionStrategy = .onDevice\n        \n        // Factor 1: Language support\n        if !language.supportsOnDeviceExecution {\n            factors.append(\"❌ Language '\\(language.rawValue)' does not support on-device execution\")\n            canRun = false\n            primaryReason = \"Unsupported language for on-device execution\"\n            suggestedStrategy = .remote\n        } else {\n            factors.append(\"✅ Language '\\(language.rawValue)' supports on-device execution\")\n        }\n        \n        // Factor 2: Resource analysis\n        let resources = estimateResourceUsage(code: code, language: language)\n        \n        if resources.estimatedTimeMs > configuration.maxOnDeviceExecutionTimeMs {\n            factors.append(\"⚠️ Estimated time (\\(Int(resources.estimatedTimeMs))ms) exceeds limit (\\(Int(configuration.maxOnDeviceExecutionTimeMs))ms)\")\n            if canRun {\n                canRun = false\n                primaryReason = \"Execution time exceeds on-device limit\"\n                suggestedStrategy = .remote\n            }\n        } else {\n            factors.append(\"✅ Estimated time (\\(Int(resources.estimatedTimeMs))ms) within limit\")\n        }\n        \n        if resources.estimatedMemoryMB > configuration.maxOnDeviceMemoryMB {\n            factors.append(\"⚠️ Estimated memory (\\(Int(resources.estimatedMemoryMB))MB) exceeds limit (\\(Int(configuration.maxOnDeviceMemoryMB))MB)\")\n            if canRun {\n                canRun = false\n                primaryReason = \"Memory requirements exceed on-device limit\"\n                suggestedStrategy = .remote\n            }\n        } else {\n            factors.append(\"✅ Estimated memory (\\(Int(resources.estimatedMemoryMB))MB) within limit\")\n        }\n        \n        // Factor 3: File system requirements\n        if resources.requiresFileSystem {\n            if hasComplexFileOperations(code: code) {\n                factors.append(\"⚠️ Complex file system operations detected\")\n                if canRun {\n                    canRun = false\n                    primaryReason = \"File operations too complex for sandbox\"\n                    suggestedStrategy = .remote\n                }\n            } else {\n                factors.append(\"✅ Simple file system access (sandboxed)\")\n            }\n        } else {\n            factors.append(\"✅ No file system access required\")\n        }\n        \n        // Factor 4: Network requirements\n        if resources.requiresNetwork {\n            factors.append(\"ℹ️ Network access required (available on-device)\")\n        } else {\n            factors.append(\"✅ No network access required\")\n        }\n        \n        // Factor 5: Complexity and dependencies\n        if resources.complexityScore > configuration.complexityThreshold {\n            factors.append(\"⚠️ High complexity score: \\(Int(resources.complexityScore))/100\")\n            if canRun && resources.complexityScore > 85 {\n                canRun = false\n                primaryReason = \"Code complexity too high for on-device execution\"\n                suggestedStrategy = .remote\n            }\n        } else {\n            factors.append(\"✅ Complexity score acceptable: \\(Int(resources.complexityScore))/100\")\n        }\n        \n        if resources.externalDependencyCount > configuration.maxExternalDependencies {\n            factors.append(\"⚠️ Too many dependencies: \\(resources.externalDependencyCount) (max: \\(configuration.maxExternalDependencies))\")\n            if canRun {\n                canRun = false\n                primaryReason = \"Too many external dependencies\"\n                suggestedStrategy = .remote\n            }\n        } else {\n            factors.append(\"✅ Dependency count acceptable: \\(resources.externalDependencyCount)\")\n        }\n        \n        // Finalize primary reason if not set\n        if primaryReason.isEmpty {\n            if canRun {\n                primaryReason = \"All requirements met for on-device execution\"\n            } else {\n                primaryReason = \"On-device execution not recommended\"\n                suggestedStrategy = .hybrid\n            }\n        }\n        \n        // Apply user preferences\n        if userPreferences.preferOnDevice && suggestedStrategy == .remote {\n            suggestedStrategy = .hybrid\n            factors.append(\"ℹ️ User prefers on-device - suggesting hybrid strategy\")\n        }\n        \n        return DeviceExecutionResult(\n            canRun: canRun,\n            reason: primaryReason,\n            factors: factors,\n            suggestedStrategy: suggestedStrategy\n        )\n    }\n    \n    /// Estimates resource usage for the given code\n    ///\n    /// Analyzes code structure to estimate:\n    /// - Execution time based on complexity and language overhead\n    /// - Memory usage based on data structures and algorithms\n    /// - CPU usage based on computational complexity\n    /// - File system and network requirements\n    ///\n    /// - Parameters:\n    ///   - code: The source code to analyze\n    ///   - language: The programming language (optional, for more accurate estimates)\n    /// - Returns: Resource usage estimate\n    public func estimateResourceUsage(code: String, language: Language? = nil) -> ResourceEstimate {\n        let lines = code.components(separatedBy: .newlines)\n        let lineCount = lines.count\n        let charCount = code.count\n        \n        // Complexity analysis\n        let complexityScore = calculateComplexityScore(code: code, lines: lines)\n        \n        // Dependency analysis\n        let dependencies = analyzeDependencies(code: code, language: language)\n        \n        // Resource requirement detection\n        let requiresFileSystem = detectFileSystemAccess(code: code, language: language)\n        let requiresNetwork = detectNetworkAccess(code: code, language: language)\n        \n        // Time estimation\n        let baseOverhead = language?.baseExecutionOverheadMs ?? 100\n        let timePerLine = 0.5  // Base ms per line\n        let complexityMultiplier = 1.0 + (complexityScore / 100.0)\n        let dependencyOverhead = Double(dependencies.count) * 50  // 50ms per import\n        let estimatedTimeMs = baseOverhead + (Double(lineCount) * timePerLine * complexityMultiplier) + dependencyOverhead\n        \n        // Memory estimation\n        let baseMemory = 10.0  // Base 10MB\n        let memoryPerLine = 0.1\n        let memoryForDependencies = Double(dependencies.count) * 5  // 5MB per dependency estimate\n        let estimatedMemoryMB = baseMemory + (Double(lineCount) * memoryPerLine) + memoryForDependencies\n        \n        // CPU estimation (rough heuristic)\n        let baseCpu = 10.0\n        let cpuForComplexity = complexityScore * 0.5\n        let estimatedCpuPercent = min(baseCpu + cpuForComplexity, 100)\n        \n        return ResourceEstimate(\n            estimatedTimeMs: estimatedTimeMs,\n            estimatedMemoryMB: estimatedMemoryMB,\n            estimatedCpuPercent: estimatedCpuPercent,\n            requiresFileSystem: requiresFileSystem,\n            requiresNetwork: requiresNetwork,\n            complexityScore: complexityScore,\n            externalDependencyCount: dependencies.count\n        )\n    }\n    \n    // MARK: - Private Analysis Methods\n    \n    /// Calculates code complexity score (0-100)\n    private func calculateComplexityScore(code: String, lines: [String]) -> Double {\n        var score: Double = 0\n        \n        // Factor 1: Lines of code\n        let lineCount = lines.count\n        if lineCount > 500 {\n            score += 30\n        } else if lineCount > 100 {\n            score += 15\n        } else if lineCount > 50 {\n            score += 5\n        }\n        \n        // Factor 2: Control flow complexity\n        let controlFlowPatterns = [\n            \"for \", \"while \", \"if \", \"switch\", \"case\", \"catch\",\n            \"try\", \"async\", \"await\", \"Promise\", \"callback\"\n        ]\n        let controlFlowCount = controlFlowPatterns.reduce(0) { count, pattern in\n            return count + code.components(separatedBy: pattern).count - 1\n        }\n        score += min(Double(controlFlowCount) * 2, 25)\n        \n        // Factor 3: Function/class definitions\n        let functionPatterns = [\"func \", \"function \", \"def \", \"class \", \"struct \", \"interface \"]\n        let definitionCount = functionPatterns.reduce(0) { count, pattern in\n            return count + code.components(separatedBy: pattern).count - 1\n        }\n        score += min(Double(definitionCount) * 3, 20)\n        \n        // Factor 4: Nesting depth (approximate)\n        let maxIndent = lines.map { line -> Int in\n            let whitespace = line.prefix(while: { $0.isWhitespace })\n            return whitespace.count / 4  // Assuming 4-space indentation\n        }.max() ?? 0\n        score += min(Double(maxIndent) * 2, 15)\n        \n        // Factor 5: External API calls\n        let apiPatterns = [\"fetch\", \"XMLHttpRequest\", \"axios\", \"http.\", \"request\", \"urllib\"]\n        let apiCount = apiPatterns.reduce(0) { count, pattern in\n            return count + code.components(separatedBy: pattern).count - 1\n        }\n        score += min(Double(apiCount) * 2, 10)\n        \n        return min(score, 100)\n    }\n    \n    /// Analyzes and extracts external dependencies\n    private func analyzeDependencies(code: String, language: Language?) -> [String] {\n        var dependencies: [String] = []\n        \n        // JavaScript/TypeScript: import/require\n        let jsImportPattern = try? NSRegularExpression(pattern: #\"import\\s+(?:.*?\\s+from\\s+)?['\"]([^'\"]+)['\"]|require\\s*\\(\\s*['\"]([^'\"]+)['\"]\\s*\\)\"#, options: [])\n        \n        // Python: import/from\n        let pyImportPattern = try? NSRegularExpression(pattern: #\"(?:from|import)\\s+(\\S+)\"#, options: [])\n        \n        // Swift: import\n        let swiftImportPattern = try? NSRegularExpression(pattern: #\"import\\s+(\\S+)\"#, options: [])\n        \n        let nsString = code as NSString\n        let range = NSRange(location: 0, length: nsString.length)\n        \n        // Language-specific dependency detection\n        switch language {\n        case .javascript, .typescript:\n            if let matches = jsImportPattern?.matches(in: code, options: [], range: range) {\n                for match in matches {\n                    if match.numberOfRanges > 1 {\n                        for i in 1..<match.numberOfRanges {\n                            let range = match.range(at: i)\n                            if range.location != NSNotFound {\n                                let dep = nsString.substring(with: range)\n                                if !dep.isEmpty && !dep.hasPrefix(\".\") {\n                                    dependencies.append(dep)\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            \n        case .python:\n            if let matches = pyImportPattern?.matches(in: code, options: [], range: range) {\n                for match in matches {\n                    if match.numberOfRanges > 1 {\n                        let range = match.range(at: 1)\n                        if range.location != NSNotFound {\n                            let dep = nsString.substring(with: range)\n                            // Filter out standard library modules\n                            let stdLibModules = [\"os\", \"sys\", \"json\", \"re\", \"math\", \"random\", \"datetime\", \"collections\", \"itertools\", \"functools\"]\n                            if !stdLibModules.contains(dep) {\n                                dependencies.append(dep)\n                            }\n                        }\n                    }\n                }\n            }\n            \n        case .swift:\n            if let matches = swiftImportPattern?.matches(in: code, options: [], range: range) {\n                for match in matches {\n                    if match.numberOfRanges > 1 {\n                        let range = match.range(at: 1)\n                        if range.location != NSNotFound {\n                            let dep = nsString.substring(with: range)\n                            // Filter out standard library\n                            if ![\"Foundation\", \"UIKit\", \"SwiftUI\", \"Combine\"].contains(dep) {\n                                dependencies.append(dep)\n                            }\n                        }\n                    }\n                }\n            }\n            \n        default:\n            break\n        }\n        \n        return Array(Set(dependencies))  // Remove duplicates\n    }\n    \n    /// Detects if code requires file system access\n    private func detectFileSystemAccess(code: String, language: Language?) -> Bool {\n        let fsPatterns: [String]\n        \n        switch language {\n        case .javascript, .typescript:\n            fsPatterns = [\n                \"fs.\", \"require('fs')\", \"fs.readFile\", \"fs.writeFile\",\n                \"FileReader\", \"Blob\", \"File\", \"localStorage\", \"indexedDB\"\n            ]\n        case .python:\n            fsPatterns = [\n                \"open(\", \"with open\", \"os.path\", \"pathlib\", \"shutil\",\n                \"json.load\", \"json.dump\", \"csv.reader\", \"csv.writer\"\n            ]\n        case .swift:\n            fsPatterns = [\n                \"FileManager\", \"URL(fileURLWithPath:\", \".write(to:\",\n                \"Data(contentsOf:\", \"String(contentsOfFile:\", \"Bundle.main\"\n            ]\n        default:\n            fsPatterns = [\n                \"file\", \"read\", \"write\", \"open(\", \"close(\", \"save\", \"load\"\n            ]\n        }\n        \n        return fsPatterns.contains { code.contains($0) }\n    }\n    \n    /// Detects if code requires network access\n    private func detectNetworkAccess(code: String, language: Language?) -> Bool {\n        let networkPatterns: [String]\n        \n        switch language {\n        case .javascript, .typescript:\n            networkPatterns = [\n                \"fetch(\", \"XMLHttpRequest\", \"axios\", \"http.\", \"https.\",\n                \"WebSocket\", \"Socket.IO\", \"EventSource\", \"navigator.sendBeacon\"\n            ]\n        case .python:\n            networkPatterns = [\n                \"urllib\", \"http.client\", \"requests.\", \"socket.\",\n                \"ftp.\", \"smtplib\", \"imaplib\", \"poplib\"\n            ]\n        case .swift:\n            networkPatterns = [\n                \"URLSession\", \"URLRequest\", \"NSURLConnection\",\n                \"Alamofire\", \"WebSocket\", \"SocketIO\"\n            ]\n        default:\n            networkPatterns = [\n                \"http\", \"url\", \"socket\", \"connect(\", \"request(\", \"fetch\"\n            ]\n        }\n        \n        return networkPatterns.contains { code.contains($0) }\n    }\n    \n    /// Detects complex file operations that may not work in sandbox\n    private func hasComplexFileOperations(code: String) -> Bool {\n        let complexPatterns = [\n            \"chmod\", \"chown\", \"symlink\", \"hardlink\", \"mount\",\n            \"exec\", \"spawn\", \"fork\", \"pipe\", \"dup2\"\n        ]\n        return complexPatterns.contains { code.contains($0) }\n    }\n    \n    /// Detects complex network operations\n    private func hasComplexNetworkOperations(code: String) -> Bool {\n        let complexPatterns = [\n            \"raw_socket\", \"socket.AF_\", \"bind(\", \"listen(\", \"accept(\",\n            \"SO_\", \"setsockopt\", \"ioctl\", \"select(\", \"poll(\", \"epoll\"\n        ]\n        return complexPatterns.contains { code.contains($0) }\n    }\n    \n    /// Notifies delegate that remote execution is required (for UI warning)\n    private func notifyRemoteRequired(reason: String) {\n        // Only notify if user wants warnings\n        guard userPreferences.warnBeforeRemote else { return }\n        \n        delegate?.runnerSelector(\n            self,\n            requiresRemoteExecution: reason\n        )\n    }\n}\n\n// MARK: - Delegate Protocol\n\n/// Protocol for UI integration with RunnerSelector\n///\n/// Implement this protocol to receive notifications about execution decisions,\n/// particularly when remote execution is required and user should be warned.\npublic protocol RunnerSelectorDelegate: AnyObject {\n    /// Called when the selector determines remote execution is required\n    /// - Parameters:\n    ///   - selector: The runner selector instance\n    ///   - reason: Human-readable explanation of why remote is needed\n    func runnerSelector(_ selector: RunnerSelector, requiresRemoteExecution reason: String)\n    \n    /// Called when execution strategy is determined (optional)\n    /// - Parameters:\n    ///   - selector: The runner selector instance\n    ///   - strategy: The selected execution strategy\n    ///   - estimate: Resource usage estimate\n    func runnerSelector(_ selector: RunnerSelector, selectedStrategy strategy: ExecutionStrategy, withEstimate estimate: ResourceEstimate)\n}\n\n// MARK: - Default Delegate Implementation\n\npublic extension RunnerSelectorDelegate {\n    func runnerSelector(_ selector: RunnerSelector, selectedStrategy strategy: ExecutionStrategy, withEstimate estimate: ResourceEstimate) {\n        // Default empty implementation\n    }\n}\n\n// MARK: - Convenience Extensions\n\npublic extension RunnerSelector {\n    /// Quick check if code should run remotely without full analysis\n    func shouldRunRemotely(code: String, language: Language) -> Bool {\n        return analyze(code: code, language: language) != .onDevice\n    }\n    \n    /// Get execution strategy with detailed explanation for UI display\n    func analyzeWithExplanation(code: String, language: Language) -> (strategy: ExecutionStrategy, explanation: String) {\n        let result = canRunOnDevice(code: code, language: language)\n        let explanation = \"\"\"\n        Execution Analysis:\n        \\(result.factors.joined(separator: \"\\n\"))\n        \n        Decision: \\(result.reason)\n        Recommended Strategy: \\(result.suggestedStrategy.description)\n        \"\"\"\n        return (result.suggestedStrategy, explanation)\n    }\n}\n"}  <|tool_calls_section_end|>

   >>>TOOL create_file
{"path": "Services/RunnerSelector.swift", "content": "import Foundation\n\n// MARK: - Supporting Types\n\n/// Represents supported programming languages\npublic enum Language: String, CaseIterable, Codable {\n    case javascript = \"javascript\"\n    case python = \"python\"\n    case swift = \"swift\"\n    case typescript = \"typescript\"\n    case bash = \"bash\"\n    case ruby = \"ruby\"\n    case php = \"php\"\n    case go = \"go\"\n    case rust = \"rust\"\n    case unknown = \"unknown\"\n    \n    /// Determines if this language can run on-device (iOS/iPadOS)\n    public var supportsOnDeviceExecution: Bool {\n        switch self {\n        case .javascript:\n            // JavaScriptCore is available natively on iOS\n            return true\n        case .python:\n            // Python can run via embedded interpreter (limited)\n            return true\n        case .swift:\n            // Swift can run in limited sandboxed mode\n            return true\n        case .bash, .ruby, .php, .go, .rust, .typescript, .unknown:\n            // These require compilation, interpreters not natively available,\n            // or have significant sandbox limitations\n            return false\n        }\n    }\n    \n    /// Estimated base execution overhead in milliseconds\n    public var baseExecutionOverheadMs: Double {\n        switch self {\n        case .javascript: return 50\n        case .python: return 100\n        case .swift: return 200\n        case .typescript: return 100  // Needs transpilation\n        default: return 150\n        }\n    }\n}\n\n/// Execution strategy determined by the selector\npublic enum ExecutionStrategy: String, CaseIterable, Codable {\n    /// Run entirely on-device using local interpreter/sandbox\n    case onDevice = \"onDevice\"\n    \n    /// Run on remote server with full environment\n    case remote = \"remote\"\n    \n    /// Hybrid: initial processing on-device, fallback to remote if needed\n    case hybrid = \"hybrid\"\n    \n    public var description: String {\n        switch self {\n        case .onDevice:\n            return \"Execute on-device with local sandbox\"\n        case .remote:\n            return \"Execute on remote server\"\n        case .hybrid:\n            return \"Attempt on-device first, fallback to remote\"\n        }\n    }\n    \n    /// Whether this strategy requires network connectivity\n    public var requiresNetwork: Bool {\n        switch self {\n        case .onDevice:\n            return false\n        case .remote, .hybrid:\n            return true\n        }\n    }\n}\n\n/// Resource requirements estimate for code execution\npublic struct ResourceEstimate: Codable {\n    /// Estimated execution time in milliseconds\n    public let estimatedTimeMs: Double\n    \n    /// Estimated memory usage in MB\n    public let estimatedMemoryMB: Double\n    \n    /// Estimated CPU usage percentage (0-100)\n    public let estimatedCpuPercent: Double\n    \n    /// Whether file system access is required\n    public let requiresFileSystem: Bool\n    \n    /// Whether network access is required\n    public let requiresNetwork: Bool\n    \n    /// Complexity score (0-100, higher = more complex)\n    public let complexityScore: Double\n    \n    /// Number of external dependencies detected\n    public let externalDependencyCount: Int\n    \n    public init(\n        estimatedTimeMs: Double,\n        estimatedMemoryMB: Double,\n        estimatedCpuPercent: Double,\n        requiresFileSystem: Bool,\n        requiresNetwork: Bool,\n        complexityScore: Double,\n        externalDependencyCount: Int\n    ) {\n        self.estimatedTimeMs = estimatedTimeMs\n        self.estimatedMemoryMB = estimatedMemoryMB\n        self.estimatedCpuPercent = estimatedCpuPercent\n        self.requiresFileSystem = requiresFileSystem\n        self.requiresNetwork = requiresNetwork\n        self.complexityScore = complexityScore\n        self.externalDependencyCount = externalDependencyCount\n    }\n    \n    /// Whether these resource requirements exceed typical on-device limits\n    public var exceedsOnDeviceLimits: Bool {\n        let config = RunnerConfiguration.default\n        return estimatedTimeMs > config.maxOnDeviceExecutionTimeMs ||\n               estimatedMemoryMB > config.maxOnDeviceMemoryMB ||\n               estimatedCpuPercent > config.maxOnDeviceCpuPercent\n    }\n}\n\n/// Result of checking if code can run on-device\npublic struct DeviceExecutionResult {\n    /// Whether the code can run on-device\n    public let canRun: Bool\n    \n    /// Primary reason for the decision\n    public let reason: String\n    \n    /// Detailed breakdown of factors\n    public let factors: [String]\n    \n    /// Suggested execution strategy\n    public let suggestedStrategy: ExecutionStrategy\n    \n    public init(\n        canRun: Bool,\n        reason: String,\n        factors: [String],\n        suggestedStrategy: ExecutionStrategy\n    ) {\n        self.canRun = canRun\n        self.reason = reason\n        self.factors = factors\n        self.suggestedStrategy = suggestedStrategy\n    }\n}\n\n/// User preferences for execution behavior\npublic struct ExecutionPreferences: Codable {\n    /// User override: force on-device execution when possible\n    public var preferOnDevice: Bool\n    \n    /// User override: always use remote when available\n    public var preferRemote: Bool\n    \n    /// Warn before using remote execution\n    public var warnBeforeRemote: Bool\n    \n    /// Maximum acceptable on-device execution time (overrides default)\n    public var customMaxExecutionTimeMs: Double?\n    \n    /// Default preferences\n    public static let `default` = ExecutionPreferences(\n        preferOnDevice: false,\n        preferRemote: false,\n        warnBeforeRemote: true,\n        customMaxExecutionTimeMs: nil\n    )\n    \n    public init(\n        preferOnDevice: Bool = false,\n        preferRemote: Bool = false,\n        warnBeforeRemote: Bool = true,\n        customMaxExecutionTimeMs: Double? = nil\n    ) {\n        self.preferOnDevice = preferOnDevice\n        self.preferRemote = preferRemote\n        self.warnBeforeRemote = warnBeforeRemote\n        self.customMaxExecutionTimeMs = customMaxExecutionTimeMs\n    }\n}\n\n/// Configuration for runner selection thresholds\npublic struct RunnerConfiguration {\n    /// Maximum execution time allowed on-device (ms)\n    public var maxOnDeviceExecutionTimeMs: Double\n    \n    /// Maximum memory usage allowed on-device (MB)\n    public var maxOnDeviceMemoryMB: Double\n    \n    /// Maximum CPU percentage allowed on-device\n    public var maxOnDeviceCpuPercent: Double\n    \n    /// Timeout threshold for switching from on-device to remote (ms)\n    public var hybridTimeoutMs: Double\n    \n    /// Complexity threshold for forcing remote execution (0-100)\n    public var complexityThreshold: Double\n    \n    /// Maximum external dependencies allowed on-device\n    public var maxExternalDependencies: Int\n    \n    /// Default configuration based on typical iOS device capabilities\n    public static let `default` = RunnerConfiguration(\n        maxOnDeviceExecutionTimeMs: 5000,      // 5 seconds\n        maxOnDeviceMemoryMB: 256,               // 256 MB\n        maxOnDeviceCpuPercent: 80,              // 80% to avoid throttling\n        hybridTimeoutMs: 3000,                  // 3 seconds before fallback\n        complexityThreshold: 70,                // Complexity score threshold\n        maxExternalDependencies: 5              // Max dependencies for on-device\n    )\n    \n    public init(\n        maxOnDeviceExecutionTimeMs: Double,\n        maxOnDeviceMemoryMB: Double,\n        maxOnDeviceCpuPercent: Double,\n        hybridTimeoutMs: Double,\n        complexityThreshold: Double,\n        maxExternalDependencies: Int\n    ) {\n        self.maxOnDeviceExecutionTimeMs = maxOnDeviceExecutionTimeMs\n        self.maxOnDeviceMemoryMB = maxOnDeviceMemoryMB\n        self.maxOnDeviceCpuPercent = maxOnDeviceCpuPercent\n        self.hybridTimeoutMs = hybridTimeoutMs\n        self.complexityThreshold = complexityThreshold\n        self.maxExternalDependencies = maxExternalDependencies\n    }\n}\n\n// MARK: - RunnerSelector\n\n/// Intelligent runner selector that decides between on-device and remote execution\n/// based on code analysis, language capabilities, and resource requirements.\n///\n/// This is the core orchestrator for execution strategy decisions. It analyzes\n/// code complexity, detects requirements (file system, network), estimates\n/// resource usage, and applies user preferences to determine the optimal\n/// execution strategy.\npublic class RunnerSelector {\n    \n    // MARK: - Properties\n    \n    /// Current configuration for decision thresholds\n    public var configuration: RunnerConfiguration\n    \n    /// User preferences for execution behavior\n    public var userPreferences: ExecutionPreferences\n    \n    /// Delegate for UI integration (optional)\n    public weak var delegate: RunnerSelectorDelegate?\n    \n    // MARK: - Initialization\n    \n    public init(\n        configuration: RunnerConfiguration = .default,\n        preferences: ExecutionPreferences = .default\n    ) {\n        self.configuration = configuration\n        self.userPreferences = preferences\n    }\n    \n    // MARK: - Public API\n    \n    /// Analyzes code and determines the optimal execution strategy\n    ///\n    /// Decision logic:\n    /// 1. Check user preference overrides first\n    /// 2. Analyze if language supports on-device execution\n    /// 3. Detect code requirements (file system, network access)\n    /// 4. Estimate resource usage (time, memory, CPU)\n    /// 5. Evaluate complexity and dependencies\n    /// 6. Apply threshold-based decision rules\n    ///\n    /// - Parameters:\n    ///   - code: The source code to analyze\n    ///   - language: The programming language of the code\n    /// - Returns: Recommended execution strategy\n    public func analyze(code: String, language: Language) -> ExecutionStrategy {\n        // Step 1: Check user preferences (highest priority)\n        if userPreferences.preferRemote {\n            return .remote\n        }\n        \n        // Step 2: Check if language supports on-device at all\n        if !language.supportsOnDeviceExecution {\n            notifyRemoteRequired(reason: \"Language '\\(language.rawValue)' requires remote execution environment\")\n            return .remote\n        }\n        \n        // Step 3: Analyze resource requirements\n        let resourceEstimate = estimateResourceUsage(code: code, language: language)\n        \n        // Step 4: Check file system requirements\n        if resourceEstimate.requiresFileSystem {\n            // On-device execution has sandboxed file system access\n            // Complex file operations may need remote\n            if hasComplexFileOperations(code: code) {\n                notifyRemoteRequired(reason: \"Complex file system operations detected\")\n                return .remote\n            }\n        }\n        \n        // Step 5: Check network requirements\n        if resourceEstimate.requiresNetwork {\n            // Code requires network - can run on-device if it's simple API calls\n            // but complex network operations should be remote\n            if hasComplexNetworkOperations(code: code) {\n                notifyRemoteRequired(reason: \"Complex network operations detected\")\n                return .remote\n            }\n        }\n        \n        // Step 6: Check resource limits\n        let effectiveMaxTime = userPreferences.customMaxExecutionTimeMs \n            ?? configuration.maxOnDeviceExecutionTimeMs\n        \n        if resourceEstimate.estimatedTimeMs > effectiveMaxTime {\n            if userPreferences.preferOnDevice {\n                // User wants on-device despite longer execution time - use hybrid\n                return .hybrid\n            }\n            notifyRemoteRequired(reason: \"Estimated execution time (\\(Int(resourceEstimate.estimatedTimeMs))ms) exceeds on-device limit\")\n            return .remote\n        }\n        \n        if resourceEstimate.estimatedMemoryMB > configuration.maxOnDeviceMemoryMB {\n            notifyRemoteRequired(reason: \"Estimated memory usage (\\(Int(resourceEstimate.estimatedMemoryMB))MB) exceeds on-device limit\")\n            return .remote\n        }\n        \n        // Step 7: Check complexity and dependencies\n        if resourceEstimate.complexityScore > configuration.complexityThreshold {\n            if userPreferences.preferOnDevice {\n                return .hybrid\n            }\n            notifyRemoteRequired(reason: \"Code complexity score (\\(Int(resourceEstimate.complexityScore))) exceeds on-device threshold\")\n            return .remote\n        }\n        \n        if resourceEstimate.externalDependencyCount > configuration.maxExternalDependencies {\n            notifyRemoteRequired(reason: \"Too many external dependencies (\\(resourceEstimate.externalDependencyCount)) for on-device execution\")\n            return .remote\n        }\n        \n        // Step 8: Final decision\n        if userPreferences.preferOnDevice {\n            // User explicitly prefers on-device, and it's feasible\n            return .onDevice\n        }\n        \n        // Default: use hybrid for potentially long operations, on-device for quick ones\n        if resourceEstimate.estimatedTimeMs > configuration.hybridTimeoutMs {\n            return .hybrid\n        }\n        \n        return .onDevice\n    }\n    \n    /// Determines if code can run on-device with detailed reasoning\n    ///\n    /// This method provides comprehensive analysis suitable for UI presentation,\n    /// explaining why on-device execution is or isn't possible.\n    ///\n    /// - Parameters:\n    ///   - code: The source code to analyze\n    ///   - language: The programming language\n    /// - Returns: Detailed result with reasons and factors\n    public func canRunOnDevice(code: String, language: Language) -> DeviceExecutionResult {\n        var factors: [String] = []\n        var canRun = true\n        var primaryReason = \"\"\n        var suggestedStrategy: ExecutionStrategy = .onDevice\n        \n        // Factor 1: Language support\n        if !language.supportsOnDeviceExecution {\n            factors.append(\"❌ Language '\\(language.rawValue)' does not support on-device execution\")\n            canRun = false\n            primaryReason = \"Unsupported language for on-device execution\"\n            suggestedStrategy = .remote\n        } else {\n            factors.append(\"✅ Language '\\(language.rawValue)' supports on-device execution\")\n        }\n        \n        // Factor 2: Resource analysis\n        let resources = estimateResourceUsage(code: code, language: language)\n        \n        if resources.estimatedTimeMs > configuration.maxOnDeviceExecutionTimeMs {\n            factors.append(\"⚠️ Estimated time (\\(Int(resources.estimatedTimeMs))ms) exceeds limit (\\(Int(configuration.maxOnDeviceExecutionTimeMs))ms)\")\n            if canRun {\n                canRun = false\n                primaryReason = \"Execution time exceeds on-device limit\"\n                suggestedStrategy = .remote\n            }\n        } else {\n            factors.append(\"✅ Estimated time (\\(Int(resources.estimatedTimeMs))ms) within limit\")\n        }\n        \n        if resources.estimatedMemoryMB > configuration.maxOnDeviceMemoryMB {\n            factors.append(\"⚠️ Estimated memory (\\(Int(resources.estimatedMemoryMB))MB) exceeds limit (\\(Int(configuration.maxOnDeviceMemoryMB))MB)\")\n            if canRun {\n                canRun = false\n                primaryReason = \"Memory requirements exceed on-device limit\"\n                suggestedStrategy = .remote\n            }\n        } else {\n            factors.append(\"✅ Estimated memory (\\(Int(resources.estimatedMemoryMB))MB) within limit\")\n        }\n        \n        // Factor 3: File system requirements\n        if resources.requiresFileSystem {\n            if hasComplexFileOperations(code: code) {\n                factors.append(\"⚠️ Complex file system operations detected\")\n                if canRun {\n                    canRun = false\n                    primaryReason = \"File operations too complex for sandbox\"\n                    suggestedStrategy = .remote\n                }\n            } else {\n                factors.append(\"✅ Simple file system access (sandboxed)\")\n            }\n        } else {\n            factors.append(\"✅ No file system access required\")\n        }\n        \n        // Factor 4: Network requirements\n        if resources.requiresNetwork {\n            factors.append(\"ℹ️ Network access required (available on-device)\")\n        } else {\n            factors.append(\"✅ No network access required\")\n        }\n        \n        // Factor 5: Complexity and dependencies\n        if resources.complexityScore > configuration.complexityThreshold {\n            factors.append(\"⚠️ High complexity score: \\(Int(resources.complexityScore))/100\")\n            if canRun && resources.complexityScore > 85 {\n                canRun = false\n                primaryReason = \"Code complexity too high for on-device execution\"\n                suggestedStrategy = .remote\n            }\n        } else {\n            factors.append(\"✅ Complexity score acceptable: \\(Int(resources.complexityScore))/100\")\n        }\n        \n        if resources.externalDependencyCount > configuration.maxExternalDependencies {\n            factors.append(\"⚠️ Too many dependencies: \\(resources.externalDependencyCount) (max: \\(configuration.maxExternalDependencies))\")\n            if canRun {\n                canRun = false\n                primaryReason = \"Too many external dependencies\"\n                suggestedStrategy = .remote\n            }\n        } else {\n            factors.append(\"✅ Dependency count acceptable: \\(resources.externalDependencyCount)\")\n        }\n        \n        // Finalize primary reason if not set\n        if primaryReason.isEmpty {\n            if canRun {\n                primaryReason = \"All requirements met for on-device execution\"\n            } else {\n                primaryReason = \"On-device execution not recommended\"\n                suggestedStrategy = .hybrid\n            }\n        }\n        \n        // Apply user preferences\n        if userPreferences.preferOnDevice && suggestedStrategy == .remote {\n            suggestedStrategy = .hybrid\n            factors.append(\"ℹ️ User prefers on-device - suggesting hybrid strategy\")\n        }\n        \n        return DeviceExecutionResult(\n            canRun: canRun,\n            reason: primaryReason,\n            factors: factors,\n            suggestedStrategy: suggestedStrategy\n        )\n    }\n    \n    /// Estimates resource usage for the given code\n    ///\n    /// Analyzes code structure to estimate:\n    /// - Execution time based on complexity and language overhead\n    /// - Memory usage based on data structures and algorithms\n    /// - CPU usage based on computational complexity\n    /// - File system and network requirements\n    ///\n    /// - Parameters:\n    ///   - code: The source code to analyze\n    ///   - language: The programming language (optional, for more accurate estimates)\n    /// - Returns: Resource usage estimate\n    public func estimateResourceUsage(code: String, language: Language? = nil) -> ResourceEstimate {\n        let lines = code.components(separatedBy: .newlines)\n        let lineCount = lines.count\n        let charCount = code.count\n        \n        // Complexity analysis\n        let complexityScore = calculateComplexityScore(code: code, lines: lines)\n        \n        // Dependency analysis\n        let dependencies = analyzeDependencies(code: code, language: language)\n        \n        // Resource requirement detection\n        let requiresFileSystem = detectFileSystemAccess(code: code, language: language)\n        let requiresNetwork = detectNetworkAccess(code: code, language: language)\n        \n        // Time estimation\n        let baseOverhead = language?.baseExecutionOverheadMs ?? 100\n        let timePerLine = 0.5  // Base ms per line\n        let complexityMultiplier = 1.0 + (complexityScore / 100.0)\n        let dependencyOverhead = Double(dependencies.count) * 50  // 50ms per import\n        let estimatedTimeMs = baseOverhead + (Double(lineCount) * timePerLine * complexityMultiplier) + dependencyOverhead\n        \n        // Memory estimation\n        let baseMemory = 10.0  // Base 10MB\n        let memoryPerLine = 0.1\n        let memoryForDependencies = Double(dependencies.count) * 5  // 5MB per dependency estimate\n        let estimatedMemoryMB = baseMemory + (Double(lineCount) * memoryPerLine) + memoryForDependencies\n        \n        // CPU estimation (rough heuristic)\n        let baseCpu = 10.0\n        let cpuForComplexity = complexityScore * 0.5\n        let estimatedCpuPercent = min(baseCpu + cpuForComplexity, 100)\n        \n        return ResourceEstimate(\n            estimatedTimeMs: estimatedTimeMs,\n            estimatedMemoryMB: estimatedMemoryMB,\n            estimatedCpuPercent: estimatedCpuPercent,\n            requiresFileSystem: requiresFileSystem,\n            requiresNetwork: requiresNetwork,\n            complexityScore: complexityScore,\n            externalDependencyCount: dependencies.count\n        )\n    }\n    \n    // MARK: - Private Analysis Methods\n    \n    /// Calculates code complexity score (0-100)\n    private func calculateComplexityScore(code: String, lines: [String]) -> Double {\n        var score: Double = 0\n        \n        // Factor 1: Lines of code\n        let lineCount = lines.count\n        if lineCount > 500 {\n            score += 30\n        } else if lineCount > 100 {\n            score += 15\n        } else if lineCount > 50 {\n            score += 5\n        }\n        \n        // Factor 2: Control flow complexity\n        let controlFlowPatterns = [\n            \"for \", \"while \", \"if \", \"switch\", \"case\", \"catch\",\n            \"try\", \"async\", \"await\", \"Promise\", \"callback\"\n        ]\n        let controlFlowCount = controlFlowPatterns.reduce(0) { count, pattern in\n            return count + code.components(separatedBy: pattern).count - 1\n        }\n        score += min(Double(controlFlowCount) * 2, 25)\n        \n        // Factor 3: Function/class definitions\n        let functionPatterns = [\"func \", \"function \", \"def \", \"class \", \"struct \", \"interface \"]\n        let definitionCount = functionPatterns.reduce(0) { count, pattern in\n            return count + code.components(separatedBy: pattern).count - 1\n        }\n        score += min(Double(definitionCount) * 3, 20)\n        \n        // Factor 4: Nesting depth (approximate)\n        let maxIndent = lines.map { line -> Int in\n            let whitespace = line.prefix(while: { $0.isWhitespace })\n            return whitespace.count / 4  // Assuming 4-space indentation\n        }.max() ?? 0\n        score += min(Double(maxIndent) * 2, 15)\n        \n        // Factor 5: External API calls\n        let apiPatterns = [\"fetch\", \"XMLHttpRequest\", \"axios\", \"http.\", \"request\", \"urllib\"]\n        let apiCount = apiPatterns.reduce(0) { count, pattern in\n            return count + code.components(separatedBy: pattern).count - 1\n        }\n        score += min(Double(apiCount) * 2, 10)\n        \n        return min(score, 100)\n    }\n    \n    /// Analyzes and extracts external dependencies\n    private func analyzeDependencies(code: String, language: Language?) -> [String] {\n        var dependencies: [String] = []\n        \n        // JavaScript/TypeScript: import/require\n        let jsImportPattern = try? NSRegularExpression(pattern: #\"import\\s+(?:.*?\\s+from\\s+)?['\"]([^'\"]+)['\"]|require\\s*\\(\\s*['\"]([^'\"]+)['\"]\\s*\\)\"#, options: [])\n        \n        // Python: import/from\n        let pyImportPattern = try? NSRegularExpression(pattern: #\"(?:from|import)\\s+(\\S+)\"#, options: [])\n        \n        // Swift: import\n        let swiftImportPattern = try? NSRegularExpression(pattern: #\"import\\s+(\\S+)\"#, options: [])\n        \n        let nsString = code as NSString\n        let range = NSRange(location: 0, length: nsString.length)\n        \n        // Language-specific dependency detection\n        switch language {\n        case .javascript, .typescript:\n            if let matches = jsImportPattern?.matches(in: code, options: [], range: range) {\n                for match in matches {\n                    if match.numberOfRanges > 1 {\n                        for i in 1..<match.numberOfRanges {\n                            let range = match.range(at: i)\n                            if range.location != NSNotFound {\n                                let dep = nsString.substring(with: range)\n                                if !dep.isEmpty && !dep.hasPrefix(\".\") {\n                                    dependencies.append(dep)\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            \n        case .python:\n            if let matches = pyImportPattern?.matches(in: code, options: [], range: range) {\n                for match in matches {\n                    if match.numberOfRanges > 1 {\n                        let range = match.range(at: 1)\n                        if range.location != NSNotFound {\n                            let dep = nsString.substring(with: range)\n                            // Filter out standard library modules\n                            let stdLibModules = [\"os\", \"sys\", \"json\", \"re\", \"math\", \"random\", \"datetime\", \"collections\", \"itertools\", \"functools\"]\n                            if !stdLibModules.contains(dep) {\n                                dependencies.append(dep)\n                            }\n                        }\n                    }\n                }\n            }\n            \n        case .swift:\n            if let matches = swiftImportPattern?.matches(in: code, options: [], range: range) {\n                for match in matches {\n                    if match.numberOfRanges > 1 {\n                        let range = match.range(at: 1)\n                        if range.location != NSNotFound {\n                            let dep = nsString.substring(with: range)\n                            // Filter out standard library\n                            if ![\"Foundation\", \"UIKit\", \"SwiftUI\", \"Combine\"].contains(dep) {\n                                dependencies.append(dep)\n                            }\n                        }\n                    }\n                }\n            }\n            \n        default:\n            break\n        }\n        \n        return Array(Set(dependencies))  // Remove duplicates\n    }\n    \n    /// Detects if code requires file system access\n    private func detectFileSystemAccess(code: String, language: Language?) -> Bool {\n        let fsPatterns: [String]\n        \n        switch language {\n        case .javascript, .typescript:\n            fsPatterns = [\n                \"fs.\", \"require('fs')\", \"fs.readFile\", \"fs.writeFile\",\n                \"FileReader\", \"Blob\", \"File\", \"localStorage\", \"indexedDB\"\n            ]\n        case .python:\n            fsPatterns = [\n                \"open(\", \"with open\", \"os.path\", \"pathlib\", \"shutil\",\n                \"json.load\", \"json.dump\", \"csv.reader\", \"csv.writer\"\n            ]\n        case .swift:\n            fsPatterns = [\n                \"FileManager\", \"URL(fileURLWithPath:\", \".write(to:\",\n                \"Data(contentsOf:\", \"String(contentsOfFile:\", \"Bundle.main\"\n            ]\n        default:\n            fsPatterns = [\n                \"file\", \"read\", \"write\", \"open(\", \"close(\", \"save\", \"load\"\n            ]\n        }\n        \n        return fsPatterns.contains { code.contains($0) }\n    }\n    \n    /// Detects if code requires network access\n    private func detectNetworkAccess(code: String, language: Language?) -> Bool {\n        let networkPatterns: [String]\n        \n        switch language {\n        case .javascript, .typescript:\n            networkPatterns = [\n                \"fetch(\", \"XMLHttpRequest\", \"axios\", \"http.\", \"https.\",\n                \"WebSocket\", \"Socket.IO\", \"EventSource\", \"navigator.sendBeacon\"\n            ]\n        case .python:\n            networkPatterns = [\n                \"urllib\", \"http.client\", \"requests.\", \"socket.\",\n                \"ftp.\", \"smtplib\", \"imaplib\", \"poplib\"\n            ]\n        case .swift:\n            networkPatterns = [\n                \"URLSession\", \"URLRequest\", \"NSURLConnection\",\n                \"Alamofire\", \"WebSocket\", \"SocketIO\"\n            ]\n        default:\n            networkPatterns = [\n                \"http\", \"url\", \"socket\", \"connect(\", \"request(\", \"fetch\"\n            ]\n        }\n        \n        return networkPatterns.contains { code.contains($0) }\n    }\n    \n    /// Detects complex file operations that may not work in sandbox\n    private func hasComplexFileOperations(code: String) -> Bool {\n        let complexPatterns = [\n            \"chmod\", \"chown\", \"symlink\", \"hardlink\", \"mount\",\n            \"exec\", \"spawn\", \"fork\", \"pipe\", \"dup2\"\n        ]\n        return complexPatterns.contains { code.contains($0) }\n    }\n    \n    /// Detects complex network operations\n    private func hasComplexNetworkOperations(code: String) -> Bool {\n        let complexPatterns = [\n            \"raw_socket\", \"socket.AF_\", \"bind(\", \"listen(\", \"accept(\",\n            \"SO_\", \"setsockopt\", \"ioctl\", \"select(\", \"poll(\", \"epoll\"\n        ]\n        return complexPatterns.contains { code.contains($0) }\n    }\n    \n    /// Notifies delegate that remote execution is required (for UI warning)\n    private func notifyRemoteRequired(reason: String) {\n        // Only notify if user wants warnings\n        guard userPreferences.warnBeforeRemote else { return }\n        \n        delegate?.runnerSelector(\n            self,\n            requiresRemoteExecution: reason\n        )\n    }\n}\n\n// MARK: - Delegate Protocol\n\n/// Protocol for UI integration with RunnerSelector\n///\n/// Implement this protocol to receive notifications about execution decisions,\n/// particularly when remote execution is required and user should be warned.\npublic protocol RunnerSelectorDelegate: AnyObject {\n    /// Called when the selector determines remote execution is required\n    /// - Parameters:\n    ///   - selector: The runner selector instance\n    ///   - reason: Human-readable explanation of why remote is needed\n    func runnerSelector(_ selector: RunnerSelector, requiresRemoteExecution reason: String)\n    \n    /// Called when execution strategy is determined (optional)\n    /// - Parameters:\n    ///   - selector: The runner selector instance\n    ///   - strategy: The selected execution strategy\n    ///   - estimate: Resource usage estimate\n    func runnerSelector(_ selector: RunnerSelector, selectedStrategy strategy: ExecutionStrategy, withEstimate estimate: ResourceEstimate)\n}\n\n// MARK: - Default Delegate Implementation\n\npublic extension RunnerSelectorDelegate {\n    func runnerSelector(_ selector: RunnerSelector, selectedStrategy strategy: ExecutionStrategy, withEstimate estimate: ResourceEstimate) {\n        // Default empty implementation\n    }\n}\n\n// MARK: - Convenience Extensions\n\npublic extension RunnerSelector {\n    /// Quick check if code should run remotely without full analysis\n    func shouldRunRemotely(code: String, language: Language) -> Bool {\n        return analyze(code: code, language: language) != .onDevice\n    }\n    \n    /// Get execution strategy with detailed explanation for UI display\n    func analyzeWithExplanation(code: String, language: Language) -> (strategy: ExecutionStrategy, explanation: String) {\n        let result = canRunOnDevice(code: code, language: language)\n        let explanation = \"\"\"\n        Execution Analysis:\n        \\(result.factors.joined(separator: \"\\n\"))\n        \n        Decision: \\(result.reason)\n        Recommended Strategy: \\(result.suggestedStrategy.description)\n        \"\"\"\n        return (result.suggestedStrategy, explanation)\n    }\n}"}   ️

  >>>REPORT
Successfully created Services/RunnerSelector.swift - a comprehensive intelligent runner selection system.

**File Created:** `Services/RunnerSelector.swift`

**Key Components:**

1. **Supporting Types (Lines 7-212):**
   - `Language` enum (10 languages) with `supportsOnDeviceExecution` property
   - `ExecutionStrategy` enum (.onDevice, .remote, .hybrid) with descriptions
   - `ResourceEstimate` struct with time/memory/CPU estimates and limits checking
   - `DeviceExecutionResult` struct with detailed factor analysis
   - `ExecutionPreferences` struct for user overrides (preferOnDevice, preferRemote, warnBeforeRemote)
   - `RunnerConfiguration` struct with configurable thresholds (time: 5s, memory: 256MB, etc.)

2. **RunnerSelector Class (Lines 215-544):**
   - **analyze(code:language:)** - Main decision engine with 8-step logic (user prefs → language support → resources → file system → network → limits → complexity → final decision)
   - **canRunOnDevice(code:language:)** - Returns `DeviceExecutionResult` with detailed factors array (✅/⚠️/❌ markers) suitable for UI display
   - **estimateResourceUsage(code:language:)** - Heuristic-based analysis of time, memory, CPU, dependencies

3. **Private Analysis Methods (Lines 397-544):**
   - `calculateComplexityScore()` - Lines of code, control flow, nesting depth, API calls
   - `analyzeDependencies()` - Language-specific regex patterns (import/require statements)
   - `detectFileSystemAccess()` - Language-specific file operation patterns
   - `detectNetworkAccess()` - Language-specific network patterns
   - `hasComplexFileOperations()` - Detects chmod, symlinks, mounts, etc.
   - `hasComplexNetworkOperations()` - Detects raw sockets, bind/listen, etc.

4. **UI Integration (Lines 546-582):**
   - `RunnerSelectorDelegate` protocol with `requiresRemoteExecution` callback for warnings
   - Optional `selectedStrategy` callback for strategy notifications
   - `notifyRemoteRequired()` method respects `userPreferences.warnBeforeRemote`

5. **Convenience Extensions (Lines 584-600):**
   - `shouldRunRemotely()` - Quick boolean check
   - `analyzeWithExplanation()` - Returns formatted explanation string for UI display

**Decision Logic Documentation:** Clear comments explain the 8-step decision hierarchy from user preferences through complexity thresholds to final strategy selection.

**Configuration Defaults:** Based on typical iOS device capabilities (5s max execution, 256MB memory, 80% CPU to avoid throttling).

**Language Support Matrix:**
- ✅ On-device: JavaScript (JavaScriptCore), Python (embedded), Swift (sandboxed)
- ❌ Remote required: TypeScript (needs transpile), Bash, Ruby, PHP, Go, Rust
>>>END
