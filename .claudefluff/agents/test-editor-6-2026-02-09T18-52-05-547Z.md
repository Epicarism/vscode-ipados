# Agent: test-editor-6
**Status:** done
**Tokens:** 12,431
**Cost:** $0.0000
**Time:** 2026-02-09T18:52:05.547Z

## Task
Create XCTest UI test methods for LINE NUMBERS display. Create test methods: testLineNumbersVisible(), testLineNumbersUpdateOnNewLine(), testCurrentLineHighlight(), testLineNumbersScrollSync(), testLineNumbersTapNavigation(). Look for elements with 'line' or 'gutter' identifiers. Return ONLY the Swift test methods (not full class). Reference VSCodeiPadOSUITests/SearchViewUITests.swift for XCTest patterns.

## Response
>>>TOOL read_file
{"path":"VSCodeiPadOSUITests/SearchViewUITests.swift"} 
>>>END>>>TOOL get_symbols
{"path":"VSCodeiPadOSUITests/SearchViewUITests.swift"} 
>>>END>>>TOOL read_file
{"path":"VSCodeiPadOSUITests/SearchViewUITests.swift","start_line":1,"end_line":260} 
>>>END>>>END

>>>TOOL search
{"query":"gutter", "glob":"**/*.*"} 
>>>END

---

## ðŸ”§ TOOL RESULTS

[search]
Found 2 matches:
MASTER_AGENT_PLAN.md:166: | git-13 | Git gutter integration | Views/Editor/GitGutterView.swift |
MASTER_AGENT_PLAN.md:179: | fold-5 | Fold gutter UI | Views/Editor/FoldingGutterView.swift (NEW) |


>>>TOOL read_file
{"path":"VSCodeiPadOSUITests/SearchViewUITests.swift","start_line":1,"end_line":260}
>>>END>>>TOOL search
{"query":"lineNumbers", "glob":"VSCodeiPadOSUITests/*.swift"}
>>>END>>>TOOL search
{"query":"gutter", "glob":"VSCodeiPadOSUITests/*.swift"}
>>>END>>>TOOL search
{"query":"identifier", "glob":"VSCodeiPadOSUITests/SearchViewUITests.swift"}
>>>END>>>TOOL search
{"query":"XCUIApplication", "glob":"VSCodeiPadOSUITests/SearchViewUITests.swift"}
>>>END

---

## ðŸ”§ TOOL RESULTS

[read_file]
File: VSCodeiPadOSUITests/SearchViewUITests.swift (lines 2-260 of 424)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
2: 
3: /// UI Tests for SearchView
4: /// Tests search functionality, toggles, replace options, and result navigation
5: final class SearchViewUITests: XCTestCase {
6:     
7:     var app: XCUIApplication!
8:     
9:     override func setUpWithError() throws {
10:         continueAfterFailure = false
11:         app = XCUIApplication()
12:         app.launch()
13:         
14:         // Navigate to search view - assuming it's accessible from main UI
15:         // This may need adjustment based on actual app navigation structure
16:         openSearchView()
17:     }
18:     
19:     override func tearDownWithError() throws {
20:         app = nil
21:     }
22:     
23:     // MARK: - Helper Methods
24:     
25:     /// Opens the search view from the main app interface
26:     private func openSearchView() {
27:         // Try to find and tap search button/shortcut
28:         // Common ways to access search: toolbar button, keyboard shortcut, or menu item
29:         let searchButton = app.buttons["Search"]
30:         let findButton = app.buttons["Find"]
31:         let searchToolbarButton = app.toolbars.buttons["Search"]
32:         
33:         if searchButton.exists {
34:             searchButton.tap()
35:         } else if findButton.exists {
36:             findButton.tap()
37:         } else if searchToolbarButton.exists {
38:             searchToolbarButton.tap()
39:         } else {
40:             // Try using keyboard shortcut Cmd+Shift+F for global search
41:             // or Cmd+F for find
42:             XCUIDevice.shared.press(.home)
43:         }
44:     }
45:     
46:     // MARK: - Test Cases
47:     
48:     /// Test 1: Verify search text field is present
49:     func testSearchFieldExists() throws {
50:         // Search field should be present in the search view
51:         let searchField = app.textFields["Search"]
52:         let searchTextField = app.searchFields["Search"]
53:         let findTextField = app.textFields["Find"]
54:         
55:         // At least one search input field should exist
56:         let searchFieldExists = searchField.waitForExistence(timeout: 2) ||
57:                               searchTextField.waitForExistence(timeout: 2) ||
58:                               findTextField.waitForExistence(timeout: 2)
59:         
60:         XCTAssertTrue(searchFieldExists, "Search text field should be present in the search view")
61:     }
62:     
63:     /// Test 2: Verify matchCase, matchWholeWord, useRegex toggles exist
64:     func testToggleButtonsExist() throws {
65:         // Check for match case toggle/button
66:         let matchCaseToggle = app.toggles["Match Case"]
67:         let matchCaseButton = app.buttons["Match Case"]
68:         let matchCaseExists = matchCaseToggle.waitForExistence(timeout: 2) ||
69:                              matchCaseButton.waitForExistence(timeout: 2)
70:         
71:         // Check for match whole word toggle/button
72:         let matchWholeWordToggle = app.toggles["Match Whole Word"]
73:         let matchWholeWordButton = app.buttons["Match Whole Word"]
74:         let matchWholeWordExists = matchWholeWordToggle.waitForExistence(timeout: 2) ||
75:                                   matchWholeWordButton.waitForExistence(timeout: 2)
76:         
77:         // Check for use regex toggle/button
78:         let useRegexToggle = app.toggles["Use Regular Expressions"]
79:         let useRegexButton = app.buttons["Use Regular Expressions"]
80:         let regexButton = app.buttons["Regex"]
81:         let useRegexExists = useRegexToggle.waitForExistence(timeout: 2) ||
82:                            useRegexButton.waitForExistence(timeout: 2) ||
83:                            regexButton.waitForExistence(timeout: 2)
84:         
85:         XCTAssertTrue(matchCaseExists, "Match Case toggle should be present")
86:         XCTAssertTrue(matchWholeWordExists, "Match Whole Word toggle should be present")
87:         XCTAssertTrue(useRegexExists, "Use Regular Expressions toggle should be present")
88:     }
89:     
90:     /// Test 3: Test expand/collapse replace section
91:     func testReplaceSectionToggle() throws {
92:         // Find the replace section toggle/disclosure button
93:         let replaceToggle = app.buttons["Replace"]
94:         let replaceDisclosure = app.disclosureTriangles["Replace"]
95:         let replaceChevron = app.buttons.element(matching: .any, identifier: "replaceToggle")
96:         
97:         // First check if replace section exists
98:         let replaceField = app.textFields["Replace"]
99:         let replaceTextField = app.textViews["Replace"]
100:         
101:         // If replace field is not visible, try to toggle it
102:         if !replaceField.exists && !replaceTextField.exists {
103:             if replaceToggle.exists {
104:                 replaceToggle.tap()
105:             } else if replaceDisclosure.exists {
106:                 replaceDisclosure.tap()
107:             }
108:             
109:             // Wait for animation
110:             sleep(1)
111:         }
112:         
113:         // Verify replace field is now visible
114:         let replaceFieldVisible = app.textFields["Replace"].waitForExistence(timeout: 2) ||
115:                                  app.textViews["Replace"].waitForExistence(timeout: 2)
116:         
117:         XCTAssertTrue(replaceFieldVisible, "Replace section should be expandable and show replace field")
118:     }
119:     
120:     /// Test 4: Test expand/collapse include/exclude patterns section
121:     func testIncludeExcludeSectionToggle() throws {
122:         // Find the patterns section toggle
123:         let patternsToggle = app.buttons["Files to Include/Exclude"]
124:         let includeExcludeToggle = app.buttons["Include/Exclude"]
125:         let filePatternsToggle = app.buttons["File Patterns"]
126:         
127:         // Try to find and toggle the patterns section
128:         let patternsToggleExists = patternsToggle.exists || 
129:                                   includeExcludeToggle.exists || 
130:                                   filePatternsToggle.exists
131:         
132:         if patternsToggleExists {
133:             if patternsToggle.exists {
134:                 patternsToggle.tap()
135:             } else if includeExcludeToggle.exists {
136:                 includeExcludeToggle.tap()
137:             } else if filePatternsToggle.exists {
138:                 filePatternsToggle.tap()
139:             }
140:             
141:             // Wait for animation
142:             sleep(1)
143:         }
144:         
145:         // Verify include/exclude fields are visible
146:         let includeField = app.textFields["files to include"]
147:         let excludeField = app.textFields["files to exclude"]
148:         let includePattern = app.textFields["Include patterns"]
149:         let excludePattern = app.textFields["Exclude patterns"]
150:         
151:         let patternsVisible = includeField.waitForExistence(timeout: 2) ||
152:                              excludeField.waitForExistence(timeout: 2) ||
153:                              includePattern.waitForExistence(timeout: 2) ||
154:                              excludePattern.waitForExistence(timeout: 2)
155:         
156:         XCTAssertTrue(patternsVisible, "Include/Exclude patterns section should be expandable")
157:     }
158:     
159:     /// Test 5: Type text and verify search triggers
160:     func testSearchExecutes() throws {
161:         // Find and interact with search field
162:         let searchField = app.textFields["Search"]
163:         let searchTextField = app.searchFields["Search"]
164:         
165:         let searchInput = searchField.exists ? searchField : searchTextField
166:         
167:         XCTAssertTrue(searchInput.waitForExistence(timeout: 2), "Search field should exist")
168:         
169:         // Tap and type search query
170:         searchInput.tap()
171:         searchInput.typeText("func")
172:         
173:         // Wait for search to execute (debounce/animation)
174:         sleep(2)
175:         
176:         // Verify search was triggered by checking for results or loading indicator
177:         let resultsList = app.collectionViews["Search Results"]
178:         let resultsTable = app.tables["Search Results"]
179:         let loadingIndicator = app.activityIndicators["In progress"]
180:         let resultCount = app.staticTexts.matching(NSPredicate(format: "label CONTAINS 'result'"))
181:         
182:         let searchTriggered = resultsList.exists || 
183:                              resultsTable.exists || 
184:                              loadingIndicator.exists || 
185:                              resultCount.count > 0
186:         
187:         XCTAssertTrue(searchTriggered, "Search should execute after typing text")
188:     }
189:     
190:     /// Test 6: Verify results appear after search
191:     func testResultsDisplay() throws {
192:         // First perform a search
193:         let searchField = app.textFields["Search"]
194:         let searchTextField = app.searchFields["Search"]
195:         let searchInput = searchField.exists ? searchField : searchTextField
196:         
197:         guard searchInput.waitForExistence(timeout: 2) else {
198:             XCTSkip("Search field not available")
199:             return
200:         }
201:         
202:         searchInput.tap()
203:         searchInput.typeText("import")
204:         
205:         // Wait for search results
206:         sleep(3)
207:         
208:         // Check for results in various formats
209:         let resultsList = app.collectionViews["Search Results"]
210:         let resultsTable = app.tables["Search Results"]
211:         let resultCells = app.cells.matching(NSPredicate(format: "identifier CONTAINS 'result' OR label CONTAINS 'result'"))
212:         let fileResults = app.staticTexts.matching(NSPredicate(format: "label CONTAINS '.swift' OR label CONTAINS '.ts' OR label CONTAINS '.js'"))
213:         let matchResults = app.staticTexts.matching(NSPredicate(format: "label CONTAINS 'import'"))
214:         
215:         let resultsVisible = resultsList.exists || 
216:                             resultsTable.exists || 
217:                             resultCells.count > 0 ||
218:                             fileResults.count > 0 ||
219:                             matchResults.count > 0
220:         
221:         XCTAssertTrue(resultsVisible, "Search results should be displayed after search execution")
222:     }
223:     
224:     /// Test 7: Test tapping result navigates to file location
225:     func testNavigateToResult() throws {
226:         // First perform a search to get results
227:         let searchField = app.textFields["Search"]
228:         let searchTextField = app.searchFields["Search"]
229:         let searchInput = searchField.exists ? searchField : searchTextField
230:         
231:         guard searchInput.waitForExistence(timeout: 2) else {
232:             XCTSkip("Search field not available")
233:             return
234:         }
235:         
236:         searchInput.tap()
237:         searchInput.typeText("func")
238:         
239:         // Wait for results
240:         sleep(3)
241:         
242:         // Find and tap a result cell
243:         let firstResult = app.cells.firstMatch
244:         let firstResultButton = app.buttons.matching(NSPredicate(format: "label CONTAINS '.swift' OR label CONTAINS '.ts'")).firstMatch
245:         let resultLink = app.links.firstMatch
246:         
247:         if firstResult.exists {
248:             firstResult.tap()
249:         } else if firstResultButton.exists {
250:             firstResultButton.tap()
251:         } else if resultLink.exists {
252:             resultLink.tap()
253:         } else {
254:             XCTSkip("No search results available to navigate")
255:             return
256:         }
257:         
258:         sleep(1)
259:         
260:         // Verify navigation occurred by checking for editor view or file content

---

[search]
No matches found for "lineNumbers"

---

[search]
No matches found for "gutter"

---

[search]
Found 4 matches:
VSCodeiPadOSUITests/SearchViewUITests.swift:95: let replaceChevron = app.buttons.element(matching: .any, identifier: "replaceToggle")
VSCodeiPadOSUITests/SearchViewUITests.swift:211: let resultCells = app.cells.matching(NSPredicate(format: "identifier CONTAINS 'result' OR label CONTAINS 'result'"))
VSCodeiPadOSUITests/SearchViewUITests.swift:262: let codeEditor = app.textViews.matching(NSPredicate(format: "identifier CONTAINS 'editor' OR label CONTAINS 'editor'"))
VSCodeiPadOSUITests/SearchViewUITests.swift:392: let clearSearchButton = app.buttons.matching(NSPredicate(format: "identifier CONTAINS 'clear'")).firstMatch

---

[search]
Found 2 matches:
VSCodeiPadOSUITests/SearchViewUITests.swift:7: var app: XCUIApplication!
VSCodeiPadOSUITests/SearchViewUITests.swift:11: app = XCUIApplication()


>>>TOOL read_file
{"path":"VSCodeiPadOSUITests/SearchViewUITests.swift","start_line":260,"end_line":460}
>>>END[read_file]
File: VSCodeiPadOSUITests/SearchViewUITests.swift (lines 260-460 of 424)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
260:         // Verify navigation occurred by checking for editor view or file content
261:         let editorView = app.scrollViews.matching(NSPredicate(format: "identifier CONTAINS 'editor' OR label CONTAINS 'editor'")).firstMatch
262:         let codeEditor = app.textViews.matching(NSPredicate(format: "identifier CONTAINS 'editor' OR label CONTAINS 'editor'")).firstMatch
263:         let fileTab = app.buttons.matching(NSPredicate(format: "identifier CONTAINS '.swift' OR identifier CONTAINS '.ts' OR identifier CONTAINS '.js'")).firstMatch
264:         
265:         let navigationSucceeded = editorView.exists || codeEditor.exists || fileTab.exists
266:         XCTAssertTrue(navigationSucceeded, "Tapping search result should navigate to editor/file view")
267:     }
268:     
269:     /// Test 8: Test search options affect results
270:     func testMatchCaseToggleAffectsSearch() throws {
271:         // Find match case toggle/button
272:         let matchCaseToggle = app.toggles["Match Case"]
273:         let matchCaseButton = app.buttons["Match Case"]
274:         let matchCase = matchCaseToggle.exists ? matchCaseToggle : matchCaseButton
275:         
276:         guard matchCase.waitForExistence(timeout: 2) else {
277:             XCTSkip("Match Case toggle not available")
278:             return
279:         }
280:         
281:         // Perform search with match case off
282:         let searchField = app.textFields["Search"]
283:         let searchTextField = app.searchFields["Search"]
284:         let searchInput = searchField.exists ? searchField : searchTextField
285:         
286:         guard searchInput.waitForExistence(timeout: 2) else {
287:             XCTSkip("Search field not available")
288:             return
289:         }
290:         
291:         searchInput.tap()
292:         searchInput.typeText("Func") // Mixed case
293:         sleep(2)
294:         
295:         // Toggle match case on
296:         matchCase.tap()
297:         sleep(2)
298:         
299:         // Check if results changed (hard to assert without specific known content)
300:         // Verify toggle state changed
301:         if matchCase is XCUIElement && matchCase.elementType == .toggle {
302:             XCTAssertTrue(matchCase.value as? String == "1" || matchCase.value as? Bool == true, "Match case should be enabled")
303:         } else {
304:             // For buttons, we can check if it's selected
305:             XCTAssertTrue(matchCase.isSelected || matchCase.isHittable, "Match case button should be activated")
306:         }
307:     }
308:     
309:     /// Test 9: Test clear search field
310:     func testClearSearchField() throws {
311:         let searchField = app.textFields["Search"]
312:         let searchTextField = app.searchFields["Search"]
313:         let searchInput = searchField.exists ? searchField : searchTextField
314:         
315:         guard searchInput.waitForExistence(timeout: 2) else {
316:             XCTSkip("Search field not available")
317:             return
318:         }
319:         
320:         searchInput.tap()
321:         searchInput.typeText("test query")
322:         
323:         // Look for clear button
324:         let clearButton = app.buttons["Clear text"]
325:         let clearSearchButton = app.buttons.matching(NSPredicate(format: "identifier CONTAINS 'clear'")).firstMatch
326:         
327:         if clearButton.exists {
328:             clearButton.tap()
329:         } else if clearSearchButton.exists {
330:             clearSearchButton.tap()
331:         } else {
332:             // Manually clear by selecting all and deleting
333:             searchInput.doubleTap()
334:             app.menuItems["Select All"].tap()
335:             searchInput.typeText("\u{8}") // Backspace
336:         }
337:         
338:         // Verify field is empty
339:         let searchValue = searchInput.value as? String ?? ""
340:         XCTAssertTrue(searchValue.isEmpty || searchValue == "Search", "Search field should be cleared")
341:     }
342:     
343:     /// Test 10: Test replace functionality
344:     func testReplaceFunctionality() throws {
345:         // Ensure replace section is visible
346:         let replaceField = app.textFields["Replace"]
347:         if !replaceField.exists {
348:             let replaceToggle = app.buttons["Replace"]
349:             if replaceToggle.exists {
350:                 replaceToggle.tap()
351:                 sleep(1)
352:             }
353:         }
354:         
355:         // Find search and replace fields
356:         let searchField = app.textFields["Search"]
357:         let replaceFieldFinal = app.textFields["Replace"]
358:         
359:         guard searchField.waitForExistence(timeout: 2) && replaceFieldFinal.waitForExistence(timeout: 2) else {
360:             XCTSkip("Search or replace fields not available")
361:             return
362:         }
363:         
364:         // Enter search and replace text
365:         searchField.tap()
366:         searchField.typeText("oldText")
367:         
368:         replaceFieldFinal.tap()
369:         replaceFieldFinal.typeText("newText")
370:         
371:         // Look for replace all button or replace button
372:         let replaceAllButton = app.buttons["Replace All"]
373:         let replaceButton = app.buttons["Replace"]
374:         
375:         // Verify replace buttons exist
376:         XCTAssertTrue(replaceAllButton.exists || replaceButton.exists, "Replace buttons should be available when replace text is entered")
377:     }
378:     
379:     /// Test 11: Test search history or recent searches
380:     func testSearchHistoryAvailable() throws {
381:         let searchField = app.textFields["Search"]
382:         guard searchField.waitForExistence(timeout: 2) else {
383:             XCTSkip("Search field not available")
384:             return
385:         }
386:         
387:         // Tap search field to show history dropdown if available
388:         searchField.tap()
389:         
390:         // Look for recent searches list or dropdown
391:         let historyList = app.tables.matching(NSPredicate(format: "identifier CONTAINS 'history' OR label CONTAINS 'recent'")).firstMatch
392:         let historyItems = app.cells.matching(NSPredicate(format: "identifier CONTAINS 'history'")).count
393:         
394:         // History may not be present if no searches performed, so this is optional
395:         XCTAssertTrue(true, "Search history test completed (history may be empty)")
396:     }
397: }
398: 
399: // Extensions or additional helper methods can be added here

---

## ðŸ”§ TOOL RESULTS

[read_file]
File: VSCodeiPadOSUITests/SearchViewUITests.swift (lines 261-424 of 424)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
261:         let editorView = app.textViews["Editor"]
262:         let codeEditor = app.textViews.matching(NSPredicate(format: "identifier CONTAINS 'editor' OR label CONTAINS 'editor'"))
263:         let fileContent = app.staticTexts.matching(NSPredicate(format: "label CONTAINS 'func'"))
264:         
265:         let navigated = editorView.exists || 
266:                        codeEditor.count > 0 ||
267:                        fileContent.count > 0
268:         
269:         XCTAssertTrue(navigated, "Tapping a search result should navigate to the file location")
270:     }
271:     
272:     /// Test 8: Test history dropdown appears when focusing search
273:     func testHistoryDropdown() throws {
274:         // First perform a search to create history
275:         let searchField = app.textFields["Search"]
276:         let searchTextField = app.searchFields["Search"]
277:         let searchInput = searchField.exists ? searchField : searchTextField
278:         
279:         guard searchInput.waitForExistence(timeout: 2) else {
280:             XCTSkip("Search field not available")
281:             return
282:         }
283:         
284:         // Create some search history
285:         searchInput.tap()
286:         searchInput.typeText("test query")
287:         sleep(2)
288:         
289:         // Clear the field
290:         let clearButton = app.buttons["Clear"]
291:         let clearTextButton = app.buttons.matching(NSPredicate(format: "label CONTAINS 'Clear' OR accessibilityLabel CONTAINS 'Clear'")).firstMatch
292:         
293:         if clearButton.exists {
294:             clearButton.tap()
295:         } else if clearTextButton.exists {
296:             clearTextButton.tap()
297:         } else {
298:             // Select all and delete
299:             searchInput.doubleTap()
300:             searchInput.typeText(XCUIKeyboardKey.delete.rawValue)
301:         }
302:         
303:         sleep(1)
304:         
305:         // Focus search field again to trigger history dropdown
306:         searchInput.tap()
307:         sleep(1)
308:         
309:         // Check for history dropdown
310:         let historyList = app.collectionViews["Search History"]
311:         let historyTable = app.tables["Search History"]
312:         let historyCell = app.cells.matching(NSPredicate(format: "label CONTAINS 'test query'"))
313:         let recentSearches = app.staticTexts["Recent Searches"]
314:         let historySection = app.otherElements["History"]
315:         
316:         let historyVisible = historyList.exists || 
317:                             historyTable.exists || 
318:                             historyCell.count > 0 ||
319:                             recentSearches.exists ||
320:                             historySection.exists
321:         
322:         // History may not always appear depending on implementation
323:         // So we just verify the field is focusable
324:         XCTAssertTrue(searchInput.isFocused || searchInput.hasKeyboardFocus || historyVisible, 
325:                     "Search field should be focusable and may show history dropdown")
326:     }
327:     
328:     /// Test 9: Verify replace button is present and clickable
329:     func testReplaceButton() throws {
330:         // First expand replace section if needed
331:         let replaceToggle = app.buttons["Replace"]
332:         if replaceToggle.exists {
333:             replaceToggle.tap()
334:             sleep(1)
335:         }
336:         
337:         // Find replace button
338:         let replaceButton = app.buttons["Replace"]
339:         let replaceAllButton = app.buttons["Replace All"]
340:         let replaceNextButton = app.buttons["Replace Next"]
341:         let replaceActionButton = app.buttons.matching(NSPredicate(format: "label CONTAINS 'Replace' AND label != 'Replace'")).firstMatch
342:         
343:         // Replace button might have different labels
344:         let replaceExists = replaceButton.waitForExistence(timeout: 2) ||
345:                          replaceAllButton.exists ||
346:                          replaceNextButton.exists ||
347:                          replaceActionButton.exists
348:         
349:         XCTAssertTrue(replaceExists, "Replace button should be present")
350:         
351:         // Enter some text in replace field first
352:         let replaceField = app.textFields["Replace"]
353:         if replaceField.exists {
354:             replaceField.tap()
355:             replaceField.typeText("replacement")
356:             
357:             // Try to tap replace button
358:             if replaceButton.exists && replaceButton.isEnabled {
359:                 replaceButton.tap()
360:                 XCTAssertTrue(true, "Replace button should be clickable")
361:             } else if replaceAllButton.exists && replaceAllButton.isEnabled {
362:                 // Don't actually replace all in tests
363:                 XCTAssertTrue(replaceAllButton.isEnabled, "Replace All button should be clickable")
364:             }
365:         }
366:     }
367:     
368:     /// Test 10: Verify clear button resets search
369:     func testClearSearch() throws {
370:         // Find search field and enter text
371:         let searchField = app.textFields["Search"]
372:         let searchTextField = app.searchFields["Search"]
373:         let searchInput = searchField.exists ? searchField : searchTextField
374:         
375:         guard searchInput.waitForExistence(timeout: 2) else {
376:             XCTSkip("Search field not available")
377:             return
378:         }
379:         
380:         // Type search text
381:         searchInput.tap()
382:         searchInput.typeText("clear test")
383:         sleep(1)
384:         
385:         // Verify text was entered
386:         let hasText = searchInput.value != nil && (searchInput.value as? String) != ""
387:         XCTAssertTrue(hasText || true, "Search field should have text entered")
388:         
389:         // Find and tap clear button
390:         let clearButton = app.buttons["Clear"]
391:         let clearTextButton = app.buttons.matching(NSPredicate(format: "label CONTAINS 'Clear' OR accessibilityLabel CONTAINS 'Clear'")).firstMatch
392:         let clearSearchButton = app.buttons.matching(NSPredicate(format: "identifier CONTAINS 'clear'")).firstMatch
393:         
394:         let clearExists = clearButton.exists || clearTextButton.exists || clearSearchButton.exists
395:         
396:         if clearExists {
397:             if clearButton.exists {
398:                 clearButton.tap()
399:             } else if clearTextButton.exists {
400:                 clearTextButton.tap()
401:             } else if clearSearchButton.exists {
402:                 clearSearchButton.tap()
403:             }
404:             
405:             sleep(1)
406:             
407:             // Verify search was cleared
408:             let searchCleared = (searchInput.value as? String)?.isEmpty ?? true
409:             XCTAssertTrue(searchCleared || searchInput.value as? String == "Search", 
410:                          "Clear button should reset search text")
411:         } else {
412:             // Try clearing with keyboard shortcut or selection + delete
413:             searchInput.doubleTap()
414:             searchInput.typeText(XCUIKeyboardKey.delete.rawValue)
415:             
416:             sleep(1)
417:             
418:             // Verify text was cleared
419:             let finalValue = searchInput.value as? String ?? ""
420:             XCTAssertTrue(finalValue.isEmpty || finalValue == "Search", 
421:                          "Search field should be cleared")
422:         }
423:     }
424: }


>>>TOOL read_file
{"path":"VSCodeiPadOSUITests/SearchViewUITests.swift","start_line":1,"end_line":460}
>>>END


---

## ðŸ”§ TOOL RESULTS

[read_file]
File: VSCodeiPadOSUITests/SearchViewUITests.swift (lines 2-424 of 424)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
2: 
3: /// UI Tests for SearchView
4: /// Tests search functionality, toggles, replace options, and result navigation
5: final class SearchViewUITests: XCTestCase {
6:     
7:     var app: XCUIApplication!
8:     
9:     override func setUpWithError() throws {
10:         continueAfterFailure = false
11:         app = XCUIApplication()
12:         app.launch()
13:         
14:         // Navigate to search view - assuming it's accessible from main UI
15:         // This may need adjustment based on actual app navigation structure
16:         openSearchView()
17:     }
18:     
19:     override func tearDownWithError() throws {
20:         app = nil
21:     }
22:     
23:     // MARK: - Helper Methods
24:     
25:     /// Opens the search view from the main app interface
26:     private func openSearchView() {
27:         // Try to find and tap search button/shortcut
28:         // Common ways to access search: toolbar button, keyboard shortcut, or menu item
29:         let searchButton = app.buttons["Search"]
30:         let findButton = app.buttons["Find"]
31:         let searchToolbarButton = app.toolbars.buttons["Search"]
32:         
33:         if searchButton.exists {
34:             searchButton.tap()
35:         } else if findButton.exists {
36:             findButton.tap()
37:         } else if searchToolbarButton.exists {
38:             searchToolbarButton.tap()
39:         } else {
40:             // Try using keyboard shortcut Cmd+Shift+F for global search
41:             // or Cmd+F for find
42:             XCUIDevice.shared.press(.home)
43:         }
44:     }
45:     
46:     // MARK: - Test Cases
47:     
48:     /// Test 1: Verify search text field is present
49:     func testSearchFieldExists() throws {
50:         // Search field should be present in the search view
51:         let searchField = app.textFields["Search"]
52:         let searchTextField = app.searchFields["Search"]
53:         let findTextField = app.textFields["Find"]
54:         
55:         // At least one search input field should exist
56:         let searchFieldExists = searchField.waitForExistence(timeout: 2) ||
57:                               searchTextField.waitForExistence(timeout: 2) ||
58:                               findTextField.waitForExistence(timeout: 2)
59:         
60:         XCTAssertTrue(searchFieldExists, "Search text field should be present in the search view")
61:     }
62:     
63:     /// Test 2: Verify matchCase, matchWholeWord, useRegex toggles exist
64:     func testToggleButtonsExist() throws {
65:         // Check for match case toggle/button
66:         let matchCaseToggle = app.toggles["Match Case"]
67:         let matchCaseButton = app.buttons["Match Case"]
68:         let matchCaseExists = matchCaseToggle.waitForExistence(timeout: 2) ||
69:                              matchCaseButton.waitForExistence(timeout: 2)
70:         
71:         // Check for match whole word toggle/button
72:         let matchWholeWordToggle = app.toggles["Match Whole Word"]
73:         let matchWholeWordButton = app.buttons["Match Whole Word"]
74:         let matchWholeWordExists = matchWholeWordToggle.waitForExistence(timeout: 2) ||
75:                                   matchWholeWordButton.waitForExistence(timeout: 2)
76:         
77:         // Check for use regex toggle/button
78:         let useRegexToggle = app.toggles["Use Regular Expressions"]
79:         let useRegexButton = app.buttons["Use Regular Expressions"]
80:         let regexButton = app.buttons["Regex"]
81:         let useRegexExists = useRegexToggle.waitForExistence(timeout: 2) ||
82:                            useRegexButton.waitForExistence(timeout: 2) ||
83:                            regexButton.waitForExistence(timeout: 2)
84:         
85:         XCTAssertTrue(matchCaseExists, "Match Case toggle should be present")
86:         XCTAssertTrue(matchWholeWordExists, "Match Whole Word toggle should be present")
87:         XCTAssertTrue(useRegexExists, "Use Regular Expressions toggle should be present")
88:     }
89:     
90:     /// Test 3: Test expand/collapse replace section
91:     func testReplaceSectionToggle() throws {
92:         // Find the replace section toggle/disclosure button
93:         let replaceToggle = app.buttons["Replace"]
94:         let replaceDisclosure = app.disclosureTriangles["Replace"]
95:         let replaceChevron = app.buttons.element(matching: .any, identifier: "replaceToggle")
96:         
97:         // First check if replace section exists
98:         let replaceField = app.textFields["Replace"]
99:         let replaceTextField = app.textViews["Replace"]
100:         
101:         // If replace field is not visible, try to toggle it
102:         if !replaceField.exists && !replaceTextField.exists {
103:             if replaceToggle.exists {
104:                 replaceToggle.tap()
105:             } else if replaceDisclosure.exists {
106:                 replaceDisclosure.tap()
107:             }
108:             
109:             // Wait for animation
110:             sleep(1)
111:         }
112:         
113:         // Verify replace field is now visible
114:         let replaceFieldVisible = app.textFields["Replace"].waitForExistence(timeout: 2) ||
115:                                  app.textViews["Replace"].waitForExistence(timeout: 2)
116:         
117:         XCTAssertTrue(replaceFieldVisible, "Replace section should be expandable and show replace field")
118:     }
119:     
120:     /// Test 4: Test expand/collapse include/exclude patterns section
121:     func testIncludeExcludeSectionToggle() throws {
122:         // Find the patterns section toggle
123:         let patternsToggle = app.buttons["Files to Include/Exclude"]
124:         let includeExcludeToggle = app.buttons["Include/Exclude"]
125:         let filePatternsToggle = app.buttons["File Patterns"]
126:         
127:         // Try to find and toggle the patterns section
128:         let patternsToggleExists = patternsToggle.exists || 
129:                                   includeExcludeToggle.exists || 
130:                                   filePatternsToggle.exists
131:         
132:         if patternsToggleExists {
133:             if patternsToggle.exists {
134:                 patternsToggle.tap()
135:             } else if includeExcludeToggle.exists {
136:                 includeExcludeToggle.tap()
137:             } else if filePatternsToggle.exists {
138:                 filePatternsToggle.tap()
139:             }
140:             
141:             // Wait for animation
142:             sleep(1)
143:         }
144:         
145:         // Verify include/exclude fields are visible
146:         let includeField = app.textFields["files to include"]
147:         let excludeField = app.textFields["files to exclude"]
148:         let includePattern = app.textFields["Include patterns"]
149:         let excludePattern = app.textFields["Exclude patterns"]
150:         
151:         let patternsVisible = includeField.waitForExistence(timeout: 2) ||
152:                              excludeField.waitForExistence(timeout: 2) ||
153:                              includePattern.waitForExistence(timeout: 2) ||
154:                              excludePattern.waitForExistence(timeout: 2)
155:         
156:         XCTAssertTrue(patternsVisible, "Include/Exclude patterns section should be expandable")
157:     }
158:     
159:     /// Test 5: Type text and verify search triggers
160:     func testSearchExecutes() throws {
161:         // Find and interact with search field
162:         let searchField = app.textFields["Search"]
163:         let searchTextField = app.searchFields["Search"]
164:         
165:         let searchInput = searchField.exists ? searchField : searchTextField
166:         
167:         XCTAssertTrue(searchInput.waitForExistence(timeout: 2), "Search field should exist")
168:         
169:         // Tap and type search query
170:         searchInput.tap()
171:         searchInput.typeText("func")
172:         
173:         // Wait for search to execute (debounce/animation)
174:         sleep(2)
175:         
176:         // Verify search was triggered by checking for results or loading indicator
177:         let resultsList = app.collectionViews["Search Results"]
178:         let resultsTable = app.tables["Search Results"]
179:         let loadingIndicator = app.activityIndicators["In progress"]
180:         let resultCount = app.staticTexts.matching(NSPredicate(format: "label CONTAINS 'result'"))
181:         
182:         let searchTriggered = resultsList.exists || 
183:                              resultsTable.exists || 
184:                              loadingIndicator.exists || 
185:                              resultCount.count > 0
186:         
187:         XCTAssertTrue(searchTriggered, "Search should execute after typing text")
188:     }
189:     
190:     /// Test 6: Verify results appear after search
191:     func testResultsDisplay() throws {
192:         // First perform a search
193:         let searchField = app.textFields["Search"]
194:         let searchTextField = app.searchFields["Search"]
195:         let searchInput = searchField.exists ? searchField : searchTextField
196:         
197:         guard searchInput.waitForExistence(timeout: 2) else {
198:             XCTSkip("Search field not available")
199:             return
200:         }
201:         
202:         searchInput.tap()
203:         searchInput.typeText("import")
204:         
205:         // Wait for search results
206:         sleep(3)
207:         
208:         // Check for results in various formats
209:         let resultsList = app.collectionViews["Search Results"]
210:         let resultsTable = app.tables["Search Results"]
211:         let resultCells = app.cells.matching(NSPredicate(format: "identifier CONTAINS 'result' OR label CONTAINS 'result'"))
212:         let fileResults = app.staticTexts.matching(NSPredicate(format: "label CONTAINS '.swift' OR label CONTAINS '.ts' OR label CONTAINS '.js'"))
213:         let matchResults = app.staticTexts.matching(NSPredicate(format: "label CONTAINS 'import'"))
214:         
215:         let resultsVisible = resultsList.exists || 
216:                             resultsTable.exists || 
217:                             resultCells.count > 0 ||
218:                             fileResults.count > 0 ||
219:                             matchResults.count > 0
220:         
221:         XCTAssertTrue(resultsVisible, "Search results should be displayed after search execution")
222:     }
223:     
224:     /// Test 7: Test tapping result navigates to file location
225:     func testNavigateToResult() throws {
226:         // First perform a search to get results
227:         let searchField = app.textFields["Search"]
228:         let searchTextField = app.searchFields["Search"]
229:         let searchInput = searchField.exists ? searchField : searchTextField
230:         
231:         guard searchInput.waitForExistence(timeout: 2) else {
232:             XCTSkip("Search field not available")
233:             return
234:         }
235:         
236:         searchInput.tap()
237:         searchInput.typeText("func")
238:         
239:         // Wait for results
240:         sleep(3)
241:         
242:         // Find and tap a result cell
243:         let firstResult = app.cells.firstMatch
244:         let firstResultButton = app.buttons.matching(NSPredicate(format: "label CONTAINS '.swift' OR label CONTAINS '.ts'")).firstMatch
245:         let resultLink = app.links.firstMatch
246:         
247:         if firstResult.exists {
248:             firstResult.tap()
249:         } else if firstResultButton.exists {
250:             firstResultButton.tap()
251:         } else if resultLink.exists {
252:             resultLink.tap()
253:         } else {
254:             XCTSkip("No search results available to navigate")
255:             return
256:         }
257:         
258:         sleep(1)
259:         
260:         // Verify navigation occurred by checking for editor view or file content
261:         let editorView = app.textViews["Editor"]
262:         let codeEditor = app.textViews.matching(NSPredicate(format: "identifier CONTAINS 'editor' OR label CONTAINS 'editor'"))
263:         let fileContent = app.staticTexts.matching(NSPredicate(format: "label CONTAINS 'func'"))
264:         
265:         let navigated = editorView.exists || 
266:                        codeEditor.count > 0 ||
267:                        fileContent.count > 0
268:         
269:         XCTAssertTrue(navigated, "Tapping a search result should navigate to the file location")
270:     }
271:     
272:     /// Test 8: Test history dropdown appears when focusing search
273:     func testHistoryDropdown() throws {
274:         // First perform a search to create history
275:         let searchField = app.textFields["Search"]
276:         let searchTextField = app.searchFields["Search"]
277:         let searchInput = searchField.exists ? searchField : searchTextField
278:         
279:         guard searchInput.waitForExistence(timeout: 2) else {
280:             XCTSkip("Search field not available")
281:             return
282:         }
283:         
284:         // Create some search history
285:         searchInput.tap()
286:         searchInput.typeText("test query")
287:         sleep(2)
288:         
289:         // Clear the field
290:         let clearButton = app.buttons["Clear"]
291:         let clearTextButton = app.buttons.matching(NSPredicate(format: "label CONTAINS 'Clear' OR accessibilityLabel CONTAINS 'Clear'")).firstMatch
292:         
293:         if clearButton.exists {
294:             clearButton.tap()
295:         } else if clearTextButton.exists {
296:             clearTextButton.tap()
297:         } else {
298:             // Select all and delete
299:             searchInput.doubleTap()
300:             searchInput.typeText(XCUIKeyboardKey.delete.rawValue)
301:         }
302:         
303:         sleep(1)
304:         
305:         // Focus search field again to trigger history dropdown
306:         searchInput.tap()
307:         sleep(1)
308:         
309:         // Check for history dropdown
310:         let historyList = app.collectionViews["Search History"]
311:         let historyTable = app.tables["Search History"]
312:         let historyCell = app.cells.matching(NSPredicate(format: "label CONTAINS 'test query'"))
313:         let recentSearches = app.staticTexts["Recent Searches"]
314:         let historySection = app.otherElements["History"]
315:         
316:         let historyVisible = historyList.exists || 
317:                             historyTable.exists || 
318:                             historyCell.count > 0 ||
319:                             recentSearches.exists ||
320:                             historySection.exists
321:         
322:         // History may not always appear depending on implementation
323:         // So we just verify the field is focusable
324:         XCTAssertTrue(searchInput.isFocused || searchInput.hasKeyboardFocus || historyVisible, 
325:                     "Search field should be focusable and may show history dropdown")
326:     }
327:     
328:     /// Test 9: Verify replace button is present and clickable
329:     func testReplaceButton() throws {
330:         // First expand replace section if needed
331:         let replaceToggle = app.buttons["Replace"]
332:         if replaceToggle.exists {
333:             replaceToggle.tap()
334:             sleep(1)
335:         }
336:         
337:         // Find replace button
338:         let replaceButton = app.buttons["Replace"]
339:         let replaceAllButton = app.buttons["Replace All"]
340:         let replaceNextButton = app.buttons["Replace Next"]
341:         let replaceActionButton = app.buttons.matching(NSPredicate(format: "label CONTAINS 'Replace' AND label != 'Replace'")).firstMatch
342:         
343:         // Replace button might have different labels
344:         let replaceExists = replaceButton.waitForExistence(timeout: 2) ||
345:                          replaceAllButton.exists ||
346:                          replaceNextButton.exists ||
347:                          replaceActionButton.exists
348:         
349:         XCTAssertTrue(replaceExists, "Replace button should be present")
350:         
351:         // Enter some text in replace field first
352:         let replaceField = app.textFields["Replace"]
353:         if replaceField.exists {
354:             replaceField.tap()
355:             replaceField.typeText("replacement")
356:             
357:             // Try to tap replace button
358:             if replaceButton.exists && replaceButton.isEnabled {
359:                 replaceButton.tap()
360:                 XCTAssertTrue(true, "Replace button should be clickable")
361:             } else if replaceAllButton.exists && replaceAllButton.isEnabled {
362:                 // Don't actually replace all in tests
363:                 XCTAssertTrue(replaceAllButton.isEnabled, "Replace All button should be clickable")
364:             }
365:         }
366:     }
367:     
368:     /// Test 10: Verify clear button resets search
369:     func testClearSearch() throws {
370:         // Find search field and enter text
371:         let searchField = app.textFields["Search"]
372:         let searchTextField = app.searchFields["Search"]
373:         let searchInput = searchField.exists ? searchField : searchTextField
374:         
375:         guard searchInput.waitForExistence(timeout: 2) else {
376:             XCTSkip("Search field not available")
377:             return
378:         }
379:         
380:         // Type search text
381:         searchInput.tap()
382:         searchInput.typeText("clear test")
383:         sleep(1)
384:         
385:         // Verify text was entered
386:         let hasText = searchInput.value != nil && (searchInput.value as? String) != ""
387:         XCTAssertTrue(hasText || true, "Search field should have text entered")
388:         
389:         // Find and tap clear button
390:         let clearButton = app.buttons["Clear"]
391:         let clearTextButton = app.buttons.matching(NSPredicate(format: "label CONTAINS 'Clear' OR accessibilityLabel CONTAINS 'Clear'")).firstMatch
392:         let clearSearchButton = app.buttons.matching(NSPredicate(format: "identifier CONTAINS 'clear'")).firstMatch
393:         
394:         let clearExists = clearButton.exists || clearTextButton.exists || clearSearchButton.exists
395:         
396:         if clearExists {
397:             if clearButton.exists {
398:                 clearButton.tap()
399:             } else if clearTextButton.exists {
400:                 clearTextButton.tap()
401:             } else if clearSearchButton.exists {
402:                 clearSearchButton.tap()
403:             }
404:             
405:             sleep(1)
406:             
407:             // Verify search was cleared
408:             let searchCleared = (searchInput.value as? String)?.isEmpty ?? true
409:             XCTAssertTrue(searchCleared || searchInput.value as? String == "Search", 
410:                          "Clear button should reset search text")
411:         } else {
412:             // Try clearing with keyboard shortcut or selection + delete
413:             searchInput.doubleTap()
414:             searchInput.typeText(XCUIKeyboardKey.delete.rawValue)
415:             
416:             sleep(1)
417:             
418:             // Verify text was cleared
419:             let finalValue = searchInput.value as? String ?? ""
420:             XCTAssertTrue(finalValue.isEmpty || finalValue == "Search", 
421:                          "Search field should be cleared")
422:         }
423:     }
424: }


>>>TOOL search
{"query":"accessibilityIdentifier", "glob":"**/*.swift"}
>>>END

---

## ðŸ”§ TOOL RESULTS

[search]
No matches found for "accessibilityIdentifier"


>>>TOOL search
{"query":"gutter", "glob":"**/*"}
>>>END

>>>TOOL search
{"query":"lineNumber", "glob":"**/*"}
>>>END

>>>TOOL search
{"query":"line number", "glob":"**/*"}
>>>END

---

## ðŸ”§ TOOL RESULTS

[search]
Found 2 matches:
MASTER_AGENT_PLAN.md:166: | git-13 | Git gutter integration | Views/Editor/GitGutterView.swift |
MASTER_AGENT_PLAN.md:179: | fold-5 | Fold gutter UI | Views/Editor/FoldingGutterView.swift (NEW) |

---

[search]
Found 30 matches:
.patch-backups/VSCodeiPadOS_VSCodeiPadOS_Views_Panels_SearchView.swift.2026-02-09T17-21-21-128Z.bak:16: let lineNumber: Int
.patch-backups/VSCodeiPadOS_VSCodeiPadOS_Views_Panels_SearchView.swift.2026-02-09T17-21-21-128Z.bak:284: onResultSelected?(fileResult.path, match.lineNumber)
.patch-backups/VSCodeiPadOS_VSCodeiPadOS_Views_Panels_SearchView.swift.2026-02-09T17-21-21-128Z.bak:813: lineNumber: match.location.line,
.patch-backups/VSCodeiPadOS_VSCodeiPadOS_Views_Panels_SearchView.swift.2026-02-09T17-21-21-128Z.bak:935: onMatchSelected?(fileResult.path, match.lineNumber)
.patch-backups/VSCodeiPadOS_VSCodeiPadOS_Views_Panels_SearchView.swift.2026-02-09T17-21-21-128Z.bak:960: Text("\(match.lineNumber)")
.patch-backups/VSCodeiPadOS_VSCodeiPadOS_Views_Panels_SearchView.swift.2026-02-09T17-21-21-128Z.bak:988: .accessibilityLabel("Line \(match.lineNumber): \(match.text)")
.patch-backups/VSCodeiPadOS_VSCodeiPadOS_Views_Panels_SearchView.swift.2026-02-09T17-21-21-128Z.bak:1176: Text("\(preview.lineNumber)")
.patch-backups/VSCodeiPadOS_VSCodeiPadOS_Views_Panels_SearchView.swift.2026-02-09T17-21-21-128Z.bak:1187: Text("\(preview.lineNumber)")
.patch-backups/VSCodeiPadOS_VSCodeiPadOS_Views_Editor_SyntaxHighlightingTextView.swift.2026-02-09T11-02-26-399Z.bak:193: let lineNumber = lines.count
.patch-backups/VSCodeiPadOS_VSCodeiPadOS_Views_Editor_SyntaxHighlightingTextView.swift.2026-02-09T11-02-26-399Z.bak:197: self.parent.currentLineNumber = lineNumber
.patch-backups/VSCodeiPadOS_VSCodeiPadOS_Views_Panels_SearchView.swift.2026-02-09T17-17-42-919Z.bak:7: let lineNumber: Int
.patch-backups/VSCodeiPadOS_VSCodeiPadOS_Views_Panels_SearchView.swift.2026-02-09T17-17-42-919Z.bak:99: SearchResultLine(lineNumber: 10, text: "struct ContentView: View {", matches: []),
.patch-backups/VSCodeiPadOS_VSCodeiPadOS_Views_Panels_SearchView.swift.2026-02-09T17-17-42-919Z.bak:100: SearchResultLine(lineNumber: 24, text: "    var body: some View {", matches: [])
.patch-backups/VSCodeiPadOS_VSCodeiPadOS_Views_Panels_SearchView.swift.2026-02-09T17-17-42-919Z.bak:103: SearchResultLine(lineNumber: 5, text: "struct SidebarView: View {", matches: [])
.patch-backups/VSCodeiPadOS_VSCodeiPadOS_Views_Panels_SearchView.swift.2026-02-09T17-17-42-919Z.bak:106: SearchResultLine(lineNumber: 1, text: "# Project Documentation", matches: []),
.patch-backups/VSCodeiPadOS_VSCodeiPadOS_Views_Panels_SearchView.swift.2026-02-09T17-17-42-919Z.bak:107: SearchResultLine(lineNumber: 5, text: "## Getting Started", matches: []),
.patch-backups/VSCodeiPadOS_VSCodeiPadOS_Views_Panels_SearchView.swift.2026-02-09T17-17-42-919Z.bak:108: SearchResultLine(lineNumber: 10, text: "### Installation", matches: [])
.patch-backups/VSCodeiPadOS_VSCodeiPadOS_Views_Panels_SearchView.swift.2026-02-09T17-17-42-919Z.bak:111: SearchResultLine(lineNumber: 3, text: "\"name\": \"MyApp\",", matches: [])
.patch-backups/VSCodeiPadOS_VSCodeiPadOS_Views_Panels_SearchView.swift.2026-02-09T17-17-42-919Z.bak:114: SearchResultLine(lineNumber: 15, text: "func helper() -> String {", matches: []),
.patch-backups/VSCodeiPadOS_VSCodeiPadOS_Views_Panels_SearchView.swift.2026-02-09T17-17-42-919Z.bak:115: SearchResultLine(lineNumber: 16, text: "    return \"helper\"", matches: []),
.patch-backups/VSCodeiPadOS_VSCodeiPadOS_Views_Panels_SearchView.swift.2026-02-09T17-17-42-919Z.bak:116: SearchResultLine(lineNumber: 17, text: "}", matches: []),
.patch-backups/VSCodeiPadOS_VSCodeiPadOS_Views_Panels_SearchView.swift.2026-02-09T17-17-42-919Z.bak:117: SearchResultLine(lineNumber: 20, text: "func another() -> Int {", matches: [])
.patch-backups/VSCodeiPadOS_VSCodeiPadOS_Views_Panels_SearchView.swift.2026-02-09T17-17-42-919Z.bak:462: Text("\(match.lineNumber)")
.patch-backups/VSCodeiPadOS_VSCodeiPadOS_Views_Panels_SearchView.swift.2026-02-09T17-17-42-919Z.bak:477: onMatchSelected?(fileResult.path, match.lineNumber)
.patch-backups/VSCodeiPadOS_VSCodeiPadOS_Views_Panels_SettingsView.swift.2026-02-09T11-39-02-237Z.bak:87: @AppStorage("lineNumbersStyle") private var lineNumbersStyle: String = "on"
.patch-backups/VSCodeiPadOS_VSCodeiPadOS_Views_Panels_SettingsView.swift.2026-02-09T11-39-02-237Z.bak:129: Picker("Line Numbers", selection: $lineNumbersStyle) {
.patch-backups/VSCodeiPadOS_VSCodeiPadOS_Views_Panels_SettingsView.swift.2026-02-09T11-39-02-237Z.bak:136: .onChange(of: lineNumbersStyle) { newValue in
.patch-backups/VSCodeiPadOS_VSCodeiPadOS_Views_Panels_SettingsView.swift.2026-02-09T11-39-02-237Z.bak:349: .foregroundColor(theme.lineNumber)
.patch-backups/VSCodeiPadOS_VSCodeiPadOS_Views_Panels_SettingsView.swift.2026-02-09T11-39-02-237Z.bak:362: .foregroundColor(theme.lineNumber)
.patch-backups/VSCodeiPadOS_VSCodeiPadOS_Views_Panels_SettingsView.swift.2026-02-09T11-39-02-237Z.bak:369: .foregroundColor(theme.lineNumberActive)

---

[search]
Found 2 matches:
.garbage/vscodeipados-cleanup/CmdNFeatureTest.swift:25: - Editor view with line numbers
.garbage/vscodeipados-cleanup/IMPLEMENTATION_SUMMARY.md:92: - `CodeEditorView`: Text editor with line numbers


>>>TOOL search
{"query":"Line Numbers", "glob":"VSCodeiPadOS/**/*.swift"}
>>>END

>>>TOOL search
{"query":"lineNumbersStyle", "glob":"VSCodeiPadOS/**/*.swift"}
>>>END

>>>TOOL search
{"query":"LineNumber", "glob":"VSCodeiPadOS/**/*.swift"}
>>>END

>>>TOOL search
{"query":"gutter", "glob":"VSCodeiPadOS/**/*.swift"}
>>>END

>>>TOOL search
{"query":"accessibility", "glob":"VSCodeiPadOS/**/*.swift"}
>>>END

---

## ðŸ”§ TOOL RESULTS

[search]
Found 2 matches:
VSCodeiPadOS/VSCodeiPadOS/ContentView.swift:527: // MARK: - Line Numbers with Folding
VSCodeiPadOS/VSCodeiPadOS/Views/DiffComponents.swift:63: // Line Numbers

---

[search]
Found 11 matches:
VSCodeiPadOS/VSCodeiPadOS/ContentView.swift:360: @AppStorage("lineNumbersStyle") private var lineNumbersStyle: String = "on"
VSCodeiPadOS/VSCodeiPadOS/ContentView.swift:390: if lineNumbersStyle != "off" {
VSCodeiPadOS/VSCodeiPadOS/ContentView.swift:480: .padding(.leading, lineNumbersStyle != "off" ? 60 : 0)
VSCodeiPadOS/VSCodeiPadOS/ContentView.swift:540: @AppStorage("lineNumbersStyle") private var lineNumbersStyle: String = "on"
VSCodeiPadOS/VSCodeiPadOS/ContentView.swift:594: switch lineNumbersStyle {
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SplitEditorView.swift:499: @AppStorage("lineNumbersStyle") private var lineNumbersStyle: String = "on"
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SplitEditorView.swift:510: if lineNumbersStyle != "off" {
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SplitEditorView.swift:654: switch lineNumbersStyle {
VSCodeiPadOS/VSCodeiPadOS/Views/Panels/SettingsView.swift:87: @AppStorage("lineNumbersStyle") private var lineNumbersStyle: String = "on"
VSCodeiPadOS/VSCodeiPadOS/Views/Panels/SettingsView.swift:129: Picker("Line Numbers", selection: $lineNumbersStyle) {
VSCodeiPadOS/VSCodeiPadOS/Views/Panels/SettingsView.swift:136: .onChange(of: lineNumbersStyle) { newValue in

---

[search]
Found 30 matches:
VSCodeiPadOS/VSCodeiPadOS/ContentView.swift:365: @State private var currentLineNumber: Int = 1
VSCodeiPadOS/VSCodeiPadOS/ContentView.swift:391: LineNumbersWithFolding(
VSCodeiPadOS/VSCodeiPadOS/ContentView.swift:394: currentLine: currentLineNumber,
VSCodeiPadOS/VSCodeiPadOS/ContentView.swift:417: currentLineNumber: $currentLineNumber,
VSCodeiPadOS/VSCodeiPadOS/ContentView.swift:447: editorCore.cursorPosition = CursorPosition(line: currentLineNumber, column: currentColumn)
VSCodeiPadOS/VSCodeiPadOS/ContentView.swift:500: .offset(x: 70, y: CGFloat(currentLineNumber) * lineHeight)
VSCodeiPadOS/VSCodeiPadOS/ContentView.swift:513: .onChange(of: currentLineNumber) { line in
VSCodeiPadOS/VSCodeiPadOS/ContentView.swift:517: editorCore.cursorPosition = CursorPosition(line: currentLineNumber, column: col)
VSCodeiPadOS/VSCodeiPadOS/ContentView.swift:529: struct LineNumbersWithFolding: View {
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:18: @Binding var currentLineNumber: Int
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:38: currentLineNumber: Binding<Int>,
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:53: self._currentLineNumber = currentLineNumber
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:71: currentLineNumber: Binding<Int>,
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:88: currentLineNumber: currentLineNumber,
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:336: self.parent.currentLineNumber = lineNumber
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView_Update.swift:498: @State private var currentLineNumber: Int = 1
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView_Update.swift:530: .foregroundColor(lineIndex + 1 == currentLineNumber ? .primary : .secondary.opacity(0.6))
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView_Update.swift:550: currentLineNumber: $currentLineNumber,
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SplitEditorView.swift:494: @State private var currentLineNumber: Int = 1
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SplitEditorView.swift:548: .foregroundColor(lineIndex + 1 == currentLineNumber ? .primary : .secondary.opacity(0.6))
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SplitEditorView.swift:572: currentLineNumber: $currentLineNumber,
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SplitEditorView.swift:657: if lineNumber == currentLineNumber { return "\(lineNumber)" }
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SplitEditorView.swift:658: return "\(abs(lineNumber - currentLineNumber))"
VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift:781: struct LineNumberViewWithFolding: View {
VSCodeiPadOS/VSCodeiPadOS/Views/DiffComponents.swift:16: let oldLineNumber: Int?
VSCodeiPadOS/VSCodeiPadOS/Views/DiffComponents.swift:17: let newLineNumber: Int?
VSCodeiPadOS/VSCodeiPadOS/Views/DiffComponents.swift:65: Text(line.oldLineNumber.map(String.init) ?? "")
VSCodeiPadOS/VSCodeiPadOS/Views/DiffComponents.swift:68: Text(line.newLineNumber.map(String.init) ?? "")
VSCodeiPadOS/VSCodeiPadOS/Views/DiffComponents.swift:124: Text(line.oldLineNumber.map(String.init) ?? "")
VSCodeiPadOS/VSCodeiPadOS/Views/DiffComponents.swift:147: Text(line.newLineNumber.map(String.init) ?? "")

---

[search]
Found 20 matches:
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SplitEditorView.swift:506: // Line numbers + breakpoints + code folding (gutter)
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SplitEditorView.swift:508: // IMPORTANT: keep gutter in sync with the editor scroll position. The gutter ScrollView
VSCodeiPadOS/VSCodeiPadOS/Services/DebugManager.swift:8: /// for the Debug sidebar and breakpoint gutter markers.
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/InlineSuggestionView.swift:32: /// Width reserved for the gutter (line numbers)
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/InlineSuggestionView.swift:33: var gutterWidth: CGFloat = 60
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/InlineSuggestionView.swift:114: // Calculate starting X position (gutter + insets + character offset)
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/InlineSuggestionView.swift:115: startX = gutterWidth + textInsets.left + (CGFloat(visualColumn) * charWidth)
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/InlineSuggestionView.swift:129: let xOffset: CGFloat = index == 0 ? startX : gutterWidth + textInsets.left
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView_Update.swift:507: // Line numbers + breakpoints (gutter)
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView_Update.swift:509: // IMPORTANT: keep gutter in sync with the editor scroll position. The gutter ScrollView
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/GitGutterView.swift:4: // MARK: - FEAT-071 Git gutter indicators + FEAT-072 Inline blame
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/GitGutterView.swift:7: // - FEAT-071: Git gutter indicators (added/modified/deleted)
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/GitGutterView.swift:113: public var gutterWidth: CGFloat = 6
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/GitGutterView.swift:114: public var gutterCornerRadius: CGFloat = 1
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/GitGutterView.swift:169: .frame(width: configuration.gutterWidth)
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/GitGutterView.swift:193: let corner = configuration.gutterCornerRadius
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/GitGutterView.swift:216: .accessibilityLabel("Git diff gutter")
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/InlayHintsOverlay.swift:17: /// Width reserved for the gutter (line numbers).
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/InlayHintsOverlay.swift:18: var gutterWidth: CGFloat = 60
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/InlayHintsOverlay.swift:47: let x = gutterWidth + textInsets.left + (CGFloat(visualColumn) * charWidth)

---

[search]
Found 12 matches:
VSCodeiPadOS/VSCodeiPadOS/Views/Panels/SearchView.swift:540: .accessibilityLabel("Search text field")
VSCodeiPadOS/VSCodeiPadOS/Views/Panels/SearchView.swift:541: .accessibilityHint("Type search query and press Enter to search. Press Escape to clear.")
VSCodeiPadOS/VSCodeiPadOS/Views/Panels/SearchView.swift:659: .accessibilityLabel("Replace text field")
VSCodeiPadOS/VSCodeiPadOS/Views/Panels/SearchView.swift:660: .accessibilityHint("Type replacement text. Press Command+Enter to replace all.")
VSCodeiPadOS/VSCodeiPadOS/Views/Panels/SearchView.swift:671: .accessibilityLabel("Replace all button")
VSCodeiPadOS/VSCodeiPadOS/Views/Panels/SearchView.swift:1132: .accessibilityLabel("File \(fileResult.fileName) with \(fileResult.matches.count) matches")
VSCodeiPadOS/VSCodeiPadOS/Views/Panels/SearchView.swift:1133: .accessibilityHint(isExpanded ? "Double tap to collapse" : "Double tap to expand")
VSCodeiPadOS/VSCodeiPadOS/Views/Panels/SearchView.swift:1134: .accessibilityAddTraits(.isButton)
VSCodeiPadOS/VSCodeiPadOS/Views/Panels/SearchView.swift:1207: .accessibilityElement(children: .combine)
VSCodeiPadOS/VSCodeiPadOS/Views/Panels/SearchView.swift:1208: .accessibilityLabel("Line \(match.lineNumber): \(match.text)")
VSCodeiPadOS/VSCodeiPadOS/Views/Panels/SearchView.swift:1209: .accessibilityHint(isSelected ? "Press Enter to open this result" : "Double tap to select")
VSCodeiPadOS/VSCodeiPadOS/Views/Panels/SearchView.swift:1210: .accessibilityAddTraits(isSelected ? [.isButton, .isSelected] : .isButton)


>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SplitEditorView.swift","start_line":470,"end_line":740}
>>>END

>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView_Update.swift","start_line":470,"end_line":610}
>>>END

>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/ContentView.swift","start_line":500,"end_line":660}
>>>END

>>>TOOL search
{"query":"accessibilityIdentifier", "glob":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor/*.swift"}
>>>END

>>>TOOL search
{"query":".accessibilityLabel(\"Line", "glob":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor/*.swift"}
>>>END

---

## ðŸ”§ TOOL RESULTS

Error: File 'VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SplitEditorView.swift' not in allowed paths: VSCodeiPadOSUITests/SearchViewUITests.swift

---

Error: File 'VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView_Update.swift' not in allowed paths: VSCodeiPadOSUITests/SearchViewUITests.swift

---

Error: File 'VSCodeiPadOS/VSCodeiPadOS/ContentView.swift' not in allowed paths: VSCodeiPadOSUITests/SearchViewUITests.swift

---

[search]
No matches found for "accessibilityIdentifier"

---

[search]
No matches found for ".accessibilityLabel("Line"


>>>REPORT
func testLineNumbersVisible() throws {
    // Navigate from Search to an editor view (pattern based on `testNavigateToResult`)
    let searchField = app.textFields["Search"]
    let searchTextField = app.searchFields["Search"]
    let searchInput = searchField.exists ? searchField : searchTextField

    guard searchInput.waitForExistence(timeout: 2) else {
        XCTSkip("Search field not available")
        return
    }

    searchInput.tap()
    searchInput.typeText("func")
    sleep(3)

    let firstResult = app.cells.firstMatch
    let firstResultButton = app.buttons.matching(NSPredicate(format: "label CONTAINS '.swift' OR label CONTAINS '.ts' OR label CONTAINS '.js'")).firstMatch
    let resultLink = app.links.firstMatch

    if firstResult.exists {
        firstResult.tap()
    } else if firstResultButton.exists {
        firstResultButton.tap()
    } else if resultLink.exists {
        resultLink.tap()
    } else {
        XCTSkip("No search results available to navigate to an editor")
        return
    }

    sleep(1)

    // Look for line numbers / gutter elements
    let gutterOrLinePredicate = NSPredicate(format: "identifier CONTAINS[c] 'gutter' OR identifier CONTAINS[c] 'line'")
    let gutterElement = app.otherElements.matching(gutterOrLinePredicate).firstMatch
    let lineNumberTexts = app.staticTexts.matching(NSPredicate(format: "(identifier CONTAINS[c] 'gutter' OR identifier CONTAINS[c] 'line') AND label MATCHES '\\\\d+'"))

    let hasLineNumbers = gutterElement.waitForExistence(timeout: 2) || lineNumberTexts.firstMatch.waitForExistence(timeout: 2)
    XCTAssertTrue(hasLineNumbers, "Line numbers gutter should be visible (look for elements with 'line'/'gutter' identifiers)")
}

func testLineNumbersUpdateOnNewLine() throws {
    // Navigate from Search to an editor view
    let searchField = app.textFields["Search"]
    let searchTextField = app.searchFields["Search"]
    let searchInput = searchField.exists ? searchField : searchTextField

    guard searchInput.waitForExistence(timeout: 2) else {
        XCTSkip("Search field not available")
        return
    }

    searchInput.tap()
    searchInput.typeText("func")
    sleep(3)

    if app.cells.firstMatch.exists {
        app.cells.firstMatch.tap()
    } else if app.links.firstMatch.exists {
        app.links.firstMatch.tap()
    } else {
        XCTSkip("No search results available to navigate to an editor")
        return
    }

    sleep(1)

    // Find an editor text view and insert a newline
    let editor = app.textViews.matching(NSPredicate(format: "identifier CONTAINS[c] 'editor' OR label CONTAINS[c] 'editor'")).firstMatch
    guard editor.waitForExistence(timeout: 2) else {
        XCTSkip("Editor view not available after navigating to a result")
        return
    }

    // Ensure we start on line 1 (best-effort; depends on editor implementation)
    editor.tap()
    editor.typeText("a")
    editor.typeText("\n")
    sleep(1)

    // Expect a "2" line number to appear in the gutter after adding a new line
    let line2 = app.staticTexts.matching(
        NSPredicate(format: "label == '2' AND (identifier CONTAINS[c] 'gutter' OR identifier CONTAINS[c] 'line')")
    ).firstMatch

    XCTAssertTrue(line2.waitForExistence(timeout: 2), "Line numbers should update when inserting a new line (expect line '2' in gutter)")
}

func testCurrentLineHighlight() throws {
    // Navigate from Search to an editor view
    let searchField = app.textFields["Search"]
    let searchTextField = app.searchFields["Search"]
    let searchInput = searchField.exists ? searchField : searchTextField

    guard searchInput.waitForExistence(timeout: 2) else {
        XCTSkip("Search field not available")
        return
    }

    searchInput.tap()
    searchInput.typeText("func")
    sleep(3)

    if app.cells.firstMatch.exists {
        app.cells.firstMatch.tap()
    } else if app.links.firstMatch.exists {
        app.links.firstMatch.tap()
    } else {
        XCTSkip("No search results available to navigate to an editor")
        return
    }

    sleep(1)

    let editor = app.textViews.matching(NSPredicate(format: "identifier CONTAINS[c] 'editor' OR label CONTAINS[c] 'editor'")).firstMatch
    guard editor.waitForExistence(timeout: 2) else {
        XCTSkip("Editor view not available after navigating to a result")
        return
    }

    // Create multiple lines and move the caret to line 2
    editor.tap()
    editor.typeText("one\n")
    editor.typeText("two")
    sleep(1)

    // Look for an explicit "current/active line" element, or a selected line-number.
    let activeLineIndicator = app.otherElements.matching(
        NSPredicate(format: "(identifier CONTAINS[c] 'current' OR identifier CONTAINS[c] 'active') AND identifier CONTAINS[c] 'line'")
    ).firstMatch

    if activeLineIndicator.exists {
        XCTAssertTrue(activeLineIndicator.isHittable || activeLineIndicator.exists, "An active/current line indicator should exist")
        return
    }

    // Fallback: scan line-number labels for a selected state (best-effort).
    let lineNumbers = app.staticTexts.matching(
        NSPredicate(format: "(identifier CONTAINS[c] 'gutter' OR identifier CONTAINS[c] 'line') AND label MATCHES '\\\\d+'")
    )

    guard lineNumbers.count > 0 else {
        XCTSkip("No line-number elements found to validate current-line highlight")
        return
    }

    var foundSelected = false
    for i in 0..<min(lineNumbers.count, 25) {
        let e = lineNumbers.element(boundBy: i)
        if e.exists && e.isSelected {
            foundSelected = true
            break
        }
    }

    XCTAssertTrue(foundSelected, "Current line number should be highlighted/selected in the gutter")
}

func testLineNumbersScrollSync() throws {
    // Navigate from Search to an editor view
    let searchField = app.textFields["Search"]
    let searchTextField = app.searchFields["Search"]
    let searchInput = searchField.exists ? searchField : searchTextField

    guard searchInput.waitForExistence(timeout: 2) else {
        XCTSkip("Search field not available")
        return
    }

    searchInput.tap()
    searchInput.typeText("func")
    sleep(3)

    if app.cells.firstMatch.exists {
        app.cells.firstMatch.tap()
    } else if app.links.firstMatch.exists {
        app.links.firstMatch.tap()
    } else {
        XCTSkip("No search results available to navigate to an editor")
        return
    }

    sleep(1)

    let editor = app.textViews.matching(NSPredicate(format: "identifier CONTAINS[c] 'editor' OR label CONTAINS[c] 'editor'")).firstMatch
    guard editor.waitForExistence(timeout: 2) else {
        XCTSkip("Editor view not available after navigating to a result")
        return
    }

    // Add enough lines to allow scrolling
    editor.tap()
    editor.typeText((1...40).map { "line\($0)" }.joined(separator: "\n"))
    sleep(1)

    let lineNumbers = app.staticTexts.matching(
        NSPredicate(format: "(identifier CONTAINS[c] 'gutter' OR identifier CONTAINS[c] 'line') AND label MATCHES '\\\\d+'")
    )

    guard lineNumbers.count > 0 else {
        XCTSkip("No line-number elements found to validate scroll sync")
        return
    }

    let beforeLabel = lineNumbers.element(boundBy: 0).label

    // Scroll editor and expect gutter's first visible line number to change (best-effort).
    editor.swipeUp()
    editor.swipeUp()
    sleep(1)

    let afterLabel = lineNumbers.element(boundBy: 0).label

    if let before = Int(beforeLabel), let after = Int(afterLabel) {
        XCTAssertTrue(after >= before, "Line numbers should scroll in sync with the editor (expected first visible line number to advance)")
        XCTAssertNotEqual(before, after, "Expected gutter to update after scrolling (first visible line number should change)")
    } else {
        XCTAssertNotEqual(beforeLabel, afterLabel, "Expected gutter to update after scrolling (first visible line label should change)")
    }
}

func testLineNumbersTapNavigation() throws {
    // Navigate from Search to an editor view
    let searchField = app.textFields["Search"]
    let searchTextField = app.searchFields["Search"]
    let searchInput = searchField.exists ? searchField : searchTextField

    guard searchInput.waitForExistence(timeout: 2) else {
        XCTSkip("Search field not available")
        return
    }

    searchInput.tap()
    searchInput.typeText("func")
    sleep(3)

    if app.cells.firstMatch.exists {
        app.cells.firstMatch.tap()
    } else if app.links.firstMatch.exists {
        app.links.firstMatch.tap()
    } else {
        XCTSkip("No search results available to navigate to an editor")
        return
    }

    sleep(1)

    let editor = app.textViews.matching(NSPredicate(format: "identifier CONTAINS[c] 'editor' OR label CONTAINS[c] 'editor'")).firstMatch
    guard editor.waitForExistence(timeout: 2) else {
        XCTSkip("Editor view not available after navigating to a result")
        return
    }

    // Ensure multiple lines exist
    editor.tap()
    editor.typeText((1...12).map { "l\($0)" }.joined(separator: "\n"))
    sleep(1)

    // Tap a line number in the gutter and expect it to become active/selected (best-effort).
    let targetLine = "5"
    let targetLineNumber = app.staticTexts.matching(
        NSPredicate(format: "label == %@ AND (identifier CONTAINS[c] 'gutter' OR identifier CONTAINS[c] 'line')", targetLine)
    ).firstMatch

    guard targetLineNumber.waitForExistence(timeout: 2) else {
        XCTSkip("No tappable line number '\(targetLine)' found (needs 'line'/'gutter' identifier)")
        return
    }

    guard targetLineNumber.isHittable else {
        XCTSkip("Line number '\(targetLine)' exists but is not hittable")
        return
    }

    targetLineNumber.tap()
    sleep(1)

    let activeLineIndicator = app.otherElements.matching(
        NSPredicate(format: "(identifier CONTAINS[c] 'current' OR identifier CONTAINS[c] 'active') AND identifier CONTAINS[c] 'line'")
    ).firstMatch

    let didNavigate =
        targetLineNumber.isSelected ||
        (activeLineIndicator.exists && (activeLineIndicator.label.contains(targetLine) || (activeLineIndicator.value as? String)?.contains(targetLine) == true))

    XCTAssertTrue(didNavigate, "Tapping a line number should navigate to / activate that line")
}
>>>END
