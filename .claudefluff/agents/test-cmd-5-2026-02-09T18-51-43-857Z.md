# Agent: test-cmd-5
**Status:** done
**Tokens:** 13,083
**Cost:** $0.0000
**Time:** 2026-02-09T18:51:43.857Z

## Task
Implement UI test: Escape closes command palette in CommandSearchUITests.swift.

## Response
>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/UITests/CommandSearchUITests.swift"} 
>>>END>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/UITests/CommandSearchUITests.swift"} 
>>>END

>>>TOOL list_dir
{"path":"VSCodeiPadOS"} 
>>>END

---

## ðŸ”§ TOOL RESULTS

Error: File 'VSCodeiPadOS' not in allowed paths: VSCodeiPadOS/VSCodeiPadOS/UITests/CommandSearchUITests.swift


>>>TOOL list_dir
{"path":"."}
>>>END

---

## ðŸ”§ TOOL RESULTS

Error: File '.' not in allowed paths: VSCodeiPadOS/VSCodeiPadOS/UITests/CommandSearchUITests.swift


>>>TOOL search
{"query":"CommandSearchUITests", "glob":"**/*.swift"}
>>>END

---

## ðŸ”§ TOOL RESULTS

[search]
No matches found for "CommandSearchUITests"


>>>TOOL search
{"query":"CommandSearch", "glob":"**/*.swift"}
>>>END

---

## ðŸ”§ TOOL RESULTS

[search]
No matches found for "CommandSearch"


>>>TOOL list_dir
{"path":"VSCodeiPadOS/VSCodeiPadOS/UITests"}
>>>END

---

## ðŸ”§ TOOL RESULTS

Error: File 'VSCodeiPadOS/VSCodeiPadOS/UITests' not in allowed paths: VSCodeiPadOS/VSCodeiPadOS/UITests/CommandSearchUITests.swift


>>>TOOL search
{"query":"UITests", "glob":"**/*.swift"}
>>>END

---

## ðŸ”§ TOOL RESULTS

[search]
Found 1 matches:
VSCodeiPadOSUITests/SearchViewUITests.swift:5: final class SearchViewUITests: XCTestCase {


>>>TOOL list_dir
{"path":"VSCodeiPadOSUITests"}
>>>END

---

## ðŸ”§ TOOL RESULTS

Error: File 'VSCodeiPadOSUITests' not in allowed paths: VSCodeiPadOS/VSCodeiPadOS/UITests/CommandSearchUITests.swift


>>>TOOL read_file
{"path":"VSCodeiPadOSUITests/SearchViewUITests.swift"}
>>>END

---

## ðŸ”§ TOOL RESULTS

Error: File 'VSCodeiPadOSUITests/SearchViewUITests.swift' not in allowed paths: VSCodeiPadOS/VSCodeiPadOS/UITests/CommandSearchUITests.swift


>>>TOOL search
{"query":"CommandSearchUITests.swift", "glob":"**/*"}
>>>END

---

## ðŸ”§ TOOL RESULTS

[search]
No matches found for "CommandSearchUITests.swift"


>>>TOOL search
{"query":"command palette", "glob":"**/*.swift"}
>>>END

---

## ðŸ”§ TOOL RESULTS

[search]
No matches found for "command palette"


>>>TOOL web_search
{"query":"XCUITest iOS typeKey escape XCUIKeyboardKey.escape rawValue", "max_results":5}
>>>END

---

## ðŸ”§ TOOL RESULTS

[web_search]
ðŸ” DuckDuckGo results for "XCUITest iOS typeKey escape XCUIKeyboardKey.escape rawValue" (5 results):

1. **escape | Apple Developer Documentation**
   https://developer.apple.com/documentation/xcuiautomation/xcuikeyboardkey/escape
   static let escape: XCUIKeyboardKey static let `return`: XCUIKeyboardKey init (String) init (rawValue: String) class func perform (withKeyModifiers: XCUIElement.KeyModifierFlags, block: () -&gt; Void) XCUIElement.KeyModifierFlags func hover ()

2. **Simulate hardware keyboard button press in Xcode UI test for iPad**
   https://stackoverflow.com/questions/78790991/simulate-hardware-keyboard-button-press-in-xcode-ui-test-for-ipad
   XCUIElement has two methods named typeKey(_:modifierFlags:): the first one takes a String as an argument, the second one a XCUIKeyboardKey, which has constants like .downArrow. Now, even if the documentation says that both methods are &quot;Available in macOS and in iPadOS 15 and later&quot;, when compiling the UI tests for iOS, the following line

3. **GitHub - aimatus/xcuitest-cheatsheet: How to&#x27;s, hacks and workarounds ...**
   https://github.com/aimatus/xcuitest-cheatsheet
   How to&#x27;s, hacks and workarounds for getting stuff tested with XCUITest - aimatus/xcuitest-cheatsheet

4. **XCUIKeyboardKey | Apple Developer Documentation**
   https://developer.apple.com/documentation/xcuiautomation/xcuikeyboardkey
   Structure XCUIKeyboardKey Constants to represent keys that have no typewritten equivalent. iOS iPadOS Mac Catalyst macOS tvOS visionOS watchOS Xcode 16.3+

5. **ios - How to use XCUIKeyboardKey constants? - Stack Overflow**
   https://stackoverflow.com/questions/31712024/how-to-use-xcuikeyboardkey-constants
   Constants for use with -[XCUIElement typeKey:modifierFlags:], representing keys that have no textual representation. These comprise the set of control, function, and modifier keys found on most keyboards. Apparently, it seems there should be a XCUIElement method called typeKey:modifierFlags:, as the note states.


>>>TOOL search
{"query":"final class Command", "glob":"**/*.swift"}
>>>END

---

## ðŸ”§ TOOL RESULTS

[search]
No matches found for "final class Command"


>>>TOOL list_dir
{"path":"VSCodeiPadOS/VSCodeiPadOS/UITests"}
>>>END

---

## ðŸ”§ TOOL RESULTS

Error: File 'VSCodeiPadOS/VSCodeiPadOS/UITests' not in allowed paths: VSCodeiPadOS/VSCodeiPadOS/UITests/CommandSearchUITests.swift


>>>TOOL read_file
{"path":"CommandSearchUITests.swift"}
>>>END

---

## ðŸ”§ TOOL RESULTS

Error: File 'CommandSearchUITests.swift' not in allowed paths: VSCodeiPadOS/VSCodeiPadOS/UITests/CommandSearchUITests.swift


>>>TOOL create_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/UITests/CommandSearchUITests.swift","content":"import XCTest\n\nfinal class CommandSearchUITests: XCTestCase {\n    private var app: XCUIApplication!\n\n    override func setUp() {\n        super.setUp()\n        continueAfterFailure = false\n\n        app = XCUIApplication()\n        app.launch()\n    }\n\n    private func waitForNonExistence(_ element: XCUIElement, timeout: TimeInterval) {\n        let predicate = NSPredicate(format: \"exists == false\")\n        let expectation = XCTNSPredicateExpectation(predicate: predicate, object: element)\n        _ = XCTWaiter().wait(for: [expectation], timeout: timeout)\n    }\n\n    func testEscapeClosesCommandPalette() {\n        // Open the command palette (VS Code standard shortcut).\n        app.typeKey(\"p\", modifierFlags: [.command, .shift])\n\n        // Command palette may be implemented as a UISearchBar (searchField) or a plain textField.\n        let searchField = app.searchFields.firstMatch\n        let textField = app.textFields.firstMatch\n\n        let paletteExists = searchField.waitForExistence(timeout: 5) || textField.waitForExistence(timeout: 0)\n        XCTAssertTrue(paletteExists, \"Expected command palette input to appear after Cmd+Shift+P\")\n\n        let paletteInput = searchField.exists ? searchField : textField\n        paletteInput.tap()\n\n        // Press Escape to close.\n        app.typeKey(.escape, modifierFlags: [])\n\n        // Verify the palette input disappears.\n        waitForNonExistence(paletteInput, timeout: 5)\n        XCTAssertFalse(paletteInput.exists, \"Expected command palette to be closed after pressing Escape\")\n    }\n}\n"} 
>>>END

---

## ðŸ”§ TOOL RESULTS

[create_file]
Error: File already exists: VSCodeiPadOS/VSCodeiPadOS/UITests/CommandSearchUITests.swift. Use overwrite:true to replace.


>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/UITests/CommandSearchUITests.swift"}
>>>END

---

## ðŸ”§ TOOL RESULTS

[read_file]
File: VSCodeiPadOS/VSCodeiPadOS/UITests/CommandSearchUITests.swift (lines 1-55 of 55)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1: import XCTest
2: 
3: final class CommandSearchUITests: XCTestCase {
4: 
5:     override func setUp() {
6:         super.setUp()
7:         continueAfterFailure = false
8:     }
9: 
10:     func testEnteringTextIntoSearchInputWorks() {
11:         let app = XCUIApplication()
12:         app.launch()
13: 
14:         // Try to find a likely command search input. If your UI uses a specific
15:         // accessibilityIdentifier for the command search field, prefer setting it
16:         // here and keep the other fallbacks.
17:         let preferredIdentifiers = [
18:             "commandSearchInput",
19:             "command-search-input",
20:             "CommandSearchInput",
21:             "commandPaletteSearchField",
22:             "command-palette-search",
23:             "Command Palette",
24:             "Command Search"
25:         ]
26: 
27:         let searchElement: XCUIElement = {
28:             for id in preferredIdentifiers {
29:                 let tf = app.textFields[id]
30:                 if tf.exists { return tf }
31:                 let sf = app.searchFields[id]
32:                 if sf.exists { return sf }
33:             }
34: 
35:             // Fallback: first visible searchField/textField.
36:             if app.searchFields.count > 0 {
37:                 return app.searchFields.element(boundBy: 0)
38:             }
39:             return app.textFields.element(boundBy: 0)
40:         }()
41: 
42:         XCTAssertTrue(searchElement.waitForExistence(timeout: 10), "Expected a command search input to exist")
43: 
44:         searchElement.tap()
45: 
46:         let textToEnter = "format"
47:         searchElement.typeText(textToEnter)
48: 
49:         // Validate the entered text is reflected in the field.
50:         // Some UIKit controls expose their content via `value`.
51:         let valueString = (searchElement.value as? String) ?? ""
52:         XCTAssertTrue(valueString.contains(textToEnter), "Expected search input value to contain '\(textToEnter)'. Actual value: '\(valueString)'")
53:     }
54: }
55: 


>>>TOOL patch
{"path":"VSCodeiPadOS/VSCodeiPadOS/UITests/CommandSearchUITests.swift","patch":">>>FILE VSCodeiPadOS/VSCodeiPadOS/UITests/CommandSearchUITests.swift\n>>>FIND\nfinal class CommandSearchUITests: XCTestCase {\n\n    override func setUp() {\n        super.setUp()\n        continueAfterFailure = false\n    }\n\n    func testEnteringTextIntoSearchInputWorks() {\n        let app = XCUIApplication()\n        app.launch()\n\n        // Try to find a likely command search input. If your UI uses a specific\n        // accessibilityIdentifier for the command search field, prefer setting it\n        // here and keep the other fallbacks.\n        let preferredIdentifiers = [\n            \"commandSearchInput\",\n            \"command-search-input\",\n            \"CommandSearchInput\",\n            \"commandPaletteSearchField\",\n            \"command-palette-search\",\n            \"Command Palette\",\n            \"Command Search\"\n        ]\n\n        let searchElement: XCUIElement = {\n            for id in preferredIdentifiers {\n                let tf = app.textFields[id]\n                if tf.exists { return tf }\n                let sf = app.searchFields[id]\n                if sf.exists { return sf }\n            }\n\n            // Fallback: first visible searchField/textField.\n            if app.searchFields.count > 0 {\n                return app.searchFields.element(boundBy: 0)\n            }\n            return app.textFields.element(boundBy: 0)\n        }()\n\n        XCTAssertTrue(searchElement.waitForExistence(timeout: 10), \"Expected a command search input to exist\")\n\n        searchElement.tap()\n\n        let textToEnter = \"format\"\n        searchElement.typeText(textToEnter)\n\n        // Validate the entered text is reflected in the field.\n        // Some UIKit controls expose their content via `value`.\n        let valueString = (searchElement.value as? String) ?? \"\"\n        XCTAssertTrue(valueString.contains(textToEnter), \"Expected search input value to contain '\\(textToEnter)'. Actual value: '\\(valueString)'\")\n    }\n}\n>>>REPLACE\nfinal class CommandSearchUITests: XCTestCase {\n\n    override func setUp() {\n        super.setUp()\n        continueAfterFailure = false\n    }\n\n    private func preferredCommandSearchIdentifiers() -> [String] {\n        [\n            \"commandSearchInput\",\n            \"command-search-input\",\n            \"CommandSearchInput\",\n            \"commandPaletteSearchField\",\n            \"command-palette-search\",\n            \"Command Palette\",\n            \"Command Search\"\n        ]\n    }\n\n    private func commandSearchElement(in app: XCUIApplication) -> XCUIElement {\n        // Try to find a likely command search input. If your UI uses a specific\n        // accessibilityIdentifier for the command search field, prefer setting it\n        // here and keep the other fallbacks.\n        for id in preferredCommandSearchIdentifiers() {\n            let tf = app.textFields[id]\n            if tf.exists { return tf }\n            let sf = app.searchFields[id]\n            if sf.exists { return sf }\n        }\n\n        // Fallback: first visible searchField/textField.\n        if app.searchFields.count > 0 {\n            return app.searchFields.element(boundBy: 0)\n        }\n        return app.textFields.element(boundBy: 0)\n    }\n\n    private func waitForNonExistence(_ element: XCUIElement, timeout: TimeInterval) {\n        let predicate = NSPredicate(format: \"exists == false\")\n        let expectation = XCTNSPredicateExpectation(predicate: predicate, object: element)\n        _ = XCTWaiter().wait(for: [expectation], timeout: timeout)\n    }\n\n    func testEnteringTextIntoSearchInputWorks() {\n        let app = XCUIApplication()\n        app.launch()\n\n        let searchElement = commandSearchElement(in: app)\n        XCTAssertTrue(searchElement.waitForExistence(timeout: 10), \"Expected a command search input to exist\")\n\n        searchElement.tap()\n\n        let textToEnter = \"format\"\n        searchElement.typeText(textToEnter)\n\n        // Validate the entered text is reflected in the field.\n        // Some UIKit controls expose their content via `value`.\n        let valueString = (searchElement.value as? String) ?? \"\"\n        XCTAssertTrue(valueString.contains(textToEnter), \"Expected search input value to contain '\\(textToEnter)'. Actual value: '\\(valueString)'\")\n    }\n\n    func testEscapeClosesCommandPalette() {\n        let app = XCUIApplication()\n        app.launch()\n\n        // Open the command palette (VS Code standard shortcut).\n        // Note: Requires hardware-keyboard support in XCUITest (iPadOS 15+).\n        app.typeKey(\"p\", modifierFlags: [.command, .shift])\n\n        let paletteInput = commandSearchElement(in: app)\n        XCTAssertTrue(paletteInput.waitForExistence(timeout: 10), \"Expected command palette input to appear after Cmd+Shift+P\")\n\n        // Press Escape to close.\n        app.typeKey(.escape, modifierFlags: [])\n\n        // Many UIs remove the palette entirely; some may simply hide it.\n        // Treat either non-existence or non-hittability as \"closed\".\n        let closedPredicate = NSPredicate(format: \"exists == false OR hittable == false\")\n        let closedExpectation = XCTNSPredicateExpectation(predicate: closedPredicate, object: paletteInput)\n        _ = XCTWaiter().wait(for: [closedExpectation], timeout: 10)\n\n        // Prefer asserting non-existence if it is removed.\n        if paletteInput.exists {\n            XCTAssertFalse(paletteInput.isHittable, \"Expected command palette to be closed (not hittable) after pressing Escape\")\n        } else {\n            XCTAssertFalse(paletteInput.exists, \"Expected command palette to be closed after pressing Escape\")\n        }\n    }\n}\n>>>END"} 
>>>END

---

## ðŸ”§ TOOL RESULTS

Error: Tool 'patch' not permitted for this agent (tools=read_write)


>>>TOOL create_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/UITests/CommandSearchUITests.swift","overwrite":true,"content":"import XCTest\n\nfinal class CommandSearchUITests: XCTestCase {\n\n    override func setUp() {\n        super.setUp()\n        continueAfterFailure = false\n    }\n\n    private func preferredCommandSearchIdentifiers() -> [String] {\n        [\n            \"commandSearchInput\",\n            \"command-search-input\",\n            \"CommandSearchInput\",\n            \"commandPaletteSearchField\",\n            \"command-palette-search\",\n            \"Command Palette\",\n            \"Command Search\"\n        ]\n    }\n\n    private func commandSearchElement(in app: XCUIApplication) -> XCUIElement {\n        // Try to find a likely command search input. If your UI uses a specific\n        // accessibilityIdentifier for the command search field, prefer setting it\n        // here and keep the other fallbacks.\n        for id in preferredCommandSearchIdentifiers() {\n            let tf = app.textFields[id]\n            if tf.exists { return tf }\n            let sf = app.searchFields[id]\n            if sf.exists { return sf }\n        }\n\n        // Fallback: first visible searchField/textField.\n        if app.searchFields.count > 0 {\n            return app.searchFields.element(boundBy: 0)\n        }\n        return app.textFields.element(boundBy: 0)\n    }\n\n    func testEnteringTextIntoSearchInputWorks() {\n        let app = XCUIApplication()\n        app.launch()\n\n        let searchElement = commandSearchElement(in: app)\n        XCTAssertTrue(searchElement.waitForExistence(timeout: 10), \"Expected a command search input to exist\")\n\n        searchElement.tap()\n\n        let textToEnter = \"format\"\n        searchElement.typeText(textToEnter)\n\n        // Validate the entered text is reflected in the field.\n        // Some UIKit controls expose their content via `value`.\n        let valueString = (searchElement.value as? String) ?? \"\"\n        XCTAssertTrue(valueString.contains(textToEnter), \"Expected search input value to contain '\\(textToEnter)'. Actual value: '\\(valueString)'\")\n    }\n\n    func testEscapeClosesCommandPalette() {\n        let app = XCUIApplication()\n        app.launch()\n\n        // Open the command palette (VS Code standard shortcut).\n        // Note: Requires hardware-keyboard support in XCUITest (iPadOS 15+).\n        app.typeKey(\"p\", modifierFlags: [.command, .shift])\n\n        let paletteInput = commandSearchElement(in: app)\n        XCTAssertTrue(paletteInput.waitForExistence(timeout: 10), \"Expected command palette input to appear after Cmd+Shift+P\")\n\n        // Press Escape to close.\n        app.typeKey(.escape, modifierFlags: [])\n\n        // Many UIs remove the palette entirely; some may simply hide it.\n        // Treat either non-existence or non-hittability as \"closed\".\n        let closedPredicate = NSPredicate(format: \"exists == false OR hittable == false\")\n        let closedExpectation = XCTNSPredicateExpectation(predicate: closedPredicate, object: paletteInput)\n        _ = XCTWaiter().wait(for: [closedExpectation], timeout: 10)\n\n        // Prefer asserting non-existence if it is removed.\n        if paletteInput.exists {\n            XCTAssertFalse(paletteInput.isHittable, \"Expected command palette to be closed (not hittable) after pressing Escape\")\n        } else {\n            XCTAssertFalse(paletteInput.exists, \"Expected command palette to be closed after pressing Escape\")\n        }\n    }\n}\n"} 
>>>END

---

## ðŸ”§ TOOL RESULTS

[create_file]
âœ… Overwrote: VSCodeiPadOS/VSCodeiPadOS/UITests/CommandSearchUITests.swift


>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/UITests/CommandSearchUITests.swift"}
>>>END

---

## ðŸ”§ TOOL RESULTS

[read_file]
File: VSCodeiPadOS/VSCodeiPadOS/UITests/CommandSearchUITests.swift (lines 1-86 of 86)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1: import XCTest
2: 
3: final class CommandSearchUITests: XCTestCase {
4: 
5:     override func setUp() {
6:         super.setUp()
7:         continueAfterFailure = false
8:     }
9: 
10:     private func preferredCommandSearchIdentifiers() -> [String] {
11:         [
12:             "commandSearchInput",
13:             "command-search-input",
14:             "CommandSearchInput",
15:             "commandPaletteSearchField",
16:             "command-palette-search",
17:             "Command Palette",
18:             "Command Search"
19:         ]
20:     }
21: 
22:     private func commandSearchElement(in app: XCUIApplication) -> XCUIElement {
23:         // Try to find a likely command search input. If your UI uses a specific
24:         // accessibilityIdentifier for the command search field, prefer setting it
25:         // here and keep the other fallbacks.
26:         for id in preferredCommandSearchIdentifiers() {
27:             let tf = app.textFields[id]
28:             if tf.exists { return tf }
29:             let sf = app.searchFields[id]
30:             if sf.exists { return sf }
31:         }
32: 
33:         // Fallback: first visible searchField/textField.
34:         if app.searchFields.count > 0 {
35:             return app.searchFields.element(boundBy: 0)
36:         }
37:         return app.textFields.element(boundBy: 0)
38:     }
39: 
40:     func testEnteringTextIntoSearchInputWorks() {
41:         let app = XCUIApplication()
42:         app.launch()
43: 
44:         let searchElement = commandSearchElement(in: app)
45:         XCTAssertTrue(searchElement.waitForExistence(timeout: 10), "Expected a command search input to exist")
46: 
47:         searchElement.tap()
48: 
49:         let textToEnter = "format"
50:         searchElement.typeText(textToEnter)
51: 
52:         // Validate the entered text is reflected in the field.
53:         // Some UIKit controls expose their content via `value`.
54:         let valueString = (searchElement.value as? String) ?? ""
55:         XCTAssertTrue(valueString.contains(textToEnter), "Expected search input value to contain '\(textToEnter)'. Actual value: '\(valueString)'")
56:     }
57: 
58:     func testEscapeClosesCommandPalette() {
59:         let app = XCUIApplication()
60:         app.launch()
61: 
62:         // Open the command palette (VS Code standard shortcut).
63:         // Note: Requires hardware-keyboard support in XCUITest (iPadOS 15+).
64:         app.typeKey("p", modifierFlags: [.command, .shift])
65: 
66:         let paletteInput = commandSearchElement(in: app)
67:         XCTAssertTrue(paletteInput.waitForExistence(timeout: 10), "Expected command palette input to appear after Cmd+Shift+P")
68: 
69:         // Press Escape to close.
70:         app.typeKey(.escape, modifierFlags: [])
71: 
72:         // Many UIs remove the palette entirely; some may simply hide it.
73:         // Treat either non-existence or non-hittability as "closed".
74:         let closedPredicate = NSPredicate(format: "exists == false OR hittable == false")
75:         let closedExpectation = XCTNSPredicateExpectation(predicate: closedPredicate, object: paletteInput)
76:         _ = XCTWaiter().wait(for: [closedExpectation], timeout: 10)
77: 
78:         // Prefer asserting non-existence if it is removed.
79:         if paletteInput.exists {
80:             XCTAssertFalse(paletteInput.isHittable, "Expected command palette to be closed (not hittable) after pressing Escape")
81:         } else {
82:             XCTAssertFalse(paletteInput.exists, "Expected command palette to be closed after pressing Escape")
83:         }
84:     }
85: }
86: 


>>>REPORT
Implemented UI test `testEscapeClosesCommandPalette()` in `VSCodeiPadOS/VSCodeiPadOS/UITests/CommandSearchUITests.swift` (lines 58-84) to verify pressing Escape closes the command palette:
- Launches app, opens palette via `Cmd+Shift+P` (line 64), waits for the palette input element to appear (lines 66-67), then sends `.escape` (line 70).
- Asserts closure by waiting until the element either no longer exists or is no longer hittable (lines 74-83).
Also refactored identifier lookup into helpers `preferredCommandSearchIdentifiers()` (lines 10-20) and `commandSearchElement(in:)` (lines 22-38) used by both tests.
>>>END
