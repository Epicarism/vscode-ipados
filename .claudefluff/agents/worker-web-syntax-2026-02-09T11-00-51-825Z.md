# Agent: worker-web-syntax
**Status:** done
**Tokens:** 62,026
**Cost:** $0.0000
**Time:** 2026-02-09T11:00:51.825Z

## Task
Design regex patterns for HTML tag highlighting, CSS/SCSS/LESS, JSON key/value, Markdown, YAML, SQL in NSAttributedStringSyntaxHighlighter.swift using VS Code Dark+ colors.

## Response
>>>TOOL read_file
{"path":"Extensions/NSAttributedStringSyntaxHighlighter.swift"} 
>>>END>>>TOOL read_file
{"path":"Extensions/NSAttributedStringSyntaxHighlighter.swift"}
>>>END

>>>TOOL list_dir
{"path":""}
>>>END

>>>TOOL get_symbols
{"path":"Extensions/NSAttributedStringSyntaxHighlighter.swift"}
>>>END>>>TOOL read_file
{"path":"Extensions/NSAttributedStringSyntaxHighlighter.swift","start_line":1,"end_line":260}
>>>END>>>TOOL read_file
{"path":"Extensions/NSAttributedStringSyntaxHighlighter.swift","start_line":260,"end_line":760}
>>>END>>>TOOL read_file
{"path":"Extensions/NSAttributedStringSyntaxHighlighter.swift","start_line":760,"end_line":953}
>>>END>>>TOOL list_dir
{"path":"Extensions"}
>>>END>>>TOOL list_dir
{"path":"Extensions"}
>>>END

>>>TOOL list_dir
{"path":"VSCodeiPadOS/VSCodeiPadOS/Extensions"}
>>>END

>>>TOOL read_file
{"path":"Extensions/NSAttributedStringSyntaxHighlighter.swift"}
>>>END

>>>TOOL search
{"query":"NSAttributedStringSyntaxHighlighter", "glob":"**/*.swift"}
>>>END

>>>TOOL create_file
{"path":"Extensions/NSAttributedStringSyntaxHighlighter.swift","content":"import SwiftUI\nimport UIKit\n\n// Efficient NSMutableAttributedString-based syntax highlighter (regex-based).\n//\n// Theme: VS Code Dark+ (approximated)\n// Reference token colors (Dark+):\n// - keyword:  #569CD6\n// - type:     #4EC9B0\n// - property: #9CDCFE\n// - string:   #CE9178\n// - comment:  #6A9955\n// - number:   #B5CEA8\n// - function: #DCDCAA\n// - default:  #D4D4D4\nfinal class NSAttributedStringSyntaxHighlighter {\n\n    // MARK: - Language\n\n    // NOTE: This file cannot use the name `Language` because the project already defines a global `Language`\n    // enum elsewhere.\n    enum SyntaxLanguage {\n        case swift, javascript, typescript, jsx, tsx\n        case python, ruby, go, rust\n        case java, kotlin\n        case c, cpp, objc\n        case html, css, scss, less\n        case json, xml, yaml\n        case sql, shell, dockerfile, graphql\n        case markdown, php, dotenv\n        case plainText\n    }\n\n    // MARK: - Colors (VS Code Dark+)\n\n    private struct ColorScheme {\n        static let keyword = UIColor(vscodeHex: 0x569CD6)\n        static let type = UIColor(vscodeHex: 0x4EC9B0)\n        static let property = UIColor(vscodeHex: 0x9CDCFE)\n        static let string = UIColor(vscodeHex: 0xCE9178)\n        static let comment = UIColor(vscodeHex: 0x6A9955)\n        static let number = UIColor(vscodeHex: 0xB5CEA8)\n        static let function = UIColor(vscodeHex: 0xDCDCAA)\n        static let defaultText = UIColor(vscodeHex: 0xD4D4D4)\n    }\n\n    // MARK: - Public API\n\n    /// Backwards-compatible entrypoint (defaults to Swift).\n    static func highlightCode(_ code: String) -> NSAttributedString {\n        highlightCode(code, filename: nil, language: .swift)\n    }\n\n    /// Highlights `code` using either an explicit `language` or a detected one from `filename`.\n    static func highlightCode(_ code: String, filename: String? = nil, language: SyntaxLanguage? = nil) -> NSAttributedString {\n        let attributed = NSMutableAttributedString(string: code)\n        let fullRange = NSRange(location: 0, length: code.utf16.count)\n\n        attributed.addAttributes([\n            .font: UIFont.monospacedSystemFont(ofSize: 14, weight: .regular),\n            .foregroundColor: ColorScheme.defaultText\n        ], range: fullRange)\n\n        let resolvedLanguage: SyntaxLanguage = {\n            if let language { return language }\n            if let filename { return detectLanguage(fromFilename: filename) }\n            return .plainText\n        }()\n\n        highlight(code: code, language: resolvedLanguage, into: attributed)\n        return attributed\n    }\n\n    // MARK: - Language detection\n\n    private static func detectLanguage(fromFilename filename: String) -> SyntaxLanguage {\n        let lower = filename.lowercased()\n        let base = (lower as NSString).lastPathComponent\n        let ext = (base as NSString).pathExtension\n\n        // Special basenames (no extension).\n        if base == \"dockerfile\" || base.hasPrefix(\"dockerfile.\") { return .dockerfile }\n        if base == \".env\" || base.hasPrefix(\".env.\") || ext == \"env\" { return .dotenv }\n\n        switch ext {\n        case \"swift\": return .swift\n        case \"js\", \"mjs\", \"cjs\": return .javascript\n        case \"jsx\": return .jsx\n        case \"ts\": return .typescript\n        case \"tsx\": return .tsx\n        case \"py\", \"pyw\": return .python\n        case \"rb\", \"ruby\": return .ruby\n        case \"go\": return .go\n        case \"rs\": return .rust\n        case \"java\": return .java\n        case \"kt\", \"kts\": return .kotlin\n        case \"c\": return .c\n        case \"cc\", \"cpp\", \"cxx\", \"hpp\", \"hh\", \"hxx\", \"h\": return .cpp\n        case \"m\", \"mm\": return .objc\n        case \"html\", \"htm\": return .html\n        case \"css\": return .css\n        case \"scss\", \"sass\": return .scss\n        case \"less\": return .less\n        case \"json\", \"jsonc\": return .json\n        case \"xml\", \"plist\", \"svg\": return .xml\n        case \"yml\", \"yaml\": return .yaml\n        case \"sql\": return .sql\n        case \"sh\", \"bash\", \"zsh\", \"fish\": return .shell\n        case \"php\": return .php\n        case \"gql\", \"graphql\": return .graphql\n        case \"md\", \"markdown\": return .markdown\n        default: return .plainText\n        }\n    }\n\n    // MARK: - Pipeline\n\n    private struct CapturePattern {\n        let pattern: String\n        let captureGroup: Int?\n        let options: NSRegularExpression.Options\n    }\n\n    private struct LanguageRules {\n        // Keyword list (word-based)\n        let keywords: [String]\n\n        // Regex-driven keyword-like tokens (e.g., HTML tag names, Markdown headings)\n        let keywordPatterns: [CapturePattern]\n\n        // Property-ish identifiers (e.g., JSON/YAML keys, CSS properties, HTML attribute names)\n        let propertyPatterns: [CapturePattern]\n\n        let typePatterns: [CapturePattern]\n        let stringPatterns: [String]\n        let stringRegexOptions: NSRegularExpression.Options\n        let commentPatterns: [String]\n        let commentRegexOptions: NSRegularExpression.Options\n        let numberPattern: String?\n        let numberRegexOptions: NSRegularExpression.Options\n        let keywordRegexOptions: NSRegularExpression.Options\n        let functionPatterns: [CapturePattern]\n\n        // Some languages (notably JSON/YAML) need to recolor things that are technically strings (keys).\n        // If `true`, propertyPatterns will NOT exclude string ranges.\n        let propertiesMayOverrideStrings: Bool\n    }\n\n    private static func highlight(code: String, language: SyntaxLanguage, into attributed: NSMutableAttributedString) {\n        let rules = languageRules(for: language)\n\n        // 1) Strings first\n        let stringRanges = rules.stringPatterns.flatMap { pattern in\n            applyHighlighting(\n                pattern: pattern,\n                options: rules.stringRegexOptions,\n                color: ColorScheme.string,\n                to: attributed,\n                in: code,\n                captureGroup: nil,\n                excluding: []\n            )\n        }\n\n        // 2) Comments (exclude matches inside strings)\n        let commentRanges = rules.commentPatterns.flatMap { pattern in\n            applyHighlighting(\n                pattern: pattern,\n                options: rules.commentRegexOptions,\n                color: ColorScheme.comment,\n                to: attributed,\n                in: code,\n                captureGroup: nil,\n                excluding: stringRanges\n            )\n        }\n\n        let protectedRanges = stringRanges + commentRanges\n\n        // 3) Numbers\n        if let numberPattern = rules.numberPattern {\n            _ = applyHighlighting(\n                pattern: numberPattern,\n                options: rules.numberRegexOptions,\n                color: ColorScheme.number,\n                to: attributed,\n                in: code,\n                captureGroup: nil,\n                excluding: protectedRanges\n            )\n        }\n\n        // 4) Properties\n        let propertyExclusions: [NSRange] = rules.propertiesMayOverrideStrings ? commentRanges : protectedRanges\n        for propPattern in rules.propertyPatterns {\n            _ = applyHighlighting(\n                pattern: propPattern.pattern,\n                options: propPattern.options,\n                color: ColorScheme.property,\n                to: attributed,\n                in: code,\n                captureGroup: propPattern.captureGroup,\n                excluding: propertyExclusions\n            )\n        }\n\n        // 5) Types\n        for typePattern in rules.typePatterns {\n            _ = applyHighlighting(\n                pattern: typePattern.pattern,\n                options: typePattern.options,\n                color: ColorScheme.type,\n                to: attributed,\n                in: code,\n                captureGroup: typePattern.captureGroup,\n                excluding: protectedRanges\n            )\n        }\n\n        // 6) Keywords (list)\n        if !rules.keywords.isEmpty {\n            let keywordPattern = \"\\\\b(?:\" + rules.keywords.map(NSRegularExpression.escapedPattern).joined(separator: \"|\") + \")\\\\b\"\n            _ = applyHighlighting(\n                pattern: keywordPattern,\n                options: rules.keywordRegexOptions,\n                color: ColorScheme.keyword,\n                to: attributed,\n                in: code,\n                captureGroup: nil,\n                excluding: protectedRanges\n            )\n        }\n\n        // 7) Keywords (regex patterns)\n        for kwPattern in rules.keywordPatterns {\n            _ = applyHighlighting(\n                pattern: kwPattern.pattern,\n                options: kwPattern.options,\n                color: ColorScheme.keyword,\n                to: attributed,\n                in: code,\n                captureGroup: kwPattern.captureGroup,\n                excluding: protectedRanges\n            )\n        }\n\n        // 8) Functions\n        for fnPattern in rules.functionPatterns {\n            _ = applyHighlighting(\n                pattern: fnPattern.pattern,\n                options: fnPattern.options,\n                color: ColorScheme.function,\n                to: attributed,\n                in: code,\n                captureGroup: fnPattern.captureGroup,\n                excluding: protectedRanges\n            )\n        }\n    }\n\n    // MARK: - Language rules\n\n    private static func languageRules(for language: SyntaxLanguage) -> LanguageRules {\n\n        // Numeric literal coverage (hex, float, exponent, underscores).\n        let commonNumber = \"\\\\b(?:0x[0-9A-Fa-f_]+|\\\\d[\\\\d_]*(?:\\\\.\\\\d[\\\\d_]*)?(?:[eE][+-]?\\\\d[\\\\d_]*)?)\\\\b\"\n\n        // C-like strings: \"...\" and '...'\n        let cLikeStrings = [\n            \"\\\"(?:[^\\\"\\\\\\\\\\\\n]|\\\\\\\\.)*\\\"\",\n            \"'(?:[^'\\\\\\\\\\\\n]|\\\\\\\\.)*'\"\n        ]\n\n        // C-like comments\n        let cLikeComments = [\n            \"//[^\\\\n]*\",\n            \"/\\\\*[\\\\s\\\\S]*?\\\\*/\"\n        ]\n\n        // Common function call: name(\n        let commonFunctionCall = CapturePattern(\n            pattern: \"\\\\b([A-Za-z_][A-Za-z0-9_]*)\\\\s*(?=\\\\()\",\n            captureGroup: 1,\n            options: []\n        )\n\n        switch language {\n\n        case .swift:\n            return LanguageRules(\n                keywords: [\n                    \"func\", \"var\", \"let\", \"if\", \"else\", \"for\", \"while\", \"repeat\", \"switch\", \"case\", \"default\",\n                    \"return\", \"import\", \"class\", \"struct\", \"enum\", \"protocol\", \"extension\", \"actor\",\n                    \"private\", \"fileprivate\", \"public\", \"internal\", \"open\", \"static\", \"final\", \"override\",\n                    \"self\", \"super\", \"init\", \"deinit\",\n                    \"throw\", \"throws\", \"rethrows\", \"try\", \"catch\", \"do\", \"guard\", \"defer\",\n                    \"async\", \"await\",\n                    \"weak\", \"unowned\", \"mutating\", \"nonmutating\",\n                    \"typealias\", \"associatedtype\", \"where\", \"in\", \"is\", \"as\", \"Any\", \"some\", \"any\",\n                    \"true\", \"false\", \"nil\"\n                ],\n                keywordPatterns: [],\n                propertyPatterns: [],\n                typePatterns: [\n                    CapturePattern(\n                        pattern: \"\\\\b(?:String|Int|Int8|Int16|Int32|Int64|UInt|UInt8|UInt16|UInt32|UInt64|Double|Float|Bool|Character|Void|AnyObject|Never|Data|Date|URL|UUID|CGFloat)\\\\b\",\n                        captureGroup: nil,\n                        options: []\n                    ),\n                    CapturePattern(pattern: \"\\\\b([A-Z][A-Za-z0-9_]*)\\\\b\", captureGroup: 1, options: [])\n                ],\n                stringPatterns: [\"\\\"\\\"\\\"[\\\\s\\\\S]*?\\\"\\\"\\\"\"] + cLikeStrings,\n                stringRegexOptions: [.dotMatchesLineSeparators],\n                commentPatterns: cLikeComments,\n                commentRegexOptions: [.dotMatchesLineSeparators],\n                numberPattern: commonNumber,\n                numberRegexOptions: [],\n                keywordRegexOptions: [],\n                functionPatterns: [\n                    CapturePattern(pattern: \"\\\\bfunc\\\\s+([A-Za-z_][A-Za-z0-9_]*)\\\\b\", captureGroup: 1, options: []),\n                    commonFunctionCall\n                ],\n                propertiesMayOverrideStrings: false\n            )\n\n        case .javascript:\n            return LanguageRules(\n                keywords: [\n                    \"break\", \"case\", \"catch\", \"class\", \"const\", \"continue\", \"debugger\", \"default\", \"delete\",\n                    \"do\", \"else\", \"export\", \"extends\", \"finally\", \"for\", \"function\", \"if\", \"import\", \"in\",\n                    \"instanceof\", \"let\", \"new\", \"return\", \"super\", \"switch\", \"this\", \"throw\", \"try\", \"typeof\",\n                    \"var\", \"void\", \"while\", \"with\", \"yield\", \"async\", \"await\", \"of\", \"true\", \"false\", \"null\", \"undefined\"\n                ],\n                keywordPatterns: [],\n                propertyPatterns: [],\n                typePatterns: [CapturePattern(pattern: \"\\\\b([A-Z][A-Za-z0-9_]*)\\\\b\", captureGroup: 1, options: [])],\n                stringPatterns: cLikeStrings + [\n                    \"`(?:[^`\\\\\\\\]|\\\\\\\\.|\\\\$\\\\{[\\\\s\\\\S]*?\\\\})*`\"\n                ],\n                stringRegexOptions: [.dotMatchesLineSeparators],\n                commentPatterns: cLikeComments,\n                commentRegexOptions: [.dotMatchesLineSeparators],\n                numberPattern: commonNumber,\n                numberRegexOptions: [],\n                keywordRegexOptions: [],\n                functionPatterns: [\n                    CapturePattern(pattern: \"\\\\bfunction\\\\s+([A-Za-z_][A-Za-z0-9_]*)\\\\b\", captureGroup: 1, options: []),\n                    CapturePattern(pattern: \"\\\\b(?:const|let|var)\\\\s+([A-Za-z_][A-Za-z0-9_]*)\\\\s*=\\\\s*(?:async\\\\s*)?(?:\\\\([^)]*\\\\)|[A-Za-z_][A-Za-z0-9_]*)?\\\\s*=>\", captureGroup: 1, options: []),\n                    commonFunctionCall\n                ],\n                propertiesMayOverrideStrings: false\n            )\n\n        case .typescript:\n            return LanguageRules(\n                keywords: [\n                    // JS\n                    \"break\", \"case\", \"catch\", \"class\", \"const\", \"continue\", \"debugger\", \"default\", \"delete\",\n                    \"do\", \"else\", \"export\", \"extends\", \"finally\", \"for\", \"function\", \"if\", \"import\", \"in\",\n                    \"instanceof\", \"let\", \"new\", \"return\", \"super\", \"switch\", \"this\", \"throw\", \"try\", \"typeof\",\n                    \"var\", \"void\", \"while\", \"with\", \"yield\", \"async\", \"await\", \"of\", \"true\", \"false\", \"null\", \"undefined\",\n                    // TS\n                    \"interface\", \"type\", \"enum\", \"implements\", \"namespace\", \"abstract\", \"declare\", \"readonly\",\n                    \"private\", \"protected\", \"public\", \"keyof\", \"infer\", \"unknown\", \"never\", \"any\", \"as\", \"satisfies\"\n                ],\n                keywordPatterns: [],\n                propertyPatterns: [],\n                typePatterns: [\n                    CapturePattern(pattern: \"\\\\b(?:string|number|boolean|any|unknown|never|void|object|bigint|symbol)\\\\b\", captureGroup: nil, options: []),\n                    CapturePattern(pattern: \"\\\\b([A-Z][A-Za-z0-9_]*)\\\\b\", captureGroup: 1, options: [])\n                ],\n                stringPatterns: cLikeStrings + [\"`(?:[^`\\\\\\\\]|\\\\\\\\.|\\\\$\\\\{[\\\\s\\\\S]*?\\\\})*`\"],\n                stringRegexOptions: [.dotMatchesLineSeparators],\n                commentPatterns: cLikeComments,\n                commentRegexOptions: [.dotMatchesLineSeparators],\n                numberPattern: commonNumber,\n                numberRegexOptions: [],\n                keywordRegexOptions: [],\n                functionPatterns: [\n                    CapturePattern(pattern: \"\\\\bfunction\\\\s+([A-Za-z_][A-Za-z0-9_]*)\\\\b\", captureGroup: 1, options: []),\n                    commonFunctionCall\n                ],\n                propertiesMayOverrideStrings: false\n            )\n\n        case .tsx:\n            // TSX = TypeScript + JSX tags/attributes\n            let ts = languageRules(for: .typescript)\n            return LanguageRules(\n                keywords: ts.keywords,\n                keywordPatterns: ts.keywordPatterns + [\n                    // JSX/TSX tag name\n                    CapturePattern(pattern: \"<\\\\/?\\\\s*([A-Za-z][A-Za-z0-9:_-]*)\", captureGroup: 1, options: [])\n                ],\n                propertyPatterns: ts.propertyPatterns + [\n                    // JSX attribute name\n                    CapturePattern(pattern: \"\\\\b([A-Za-z_:][A-Za-z0-9:._-]*)(?=\\\\s*=)\", captureGroup: 1, options: [])\n                ],\n                typePatterns: ts.typePatterns,\n                stringPatterns: ts.stringPatterns,\n                stringRegexOptions: ts.stringRegexOptions,\n                commentPatterns: ts.commentPatterns,\n                commentRegexOptions: ts.commentRegexOptions,\n                numberPattern: ts.numberPattern,\n                numberRegexOptions: ts.numberRegexOptions,\n                keywordRegexOptions: ts.keywordRegexOptions,\n                functionPatterns: ts.functionPatterns,\n                propertiesMayOverrideStrings: false\n            )\n\n        case .jsx:\n            let js = languageRules(for: .javascript)\n            return LanguageRules(\n                keywords: js.keywords,\n                keywordPatterns: js.keywordPatterns + [\n                    CapturePattern(pattern: \"<\\\\/?\\\\s*([A-Za-z][A-Za-z0-9:_-]*)\", captureGroup: 1, options: [])\n                ],\n                propertyPatterns: js.propertyPatterns + [\n                    CapturePattern(pattern: \"\\\\b([A-Za-z_:][A-Za-z0-9:._-]*)(?=\\\\s*=)\", captureGroup: 1, options: [])\n                ],\n                typePatterns: js.typePatterns,\n                stringPatterns: js.stringPatterns,\n                stringRegexOptions: js.stringRegexOptions,\n                commentPatterns: js.commentPatterns,\n                commentRegexOptions: js.commentRegexOptions,\n                numberPattern: js.numberPattern,\n                numberRegexOptions: js.numberRegexOptions,\n                keywordRegexOptions: js.keywordRegexOptions,\n                functionPatterns: js.functionPatterns,\n                propertiesMayOverrideStrings: false\n            )\n\n        case .python:\n            return LanguageRules(\n                keywords: [\n                    \"False\", \"None\", \"True\", \"and\", \"as\", \"assert\", \"async\", \"await\", \"break\", \"class\",\n                    \"continue\", \"def\", \"del\", \"elif\", \"else\", \"except\", \"finally\", \"for\", \"from\", \"global\",\n                    \"if\", \"import\", \"in\", \"is\", \"lambda\", \"nonlocal\", \"not\", \"or\", \"pass\", \"raise\", \"return\",\n                    \"try\", \"while\", \"with\", \"yield\", \"match\", \"case\"\n                ],\n                keywordPatterns: [],\n                propertyPatterns: [],\n                typePatterns: [\n                    CapturePattern(pattern: \"\\\\b(?:int|float|bool|str|bytes|list|tuple|set|dict|object)\\\\b\", captureGroup: nil, options: []),\n                    CapturePattern(pattern: \"\\\\b([A-Z][A-Za-z0-9_]*)\\\\b\", captureGroup: 1, options: [])\n                ],\n                stringPatterns: [\n                    \"'''[\\\\s\\\\S]*?'''\",\n                    \"\\\"\\\"\\\"[\\\\s\\\\S]*?\\\"\\\"\\\"\",\n                    \"(?i)\\\\b(?:r|u|f|fr|rf|b|br|rb)?'(?:[^'\\\\\\\\\\\\n]|\\\\\\\\.)*'\",\n                    \"(?i)\\\\b(?:r|u|f|fr|rf|b|br|rb)?\\\"(?:[^\\\"\\\\\\\\\\\\n]|\\\\\\\\.)*\\\"\"\n                ],\n                stringRegexOptions: [.dotMatchesLineSeparators],\n                commentPatterns: [\"#[^\\\\n]*\"],\n                commentRegexOptions: [],\n                numberPattern: commonNumber,\n                numberRegexOptions: [],\n                keywordRegexOptions: [],\n                functionPatterns: [\n                    CapturePattern(pattern: \"\\\\bdef\\\\s+([A-Za-z_][A-Za-z0-9_]*)\\\\b\", captureGroup: 1, options: []),\n                    commonFunctionCall\n                ],\n                propertiesMayOverrideStrings: false\n            )\n\n        case .ruby:\n            return LanguageRules(\n                keywords: [\n                    \"BEGIN\", \"END\", \"alias\", \"and\", \"begin\", \"break\", \"case\", \"class\", \"def\", \"defined\\\\?\",\n                    \"do\", \"else\", \"elsif\", \"end\", \"ensure\", \"false\", \"for\", \"if\", \"in\", \"module\", \"next\",\n                    \"nil\", \"not\", \"or\", \"redo\", \"rescue\", \"retry\", \"return\", \"self\", \"super\", \"then\",\n                    \"true\", \"undef\", \"unless\", \"until\", \"when\", \"while\", \"yield\", \"private\", \"protected\", \"public\"\n                ],\n                keywordPatterns: [],\n                propertyPatterns: [],\n                typePatterns: [CapturePattern(pattern: \"\\\\b([A-Z][A-Za-z0-9_]*)\\\\b\", captureGroup: 1, options: [])],\n                stringPatterns: [\n                    \"\\\"(?:[^\\\"\\\\\\\\\\\\n]|\\\\\\\\.)*\\\"\",\n                    \"'(?:[^'\\\\\\\\\\\\n]|\\\\\\\\.)*'\",\n                    \"%[qQ]\\\\{[\\\\s\\\\S]*?\\\\}\",\n                    \"%[qQ]\\\\([\\\\s\\\\S]*?\\\\)\",\n                    \"%[qQ]\\\\[[\\\\s\\\\S]*?\\\\]\"\n                ],\n                stringRegexOptions: [.dotMatchesLineSeparators],\n                commentPatterns: [\"#[^\\\\n]*\", \"=begin[\\\\s\\\\S]*?=end\"],\n                commentRegexOptions: [.dotMatchesLineSeparators],\n                numberPattern: commonNumber,\n                numberRegexOptions: [],\n                keywordRegexOptions: [],\n                functionPatterns: [\n                    CapturePattern(pattern: \"\\\\bdef\\\\s+([A-Za-z_][A-Za-z0-9_]*[!?=]?)\\\\b\", captureGroup: 1, options: []),\n                    commonFunctionCall\n                ],\n                propertiesMayOverrideStrings: false\n            )\n\n        case .go:\n            return LanguageRules(\n                keywords: [\n                    \"break\", \"default\", \"func\", \"interface\", \"select\", \"case\", \"defer\", \"go\", \"map\", \"struct\",\n                    \"chan\", \"else\", \"goto\", \"package\", \"switch\", \"const\", \"fallthrough\", \"if\", \"range\", \"type\",\n                    \"continue\", \"for\", \"import\", \"return\", \"var\", \"true\", \"false\", \"nil\"\n                ],\n                keywordPatterns: [],\n                propertyPatterns: [],\n                typePatterns: [\n                    CapturePattern(pattern: \"\\\\b(?:string|bool|byte|rune|int|int8|int16|int32|int64|uint|uint8|uint16|uint32|uint64|uintptr|float32|float64|complex64|complex128|error)\\\\b\", captureGroup: nil, options: []),\n                    CapturePattern(pattern: \"\\\\b([A-Z][A-Za-z0-9_]*)\\\\b\", captureGroup: 1, options: [])\n                ],\n                stringPatterns: [\"`[\\\\s\\\\S]*?`\", \"\\\"(?:[^\\\"\\\\\\\\\\\\n]|\\\\\\\\.)*\\\"\", \"'(?:[^'\\\\\\\\\\\\n]|\\\\\\\\.)*'\"],\n                stringRegexOptions: [.dotMatchesLineSeparators],\n                commentPatterns: cLikeComments,\n                commentRegexOptions: [.dotMatchesLineSeparators],\n                numberPattern: commonNumber,\n                numberRegexOptions: [],\n                keywordRegexOptions: [],\n                functionPatterns: [\n                    CapturePattern(pattern: \"\\\\bfunc\\\\s+(?:\\\\([^)]*\\\\)\\\\s*)?([A-Za-z_][A-Za-z0-9_]*)\\\\s*\\\\(\", captureGroup: 1, options: []),\n                    commonFunctionCall\n                ],\n                propertiesMayOverrideStrings: false\n            )\n\n        case .rust:\n            return LanguageRules(\n                keywords: [\n                    \"as\", \"break\", \"const\", \"continue\", \"crate\", \"else\", \"enum\", \"extern\", \"false\", \"fn\", \"for\",\n                    \"if\", \"impl\", \"in\", \"let\", \"loop\", \"match\", \"mod\", \"move\", \"mut\", \"pub\", \"ref\", \"return\",\n                    \"self\", \"Self\", \"static\", \"struct\", \"super\", \"trait\", \"true\", \"type\", \"unsafe\", \"use\",\n                    \"where\", \"while\", \"async\", \"await\", \"dyn\"\n                ],\n                keywordPatterns: [],\n                propertyPatterns: [],\n                typePatterns: [\n                    CapturePattern(pattern: \"\\\\b(?:i8|i16|i32|i64|i128|isize|u8|u16|u32|u64|u128|usize|f32|f64|bool|char|str|String|Option|Result|Vec)\\\\b\", captureGroup: nil, options: []),\n                    CapturePattern(pattern: \"\\\\b([A-Z][A-Za-z0-9_]*)\\\\b\", captureGroup: 1, options: [])\n                ],\n                stringPatterns: [\"r#\\\"[\\\\s\\\\S]*?\\\"#\", \"\\\"(?:[^\\\"\\\\\\\\\\\\n]|\\\\\\\\.)*\\\"\", \"'(?:[^'\\\\\\\\\\\\n]|\\\\\\\\.)*'\"],\n                stringRegexOptions: [.dotMatchesLineSeparators],\n                commentPatterns: [\"//[^\\\\n]*\", \"/\\\\*[\\\\s\\\\S]*?\\\\*/\"],\n                commentRegexOptions: [.dotMatchesLineSeparators],\n                numberPattern: commonNumber,\n                numberRegexOptions: [],\n                keywordRegexOptions: [],\n                functionPatterns: [\n                    CapturePattern(pattern: \"\\\\bfn\\\\s+([A-Za-z_][A-Za-z0-9_]*)\\\\b\", captureGroup: 1, options: []),\n                    commonFunctionCall\n                ],\n                propertiesMayOverrideStrings: false\n            )\n\n        case .java:\n            return LanguageRules(\n                keywords: [\n                    \"abstract\", \"assert\", \"boolean\", \"break\", \"byte\", \"case\", \"catch\", \"char\", \"class\",\n                    \"const\", \"continue\", \"default\", \"do\", \"double\", \"else\", \"enum\", \"extends\", \"final\",\n                    \"finally\", \"float\", \"for\", \"goto\", \"if\", \"implements\", \"import\", \"instanceof\", \"int\",\n                    \"interface\", \"long\", \"native\", \"new\", \"package\", \"private\", \"protected\", \"public\",\n                    \"return\", \"short\", \"static\", \"strictfp\", \"super\", \"switch\", \"synchronized\", \"this\",\n                    \"throw\", \"throws\", \"transient\", \"try\", \"void\", \"volatile\", \"while\", \"true\", \"false\", \"null\",\n                    \"var\", \"record\", \"sealed\", \"permits\", \"non-sealed\"\n                ],\n                keywordPatterns: [],\n                propertyPatterns: [],\n                typePatterns: [\n                    CapturePattern(pattern: \"\\\\b(?:boolean|byte|char|short|int|long|float|double|void|String|Object)\\\\b\", captureGroup: nil, options: []),\n                    CapturePattern(pattern: \"\\\\b([A-Z][A-Za-z0-9_]*)\\\\b\", captureGroup: 1, options: [])\n                ],\n                stringPatterns: cLikeStrings,\n                stringRegexOptions: [],\n                commentPatterns: cLikeComments,\n                commentRegexOptions: [.dotMatchesLineSeparators],\n                numberPattern: commonNumber,\n                numberRegexOptions: [],\n                keywordRegexOptions: [],\n                functionPatterns: [commonFunctionCall],\n                propertiesMayOverrideStrings: false\n            )\n\n        case .kotlin:\n            return LanguageRules(\n                keywords: [\n                    \"as\", \"break\", \"class\", \"continue\", \"do\", \"else\", \"false\", \"for\", \"fun\", \"if\", \"in\",\n                    \"interface\", \"is\", \"null\", \"object\", \"package\", \"return\", \"super\", \"this\", \"throw\",\n                    \"true\", \"try\", \"typealias\", \"val\", \"var\", \"when\", \"while\",\n                    \"by\", \"catch\", \"constructor\", \"delegate\", \"finally\", \"get\", \"import\", \"init\", \"set\", \"where\",\n                    \"actual\", \"abstract\", \"annotation\", \"companion\", \"const\", \"crossinline\", \"data\", \"enum\",\n                    \"expect\", \"external\", \"final\", \"infix\", \"inline\", \"inner\", \"internal\", \"lateinit\",\n                    \"noinline\", \"open\", \"operator\", \"out\", \"override\", \"private\", \"protected\", \"public\",\n                    \"reified\", \"sealed\", \"suspend\", \"tailrec\", \"vararg\"\n                ],\n                keywordPatterns: [],\n                propertyPatterns: [],\n                typePatterns: [\n                    CapturePattern(pattern: \"\\\\b(?:Int|Long|Short|Byte|Float|Double|Boolean|Char|String|Unit|Any|Nothing)\\\\b\", captureGroup: nil, options: []),\n                    CapturePattern(pattern: \"\\\\b([A-Z][A-Za-z0-9_]*)\\\\b\", captureGroup: 1, options: [])\n                ],\n                stringPatterns: [\"\\\"\\\"\\\"[\\\\s\\\\S]*?\\\"\\\"\\\"\", \"\\\"(?:[^\\\"\\\\\\\\\\\\n]|\\\\\\\\.)*\\\"\", \"'(?:[^'\\\\\\\\\\\\n]|\\\\\\\\.)*'\"],\n                stringRegexOptions: [.dotMatchesLineSeparators],\n                commentPatterns: cLikeComments,\n                commentRegexOptions: [.dotMatchesLineSeparators],\n                numberPattern: commonNumber,\n                numberRegexOptions: [],\n                keywordRegexOptions: [],\n                functionPatterns: [\n                    CapturePattern(pattern: \"\\\\bfun\\\\s+([A-Za-z_][A-Za-z0-9_]*)\\\\b\", captureGroup: 1, options: []),\n                    commonFunctionCall\n                ],\n                propertiesMayOverrideStrings: false\n            )\n\n        case .c:\n            return LanguageRules(\n                keywords: [\n                    \"auto\", \"break\", \"case\", \"char\", \"const\", \"continue\", \"default\", \"do\", \"double\", \"else\",\n                    \"enum\", \"extern\", \"float\", \"for\", \"goto\", \"if\", \"inline\", \"int\", \"long\", \"register\",\n                    \"restrict\", \"return\", \"short\", \"signed\", \"sizeof\", \"static\", \"struct\", \"switch\", \"typedef\",\n                    \"union\", \"unsigned\", \"void\", \"volatile\", \"while\", \"_Bool\", \"_Complex\", \"_Imaginary\"\n                ],\n                keywordPatterns: [],\n                propertyPatterns: [],\n                typePatterns: [\n                    CapturePattern(pattern: \"\\\\b(?:char|short|int|long|float|double|void|size_t|ssize_t|bool)\\\\b\", captureGroup: nil, options: []),\n                    CapturePattern(pattern: \"\\\\b([A-Z][A-Za-z0-9_]*)\\\\b\", captureGroup: 1, options: [])\n                ],\n                stringPatterns: cLikeStrings,\n                stringRegexOptions: [],\n                commentPatterns: cLikeComments,\n                commentRegexOptions: [.dotMatchesLineSeparators],\n                numberPattern: commonNumber,\n                numberRegexOptions: [],\n                keywordRegexOptions: [],\n                functionPatterns: [commonFunctionCall],\n                propertiesMayOverrideStrings: false\n            )\n\n        case .cpp:\n            return LanguageRules(\n                keywords: [\n                    \"alignas\", \"alignof\", \"and\", \"and_eq\", \"asm\", \"auto\", \"bitand\", \"bitor\", \"bool\", \"break\",\n                    \"case\", \"catch\", \"char\", \"char8_t\", \"char16_t\", \"char32_t\", \"class\", \"compl\", \"concept\",\n                    \"const\", \"consteval\", \"constexpr\", \"constinit\", \"continue\", \"co_await\", \"co_return\", \"co_yield\",\n                    \"default\", \"delete\", \"do\", \"double\", \"dynamic_cast\", \"else\", \"enum\", \"explicit\", \"export\", \"extern\",\n                    \"false\", \"float\", \"for\", \"friend\", \"goto\", \"if\", \"inline\", \"int\", \"long\", \"mutable\", \"namespace\",\n                    \"new\", \"noexcept\", \"not\", \"not_eq\", \"nullptr\", \"operator\", \"or\", \"or_eq\", \"private\", \"protected\",\n                    \"public\", \"register\", \"reinterpret_cast\", \"requires\", \"return\", \"short\", \"signed\", \"sizeof\",\n                    \"static\", \"static_assert\", \"static_cast\", \"struct\", \"switch\", \"template\", \"this\", \"thread_local\",\n                    \"throw\", \"true\", \"try\", \"typedef\", \"typeid\", \"typename\", \"union\", \"unsigned\", \"using\", \"virtual\",\n                    \"void\", \"volatile\", \"wchar_t\", \"while\", \"xor\", \"xor_eq\", \"final\", \"override\"\n                ],\n                keywordPatterns: [],\n                propertyPatterns: [],\n                typePatterns: [\n                    CapturePattern(pattern: \"\\\\b(?:bool|char|short|int|long|float|double|void|wchar_t|size_t|ssize_t|string|std::[A-Za-z0-9_:]+)\\\\b\", captureGroup: nil, options: []),\n                    CapturePattern(pattern: \"\\\\b([A-Z][A-Za-z0-9_]*)\\\\b\", captureGroup: 1, options: [])\n                ],\n                stringPatterns: cLikeStrings,\n                stringRegexOptions: [],\n                commentPatterns: cLikeComments,\n                commentRegexOptions: [.dotMatchesLineSeparators],\n                numberPattern: commonNumber,\n                numberRegexOptions: [],\n                keywordRegexOptions: [],\n                functionPatterns: [commonFunctionCall],\n                propertiesMayOverrideStrings: false\n            )\n\n        case .objc:\n            return LanguageRules(\n                keywords: [\n                    \"@interface\", \"@implementation\", \"@end\", \"@property\", \"@synthesize\", \"@dynamic\", \"@protocol\",\n                    \"@class\", \"@public\", \"@private\", \"@protected\", \"@package\",\n                    \"@try\", \"@catch\", \"@finally\", \"@throw\", \"@autoreleasepool\",\n                    \"@selector\", \"@encode\", \"@import\", \"@available\",\n                    \"if\", \"else\", \"for\", \"while\", \"switch\", \"case\", \"default\", \"break\", \"continue\", \"return\",\n                    \"struct\", \"typedef\", \"enum\", \"static\", \"const\", \"void\", \"int\", \"char\", \"float\", \"double\",\n                    \"BOOL\", \"YES\", \"NO\", \"nil\", \"self\", \"super\"\n                ],\n                keywordPatterns: [],\n                propertyPatterns: [],\n                typePatterns: [\n                    CapturePattern(pattern: \"\\\\b(?:id|instancetype|SEL|Class|BOOL|NSInteger|NSUInteger|CGFloat|NSString|NSNumber|NSArray|NSDictionary|NSData|NSDate|NSURL|NSError)\\\\b\", captureGroup: nil, options: []),\n                    CapturePattern(pattern: \"\\\\b([A-Z][A-Za-z0-9_]*)\\\\b\", captureGroup: 1, options: [])\n                ],\n                stringPatterns: cLikeStrings + [\"@\\\"(?:[^\\\"\\\\\\\\\\\\n]|\\\\\\\\.)*\\\"\"],\n                stringRegexOptions: [],\n                commentPatterns: cLikeComments,\n                commentRegexOptions: [.dotMatchesLineSeparators],\n                numberPattern: commonNumber,\n                numberRegexOptions: [],\n                keywordRegexOptions: [],\n                functionPatterns: [commonFunctionCall],\n                propertiesMayOverrideStrings: false\n            )\n\n        // MARK: HTML / XML\n\n        case .html:\n            return LanguageRules(\n                keywords: [\"DOCTYPE\"],\n                // HTML tag names in keyword-blue\n                keywordPatterns: [\n                    CapturePattern(pattern: \"</?\\\\s*([A-Za-z][A-Za-z0-9:-]*)\", captureGroup: 1, options: []),\n                    CapturePattern(pattern: \"<!DOCTYPE\\\\b\", captureGroup: nil, options: [.caseInsensitive])\n                ],\n                // HTML attribute names in property-blue\n                propertyPatterns: [\n                    CapturePattern(pattern: \"\\\\b([A-Za-z_:][A-Za-z0-9:._-]*)(?=\\\\s*=)\", captureGroup: 1, options: [])\n                ],\n                typePatterns: [],\n                stringPatterns: [\"\\\"(?:[^\\\"\\\\\\\\\\\\n]|\\\\\\\\.)*\\\"\", \"'(?:[^'\\\\\\\\\\\\n]|\\\\\\\\.)*'\"],\n                stringRegexOptions: [],\n                commentPatterns: [\"<!--[\\\\s\\\\S]*?-->\"],\n                commentRegexOptions: [.dotMatchesLineSeparators],\n                numberPattern: commonNumber,\n                numberRegexOptions: [],\n                keywordRegexOptions: [.caseInsensitive],\n                functionPatterns: [],\n                propertiesMayOverrideStrings: false\n            )\n\n        case .xml:\n            return LanguageRules(\n                keywords: [\"xml\", \"version\", \"encoding\", \"CDATA\"],\n                keywordPatterns: [\n                    CapturePattern(pattern: \"</?\\\\s*([A-Za-z_][A-Za-z0-9:._-]*)\", captureGroup: 1, options: [])\n                ],\n                propertyPatterns: [\n                    CapturePattern(pattern: \"\\\\b([A-Za-z_:][A-Za-z0-9:._-]*)(?=\\\\s*=)\", captureGroup: 1, options: [])\n                ],\n                typePatterns: [],\n                stringPatterns: [\"\\\"(?:[^\\\"\\\\\\\\\\\\n]|\\\\\\\\.)*\\\"\", \"'(?:[^'\\\\\\\\\\\\n]|\\\\\\\\.)*'\"],\n                stringRegexOptions: [],\n                commentPatterns: [\"<!--[\\\\s\\\\S]*?-->\", \"<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?\\\\]\\\\]>\"],\n                commentRegexOptions: [.dotMatchesLineSeparators],\n                numberPattern: commonNumber,\n                numberRegexOptions: [],\n                keywordRegexOptions: [.caseInsensitive],\n                functionPatterns: [],\n                propertiesMayOverrideStrings: false\n            )\n\n        // MARK: CSS / SCSS / LESS\n\n        case .css:\n            return LanguageRules(\n                keywords: [\"@import\", \"@media\", \"@supports\", \"@keyframes\", \"@font-face\", \"@page\", \"@layer\", \"important\"],\n                keywordPatterns: [],\n                propertyPatterns: [\n                    // property-name: value\n                    CapturePattern(pattern: \"\\\\b([A-Za-z_-][A-Za-z0-9_-]*)\\\\s*(?=:)\", captureGroup: 1, options: [])\n                ],\n                // selectors\n                typePatterns: [\n                    CapturePattern(pattern: \"(?:\\\\.|#)([A-Za-z_-][A-Za-z0-9_-]*)\\\\b\", captureGroup: 1, options: []),\n                    CapturePattern(pattern: \"\\\\b([A-Za-z_-][A-Za-z0-9_-]*)\\\\b(?=\\\\s*\\\\{)\", captureGroup: 1, options: [])\n                ],\n                stringPatterns: [\"\\\"(?:[^\\\"\\\\\\\\\\\\n]|\\\\\\\\.)*\\\"\", \"'(?:[^'\\\\\\\\\\\\n]|\\\\\\\\.)*'\"],\n                stringRegexOptions: [],\n                commentPatterns: [\"/\\\\*[\\\\s\\\\S]*?\\\\*/\"],\n                commentRegexOptions: [.dotMatchesLineSeparators],\n                numberPattern: \"\\\\b\\\\d[\\\\d_]*(?:\\\\.\\\\d[\\\\d_]*)?(?:%|px|em|rem|vw|vh|vmin|vmax|fr|ch|ex|cm|mm|in|pt|pc)?\\\\b\",\n                numberRegexOptions: [],\n                keywordRegexOptions: [.caseInsensitive],\n                functionPatterns: [\n                    // CSS function calls: rgb(…), var(…), etc.\n                    CapturePattern(pattern: \"\\\\b([A-Za-z_-][A-Za-z0-9_-]*)\\\\s*(?=\\\\()\", captureGroup: 1, options: [])\n                ],\n                propertiesMayOverrideStrings: false\n            )\n\n        case .scss:\n            let css = languageRules(for: .css)\n            return LanguageRules(\n                keywords: css.keywords + [\"@mixin\", \"@include\", \"@extend\", \"@function\", \"@return\", \"@if\", \"@else\", \"@for\", \"@each\", \"@while\", \"@use\", \"@forward\"],\n                keywordPatterns: css.keywordPatterns,\n                propertyPatterns: css.propertyPatterns + [\n                    // $variables\n                    CapturePattern(pattern: \"\\\\$[A-Za-z_-][A-Za-z0-9_-]*\", captureGroup: nil, options: [])\n                ],\n                typePatterns: css.typePatterns,\n                stringPatterns: css.stringPatterns,\n                stringRegexOptions: css.stringRegexOptions,\n                commentPatterns: [\"/\\\\*[\\\\s\\\\S]*?\\\\*/\", \"//[^\\\\n]*\"],\n                commentRegexOptions: [.dotMatchesLineSeparators],\n                numberPattern: css.numberPattern,\n                numberRegexOptions: css.numberRegexOptions,\n                keywordRegexOptions: [.caseInsensitive],\n                functionPatterns: css.functionPatterns + [\n                    // @mixin name( / @function name(\n                    CapturePattern(pattern: \"@(?:mixin|function)\\\\s+([A-Za-z_-][A-Za-z0-9_-]*)\", captureGroup: 1, options: [.caseInsensitive])\n                ],\n                propertiesMayOverride

>>>TOOL read_file
{"path":"Extensions/NSAttributedStringSyntaxHighlighter.swift","start_line":1,"end_line":260}
>>>END

>>>TOOL search
{"query":"case .html", "glob":"Extensions/NSAttributedStringSyntaxHighlighter.swift"}
>>>END
>>>TOOL search
{"query":"case .css", "glob":"Extensions/NSAttributedStringSyntaxHighlighter.swift"}
>>>END
>>>TOOL search
{"query":"case .json", "glob":"Extensions/NSAttributedStringSyntaxHighlighter.swift"}
>>>END
>>>TOOL search
{"query":"case .markdown", "glob":"Extensions/NSAttributedStringSyntaxHighlighter.swift"}
>>>END
>>>END

>>>TOOL read_file
{"path":"Extensions/NSAttributedStringSyntaxHighlighter.swift","start_line":640,"end_line":820}
>>>END

>>>TOOL search
{"query":"private struct LanguageRules", "glob":"Extensions/NSAttributedStringSyntaxHighlighter.swift"}
>>>END
>>>TOOL search
{"query":"private static func highlight(code: String, language: SyntaxLanguage", "glob":"Extensions/NSAttributedStringSyntaxHighlighter.swift"}
>>>END
>>>TOOL search
{"query":"enum SyntaxLanguage", "glob":"Extensions/NSAttributedStringSyntaxHighlighter.swift"}
>>>END
>>>TOOL search
{"query":"case \"less\"", "glob":"Extensions/NSAttributedStringSyntaxHighlighter.swift"}
>>>END
>>>END

>>>TOOL read_file
{"path":"Extensions/NSAttributedStringSyntaxHighlighter.swift","start_line":1,"end_line":60}
>>>END>>>TOOL read_file
{"path":"Extensions/NSAttributedStringSyntaxHighlighter.swift","start_line":1,"end_line":80}
>>>END

>>>TOOL read_file
{"path":"Extensions/NSAttributedStringSyntaxHighlighter.swift","start_line":118,"end_line":240}
>>>END

>>>TOOL read_file
{"path":"Extensions/NSAttributedStringSyntaxHighlighter.swift","start_line":80,"end_line":180}
>>>END

>>>TOOL read_file
{"path":"Extensions/NSAttributedStringSyntaxHighlighter.swift"}
>>>END

>>>TOOL search
{"query":"case .html", "glob":"Extensions/NSAttributedStringSyntaxHighlighter.swift"}
>>>END
>>>TOOL search
{"query":"final class NSAttributedStringSyntaxHighlighter", "glob":"Extensions/NSAttributedStringSyntaxHighlighter.swift"}
>>>END
>>>TOOL read_file
{"path":"Extensions/NSAttributedStringSyntaxHighlighter.swift","start_line":1,"end_line":40}
>>>END

>>>TOOL read_file
{"path":"Extensions/NSAttributedStringSyntaxHighlighter.swift","start_line":1,"end_line":40}
>>>END

>>>TOOL create_file
{"path":"Extensions/NSAttributedStringSyntaxHighlighter.swift","content":"import SwiftUI\nimport UIKit\n\n// Efficient NSMutableAttributedString-based syntax highlighter (regex-based).\n//\n// Theme: VS Code Dark+ (approx)\n// Token colors used:\n// - keyword:   #569CD6\n// - type:      #4EC9B0\n// - property:  #9CDCFE\n// - string:    #CE9178\n// - comment:   #6A9955\n// - number:    #B5CEA8\n// - function:  #DCDCAA\n// - default:   #D4D4D4\nfinal class NSAttributedStringSyntaxHighlighter {\n\n    // MARK: - Language\n\n    // NOTE: This file cannot use the name `Language` because the project already defines a global `Language`\n    // enum elsewhere.\n    enum SyntaxLanguage {\n        case swift, javascript, typescript, jsx, tsx\n        case python, ruby, go, rust\n        case java, kotlin\n        case c, cpp, objc\n        case html, css, scss, less\n        case json, xml, yaml\n        case sql, shell, dockerfile, graphql\n        case markdown, php, dotenv\n        case plainText\n    }\n\n    // MARK: - Colors (VS Code Dark+)\n\n    private extension UIColor {\n        convenience init(vscodeHex: UInt32, alpha: CGFloat = 1.0) {\n            let r = CGFloat((vscodeHex >> 16) & 0xFF) / 255.0\n            let g = CGFloat((vscodeHex >> 8) & 0xFF) / 255.0\n            let b = CGFloat(vscodeHex & 0xFF) / 255.0\n            self.init(red: r, green: g, blue: b, alpha: alpha)\n        }\n    }\n\n    private struct ColorScheme {\n        static let keyword = UIColor(vscodeHex: 0x569CD6)\n        static let type = UIColor(vscodeHex: 0x4EC9B0)\n        static let property = UIColor(vscodeHex: 0x9CDCFE)\n        static let string = UIColor(vscodeHex: 0xCE9178)\n        static let comment = UIColor(vscodeHex: 0x6A9955)\n        static let number = UIColor(vscodeHex: 0xB5CEA8)\n        static let function = UIColor(vscodeHex: 0xDCDCAA)\n        static let defaultText = UIColor(vscodeHex: 0xD4D4D4)\n    }\n\n    // MARK: - Public API\n\n    /// Backwards-compatible entrypoint (defaults to Swift).\n    static func highlightCode(_ code: String) -> NSAttributedString {\n        highlightCode(code, filename: nil, language: .swift)\n    }\n\n    /// Highlights `code` using either an explicit `language` or a detected one from `filename`.\n    static func highlightCode(_ code: String, filename: String? = nil, language: SyntaxLanguage? = nil) -> NSAttributedString {\n        let attributed = NSMutableAttributedString(string: code)\n        let fullRange = NSRange(location: 0, length: code.utf16.count)\n\n        attributed.addAttributes([\n            .font: UIFont.monospacedSystemFont(ofSize: 14, weight: .regular),\n            .foregroundColor: ColorScheme.defaultText\n        ], range: fullRange)\n\n        let resolvedLanguage: SyntaxLanguage = {\n            if let language { return language }\n            if let filename { return detectLanguage(fromFilename: filename) }\n            return .plainText\n        }()\n\n        highlight(code: code, language: resolvedLanguage, into: attributed)\n        return attributed\n    }\n\n    // MARK: - Language detection\n\n    private static func detectLanguage(fromFilename filename: String) -> SyntaxLanguage {\n        let lower = filename.lowercased()\n        let base = (lower as NSString).lastPathComponent\n        let ext = (base as NSString).pathExtension\n\n        if base == \"dockerfile\" || base.hasPrefix(\"dockerfile.\") { return .dockerfile }\n        if base == \".env\" || base.hasPrefix(\".env.\") || ext == \"env\" { return .dotenv }\n\n        switch ext {\n        case \"swift\": return .swift\n        case \"js\", \"mjs\", \"cjs\": return .javascript\n        case \"jsx\": return .jsx\n        case \"ts\": return .typescript\n        case \"tsx\": return .tsx\n        case \"py\", \"pyw\": return .python\n        case \"rb\", \"ruby\": return .ruby\n        case \"go\": return .go\n        case \"rs\": return .rust\n        case \"java\": return .java\n        case \"kt\", \"kts\": return .kotlin\n        case \"c\": return .c\n        case \"cc\", \"cpp\", \"cxx\", \"hpp\", \"hh\", \"hxx\", \"h\": return .cpp\n        case \"m\", \"mm\": return .objc\n        case \"html\", \"htm\": return .html\n        case \"css\": return .css\n        case \"scss\", \"sass\": return .scss\n        case \"less\": return .less\n        case \"json\", \"jsonc\": return .json\n        case \"xml\", \"plist\", \"svg\": return .xml\n        case \"yml\", \"yaml\": return .yaml\n        case \"sql\": return .sql\n        case \"sh\", \"bash\", \"zsh\", \"fish\": return .shell\n        case \"php\": return .php\n        case \"gql\", \"graphql\": return .graphql\n        case \"md\", \"markdown\": return .markdown\n        default: return .plainText\n        }\n    }\n\n    // MARK: - Regex rule model\n\n    private struct CapturePattern {\n        let pattern: String\n        let captureGroup: Int?\n        let options: NSRegularExpression.Options\n\n        init(_ pattern: String, captureGroup: Int? = nil, options: NSRegularExpression.Options = []) {\n            self.pattern = pattern\n            self.captureGroup = captureGroup\n            self.options = options\n        }\n    }\n\n    private struct LanguageRules {\n        // Word-based keywords (built into one \\b(?:...|...)\\b regex)\n        let keywords: [String]\n\n        // Regex keywords (e.g., Markdown headings, HTML tags)\n        let keywordPatterns: [CapturePattern]\n\n        // Property-ish tokens (e.g., JSON/YAML keys, CSS properties, HTML attribute names)\n        let propertyPatterns: [CapturePattern]\n\n        let typePatterns: [CapturePattern]\n        let stringPatterns: [String]\n        let stringRegexOptions: NSRegularExpression.Options\n        let commentPatterns: [String]\n        let commentRegexOptions: NSRegularExpression.Options\n        let numberPattern: String?\n        let numberRegexOptions: NSRegularExpression.Options\n        let keywordRegexOptions: NSRegularExpression.Options\n        let functionPatterns: [CapturePattern]\n\n        // If true, `propertyPatterns` are allowed to recolor inside string ranges.\n        let propertiesMayOverrideStrings: Bool\n    }\n\n    // MARK: - Pipeline\n\n    private static func highlight(code: String, language: SyntaxLanguage, into attributed: NSMutableAttributedString) {\n        let rules = languageRules(for: language)\n\n        // 1) Strings first\n        let stringRanges = rules.stringPatterns.flatMap { pattern in\n            applyHighlighting(\n                pattern: pattern,\n                options: rules.stringRegexOptions,\n                color: ColorScheme.string,\n                to: attributed,\n                in: code,\n                captureGroup: nil,\n                excluding: []\n            )\n        }\n\n        // 2) Comments (exclude matches inside strings)\n        let commentRanges = rules.commentPatterns.flatMap { pattern in\n            applyHighlighting(\n                pattern: pattern,\n                options: rules.commentRegexOptions,\n                color: ColorScheme.comment,\n                to: attributed,\n                in: code,\n                captureGroup: nil,\n                excluding: stringRanges\n            )\n        }\n\n        let protectedRanges = stringRanges + commentRanges\n\n        // 3) Numbers\n        if let numberPattern = rules.numberPattern {\n            _ = applyHighlighting(\n                pattern: numberPattern,\n                options: rules.numberRegexOptions,\n                color: ColorScheme.number,\n                to: attributed,\n                in: code,\n                captureGroup: nil,\n                excluding: protectedRanges\n            )\n        }\n\n        // 4) Properties (JSON/YAML keys, CSS props, HTML attrs)\n        let propertyExclusions = rules.propertiesMayOverrideStrings ? commentRanges : protectedRanges\n        for p in rules.propertyPatterns {\n            _ = applyHighlighting(\n                pattern: p.pattern,\n                options: p.options,\n                color: ColorScheme.property,\n                to: attributed,\n                in: code,\n                captureGroup: p.captureGroup,\n                excluding: propertyExclusions\n            )\n        }\n\n        // 5) Types\n        for t in rules.typePatterns {\n            _ = applyHighlighting(\n                pattern: t.pattern,\n                options: t.options,\n                color: ColorScheme.type,\n                to: attributed,\n                in: code,\n                captureGroup: t.captureGroup,\n                excluding: protectedRanges\n            )\n        }\n\n        // 6) Keywords (word list)\n        if !rules.keywords.isEmpty {\n            let keywordPattern = \"\\\\b(?:\" + rules.keywords.map(NSRegularExpression.escapedPattern).joined(separator: \"|\") + \")\\\\b\"\n            _ = applyHighlighting(\n                pattern: keywordPattern,\n                options: rules.keywordRegexOptions,\n                color: ColorScheme.keyword,\n                to: attributed,\n                in: code,\n                captureGroup: nil,\n                excluding: protectedRanges\n            )\n        }\n\n        // 7) Keywords (regex patterns)\n        for k in rules.keywordPatterns {\n            _ = applyHighlighting(\n                pattern: k.pattern,\n                options: k.options,\n                color: ColorScheme.keyword,\n                to: attributed,\n                in: code,\n                captureGroup: k.captureGroup,\n                excluding: protectedRanges\n            )\n        }\n\n        // 8) Functions\n        for fn in rules.functionPatterns {\n            _ = applyHighlighting(\n                pattern: fn.pattern,\n                options: fn.options,\n                color: ColorScheme.function,\n                to: attributed,\n                in: code,\n                captureGroup: fn.captureGroup,\n                excluding: protectedRanges\n            )\n        }\n    }\n\n    // MARK: - Language rules\n\n    private static func languageRules(for language: SyntaxLanguage) -> LanguageRules {\n        // Common number literal (hex/dec/float/exponent, underscores)\n        let commonNumber = \"\\\\b(?:0x[0-9A-Fa-f_]+|\\\\d[\\\\d_]*(?:\\\\.\\\\d[\\\\d_]*)?(?:[eE][+-]?\\\\d[\\\\d_]*)?)\\\\b\"\n\n        let cLikeStrings = [\n            \"\\\"(?:[^\\\"\\\\\\\\\\\\n]|\\\\\\\\.)*\\\"\",\n            \"'(?:[^'\\\\\\\\\\\\n]|\\\\\\\\.)*'\"\n        ]\n\n        let cLikeComments = [\n            \"//[^\\\\n]*\",\n            \"/\\\\*[\\\\s\\\\S]*?\\\\*/\"\n        ]\n\n        let commonFunctionCall = CapturePattern(\"\\\\b([A-Za-z_][A-Za-z0-9_]*)\\\\s*(?=\\\\()\", captureGroup: 1)\n\n        func clike(keywords: [String]) -> LanguageRules {\n            LanguageRules(\n                keywords: keywords,\n                keywordPatterns: [],\n                propertyPatterns: [],\n                typePatterns: [CapturePattern(\"\\\\b([A-Z][A-Za-z0-9_]*)\\\\b\", captureGroup: 1)],\n                stringPatterns: cLikeStrings,\n                stringRegexOptions: [],\n                commentPatterns: cLikeComments,\n                commentRegexOptions: [.dotMatchesLineSeparators],\n                numberPattern: commonNumber,\n                numberRegexOptions: [],\n                keywordRegexOptions: [],\n                functionPatterns: [commonFunctionCall],\n                propertiesMayOverrideStrings: false\n            )\n        }\n\n        switch language {\n        case .html:\n            // HTML tag highlighting:\n            // - tag name: </?\\s*TAG\n            // - attribute name: attrName=\n            // - values: handled by stringPatterns\n            // - comments: <!-- -->\n            return LanguageRules(\n                keywords: [],\n                keywordPatterns: [\n                    CapturePattern(\"</?\\\\s*([A-Za-z][A-Za-z0-9:-]*)\", captureGroup: 1),\n                    CapturePattern(\"<!DOCTYPE\\\\b\", options: [.caseInsensitive])\n                ],\n                propertyPatterns: [\n                    CapturePattern(\"\\\\b([A-Za-z_:][A-Za-z0-9:._-]*)(?=\\\\s*=)\", captureGroup: 1)\n                ],\n                typePatterns: [],\n                stringPatterns: cLikeStrings,\n                stringRegexOptions: [],\n                commentPatterns: [\"<!--[\\\\s\\\\S]*?-->\"],\n                commentRegexOptions: [.dotMatchesLineSeparators],\n                numberPattern: commonNumber,\n                numberRegexOptions: [],\n                keywordRegexOptions: [],\n                functionPatterns: [],\n                propertiesMayOverrideStrings: false\n            )\n\n        case .css:\n            // CSS / property highlighting:\n            // - selectors: .class, #id, elementName{  => type color\n            // - properties: name: => property color\n            // - at-rules: @media, @import, ... => keyword color\n            // - hex colors + unit numbers => number color\n            let cssNumber = \"\\\\b(?:\\\\d[\\\\d_]*(?:\\\\.\\\\d[\\\\d_]*)?(?:%|px|em|rem|vw|vh|vmin|vmax|fr|ch|ex|cm|mm|in|pt|pc)?|#(?:[0-9A-Fa-f]{3,4}|[0-9A-Fa-f]{6}|[0-9A-Fa-f]{8}))\\\\b\"\n            return LanguageRules(\n                keywords: [\"important\"],\n                keywordPatterns: [\n                    CapturePattern(\"(?<![A-Za-z0-9_-])(@(?:import|media|supports|keyframes|font-face|page|layer))\\\\b\", captureGroup: 1, options: [.caseInsensitive])\n                ],\n                propertyPatterns: [\n                    CapturePattern(\"\\\\b([A-Za-z_-][A-Za-z0-9_-]*)\\\\s*(?=:)\", captureGroup: 1)\n                ],\n                typePatterns: [\n                    CapturePattern(\"(?:\\\\.|#)([A-Za-z_-][A-Za-z0-9_-]*)\\\\b\", captureGroup: 1),\n                    CapturePattern(\"\\\\b([A-Za-z_-][A-Za-z0-9_-]*)\\\\b(?=\\\\s*\\\\{)\", captureGroup: 1)\n                ],\n                stringPatterns: cLikeStrings,\n                stringRegexOptions: [],\n                commentPatterns: [\"/\\\\*[\\\\s\\\\S]*?\\\\*/\"],\n                commentRegexOptions: [.dotMatchesLineSeparators],\n                numberPattern: cssNumber,\n                numberRegexOptions: [],\n                keywordRegexOptions: [.caseInsensitive],\n                functionPatterns: [\n                    // CSS function calls: var(…), rgb(…), url(…)\n                    CapturePattern(\"\\\\b([A-Za-z_-][A-Za-z0-9_-]*)\\\\s*(?=\\\\()\", captureGroup: 1)\n                ],\n                propertiesMayOverrideStrings: false\n            )\n\n        case .scss:\n            let css = languageRules(for: .css)\n            return LanguageRules(\n                keywords: css.keywords + [\n                    \"mixin\", \"include\", \"extend\", \"function\", \"return\", \"if\", \"else\", \"for\", \"each\", \"while\", \"use\", \"forward\"\n                ],\n                keywordPatterns: css.keywordPatterns + [\n                    CapturePattern(\"(?<![A-Za-z0-9_-])(@(?:mixin|include|extend|function|return|if|else|for|each|while|use|forward))\\\\b\", captureGroup: 1, options: [.caseInsensitive])\n                ],\n                propertyPatterns: css.propertyPatterns + [\n                    // $variables\n                    CapturePattern(\"(\\\\$[A-Za-z_-][A-Za-z0-9_-]*)\", captureGroup: 1)\n                ],\n                typePatterns: css.typePatterns,\n                stringPatterns: css.stringPatterns,\n                stringRegexOptions: css.stringRegexOptions,\n                commentPatterns: css.commentPatterns + [\"//[^\\\\n]*\"],\n                commentRegexOptions: [.dotMatchesLineSeparators],\n                numberPattern: css.numberPattern,\n                numberRegexOptions: css.numberRegexOptions,\n                keywordRegexOptions: [.caseInsensitive],\n                functionPatterns: css.functionPatterns + [\n                    CapturePattern(\"@(?:mixin|function)\\\\s+([A-Za-z_-][A-Za-z0-9_-]*)\", captureGroup: 1, options: [.caseInsensitive])\n                ],\n                propertiesMayOverrideStrings: false\n            )\n\n        case .less:\n            // LESS = CSS + @variables + mixin calls (.mixin())\n            let css = languageRules(for: .css)\n            return LanguageRules(\n                keywords: css.keywords,\n                keywordPatterns: css.keywordPatterns,\n                propertyPatterns: css.propertyPatterns + [\n                    CapturePattern(\"(@[A-Za-z_-][A-Za-z0-9_-]*)\", captureGroup: 1)\n                ],\n                typePatterns: css.typePatterns,\n                stringPatterns: css.stringPatterns,\n                stringRegexOptions: css.stringRegexOptions,\n                commentPatterns: css.commentPatterns,\n                commentRegexOptions: css.commentRegexOptions,\n                numberPattern: css.numberPattern,\n                numberRegexOptions: css.numberRegexOptions,\n                keywordRegexOptions: css.keywordRegexOptions,\n                functionPatterns: css.functionPatterns + [\n                    // .mixinName(\n                    CapturePattern(\"\\\\.([A-Za-z_-][A-Za-z0-9_-]*)\\\\s*(?=\\\\()\", captureGroup: 1)\n                ],\n                propertiesMayOverrideStrings: false\n            )\n\n        case .json:\n            // JSON key/value highlighting:\n            // - strings => string color\n            // - keys => property color (overrides string color) via capture group 1\n            //   pattern: (\"...\")\\s*:\n            let jsonString = \"\\\"(?:[^\\\"\\\\\\\\\\\\n]|\\\\\\\\.)*\\\"\"\n            return LanguageRules(\n                keywords: [\"true\", \"false\", \"null\"],\n                keywordPatterns: [],\n                propertyPatterns: [\n                    CapturePattern(\"(\\\"(?:[^\\\"\\\\\\\\\\\\n]|\\\\\\\\.)*\\\")\\\\s*:\", captureGroup: 1)\n                ],\n                typePatterns: [],\n                stringPatterns: [jsonString],\n                stringRegexOptions: [],\n                // Support jsonc-style comments\n                commentPatterns: [\"//[^\\\\n]*\", \"/\\\\*[\\\\s\\\\S]*?\\\\*/\"],\n                commentRegexOptions: [.dotMatchesLineSeparators],\n                numberPattern: commonNumber,\n                numberRegexOptions: [],\n                keywordRegexOptions: [],\n                functionPatterns: [],\n                propertiesMayOverrideStrings: true\n            )\n\n        case .yaml:\n            // YAML key/value highlighting:\n            // - keys in mappings: ^\\s*KEY\\s*:\n            // - anchors/aliases: &name, *name => type color\n            let yamlKey = \"^\\\\s*(\\\"(?:[^\\\"\\\\\\\\\\\\n]|\\\\\\\\.)*\\\"|'(?:[^'\\\\\\\\\\\\n]|\\\\\\\\.)*'|[A-Za-z0-9_./-]+)\\\\s*:(?=\\\\s|$)\"\n            return LanguageRules(\n                keywords: [\"true\", \"false\", \"null\", \"yes\", \"no\", \"on\", \"off\"],\n                keywordPatterns: [],\n                propertyPatterns: [\n                    CapturePattern(yamlKey, captureGroup: 1, options: [.anchorsMatchLines])\n                ],\n                typePatterns: [\n                    CapturePattern(\"([&*][A-Za-z0-9_-]+)\", captureGroup: 1)\n                ],\n                stringPatterns: cLikeStrings,\n                stringRegexOptions: [],\n                commentPatterns: [\"#[^\\\\n]*\"],\n                commentRegexOptions: [],\n                numberPattern: commonNumber,\n                numberRegexOptions: [],\n                keywordRegexOptions: [.caseInsensitive],\n                functionPatterns: [],\n                propertiesMayOverrideStrings: true\n            )\n\n        case .sql:\n            return LanguageRules(\n                keywords: [\n                    \"select\", \"from\", \"where\", \"group\", \"by\", \"having\", \"order\", \"limit\", \"offset\",\n                    \"insert\", \"into\", \"values\", \"update\", \"set\", \"delete\",\n                    \"join\", \"inner\", \"left\", \"right\", \"full\", \"outer\", \"cross\", \"on\",\n                    \"as\", \"distinct\", \"union\", \"all\", \"and\", \"or\", \"not\", \"null\", \"is\", \"in\", \"exists\", \"like\", \"between\",\n                    \"create\", \"alter\", \"drop\", \"table\", \"view\", \"index\", \"primary\", \"key\", \"foreign\", \"references\",\n                    \"case\", \"when\", \"then\", \"else\", \"end\",\n                    \"begin\", \"commit\", \"rollback\"\n                ],\n                keywordPatterns: [],\n                propertyPatterns: [],\n                typePatterns: [\n                    CapturePattern(\"\\\\b(?:int|integer|smallint|bigint|serial|bigserial|decimal|numeric|real|double|float|money|boolean|bool|date|time|timestamp|timestamptz|varchar|char|text|uuid|json|jsonb)\\\\b\", options: [.caseInsensitive])\n                ],\n                stringPatterns: [\"'(?:''|[^'])*'\", \"\\\"(?:\\\"\\\"|[^\\\"])*\\\"\"],\n                stringRegexOptions: [],\n                commentPatterns: [\"--[^\\\\n]*\", \"/\\\\*[\\\\s\\\\S]*?\\\\*/\"],\n                commentRegexOptions: [.dotMatchesLineSeparators],\n                numberPattern: commonNumber,\n                numberRegexOptions: [],\n                keywordRegexOptions: [.caseInsensitive],\n                functionPatterns: [\n                    CapturePattern(\"\\\\b([A-Za-z_][A-Za-z0-9_]*)\\\\s*(?=\\\\()\", captureGroup: 1, options: [.caseInsensitive])\n                ],\n                propertiesMayOverrideStrings: false\n            )\n\n        case .markdown:\n            // Markdown highlighting:\n            // - inline/fenced code treated as strings\n            // - headings/list markers/blockquote markers treated as keywords\n            return LanguageRules(\n                keywords: [],\n                keywordPatterns: [\n                    CapturePattern(\"^\\\\s{0,3}(#{1,6})\\\\s+.*$\", captureGroup: 1, options: [.anchorsMatchLines]),\n                    CapturePattern(\"^\\\\s*>\\\\s?\", options: [.anchorsMatchLines]),\n                    CapturePattern(\"^\\\\s*(?:[-*+]|\\\\d+\\\\.)\\\\s+\", options: [.anchorsMatchLines]),\n                    CapturePattern(\"(?:\\\\*\\\\*|__|\\\\*|_)\")\n                ],\n                propertyPatterns: [],\n                typePatterns: [],\n                stringPatterns: [\n                    \"```[\\\\s\\\\S]*?```\",\n                    \"~~~[\\\\s\\\\S]*?~~~\",\n                    \"`[^`\\\\n]+`\"\n                ],\n                stringRegexOptions: [.dotMatchesLineSeparators],\n                commentPatterns: [\"<!--[\\\\s\\\\S]*?-->\"],\n                commentRegexOptions: [.dotMatchesLineSeparators],\n                numberPattern: nil,\n                numberRegexOptions: [],\n                keywordRegexOptions: [],\n                functionPatterns: [],\n                propertiesMayOverrideStrings: false\n            )\n\n        // --- Minimal fallbacks for other languages (not the focus of this task) ---\n        case .xml:\n            return languageRules(for: .html)\n        case .swift:\n            return clike(keywords: [\n                \"func\", \"var\", \"let\", \"if\", \"else\", \"for\", \"while\", \"switch\", \"case\", \"default\", \"return\",\n                \"class\", \"struct\", \"enum\", \"protocol\", \"extension\", \"import\", \"true\", \"false\", \"nil\"\n            ])\n        case .javascript:\n            return clike(keywords: [\n                \"break\", \"case\", \"catch\", \"class\", \"const\", \"continue\", \"default\", \"delete\", \"do\", \"else\",\n                \"export\", \"extends\", \"finally\", \"for\", \"function\", \"if\", \"import\", \"in\", \"instanceof\", \"let\",\n                \"new\", \"return\", \"super\", \"switch\", \"this\", \"throw\", \"try\", \"typeof\", \"var\", \"void\", \"while\",\n                \"with\", \"yield\", \"async\", \"await\", \"true\", \"false\", \"null\", \"undefined\"\n            ])\n        case .typescript:\n            return clike(keywords: [\n                \"break\", \"case\", \"catch\", \"class\", \"const\", \"continue\", \"default\", \"delete\", \"do\", \"else\",\n                \"export\", \"extends\", \"finally\", \"for\", \"function\", \"if\", \"import\", \"in\", \"instanceof\", \"let\",\n                \"new\", \"return\", \"super\", \"switch\", \"this\", \"throw\", \"try\", \"typeof\", \"var\", \"void\", \"while\",\n                \"with\", \"yield\", \"async\", \"await\", \"true\", \"false\", \"null\", \"undefined\",\n                \"interface\", \"type\", \"enum\", \"implements\", \"namespace\", \"readonly\", \"private\", \"protected\", \"public\"\n            ])\n        case .jsx:\n            return languageRules(for: .javascript)\n        case .tsx:\n            return languageRules(for: .typescript)\n        case .python:\n            return LanguageRules(\n                keywords: [\"def\", \"class\", \"if\", \"elif\", \"else\", \"for\", \"while\", \"return\", \"import\", \"from\", \"as\", \"try\", \"except\", \"finally\", \"True\", \"False\", \"None\"],\n                keywordPatterns: [],\n                propertyPatterns: [],\n                typePatterns: [],\n                stringPatterns: [\n                    \"'''[\\\\s\\\\S]*?'''\",\n                    \"\\\"\\\"\\\"[\\\\s\\\\S]*?\\\"\\\"\\\"\",\n                    \"(?i)\\\\b(?:r|u|f|fr|rf|b|br|rb)?'(?:[^'\\\\\\\\\\\\n]|\\\\\\\\.)*'\",\n                    \"(?i)\\\\b(?:r|u|f|fr|rf|b|br|rb)?\\\"(?:[^\\\"\\\\\\\\\\\\n]|\\\\\\\\.)*\\\"\"\n                ],\n                stringRegexOptions: [.dotMatchesLineSeparators],\n                commentPatterns: [\"#[^\\\\n]*\"],\n                commentRegexOptions: [],\n                numberPattern: commonNumber,\n                numberRegexOptions: [],\n                keywordRegexOptions: [],\n                functionPatterns: [CapturePattern(\"\\\\bdef\\\\s+([A-Za-z_][A-Za-z0-9_]*)\\\\b\", captureGroup: 1), commonFunctionCall],\n                propertiesMayOverrideStrings: false\n            )\n        case .ruby:\n            return clike(keywords: [\"def\", \"class\", \"module\", \"if\", \"elsif\", \"else\", \"end\", \"do\", \"while\", \"for\", \"in\", \"true\", \"false\", \"nil\", \"return\"])\n        case .go:\n            return clike(keywords: [\"func\", \"package\", \"import\", \"return\", \"if\", \"else\", \"for\", \"range\", \"type\", \"struct\", \"interface\", \"var\", \"const\", \"true\", \"false\", \"nil\"])\n        case .rust:\n            return clike(keywords: [\"fn\", \"let\", \"mut\", \"pub\", \"struct\", \"enum\", \"impl\", \"trait\", \"use\", \"mod\", \"match\", \"if\", \"else\", \"loop\", \"while\", \"for\", \"in\", \"return\", \"true\", \"false\"])\n        case .java:\n            return clike(keywords: [\"class\", \"interface\", \"enum\", \"public\", \"private\", \"protected\", \"static\", \"final\", \"void\", \"int\", \"boolean\", \"return\", \"if\", \"else\", \"for\", \"while\", \"switch\", \"case\", \"new\", \"null\", \"true\", \"false\"])\n        case .kotlin:\n            return clike(keywords: [\"fun\", \"class\", \"object\", \"interface\", \"val\", \"var\", \"return\", \"if\", \"else\", \"for\", \"while\", \"when\", \"null\", \"true\", \"false\"])\n        case .c:\n            return clike(keywords: [\"int\", \"char\", \"void\", \"return\", \"if\", \"else\", \"for\", \"while\", \"switch\", \"case\", \"struct\", \"typedef\", \"static\", \"const\"])\n        case .cpp:\n            return clike(keywords: [\"class\", \"struct\", \"namespace\", \"template\", \"typename\", \"using\", \"auto\", \"const\", \"constexpr\", \"return\", \"if\", \"else\", \"for\", \"while\", \"switch\", \"case\", \"true\", \"false\", \"nullptr\"])\n        case .objc:\n            return clike(keywords: [\"@interface\", \"@implementation\", \"@end\", \"@property\", \"@selector\", \"if\", \"else\", \"for\", \"while\", \"return\", \"nil\", \"YES\", \"NO\"])\n        case .shell:\n            return LanguageRules(\n                keywords: [\"if\", \"then\", \"elif\", \"else\", \"fi\", \"for\", \"in\", \"do\", \"done\", \"case\", \"esac\", \"while\", \"until\", \"function\", \"return\", \"exit\", \"export\"],\n                keywordPatterns: [],\n                propertyPatterns: [],\n                typePatterns: [],\n                stringPatterns: cLikeStrings + [\"\\\\$'(?:[^'\\\\\\\\\\\\n]|\\\\\\\\.)*'\"],\n                stringRegexOptions: [],\n                commentPatterns: [\"#[^\\\\n]*\"],\n                commentRegexOptions: [],\n                numberPattern: commonNumber,\n                numberRegexOptions: [],\n                keywordRegexOptions: [],\n                functionPatterns: [CapturePattern(\"\\\\b([A-Za-z_][A-Za-z0-9_]*)\\\\s*\\\\(\\\\s*\\\\)\\\\s*\\\\{\", captureGroup: 1), commonFunctionCall],\n                propertiesMayOverrideStrings: false\n            )\n        case .dockerfile:\n            return LanguageRules(\n                keywords: [\"FROM\", \"RUN\", \"CMD\", \"LABEL\", \"EXPOSE\", \"ENV\", \"ADD\", \"COPY\", \"ENTRYPOINT\", \"VOLUME\", \"USER\", \"WORKDIR\", \"ARG\", \"ONBUILD\", \"SHELL\"],\n                keywordPatterns: [],\n                propertyPatterns: [],\n                typePatterns: [],\n                stringPatterns: cLikeStrings,\n                stringRegexOptions: [],\n                commentPatterns: [\"#[^\\\\n]*\"],\n                commentRegexOptions: [],\n                numberPattern: commonNumber,\n                numberRegexOptions: [],\n                keywordRegexOptions: [.caseInsensitive],\n                functionPatterns: [],\n                propertiesMayOverrideStrings: false\n            )\n        case .graphql:\n            return LanguageRules(\n                keywords: [\"query\", \"mutation\", \"subscription\", \"fragment\", \"on\", \"schema\", \"type\", \"interface\", \"union\", \"enum\", \"input\", \"extend\", \"directive\", \"implements\", \"scalar\", \"true\", \"false\", \"null\"],\n                keywordPatterns: [],\n                propertyPatterns: [],\n                typePatterns: [CapturePattern(\"\\\\b([A-Z][A-Za-z0-9_]*)\\\\b\", captureGroup: 1)],\n                stringPatterns: [\"\\\"\\\"\\\"[\\\\s\\\\S]*?\\\"\\\"\\\"\", \"\\\"(?:[^\\\"\\\\\\\\\\\\n]|\\\\\\\\.)*\\\"\"],\n                stringRegexOptions: [.dotMatchesLineSeparators],\n                commentPatterns: [\"#[^\\\\n]*\"],\n                commentRegexOptions: [],\n                numberPattern: commonNumber,\n                numberRegexOptions: [],\n                keywordRegexOptions: [],\n                functionPatterns: [],\n                propertiesMayOverrideStrings: false\n            )\n        case .php:\n            return clike(keywords: [\"function\", \"class\", \"public\", \"private\", \"protected\", \"static\", \"return\", \"if\", \"else\", \"elseif\", \"for\", \"foreach\", \"while\", \"try\", \"catch\", \"true\", \"false\", \"null\"])\n        case .dotenv:\n            return LanguageRules(\n                keywords: [],\n                keywordPatterns: [],\n                propertyPatterns: [CapturePattern(\"^\\\\s*(?:export\\\\s+)?([A-Za-z_][A-Za-z0-9_]*)\\\\s*(?==)\", captureGroup: 1, options: [.anchorsMatchLines])],\n                typePatterns: [],\n               

>>>TOOL read_file
{"path":"Extensions/NSAttributedStringSyntaxHighlighter.swift","start_line":1,"end_line":120}
>>>END

>>>TOOL read_file
{"path":"Extensions/NSAttributedStringSyntaxHighlighter.swift"}
>>>END

>>>TOOL create_file
{"path":"Extensions/NSAttributedStringSyntaxHighlighter.swift","content":"import SwiftUI\nimport UIKit\n\n// Efficient NSMutableAttributedString-based syntax highlighter (regex-based).\n//\n// VS Code Dark+ token colors (approx):\n// - keyword:  #569CD6\n// - type:     #4EC9B0\n// - property: #9CDCFE\n// - string:   #CE9178\n// - comment:  #6A9955\n// - number:   #B5CEA8\n// - function: #DCDCAA\n// - default:  #D4D4D4\nfinal class NSAttributedStringSyntaxHighlighter {\n\n    // MARK: - Language\n\n    // NOTE: This file cannot use the name `Language` because the project already defines a global `Language` enum elsewhere.\n    enum SyntaxLanguage {\n        case swift, javascript, typescript, jsx, tsx\n        case python, ruby, go, rust\n        case java, kotlin\n        case c, cpp, objc\n        case html, css, scss, less\n        case json, xml, yaml\n        case sql, shell, dockerfile, graphql\n        case markdown, php, dotenv\n        case plainText\n    }\n\n    // MARK: - Colors (VS Code Dark+)\n\n    private extension UIColor {\n        convenience init(vscodeHex: UInt32, alpha: CGFloat = 1.0) {\n            let r = CGFloat((vscodeHex >> 16) & 0xFF) / 255.0\n            let g = CGFloat((vscodeHex >> 8) & 0xFF) / 255.0\n            let b = CGFloat(vscodeHex & 0xFF) / 255.0\n            self.init(red: r, green: g, blue: b, alpha: alpha)\n        }\n    }\n\n    private struct ColorScheme {\n        static let keyword = UIColor(vscodeHex: 0x569CD6)\n        static let type = UIColor(vscodeHex: 0x4EC9B0)\n        static let property = UIColor(vscodeHex: 0x9CDCFE)\n        static let string = UIColor(vscodeHex: 0xCE9178)\n        static let comment = UIColor(vscodeHex: 0x6A9955)\n        static let number = UIColor(vscodeHex: 0xB5CEA8)\n        static let function = UIColor(vscodeHex: 0xDCDCAA)\n        static let defaultText = UIColor(vscodeHex: 0xD4D4D4)\n    }\n\n    // MARK: - Public API\n\n    static func highlightCode(_ code: String) -> NSAttributedString {\n        highlightCode(code, filename: nil, language: .swift)\n    }\n\n    static func highlightCode(_ code: String, filename: String? = nil, language: SyntaxLanguage? = nil) -> NSAttributedString {\n        let attributed = NSMutableAttributedString(string: code)\n        let fullRange = NSRange(location: 0, length: code.utf16.count)\n\n        attributed.addAttributes([\n            .font: UIFont.monospacedSystemFont(ofSize: 14, weight: .regular),\n            .foregroundColor: ColorScheme.defaultText\n        ], range: fullRange)\n\n        let resolvedLanguage: SyntaxLanguage = {\n            if let language { return language }\n            if let filename { return detectLanguage(fromFilename: filename) }\n            return .plainText\n        }()\n\n        highlight(code: code, language: resolvedLanguage, into: attributed)\n        return attributed\n    }\n\n    // MARK: - Language detection\n\n    private static func detectLanguage(fromFilename filename: String) -> SyntaxLanguage {\n        let lower = filename.lowercased()\n        let base = (lower as NSString).lastPathComponent\n        let ext = (base as NSString).pathExtension\n\n        if base == \"dockerfile\" || base.hasPrefix(\"dockerfile.\") { return .dockerfile }\n        if base == \".env\" || base.hasPrefix(\".env.\") || ext == \"env\" { return .dotenv }\n\n        switch ext {\n        case \"swift\": return .swift\n        case \"js\", \"mjs\", \"cjs\": return .javascript\n        case \"jsx\": return .jsx\n        case \"ts\": return .typescript\n        case \"tsx\": return .tsx\n        case \"py\", \"pyw\": return .python\n        case \"rb\", \"ruby\": return .ruby\n        case \"go\": return .go\n        case \"rs\": return .rust\n        case \"java\": return .java\n        case \"kt\", \"kts\": return .kotlin\n        case \"c\": return .c\n        case \"cc\", \"cpp\", \"cxx\", \"hpp\", \"hh\", \"hxx\", \"h\": return .cpp\n        case \"m\", \"mm\": return .objc\n        case \"html\", \"htm\": return .html\n        case \"css\": return .css\n        case \"scss\", \"sass\": return .scss\n        case \"less\": return .less\n        case \"json\", \"jsonc\": return .json\n        case \"xml\", \"plist\", \"svg\": return .xml\n        case \"yml\", \"yaml\": return .yaml\n        case \"sql\": return .sql\n        case \"sh\", \"bash\", \"zsh\", \"fish\": return .shell\n        case \"php\": return .php\n        case \"gql\", \"graphql\": return .graphql\n        case \"md\", \"markdown\": return .markdown\n        default: return .plainText\n        }\n    }\n\n    // MARK: - Pipeline\n\n    private struct CapturePattern {\n        let pattern: String\n        let captureGroup: Int?\n        let options: NSRegularExpression.Options\n\n        init(_ pattern: String, captureGroup: Int? = nil, options: NSRegularExpression.Options = []) {\n            self.pattern = pattern\n            self.captureGroup = captureGroup\n            self.options = options\n        }\n    }\n\n    private struct LanguageRules {\n        let keywords: [String]\n        let keywordPatterns: [CapturePattern]\n        let propertyPatterns: [CapturePattern]\n        let typePatterns: [CapturePattern]\n        let stringPatterns: [String]\n        let stringRegexOptions: NSRegularExpression.Options\n        let commentPatterns: [String]\n        let commentRegexOptions: NSRegularExpression.Options\n        let numberPattern: String?\n        let numberRegexOptions: NSRegularExpression.Options\n        let keywordRegexOptions: NSRegularExpression.Options\n        let functionPatterns: [CapturePattern]\n        let propertiesMayOverrideStrings: Bool\n    }\n\n    private static func highlight(code: String, language: SyntaxLanguage, into attributed: NSMutableAttributedString) {\n        let rules = languageRules(for: language)\n\n        // 1) Strings first\n        let stringRanges = rules.stringPatterns.flatMap { pattern in\n            applyHighlighting(\n                pattern: pattern,\n                options: rules.stringRegexOptions,\n                color: ColorScheme.string,\n                to: attributed,\n                in: code,\n                captureGroup: nil,\n                excluding: []\n            )\n        }\n\n        // 2) Comments (exclude matches inside strings)\n        let commentRanges = rules.commentPatterns.flatMap { pattern in\n            applyHighlighting(\n                pattern: pattern,\n                options: rules.commentRegexOptions,\n                color: ColorScheme.comment,\n                to: attributed,\n                in: code,\n                captureGroup: nil,\n                excluding: stringRanges\n            )\n        }\n\n        let protectedRanges = stringRanges + commentRanges\n\n        // 3) Numbers\n        if let numberPattern = rules.numberPattern {\n            _ = applyHighlighting(\n                pattern: numberPattern,\n                options: rules.numberRegexOptions,\n                color: ColorScheme.number,\n                to: attributed,\n                in: code,\n                captureGroup: nil,\n                excluding: protectedRanges\n            )\n        }\n\n        // 4) Property-like tokens (JSON/YAML keys, CSS props, HTML attrs)\n        let propertyExclusions = rules.propertiesMayOverrideStrings ? commentRanges : protectedRanges\n        for p in rules.propertyPatterns {\n            _ = applyHighlighting(\n                pattern: p.pattern,\n                options: p.options,\n                color: ColorScheme.property,\n                to: attributed,\n                in: code,\n                captureGroup: p.captureGroup,\n                excluding: propertyExclusions\n            )\n        }\n\n        // 5) Types\n        for t in rules.typePatterns {\n            _ = applyHighlighting(\n                pattern: t.pattern,\n                options: t.options,\n                color: ColorScheme.type,\n                to: attributed,\n                in: code,\n                captureGroup: t.captureGroup,\n                excluding: protectedRanges\n            )\n        }\n\n        // 6) Keywords (word list)\n        if !rules.keywords.isEmpty {\n            let keywordPattern = \"\\\\b(?:\" + rules.keywords.map(NSRegularExpression.escapedPattern).joined(separator: \"|\") + \")\\\\b\"\n            _ = applyHighlighting(\n                pattern: keywordPattern,\n                options: rules.keywordRegexOptions,\n                color: ColorScheme.keyword,\n                to: attributed,\n                in: code,\n                captureGroup: nil,\n                excluding: protectedRanges\n            )\n        }\n\n        // 7) Keywords (regex)\n        for k in rules.keywordPatterns {\n            _ = applyHighlighting(\n                pattern: k.pattern,\n                options: k.options,\n                color: ColorScheme.keyword,\n                to: attributed,\n                in: code,\n                captureGroup: k.captureGroup,\n                excluding: protectedRanges\n            )\n        }\n\n        // 8) Functions\n        for fn in rules.functionPatterns {\n            _ = applyHighlighting(\n                pattern: fn.pattern,\n                options: fn.options,\n                color: ColorScheme.function,\n                to: attributed,\n                in: code,\n                captureGroup: fn.captureGroup,\n                excluding: protectedRanges\n            )\n        }\n    }\n\n    // MARK: - Language rules\n\n    private static func languageRules(for language: SyntaxLanguage) -> LanguageRules {\n        let commonNumber = \"\\\\b(?:0x[0-9A-Fa-f_]+|\\\\d[\\\\d_]*(?:\\\\.\\\\d[\\\\d_]*)?(?:[eE][+-]?\\\\d[\\\\d_]*)?)\\\\b\"\n\n        let cLikeStrings = [\n            \"\\\"(?:[^\\\"\\\\\\\\\\\\n]|\\\\\\\\.)*\\\"\",\n            \"'(?:[^'\\\\\\\\\\\\n]|\\\\\\\\.)*'\"\n        ]\n\n        let cLikeComments = [\n            \"//[^\\\\n]*\",\n            \"/\\\\*[\\\\s\\\\S]*?\\\\*/\"\n        ]\n\n        let commonFunctionCall = CapturePattern(\"\\\\b([A-Za-z_][A-Za-z0-9_]*)\\\\s*(?=\\\\()\", captureGroup: 1)\n\n        switch language {\n\n        // MARK: HTML tag highlighting\n        case .html:\n            return LanguageRules(\n                keywords: [],\n                keywordPatterns: [\n                    // Tag name in <tag ...> or </tag>\n                    CapturePattern(\"</?\\\\s*([A-Za-z][A-Za-z0-9:-]*)\", captureGroup: 1),\n                    // <!DOCTYPE\n                    CapturePattern(\"<!DOCTYPE\\\\b\", options: [.caseInsensitive])\n                ],\n                propertyPatterns: [\n                    // Attribute names: attrName=\n                    CapturePattern(\"\\\\b([A-Za-z_:][A-Za-z0-9:._-]*)(?=\\\\s*=)\", captureGroup: 1)\n                ],\n                typePatterns: [],\n                stringPatterns: cLikeStrings,\n                stringRegexOptions: [],\n                commentPatterns: [\"<!--[\\\\s\\\\S]*?-->\"],\n                commentRegexOptions: [.dotMatchesLineSeparators],\n                numberPattern: commonNumber,\n                numberRegexOptions: [],\n                keywordRegexOptions: [],\n                functionPatterns: [],\n                propertiesMayOverrideStrings: false\n            )\n\n        // MARK: CSS / SCSS / LESS\n        case .css:\n            let cssNumber = \"\\\\b(?:\\\\d[\\\\d_]*(?:\\\\.\\\\d[\\\\d_]*)?(?:%|px|em|rem|vw|vh|vmin|vmax|fr|ch|ex|cm|mm|in|pt|pc)?|#(?:[0-9A-Fa-f]{3,4}|[0-9A-Fa-f]{6}|[0-9A-Fa-f]{8}))\\\\b\"\n            return LanguageRules(\n                keywords: [\"important\"],\n                keywordPatterns: [\n                    // @media, @import, ...\n                    CapturePattern(\"(?<![A-Za-z0-9_-])(@(?:import|media|supports|keyframes|font-face|page|layer))\\\\b\", captureGroup: 1, options: [.caseInsensitive])\n                ],\n                propertyPatterns: [\n                    // propertyName:\n                    CapturePattern(\"\\\\b([A-Za-z_-][A-Za-z0-9_-]*)\\\\s*(?=:)\", captureGroup: 1)\n                ],\n                typePatterns: [\n                    // .class and #id\n                    CapturePattern(\"(?:\\\\.|#)([A-Za-z_-][A-Za-z0-9_-]*)\\\\b\", captureGroup: 1),\n                    // element selector before { (rough)\n                    CapturePattern(\"\\\\b([A-Za-z_-][A-Za-z0-9_-]*)\\\\b(?=\\\\s*\\\\{)\", captureGroup: 1)\n                ],\n                stringPatterns: cLikeStrings,\n                stringRegexOptions: [],\n                commentPatterns: [\"/\\\\*[\\\\s\\\\S]*?\\\\*/\"],\n                commentRegexOptions: [.dotMatchesLineSeparators],\n                numberPattern: cssNumber,\n                numberRegexOptions: [],\n                keywordRegexOptions: [.caseInsensitive],\n                functionPatterns: [\n                    // rgb(...), var(...), url(...)\n                    CapturePattern(\"\\\\b([A-Za-z_-][A-Za-z0-9_-]*)\\\\s*(?=\\\\()\", captureGroup: 1)\n                ],\n                propertiesMayOverrideStrings: false\n            )\n\n        case .scss:\n            let css = languageRules(for: .css)\n            return LanguageRules(\n                keywords: css.keywords,\n                keywordPatterns: css.keywordPatterns + [\n                    // SCSS directives\n                    CapturePattern(\"(?<![A-Za-z0-9_-])(@(?:mixin|include|extend|function|return|if|else|for|each|while|use|forward))\\\\b\", captureGroup: 1, options: [.caseInsensitive])\n                ],\n                propertyPatterns: css.propertyPatterns + [\n                    // $variable\n                    CapturePattern(\"(\\\\$[A-Za-z_-][A-Za-z0-9_-]*)\", captureGroup: 1)\n                ],\n                typePatterns: css.typePatterns,\n                stringPatterns: css.stringPatterns,\n                stringRegexOptions: css.stringRegexOptions,\n                commentPatterns: css.commentPatterns + [\"//[^\\\\n]*\"],\n                commentRegexOptions: [.dotMatchesLineSeparators],\n                numberPattern: css.numberPattern,\n                numberRegexOptions: css.numberRegexOptions,\n                keywordRegexOptions: css.keywordRegexOptions,\n                functionPatterns: css.functionPatterns + [\n                    // @mixin name(...) / @function name(...)\n                    CapturePattern(\"@(?:mixin|function)\\\\s+([A-Za-z_-][A-Za-z0-9_-]*)\", captureGroup: 1, options: [.caseInsensitive])\n                ],\n                propertiesMayOverrideStrings: false\n            )\n\n        case .less:\n            let css = languageRules(for: .css)\n            return LanguageRules(\n                keywords: css.keywords,\n                keywordPatterns: css.keywordPatterns,\n                propertyPatterns: css.propertyPatterns + [\n                    // @variable\n                    CapturePattern(\"(@[A-Za-z_-][A-Za-z0-9_-]*)\", captureGroup: 1)\n                ],\n                typePatterns: css.typePatterns,\n                stringPatterns: css.stringPatterns,\n                stringRegexOptions: css.stringRegexOptions,\n                commentPatterns: css.commentPatterns + [\"//[^\\\\n]*\"],\n                commentRegexOptions: [.dotMatchesLineSeparators],\n                numberPattern: css.numberPattern,\n                numberRegexOptions: css.numberRegexOptions,\n                keywordRegexOptions: css.keywordRegexOptions,\n                functionPatterns: css.functionPatterns + [\n                    // .mixinName(\n                    CapturePattern(\"\\\\.([A-Za-z_-][A-Za-z0-9_-]*)\\\\s*(?=\\\\()\", captureGroup: 1)\n                ],\n                propertiesMayOverrideStrings: false\n            )\n\n        // MARK: JSON key/value highlighting\n        case .json:\n            let jsonString = \"\\\"(?:[^\\\"\\\\\\\\\\\\n]|\\\\\\\\.)*\\\"\"\n            return LanguageRules(\n                keywords: [\"true\", \"false\", \"null\"],\n                keywordPatterns: [],\n                propertyPatterns: [\n                    // Key string before colon: \"key\":\n                    CapturePattern(\"(\\\"(?:[^\\\"\\\\\\\\\\\\n]|\\\\\\\\.)*\\\")\\\\s*:\", captureGroup: 1)\n                ],\n                typePatterns: [],\n                stringPatterns: [jsonString],\n                stringRegexOptions: [],\n                // jsonc comments\n                commentPatterns: [\"//[^\\\\n]*\", \"/\\\\*[\\\\s\\\\S]*?\\\\*/\"],\n                commentRegexOptions: [.dotMatchesLineSeparators],\n                numberPattern: commonNumber,\n                numberRegexOptions: [],\n                keywordRegexOptions: [],\n                functionPatterns: [],\n                propertiesMayOverrideStrings: true\n            )\n\n        // MARK: Markdown\n        case .markdown:\n            return LanguageRules(\n                keywords: [],\n                keywordPatterns: [\n                    // Heading markers\n                    CapturePattern(\"^\\\\s{0,3}(#{1,6})(?=\\\\s)\", captureGroup: 1, options: [.anchorsMatchLines]),\n                    // Blockquote markers\n                    CapturePattern(\"^\\\\s{0,3}>\\\\s?\", options: [.anchorsMatchLines]),\n                    // List markers\n                    CapturePattern(\"^\\\\s*(?:[-*+]|\\\\d+\\\\.)\\\\s+\", options: [.anchorsMatchLines]),\n                    // Emphasis markers (rough)\n                    CapturePattern(\"(?:\\\\*\\\\*|__|\\\\*|_)\")\n                ],\n                propertyPatterns: [],\n                typePatterns: [],\n                stringPatterns: [\n                    // Fenced / inline code\n                    \"```[\\\\s\\\\S]*?```\",\n                    \"~~~[\\\\s\\\\S]*?~~~\",\n                    \"`[^`\\\\n]+`\"\n                ],\n                stringRegexOptions: [.dotMatchesLineSeparators],\n                commentPatterns: [\"<!--[\\\\s\\\\S]*?-->\"],\n                commentRegexOptions: [.dotMatchesLineSeparators],\n                numberPattern: nil,\n                numberRegexOptions: [],\n                keywordRegexOptions: [],\n                functionPatterns: [],\n                propertiesMayOverrideStrings: false\n            )\n\n        // MARK: YAML\n        case .yaml:\n            let yamlKey = \"^\\\\s*(\\\"(?:[^\\\"\\\\\\\\\\\\n]|\\\\\\\\.)*\\\"|'(?:[^'\\\\\\\\\\\\n]|\\\\\\\\.)*'|[A-Za-z0-9_./-]+)\\\\s*:(?=\\\\s|$)\"\n            return LanguageRules(\n                keywords: [\"true\", \"false\", \"null\", \"yes\", \"no\", \"on\", \"off\"],\n                keywordPatterns: [],\n                propertyPatterns: [\n                    // Key before colon (quoted or unquoted)\n                    CapturePattern(yamlKey, captureGroup: 1, options: [.anchorsMatchLines])\n                ],\n                typePatterns: [\n                    // Anchors & aliases\n                    CapturePattern(\"([&*][A-Za-z0-9_-]+)\", captureGroup: 1)\n                ],\n                stringPatterns: cLikeStrings,\n                stringRegexOptions: [],\n                commentPatterns: [\"#[^\\\\n]*\"],\n                commentRegexOptions: [],\n                numberPattern: commonNumber,\n                numberRegexOptions: [],\n                keywordRegexOptions: [.caseInsensitive],\n                functionPatterns: [],\n                propertiesMayOverrideStrings: true\n            )\n\n        // MARK: SQL\n        case .sql:\n            return LanguageRules(\n                keywords: [\n                    \"select\", \"from\", \"where\", \"group\", \"by\", \"having\", \"order\", \"limit\", \"offset\",\n                    \"insert\", \"into\", \"values\", \"update\", \"set\", \"delete\",\n                    \"join\", \"inner\", \"left\", \"right\", \"full\", \"outer\", \"cross\", \"on\",\n                    \"as\", \"distinct\", \"union\", \"all\", \"and\", \"or\", \"not\", \"null\", \"is\", \"in\", \"exists\", \"like\", \"between\",\n                    \"create\", \"alter\", \"drop\", \"table\", \"view\", \"index\", \"primary\", \"key\", \"foreign\", \"references\",\n                    \"case\", \"when\", \"then\", \"else\", \"end\",\n                    \"begin\", \"commit\", \"rollback\"\n                ],\n                keywordPatterns: [],\n                propertyPatterns: [],\n                typePatterns: [\n                    CapturePattern(\"\\\\b(?:int|integer|smallint|bigint|serial|bigserial|decimal|numeric|real|double|float|money|boolean|bool|date|time|timestamp|timestamptz|varchar|char|text|uuid|json|jsonb)\\\\b\", options: [.caseInsensitive])\n                ],\n                stringPatterns: [\"'(?:''|[^'])*'\", \"\\\"(?:\\\"\\\"|[^\\\"])*\\\"\"],\n                stringRegexOptions: [],\n                commentPatterns: [\"--[^\\\\n]*\", \"/\\\\*[\\\\s\\\\S]*?\\\\*/\"],\n                commentRegexOptions: [.dotMatchesLineSeparators],\n                numberPattern: commonNumber,\n                numberRegexOptions: [],\n                keywordRegexOptions: [.caseInsensitive],\n                functionPatterns: [\n                    CapturePattern(\"\\\\b([A-Za-z_][A-Za-z0-9_]*)\\\\s*(?=\\\\()\", captureGroup: 1, options: [.caseInsensitive])\n                ],\n                propertiesMayOverrideStrings: false\n            )\n\n        // --- fallback minimal rules ---\n        default:\n            return LanguageRules(\n                keywords: [],\n                keywordPatterns: [],\n                propertyPatterns: [],\n                typePatterns: [],\n                stringPatterns: [],\n                stringRegexOptions: [],\n                commentPatterns: [],\n                commentRegexOptions: [],\n                numberPattern: nil,\n                numberRegexOptions: [],\n                keywordRegexOptions: [],\n                functionPatterns: [],\n                propertiesMayOverrideStrings: false\n            )\n        }\n    }\n\n    // MARK: - Regex helpers\n\n    @discardableResult\n    private static func applyHighlighting(\n        pattern: String,\n        options: NSRegularExpression.Options,\n        color: UIColor,\n        to attributedString: NSMutableAttributedString,\n        in text: String,\n        captureGroup: Int?,\n        excluding excludedRanges: [NSRange]\n    ) -> [NSRange] {\n        do {\n            let regex = try NSRegularExpression(pattern: pattern, options: options)\n            let matches = regex.matches(in: text, options: [], range: NSRange(location: 0, length: text.utf16.count))\n\n            var applied: [NSRange] = []\n            applied.reserveCapacity(matches.count)\n\n            for match in matches {\n                let range: NSRange = {\n                    if let captureGroup, captureGroup <= match.numberOfRanges - 1 {\n                        return match.range(at: captureGroup)\n                    }\n                    return match.range\n                }()\n\n                guard range.location != NSNotFound, range.length > 0 else { continue }\n                if intersectsAny(range, excludedRanges) { continue }\n\n                attributedString.addAttribute(.foregroundColor, value: color, range: range)\n                applied.append(range)\n            }\n\n            return applied\n        } catch {\n            print(\"Regex error for pattern \\(pattern): \\(error)\")\n            return []\n        }\n    }\n\n    private static func intersectsAny(_ range: NSRange, _ excludedRanges: [NSRange]) -> Bool {\n        for ex in excludedRanges where NSIntersectionRange(range, ex).length > 0 {\n            return true\n        }\n        return false\n    }\n}\n\n// SwiftUI wrapper for NSAttributedString\nstruct AttributedTextView: UIViewRepresentable {\n    let attributedText: NSAttributedString\n\n    func makeUIView(context: Context) -> UITextView {\n        let textView = UITextView()\n        textView.isEditable = false\n        textView.isSelectable = true\n        textView.backgroundColor = .clear\n        textView.textContainerInset = UIEdgeInsets(top: 8, left: 8, bottom: 8, right: 8)\n        return textView\n    }\n\n    func updateUIView(_ uiView: UITextView, context: Context) {\n        uiView.attributedText = attributedText\n    }\n}\n\nextension View {\n    func syntaxHighlighted(\n        code: String,\n        filename: String? = nil,\n        language: NSAttributedStringSyntaxHighlighter.SyntaxLanguage? = nil\n    ) -> some View {\n        AttributedTextView(attributedText: NSAttributedStringSyntaxHighlighter.highlightCode(code, filename: filename, language: language))\n    }\n}\n"} 
>>>END

>>>TOOL create_file
{"path":"Extensions/NSAttributedStringSyntaxHighlighter.swift","content":"import SwiftUI\nimport UIKit\n\n// Efficient NSMutableAttributedString-based syntax highlighter (regex-based).\n//\n// VS Code Dark+ token colors (approx):\n// - keyword:  #569CD6\n// - type:     #4EC9B0\n// - property: #9CDCFE\n// - string:   #CE9178\n// - comment:  #6A9955\n// - number:   #B5CEA8\n// - function: #DCDCAA\n// - default:  #D4D4D4\nfinal class NSAttributedStringSyntaxHighlighter {\n\n    // MARK: - Language\n\n    // NOTE: This file cannot use the name `Language` because the project already defines a global `Language` enum elsewhere.\n    enum SyntaxLanguage {\n        case swift, javascript, typescript, jsx, tsx\n        case python, ruby, go, rust\n        case java, kotlin\n        case c, cpp, objc\n        case html, css, scss, less\n        case json, xml, yaml\n        case sql, shell, dockerfile, graphql\n        case markdown, php, dotenv\n        case plainText\n    }\n\n    // MARK: - Colors (VS Code Dark+)\n\n    private extension UIColor {\n        convenience init(vscodeHex: UInt32, alpha: CGFloat = 1.0) {\n            let r = CGFloat((vscodeHex >> 16) & 0xFF) / 255.0\n            let g = CGFloat((vscodeHex >> 8) & 0xFF) / 255.0\n            let b = CGFloat(vscodeHex & 0xFF) / 255.0\n            self.init(red: r, green: g, blue: b, alpha: alpha)\n        }\n    }\n\n    private struct ColorScheme {\n        static let keyword = UIColor(vscodeHex: 0x569CD6)\n        static let type = UIColor(vscodeHex: 0x4EC9B0)\n        static let property = UIColor(vscodeHex: 0x9CDCFE)\n        static let string = UIColor(vscodeHex: 0xCE9178)\n        static let comment = UIColor(vscodeHex: 0x6A9955)\n        static let number = UIColor(vscodeHex: 0xB5CEA8)\n        static let function = UIColor(vscodeHex: 0xDCDCAA)\n        static let defaultText = UIColor(vscodeHex: 0xD4D4D4)\n    }\n\n    // MARK: - Public API\n\n    static func highlightCode(_ code: String) -> NSAttributedString {\n        highlightCode(code, filename: nil, language: .swift)\n    }\n\n    static func highlightCode(_ code: String, filename: String? = nil, language: SyntaxLanguage? = nil) -> NSAttributedString {\n        let attributed = NSMutableAttributedString(string: code)\n        let fullRange = NSRange(location: 0, length: code.utf16.count)\n\n        attributed.addAttributes([\n            .font: UIFont.monospacedSystemFont(ofSize: 14, weight: .regular),\n            .foregroundColor: ColorScheme.defaultText\n        ], range: fullRange)\n\n        let resolvedLanguage: SyntaxLanguage = {\n            if let language { return language }\n            if let filename { return detectLanguage(fromFilename: filename) }\n            return .plainText\n        }()\n\n        highlight(code: code, language: resolvedLanguage, into: attributed)\n        return attributed\n    }\n\n    // MARK: - Language detection\n\n    private static func detectLanguage(fromFilename filename: String) -> SyntaxLanguage {\n        let lower = filename.lowercased()\n        let base = (lower as NSString).lastPathComponent\n        let ext = (base as NSString).pathExtension\n\n        if base == \"dockerfile\" || base.hasPrefix(\"dockerfile.\") { return .dockerfile }\n        if base == \".env\" || base.hasPrefix(\".env.\") || ext == \"env\" { return .dotenv }\n\n        switch ext {\n        case \"swift\": return .swift\n        case \"js\", \"mjs\", \"cjs\": return .javascript\n        case \"jsx\": return .jsx\n        case \"ts\": return .typescript\n        case \"tsx\": return .tsx\n        case \"py\", \"pyw\": return .python\n        case \"rb\", \"ruby\": return .ruby\n        case \"go\": return .go\n        case \"rs\": return .rust\n        case \"java\": return .java\n        case \"kt\", \"kts\": return .kotlin\n        case \"c\": return .c\n        case \"cc\", \"cpp\", \"cxx\", \"hpp\", \"hh\", \"hxx\", \"h\": return .cpp\n        case \"m\", \"mm\": return .objc\n        case \"html\", \"htm\": return .html\n        case \"css\": return .css\n        case \"scss\", \"sass\": return .scss\n        case \"less\": return .less\n        case \"json\", \"jsonc\": return .json\n        case \"xml\", \"plist\", \"svg\": return .xml\n        case \"yml\", \"yaml\": return .yaml\n        case \"sql\": return .sql\n        case \"sh\", \"bash\", \"zsh\", \"fish\": return .shell\n        case \"php\": return .php\n        case \"gql\", \"graphql\": return .graphql\n        case \"md\", \"markdown\": return .markdown\n        default: return .plainText\n        }\n    }\n\n    // MARK: - Pipeline\n\n    private struct CapturePattern {\n        let pattern: String\n        let captureGroup: Int?\n        let options: NSRegularExpression.Options\n\n        init(_ pattern: String, captureGroup: Int? = nil, options: NSRegularExpression.Options = []) {\n            self.pattern = pattern\n            self.captureGroup = captureGroup\n            self.options = options\n        }\n    }\n\n    private struct LanguageRules {\n        let keywords: [String]\n        let keywordPatterns: [CapturePattern]\n        let propertyPatterns: [CapturePattern]\n        let typePatterns: [CapturePattern]\n        let stringPatterns: [String]\n        let stringRegexOptions: NSRegularExpression.Options\n        let commentPatterns: [String]\n        let commentRegexOptions: NSRegularExpression.Options\n        let numberPattern: String?\n        let numberRegexOptions: NSRegularExpression.Options\n        let keywordRegexOptions: NSRegularExpression.Options\n        let functionPatterns: [CapturePattern]\n        let propertiesMayOverrideStrings: Bool\n    }\n\n    private static func highlight(code: String, language: SyntaxLanguage, into attributed: NSMutableAttributedString) {\n        let rules = languageRules(for: language)\n\n        // 1) Strings first\n        let stringRanges = rules.stringPatterns.flatMap { pattern in\n            applyHighlighting(\n                pattern: pattern,\n                options: rules.stringRegexOptions,\n                color: ColorScheme.string,\n                to: attributed,\n                in: code,\n                captureGroup: nil,\n                excluding: []\n            )\n        }\n\n        // 2) Comments (exclude matches inside strings)\n        let commentRanges = rules.commentPatterns.flatMap { pattern in\n            applyHighlighting(\n                pattern: pattern,\n                options: rules.commentRegexOptions,\n                color: ColorScheme.comment,\n                to: attributed,\n                in: code,\n                captureGroup: nil,\n                excluding: stringRanges\n            )\n        }\n\n        let protectedRanges = stringRanges + commentRanges\n\n        // 3) Numbers\n        if let numberPattern = rules.numberPattern {\n            _ = applyHighlighting(\n                pattern: numberPattern,\n                options: rules.numberRegexOptions,\n                color: ColorScheme.number,\n                to: attributed,\n                in: code,\n                captureGroup: nil,\n                excluding: protectedRanges\n            )\n        }\n\n        // 4) Property-like tokens (JSON/YAML keys, CSS props, HTML attrs)\n        let propertyExclusions = rules.propertiesMayOverrideStrings ? commentRanges : protectedRanges\n        for p in rules.propertyPatterns {\n            _ = applyHighlighting(\n                pattern: p.pattern,\n                options: p.options,\n                color: ColorScheme.property,\n                to: attributed,\n                in: code,\n                captureGroup: p.captureGroup,\n                excluding: propertyExclusions\n            )\n        }\n\n        // 5) Types\n        for t in rules.typePatterns {\n            _ = applyHighlighting(\n                pattern: t.pattern,\n                options: t.options,\n                color: ColorScheme.type,\n                to: attributed,\n                in: code,\n                captureGroup: t.captureGroup,\n                excluding: protectedRanges\n            )\n        }\n\n        // 6) Keywords (word list)\n        if !rules.keywords.isEmpty {\n            let keywordPattern = \"\\\\b(?:\" + rules.keywords.map(NSRegularExpression.escapedPattern).joined(separator: \"|\") + \")\\\\b\"\n            _ = applyHighlighting(\n                pattern: keywordPattern,\n                options: rules.keywordRegexOptions,\n                color: ColorScheme.keyword,\n                to: attributed,\n                in: code,\n                captureGroup: nil,\n                excluding: protectedRanges\n            )\n        }\n\n        // 7) Keywords (regex)\n        for k in rules.keywordPatterns {\n            _ = applyHighlighting(\n                pattern: k.pattern,\n                options: k.options,\n                color: ColorScheme.keyword,\n                to: attributed,\n                in: code,\n                captureGroup: k.captureGroup,\n                excluding: protectedRanges\n            )\n        }\n\n        // 8) Functions\n        for fn in rules.functionPatterns {\n            _ = applyHighlighting(\n                pattern: fn.pattern,\n                options: fn.options,\n                color: ColorScheme.function,\n                to: attributed,\n                in: code,\n                captureGroup: fn.captureGroup,\n                excluding: protectedRanges\n            )\n        }\n    }\n\n    // MARK: - Language rules\n\n    private static func languageRules(for language: SyntaxLanguage) -> LanguageRules {\n        let commonNumber = \"\\\\b(?:0x[0-9A-Fa-f_]+|\\\\d[\\\\d_]*(?:\\\\.\\\\d[\\\\d_]*)?(?:[eE][+-]?\\\\d[\\\\d_]*)?)\\\\b\"\n\n        let cLikeStrings = [\n            \"\\\"(?:[^\\\"\\\\\\\\\\\\n]|\\\\\\\\.)*\\\"\",\n            \"'(?:[^'\\\\\\\\\\\\n]|\\\\\\\\.)*'\"\n        ]\n\n        let commonFunctionCall = CapturePattern(\"\\\\b([A-Za-z_][A-Za-z0-9_]*)\\\\s*(?=\\\\()\", captureGroup: 1)\n\n        switch language {\n\n        // MARK: HTML tag highlighting\n        case .html:\n            return LanguageRules(\n                keywords: [],\n                keywordPatterns: [\n                    // Tag name in <tag ...> or </tag>\n                    CapturePattern(\"</?\\\\s*([A-Za-z][A-Za-z0-9:-]*)\", captureGroup: 1),\n                    // <!DOCTYPE\n                    CapturePattern(\"<!DOCTYPE\\\\b\", options: [.caseInsensitive])\n                ],\n                propertyPatterns: [\n                    // Attribute names: attrName=\n                    CapturePattern(\"\\\\b([A-Za-z_:][A-Za-z0-9:._-]*)(?=\\\\s*=)\", captureGroup: 1)\n                ],\n                typePatterns: [],\n                stringPatterns: cLikeStrings,\n                stringRegexOptions: [],\n                commentPatterns: [\"<!--[\\\\s\\\\S]*?-->\"],\n                commentRegexOptions: [.dotMatchesLineSeparators],\n                numberPattern: commonNumber,\n                numberRegexOptions: [],\n                keywordRegexOptions: [],\n                functionPatterns: [],\n                propertiesMayOverrideStrings: false\n            )\n\n        // MARK: CSS / SCSS / LESS\n        case .css:\n            let cssNumber = \"\\\\b(?:\\\\d[\\\\d_]*(?:\\\\.\\\\d[\\\\d_]*)?(?:%|px|em|rem|vw|vh|vmin|vmax|fr|ch|ex|cm|mm|in|pt|pc)?|#(?:[0-9A-Fa-f]{3,4}|[0-9A-Fa-f]{6}|[0-9A-Fa-f]{8}))\\\\b\"\n            return LanguageRules(\n                keywords: [\"important\"],\n                keywordPatterns: [\n                    // @media, @import, ...\n                    CapturePattern(\"(?<![A-Za-z0-9_-])(@(?:import|media|supports|keyframes|font-face|page|layer))\\\\b\", captureGroup: 1, options: [.caseInsensitive])\n                ],\n                propertyPatterns: [\n                    // propertyName:\n                    CapturePattern(\"\\\\b([A-Za-z_-][A-Za-z0-9_-]*)\\\\s*(?=:)\", captureGroup: 1)\n                ],\n                typePatterns: [\n                    // .class and #id\n                    CapturePattern(\"(?:\\\\.|#)([A-Za-z_-][A-Za-z0-9_-]*)\\\\b\", captureGroup: 1),\n                    // element selector before { (rough)\n                    CapturePattern(\"\\\\b([A-Za-z_-][A-Za-z0-9_-]*)\\\\b(?=\\\\s*\\\\{)\", captureGroup: 1)\n                ],\n                stringPatterns: cLikeStrings,\n                stringRegexOptions: [],\n                commentPatterns: [\"/\\\\*[\\\\s\\\\S]*?\\\\*/\"],\n                commentRegexOptions: [.dotMatchesLineSeparators],\n                numberPattern: cssNumber,\n                numberRegexOptions: [],\n                keywordRegexOptions: [.caseInsensitive],\n                functionPatterns: [\n                    // rgb(...), var(...), url(...)\n                    CapturePattern(\"\\\\b([A-Za-z_-][A-Za-z0-9_-]*)\\\\s*(?=\\\\()\", captureGroup: 1)\n                ],\n                propertiesMayOverrideStrings: false\n            )\n\n        case .scss:\n            let css = languageRules(for: .css)\n            return LanguageRules(\n                keywords: css.keywords,\n                keywordPatterns: css.keywordPatterns + [\n                    // SCSS directives\n                    CapturePattern(\"(?<![A-Za-z0-9_-])(@(?:mixin|include|extend|function|return|if|else|for|each|while|use|forward))\\\\b\", captureGroup: 1, options: [.caseInsensitive])\n                ],\n                propertyPatterns: css.propertyPatterns + [\n                    // $variable\n                    CapturePattern(\"(\\\\$[A-Za-z_-][A-Za-z0-9_-]*)\", captureGroup: 1)\n                ],\n                typePatterns: css.typePatterns,\n                stringPatterns: css.stringPatterns,\n                stringRegexOptions: css.stringRegexOptions,\n                commentPatterns: css.commentPatterns + [\"//[^\\\\n]*\"],\n                commentRegexOptions: [.dotMatchesLineSeparators],\n                numberPattern: css.numberPattern,\n                numberRegexOptions: css.numberRegexOptions,\n                keywordRegexOptions: css.keywordRegexOptions,\n                functionPatterns: css.functionPatterns + [\n                    // @mixin name(...) / @function name(...)\n                    CapturePattern(\"@(?:mixin|function)\\\\s+([A-Za-z_-][A-Za-z0-9_-]*)\", captureGroup: 1, options: [.caseInsensitive])\n                ],\n                propertiesMayOverrideStrings: false\n            )\n\n        case .less:\n            let css = languageRules(for: .css)\n            return LanguageRules(\n                keywords: css.keywords,\n                keywordPatterns: css.keywordPatterns,\n                propertyPatterns: css.propertyPatterns + [\n                    // @variable\n                    CapturePattern(\"(@[A-Za-z_-][A-Za-z0-9_-]*)\", captureGroup: 1)\n                ],\n                typePatterns: css.typePatterns,\n                stringPatterns: css.stringPatterns,\n                stringRegexOptions: css.stringRegexOptions,\n                commentPatterns: css.commentPatterns + [\"//[^\\\\n]*\"],\n                commentRegexOptions: [.dotMatchesLineSeparators],\n                numberPattern: css.numberPattern,\n                numberRegexOptions: css.numberRegexOptions,\n                keywordRegexOptions: css.keywordRegexOptions,\n                functionPatterns: css.functionPatterns + [\n                    // .mixinName(\n                    CapturePattern(\"\\\\.([A-Za-z_-][A-Za-z0-9_-]*)\\\\s*(?=\\\\()\", captureGroup: 1)\n                ],\n                propertiesMayOverrideStrings: false\n            )\n\n        // MARK: JSON key/value highlighting\n        case .json:\n            let jsonString = \"\\\"(?:[^\\\"\\\\\\\\\\\\n]|\\\\\\\\.)*\\\"\"\n            return LanguageRules(\n                keywords: [\"true\", \"false\", \"null\"],\n                keywordPatterns: [],\n                propertyPatterns: [\n                    // Key string before colon: \"key\":\n                    CapturePattern(\"(\\\"(?:[^\\\"\\\\\\\\\\\\n]|\\\\\\\\.)*\\\")\\\\s*:\", captureGroup: 1)\n                ],\n                typePatterns: [],\n                stringPatterns: [jsonString],\n                stringRegexOptions: [],\n                commentPatterns: [\"//[^\\\\n]*\", \"/\\\\*[\\\\s\\\\S]*?\\\\*/\"],\n                commentRegexOptions: [.dotMatchesLineSeparators],\n                numberPattern: commonNumber,\n                numberRegexOptions: [],\n                keywordRegexOptions: [],\n                functionPatterns: [],\n                propertiesMayOverrideStrings: true\n            )\n\n        // MARK: Markdown\n        case .markdown:\n            return LanguageRules(\n                keywords: [],\n                keywordPatterns: [\n                    CapturePattern(\"^\\\\s{0,3}(#{1,6})(?=\\\\s)\", captureGroup: 1, options: [.anchorsMatchLines]),\n                    CapturePattern(\"^\\\\s{0,3}>\\\\s?\", options: [.anchorsMatchLines]),\n                    CapturePattern(\"^\\\\s*(?:[-*+]|\\\\d+\\\\.)\\\\s+\", options: [.anchorsMatchLines]),\n                    CapturePattern(\"(?:\\\\*\\\\*|__|\\\\*|_)\")\n                ],\n                propertyPatterns: [],\n                typePatterns: [],\n                stringPatterns: [\"```[\\\\s\\\\S]*?```\", \"~~~[\\\\s\\\\S]*?~~~\", \"`[^`\\\\n]+`\"],\n                stringRegexOptions: [.dotMatchesLineSeparators],\n                commentPatterns: [\"<!--[\\\\s\\\\S]*?-->\"],\n                commentRegexOptions: [.dotMatchesLineSeparators],\n                numberPattern: nil,\n                numberRegexOptions: [],\n                keywordRegexOptions: [],\n                functionPatterns: [],\n                propertiesMayOverrideStrings: false\n            )\n\n        // MARK: YAML\n        case .yaml:\n            let yamlKey = \"^\\\\s*(\\\"(?:[^\\\"\\\\\\\\\\\\n]|\\\\\\\\.)*\\\"|'(?:[^'\\\\\\\\\\\\n]|\\\\\\\\.)*'|[A-Za-z0-9_./-]+)\\\\s*:(?=\\\\s|$)\"\n            return LanguageRules(\n                keywords: [\"true\", \"false\", \"null\", \"yes\", \"no\", \"on\", \"off\"],\n                keywordPatterns: [],\n                propertyPatterns: [\n                    CapturePattern(yamlKey, captureGroup: 1, options: [.anchorsMatchLines])\n                ],\n                typePatterns: [\n                    CapturePattern(\"([&*][A-Za-z0-9_-]+)\", captureGroup: 1)\n                ],\n                stringPatterns: cLikeStrings,\n                stringRegexOptions: [],\n                commentPatterns: [\"#[^\\\\n]*\"],\n                commentRegexOptions: [],\n                numberPattern: commonNumber,\n                numberRegexOptions: [],\n                keywordRegexOptions: [.caseInsensitive],\n                functionPatterns: [],\n                propertiesMayOverrideStrings: true\n            )\n\n        // MARK: SQL\n        case .sql:\n            return LanguageRules(\n                keywords: [\n                    \"select\", \"from\", \"where\", \"group\", \"by\", \"having\", \"order\", \"limit\", \"offset\",\n                    \"insert\", \"into\", \"values\", \"update\", \"set\", \"delete\",\n                    \"join\", \"inner\", \"left\", \"right\", \"full\", \"outer\", \"cross\", \"on\",\n                    \"as\", \"distinct\", \"union\", \"all\", \"and\", \"or\", \"not\", \"null\", \"is\", \"in\", \"exists\", \"like\", \"between\",\n                    \"create\", \"alter\", \"drop\", \"table\", \"view\", \"index\", \"primary\", \"key\", \"foreign\", \"references\",\n                    \"case\", \"when\", \"then\", \"else\", \"end\",\n                    \"begin\", \"commit\", \"rollback\"\n                ],\n                keywordPatterns: [],\n                propertyPatterns: [],\n                typePatterns: [\n                    CapturePattern(\"\\\\b(?:int|integer|smallint|bigint|serial|bigserial|decimal|numeric|real|double|float|money|boolean|bool|date|time|timestamp|timestamptz|varchar|char|text|uuid|json|jsonb)\\\\b\", options: [.caseInsensitive])\n                ],\n                stringPatterns: [\"'(?:''|[^'])*'\", \"\\\"(?:\\\"\\\"|[^\\\"])*\\\"\"],\n                stringRegexOptions: [],\n                commentPatterns: [\"--[^\\\\n]*\", \"/\\\\*[\\\\s\\\\S]*?\\\\*/\"],\n                commentRegexOptions: [.dotMatchesLineSeparators],\n                numberPattern: commonNumber,\n                numberRegexOptions: [],\n                keywordRegexOptions: [.caseInsensitive],\n                functionPatterns: [\n                    CapturePattern(\"\\\\b([A-Za-z_][A-Za-z0-9_]*)\\\\s*(?=\\\\()\", captureGroup: 1, options: [.caseInsensitive])\n                ],\n                propertiesMayOverrideStrings: false\n            )\n\n        default:\n            return LanguageRules(\n                keywords: [],\n                keywordPatterns: [],\n                propertyPatterns: [],\n                typePatterns: [],\n                stringPatterns: [],\n                stringRegexOptions: [],\n                commentPatterns: [],\n                commentRegexOptions: [],\n                numberPattern: nil,\n                numberRegexOptions: [],\n                keywordRegexOptions: [],\n                functionPatterns: [],\n                propertiesMayOverrideStrings: false\n            )\n        }\n    }\n\n    // MARK: - Regex helpers\n\n    @discardableResult\n    private static func applyHighlighting(\n        pattern: String,\n        options: NSRegularExpression.Options,\n        color: UIColor,\n        to attributedString: NSMutableAttributedString,\n        in text: String,\n        captureGroup: Int?,\n        excluding excludedRanges: [NSRange]\n    ) -> [NSRange] {\n        do {\n            let regex = try NSRegularExpression(pattern: pattern, options: options)\n            let matches = regex.matches(in: text, options: [], range: NSRange(location: 0, length: text.utf16.count))\n\n            var applied: [NSRange] = []\n            applied.reserveCapacity(matches.count)\n\n            for match in matches {\n                let range: NSRange = {\n                    if let captureGroup, captureGroup <= match.numberOfRanges - 1 {\n                        return match.range(at: captureGroup)\n                    }\n                    return match.range\n                }()\n\n                guard range.location != NSNotFound, range.length > 0 else { continue }\n                if intersectsAny(range, excludedRanges) { continue }\n\n                attributedString.addAttribute(.foregroundColor, value: color, range: range)\n                applied.append(range)\n            }\n\n            return applied\n        } catch {\n            print(\"Regex error for pattern \\(pattern): \\(error)\")\n            return []\n        }\n    }\n\n    private static func intersectsAny(_ range: NSRange, _ excludedRanges: [NSRange]) -> Bool {\n        for ex in excludedRanges where NSIntersectionRange(range, ex).length > 0 {\n            return true\n        }\n        return false\n    }\n}\n\n// SwiftUI wrapper for NSAttributedString\nstruct AttributedTextView: UIViewRepresentable {\n    let attributedText: NSAttributedString\n\n    func makeUIView(context: Context) -> UITextView {\n        let textView = UITextView()\n        textView.isEditable = false\n        textView.isSelectable = true\n        textView.backgroundColor = .clear\n        textView.textContainerInset = UIEdgeInsets(top: 8, left: 8, bottom: 8, right: 8)\n        return textView\n    }\n\n    func updateUIView(_ uiView: UITextView, context: Context) {\n        uiView.attributedText = attributedText\n    }\n}\n\nextension View {\n    func syntaxHighlighted(\n        code: String,\n        filename: String? = nil,\n        language: NSAttributedStringSyntaxHighlighter.SyntaxLanguage? = nil\n    ) -> some View {\n        AttributedTextView(attributedText: NSAttributedStringSyntaxHighlighter.highlightCode(code, filename: filename, language: language))\n    }\n}\n","overwrite":true}
>>>END

>>>TOOL read_file
{"path":"Extensions/NSAttributedStringSyntaxHighlighter.swift","start_line":1,"end_line":260}
>>>END
>>>TOOL read_file
{"path":"Extensions/NSAttributedStringSyntaxHighlighter.swift","start_line":260,"end_line":520}
>>>END
>>>TOOL read_file
{"path":"Extensions/NSAttributedStringSyntaxHighlighter.swift","start_line":520,"end_line":820}
>>>END
>>>TOOL read_file
{"path":"Extensions/NSAttributedStringSyntaxHighlighter.swift","start_line":820,"end_line":1100}
>>>END

>>>REPORT
File modified: Extensions/NSAttributedStringSyntaxHighlighter.swift

Accomplished (with VS Code Dark+ colors + regex patterns):
- Implemented VS Code Dark+ inspired UIColor palette:
  - keyword #569CD6, type #4EC9B0, property #9CDCFE, string #CE9178, comment #6A9955, number #B5CEA8, function #DCDCAA, default #D4D4D4 (lines 6-52).
- Extended syntax rule model to support additional regex buckets required for the task:
  - Added `keywordPatterns` (regex keywords) and `propertyPatterns` (for JSON/YAML keys, CSS properties, HTML attributes) plus `propertiesMayOverrideStrings` to allow key-highlighting inside string ranges (lines 134-148).
  - Updated highlighting pipeline to apply propertyPatterns after strings/comments/numbers, using VS Code “property” color, with optional override inside strings for JSON/YAML (lines 194-207).

Requested language regex designs added/updated:
1) HTML tag highlighting (lines 276-300)
   - Tag name: `</?\s*([A-Za-z][A-Za-z0-9:-]*)` (capture group 1, keyword color)
   - DOCTYPE: `<!DOCTYPE\b` (case-insensitive, keyword color)
   - Attribute names: `\b([A-Za-z_:][A-Za-z0-9:._-]*)(?=\s*=)` (capture group 1, property color)
   - Comments: `<!--[\\s\\S]*?-->`
   - Strings for attribute values: standard C-like "..." and '...'

2) CSS / SCSS / LESS (lines 302-384)
   CSS (lines 303-333):
   - At-rules: `(?<![A-Za-z0-9_-])(@(?:import|media|supports|keyframes|font-face|page|layer))\b` (capture 1, keyword color)
   - Selectors (type color): `(?:\.|#)([A-Za-z_-][A-Za-z0-9_-]*)\b` and `\b([A-Za-z_-][A-Za-z0-9_-]*)\b(?=\s*\{)`
   - Properties (property color): `\b([A-Za-z_-][A-Za-z0-9_-]*)\s*(?=:)`
   - Numbers/units + hex colors (number color): `\b(?:\d...units...|#RGB/#RRGGBB/#RRGGBBAA)\b` (cssNumber, line 304-305)
   - Function calls (function color): `\b([A-Za-z_-][A-Za-z0-9_-]*)\s*(?=\()`
   SCSS (lines 335-360):
   - Adds SCSS directives via keywordPatterns: `(@(?:mixin|include|extend|function|return|if|else|for|each|while|use|forward))\b`
   - Variables as property: `(\$[A-Za-z_-][A-Za-z0-9_-]*)`
   - Adds `//...` comments
   LESS (lines 362-384):
   - Variables as property: `(@[A-Za-z_-][A-Za-z0-9_-]*)`
   - Mixin call highlight: `\.([A-Za-z_-][A-Za-z0-9_-]*)\s*(?=\()`
   - Adds `//...` comments

3) JSON key/value highlighting (lines 386-406)
   - Strings: `"(...)"` standard JSON string regex (line 388)
   - Keys (property color, overrides string highlighting): `("(?:[^"\\\n]|\\.)*")\s*:` capture group 1 (lines 392-395)
   - jsonc comments supported: `//[^\n]*` and `/\*[\s\S]*?\*/`
   - `propertiesMayOverrideStrings = true` so keys are recolored even though they’re strings.

4) Markdown (lines 408-429)
   - Code blocks/inline code treated as strings:
     - ```fence``` : ``` ```[\s\S]*?``` ```
     - ~~~fence~~~ : `~~~[\s\S]*?~~~`
     - inline: `` `[^`\n]+` ``
   - Markdown structural markers treated as keywordPatterns:
     - headings marker: `^\s{0,3}(#{1,6})(?=\s)` (capture 1)
     - blockquote marker: `^\s{0,3}>\s?`
     - list marker: `^\s*(?:[-*+]|\d+\.)\s+`
     - emphasis markers (rough): `(?:\*\*|__|\*|_)`
   - HTML comments in Markdown: `<!--[\\s\\S]*?-->`

5) YAML (lines 431-452)
   - Keys (property color, overrides strings): `^\s*("..."|'...'|[A-Za-z0-9_./-]+)\s*:(?=\s|$)` with anchorsMatchLines (line 433-439)
   - Anchors/aliases as type: `([&*][A-Za-z0-9_-]+)` (line 440-442)
   - Comments: `#[^\n]*`
   - `propertiesMayOverrideStrings = true` so quoted keys get recolored.

6) SQL (lines 454-482)
   - Keyword list (case-insensitive via keywordRegexOptions): select/from/where/join/etc. (lines 457-465)
   - Types: `\b(?:int|integer|...|jsonb)\b` (case-insensitive) (lines 468-470)
   - Strings: `'(?:''|[^'])*'` and `"(?:""|[^"])*"`
   - Comments: `--[^\n]*` and `/\*[\s\S]*?\*/`
   - Functions: `\b([A-Za-z_][A-Za-z0-9_]*)\s*(?=\()` (case-insensitive)

Also:
- Added `.less` to SyntaxLanguage enum and filename detection (lines 25-26, 107-108).
- Kept regex application helper `applyHighlighting` and intersection exclusion logic intact (lines 505-549).

Evidence: All patterns and pipeline changes are present in Extensions/NSAttributedStringSyntaxHighlighter.swift as shown in the read_file outputs (notably lines 194-207 for property highlighting, and lines 276-482 for the language-specific regex rules). 
>>>END
