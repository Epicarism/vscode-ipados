# Agent: highlight-fix-gpt
**Status:** done
**Tokens:** 22,918
**Cost:** $0.0000
**Time:** 2026-02-10T02:28:19.108Z

## Task
CRITICAL: Syntax highlighting bug in VSCodeiPadOS. The highlighting only triggers on textViewDidChange. Find where the initial text is set in SyntaxHighlightingTextView.swift and add applySyntaxHighlighting call. Check if there's a textViewDidBeginEditing that should also trigger it. Build after fix.

## Response
>>>TOOL search
{"query":"SyntaxHighlightingTextView", "glob":"**/*"} 
>>>END

>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift","start_line":1,"end_line":220}
>>>END

---

## ðŸ”§ TOOL RESULTS

[read_file]
File: VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift (lines 2-220 of 1931)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
2: //  SyntaxHighlightingTextView.swift
3: //  VSCodeiPadOS
4: //
5: //  Upgraded syntax highlighting with VSCode-like colors
6: //
7: 
8: import SwiftUI
9: import UIKit
10: 
11: /// UITextView wrapper with syntax highlighting support
12: struct SyntaxHighlightingTextView: UIViewRepresentable {
13:     @Binding var text: String
14:     let filename: String
15:     @Binding var scrollPosition: Int
16:     @Binding var totalLines: Int
17:     @Binding var visibleLines: Int
18:     @Binding var currentLineNumber: Int
19:     @Binding var currentColumn: Int
20:     @Binding var cursorIndex: Int
21:     @Binding var lineHeight: CGFloat
22:     @Binding var requestedLineSelection: Int?
23:     @Binding var requestedCursorIndex: Int?
24: 
25:     /// Autocomplete key handling hooks (return true if handled)
26:     let onAcceptAutocomplete: (() -> Bool)?
27:     let onDismissAutocomplete: (() -> Bool)?
28: 
29:     let isActive: Bool
30:     let fontSize: CGFloat  // Explicit parameter to trigger SwiftUI updates
31:     @EnvironmentObject var editorCore: EditorCore
32: 
33:     init(
34:         text: Binding<String>,
35:         filename: String,
36:         scrollPosition: Binding<Int>,
37:         totalLines: Binding<Int>,
38:         visibleLines: Binding<Int>,
39:         currentLineNumber: Binding<Int>,
40:         currentColumn: Binding<Int>,
41:         cursorIndex: Binding<Int> = .constant(0),
42:         lineHeight: Binding<CGFloat>,
43:         isActive: Bool,
44:         fontSize: CGFloat = 14.0,
45:         requestedLineSelection: Binding<Int?> = .constant(nil),
46:         requestedCursorIndex: Binding<Int?> = .constant(nil),
47:         onAcceptAutocomplete: (() -> Bool)? = nil,
48:         onDismissAutocomplete: (() -> Bool)? = nil
49:     ) {
50:         self._text = text
51:         self.filename = filename
52:         self._scrollPosition = scrollPosition
53:         self._totalLines = totalLines
54:         self._visibleLines = visibleLines
55:         self._currentLineNumber = currentLineNumber
56:         self._currentColumn = currentColumn
57:         self._cursorIndex = cursorIndex
58:         self._lineHeight = lineHeight
59:         self.isActive = isActive
60:         self.fontSize = fontSize
61:         self._requestedLineSelection = requestedLineSelection
62:         self._requestedCursorIndex = requestedCursorIndex
63:         self.onAcceptAutocomplete = onAcceptAutocomplete
64:         self.onDismissAutocomplete = onDismissAutocomplete
65:     }
66:     
67:     // Compatibility init for older call sites (e.g. SplitEditorView) that pass editorCore explicitly.
68:     init(
69:         text: Binding<String>,
70:         filename: String,
71:         scrollPosition: Binding<Int>,
72:         totalLines: Binding<Int>,
73:         visibleLines: Binding<Int>,
74:         currentLineNumber: Binding<Int>,
75:         currentColumn: Binding<Int>,
76:         cursorIndex: Binding<Int> = .constant(0),
77:         lineHeight: Binding<CGFloat>,
78:         isActive: Bool,
79:         editorCore: EditorCore,
80:         requestedLineSelection: Binding<Int?> = .constant(nil),
81:         requestedCursorIndex: Binding<Int?> = .constant(nil),
82:         onAcceptAutocomplete: (() -> Bool)? = nil,
83:         onDismissAutocomplete: (() -> Bool)? = nil
84:     ) {
85:         self.init(
86:             text: text,
87:             filename: filename,
88:             scrollPosition: scrollPosition,
89:             totalLines: totalLines,
90:             visibleLines: visibleLines,
91:             currentLineNumber: currentLineNumber,
92:             currentColumn: currentColumn,
93:             cursorIndex: cursorIndex,
94:             lineHeight: lineHeight,
95:             isActive: isActive,
96:             fontSize: editorCore.editorFontSize,
97:             requestedLineSelection: requestedLineSelection,
98:             requestedCursorIndex: requestedCursorIndex,
99:             onAcceptAutocomplete: onAcceptAutocomplete,
100:             onDismissAutocomplete: onDismissAutocomplete
101:         )
102:     }
103: 
104:     func makeCoordinator() -> Coordinator {
105:         Coordinator(self)
106:     }
107:     
108:     func makeUIView(context: Context) -> UITextView {
109:         let textView = EditorTextView()
110:         textView.delegate = context.coordinator
111: 
112:         // Autocomplete hooks
113:         textView.onAcceptAutocomplete = onAcceptAutocomplete
114:         textView.onDismissAutocomplete = onDismissAutocomplete
115: 
116:         textView.onPeekDefinition = {
117:             context.coordinator.handlePeekDefinition(in: textView)
118:         }
119: 
120:         textView.onEscape = {
121:             context.coordinator.handleEscape()
122:         }
123: 
124:         textView.onGoToLine = {
125:             self.editorCore.showGoToLine = true
126:         }
127:         
128:         // Wire up custom context menu actions
129:         textView.onGoToDefinition = {
130:             context.coordinator.handleGoToDefinition(in: textView)
131:         }
132:         
133:         textView.onFindReferences = {
134:             context.coordinator.handleFindReferences(in: textView)
135:         }
136:         
137:         textView.onFormatDocument = {
138:             context.coordinator.handleFormatDocument(in: textView)
139:         }
140:         
141:         textView.onToggleComment = {
142:             context.coordinator.handleToggleComment(in: textView)
143:         }
144:         
145:         textView.onFold = {
146:             context.coordinator.handleFold(in: textView)
147:         }
148:         
149:         textView.onUnfold = {
150:             context.coordinator.handleUnfold(in: textView)
151:         }
152:         
153:         // Add pinch gesture for zoom
154:         let pinchGesture = UIPinchGestureRecognizer(target: context.coordinator, action: #selector(Coordinator.handlePinch(_:)))
155:         textView.addGestureRecognizer(pinchGesture)
156:         context.coordinator.pinchGesture = pinchGesture
157:         
158:         // Configure text view
159:         textView.isEditable = true
160:         textView.isSelectable = true
161:         textView.autocapitalizationType = .none
162:         textView.autocorrectionType = .no
163:         textView.smartDashesType = .no
164:         textView.smartQuotesType = .no
165:         textView.smartInsertDeleteType = .no
166:         textView.spellCheckingType = .no
167:         
168:         // Set font and appearance (use editorCore.editorFontSize)
169:         textView.font = UIFont.monospacedSystemFont(ofSize: editorCore.editorFontSize, weight: .regular)
170:         textView.textColor = UIColor(ThemeManager.shared.currentTheme.editorForeground)
171:         textView.backgroundColor = UIColor(ThemeManager.shared.currentTheme.editorBackground)
172:         textView.keyboardType = .default
173:         textView.textContainerInset = UIEdgeInsets(top: 8, left: 8, bottom: 8, right: 8)
174:         
175:         // Enable line wrapping
176:         textView.textContainer.lineBreakMode = .byCharWrapping
177:         textView.textContainer.widthTracksTextView = true
178:         
179:         // Calculate line height
180:         if let font = textView.font {
181:             DispatchQueue.main.async {
182:                 self.lineHeight = font.lineHeight
183:             }
184:         }
185:         
186:         // Set initial text with syntax highlighting
187:         textView.text = text
188:         context.coordinator.applySyntaxHighlighting(to: textView)
189:         context.coordinator.updateLineCount(textView)
190:         
191:         return textView
192:     }
193:     
194:     func updateUIView(_ textView: UITextView, context: Context) {
195:         // Update colors when theme changes
196:         textView.backgroundColor = UIColor(ThemeManager.shared.currentTheme.editorBackground)
197:         textView.textColor = UIColor(ThemeManager.shared.currentTheme.editorForeground)
198:         textView.tintColor = UIColor(ThemeManager.shared.currentTheme.cursor)
199:         
200:         if let editorView = textView as? EditorTextView {
201:             editorView.updateThemeColors(theme: ThemeManager.shared.currentTheme)
202:         }
203:         
204:         // Update font size if changed (using explicit fontSize parameter for proper SwiftUI updates)
205:         if let currentFont = textView.font, currentFont.pointSize != fontSize {
206:             let selectedRange = textView.selectedRange
207:             textView.font = UIFont.monospacedSystemFont(ofSize: fontSize, weight: .regular)
208:             context.coordinator.applySyntaxHighlighting(to: textView)
209:             textView.selectedRange = selectedRange
210:             
211:             // Update line height
212:             if let font = textView.font {
213:                 DispatchQueue.main.async {
214:                     self.lineHeight = font.lineHeight
215:                 }
216:             }
217:         }
218:         
219:         // Update text if changed externally
220:         if textView.text != text {


>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift","start_line":218,"end_line":360}
>>>END

---

## ðŸ”§ TOOL RESULTS

[read_file]
File: VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift (lines 219-360 of 1931)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
219:         // Update text if changed externally
220:         if textView.text != text {
221:             let selectedRange = textView.selectedRange
222:             textView.text = text
223:             context.coordinator.applySyntaxHighlighting(to: textView)
224:             textView.selectedRange = selectedRange
225:         } else if context.coordinator.lastThemeId != ThemeManager.shared.currentTheme.id {
226:             // Re-apply highlighting if theme changed
227:             context.coordinator.applySyntaxHighlighting(to: textView)
228:         }
229:         
230:         // Handle minimap scrolling
231:         if scrollPosition != context.coordinator.lastKnownScrollPosition && scrollPosition >= 0 {
232:             // Update lastKnownScrollPosition FIRST to prevent race condition
233:             // where user scroll gets overridden by stale binding value
234:             context.coordinator.lastKnownScrollPosition = scrollPosition
235:             context.coordinator.scrollToLine(scrollPosition, in: textView)
236:         }
237: 
238:         // Handle line selection requests (e.g. tapping line numbers)
239:         if let requested = requestedLineSelection,
240:            requested != context.coordinator.lastRequestedLineSelection {
241:             context.coordinator.lastRequestedLineSelection = requested
242:             context.coordinator.scrollToAndSelectLine(requested, in: textView)
243:             // Defer @Binding update to avoid "Publishing changes from within view updates"
244:             DispatchQueue.main.async {
245:                 self.requestedLineSelection = nil
246:             }
247:         }
248: 
249:         // Handle cursor index requests (e.g. accepting autocomplete)
250:         if let requested = requestedCursorIndex,
251:            requested != context.coordinator.lastRequestedCursorIndex {
252:             context.coordinator.lastRequestedCursorIndex = requested
253:             textView.selectedRange = NSRange(location: max(0, requested), length: 0)
254:             // Defer @Binding update to avoid "Publishing changes from within view updates"
255:             DispatchQueue.main.async {
256:                 self.requestedCursorIndex = nil
257:             }
258: 
259:             // Update SwiftUI state
260:             context.coordinator.updateCursorPosition(textView)
261:             context.coordinator.updateScrollPosition(textView)
262:         }
263:         
264:         // Note: updateLineCount is called in textViewDidChange, no need to call here
265:         // as it causes unnecessary state churn on every updateUIView
266:     }
267:     
268:     // MARK: - Coordinator
269:     
270:     class Coordinator: NSObject, UITextViewDelegate {
271:         var parent: SyntaxHighlightingTextView
272:         var lastKnownScrollPosition: Int = 0
273:         var lastThemeId: String = ""
274:         var lastRequestedLineSelection: Int? = nil
275:         var lastRequestedCursorIndex: Int? = nil
276:         private var isUpdatingFromMinimap = false
277:         private var highlightDebouncer: Timer?
278:         weak var pinchGesture: UIPinchGestureRecognizer?
279:         private var initialFontSize: CGFloat = 0
280: 
281:         // FEAT-044: Matching bracket highlight state
282:         private var bracketHighlightRanges: [NSRange] = []
283:         
284:         init(_ parent: SyntaxHighlightingTextView) {
285:             self.parent = parent
286:         }
287:         
288:         func textViewDidBeginEditing(_ textView: UITextView) {
289:             // Ensure syntax highlighting is current when user begins editing
290:             // This handles cases where text was set but highlighting hasn't run yet
291:             applySyntaxHighlighting(to: textView)
292:         }
293:         
294:         func textViewDidChange(_ textView: UITextView) {
295:             // Update parent text
296:             parent.text = textView.text
297:             
298:             // Set typing attributes IMMEDIATELY so new characters have proper base styling
299:             // This prevents flicker during the debounce period
300:             let theme = ThemeManager.shared.currentTheme
301:             let fontSize = parent.editorCore.editorFontSize
302:             textView.typingAttributes = [
303:                 .font: UIFont.monospacedSystemFont(ofSize: fontSize, weight: .regular),
304:                 .foregroundColor: UIColor(theme.editorForeground)
305:             ]
306:             
307:             // Debounced syntax highlighting for performance (reduced from 0.15s to 0.08s)
308:             highlightDebouncer?.invalidate()
309:             highlightDebouncer = Timer.scheduledTimer(withTimeInterval: 0.08, repeats: false) { [weak self] _ in
310:                 DispatchQueue.main.async {
311:                     self?.applySyntaxHighlighting(to: textView)
312:                 }
313:             }
314:             
315:             updateLineCount(textView)
316:             updateCursorPosition(textView)
317:         }
318:         
319:         func textViewDidChangeSelection(_ textView: UITextView) {
320:             if !isUpdatingFromMinimap {
321:                 updateCursorPosition(textView)
322:                 updateScrollPosition(textView)
323: 
324:                 // FEAT-044: Matching bracket highlight
325:                 updateMatchingBracketHighlight(textView)
326: 
327:                 // Trigger redraw so current-line highlight/indent guides track the caret
328:                 (textView as? EditorTextView)?.setNeedsDisplay()
329: 
330:                 // Update selection in EditorCore for multi-cursor support
331:                 let range = textView.selectedRange
332:                 parent.editorCore.updateSelection(range: range, text: textView.text ?? "")
333: 
334:                 // If user clicks elsewhere (not multi-cursor operation), reset to single cursor
335:                 if !parent.editorCore.multiCursorState.isMultiCursor {
336:                     parent.editorCore.multiCursorState.reset(to: range.location + range.length)
337:                 }
338:             }
339:         }
340:         
341:         func scrollViewDidScroll(_ scrollView: UIScrollView) {
342:             guard let textView = scrollView as? UITextView, !isUpdatingFromMinimap else { return }
343:             updateScrollPosition(textView)
344:         }
345:         
346:         func updateLineCount(_ textView: UITextView) {
347:             let lines = textView.text.components(separatedBy: .newlines)
348:             DispatchQueue.main.async {
349:                 self.parent.totalLines = max(1, lines.count)
350:             }
351:         }
352:         
353:         func updateCursorPosition(_ textView: UITextView) {
354:             guard let selectedRange = textView.selectedTextRange else { return }
355:              let cursorPosition = textView.offset(from: textView.beginningOfDocument, to: selectedRange.start)
356:              
357:              let text = textView.text ?? ""
358:              let prefix = String(text.prefix(cursorPosition))
359:              let lines = prefix.components(separatedBy: .newlines)
360:              


>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView_Update.swift","start_line":1,"end_line":260}
>>>END

---

## ðŸ”§ TOOL RESULTS

[read_file]
File: VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView_Update.swift (lines 2-260 of 708)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
2: //  SplitEditorView.swift
3: //  VSCodeiPadOS
4: //
5: //  Split editor panes implementation
6: //  - Split right/down
7: //  - Drag tabs to create splits
8: //  - Independent panes with own tabs
9: //  - Resizable with drag handles
10: //  - Close split buttons
11: //  - Sync scroll option
12: //
13: 
14: import SwiftUI
15: 
16: // MARK: - Split Direction
17: 
18: enum SplitDirection: String, CaseIterable {
19:     case horizontal // side by side
20:     case vertical   // top and bottom
21: }
22: 
23: // MARK: - Editor Pane Model
24: 
25: class EditorPane: ObservableObject, Identifiable {
26:     let id: UUID
27:     @Published var tabs: [Tab]
28:     @Published var activeTabId: UUID?
29:     @Published var scrollOffset: CGFloat = 0
30:     
31:     var activeTab: Tab? {
32:         tabs.first { $0.id == activeTabId }
33:     }
34:     
35:     init(id: UUID = UUID(), tabs: [Tab] = [], activeTabId: UUID? = nil) {
36:         self.id = id
37:         self.tabs = tabs
38:         self.activeTabId = activeTabId ?? tabs.first?.id
39:     }
40:     
41:     func addTab(_ tab: Tab) {
42:         // Check if already exists
43:         if let existing = tabs.first(where: { $0.url == tab.url && tab.url != nil }) {
44:             activeTabId = existing.id
45:             return
46:         }
47:         tabs.append(tab)
48:         activeTabId = tab.id
49:     }
50:     
51:     func closeTab(id: UUID) {
52:         guard let index = tabs.firstIndex(where: { $0.id == id }) else { return }
53:         tabs.remove(at: index)
54:         
55:         if activeTabId == id {
56:             if tabs.isEmpty {
57:                 activeTabId = nil
58:             } else if index >= tabs.count {
59:                 activeTabId = tabs[tabs.count - 1].id
60:             } else {
61:                 activeTabId = tabs[index].id
62:             }
63:         }
64:     }
65:     
66:     func selectTab(id: UUID) {
67:         activeTabId = id
68:     }
69:     
70:     func updateTabContent(_ content: String) {
71:         guard let index = tabs.firstIndex(where: { $0.id == activeTabId }) else { return }
72:         tabs[index].content = content
73:         if tabs[index].url != nil {
74:             tabs[index].isUnsaved = true
75:         }
76:     }
77: }
78: 
79: // MARK: - Split Editor Manager
80: 
81: class SplitEditorManager: ObservableObject {
82:     @Published var panes: [EditorPane] = []
83:     @Published var splitDirection: SplitDirection = .horizontal
84:     @Published var splitRatios: [CGFloat] = [1.0]
85:     @Published var activePaneId: UUID?
86:     @Published var syncScroll: Bool = false
87:     
88:     var activePane: EditorPane? {
89:         panes.first { $0.id == activePaneId }
90:     }
91:     
92:     init() {
93:         let initialPane = EditorPane()
94:         panes = [initialPane]
95:         activePaneId = initialPane.id
96:         splitRatios = [1.0]
97:     }
98:     
99:     // Initialize with EditorCore's tabs
100:     func initializeWithTabs(_ tabs: [Tab], activeTabId: UUID?) {
101:         if panes.isEmpty {
102:             let pane = EditorPane(tabs: tabs, activeTabId: activeTabId)
103:             panes = [pane]
104:             activePaneId = pane.id
105:             splitRatios = [1.0]
106:         } else if let firstPane = panes.first, firstPane.tabs.isEmpty {
107:             firstPane.tabs = tabs
108:             firstPane.activeTabId = activeTabId
109:         }
110:     }
111:     
112:     // MARK: - Split Operations
113:     
114:     func splitPane(direction: SplitDirection, fromPaneId: UUID? = nil) {
115:         let sourcePane = fromPaneId.flatMap { id in panes.first { $0.id == id } } ?? activePane
116:         guard let source = sourcePane else { return }
117:         
118:         // Create new pane with duplicate of active tab (or empty)
119:         var newTabs: [Tab] = []
120:         if let activeTab = source.activeTab {
121:             let duplicateTab = Tab(
122:                 fileName: activeTab.fileName,
123:                 content: activeTab.content,
124:                 language: activeTab.language,
125:                 url: activeTab.url,
126:                 isUnsaved: activeTab.isUnsaved
127:             )
128:             newTabs = [duplicateTab]
129:         }
130:         
131:         let newPane = EditorPane(tabs: newTabs, activeTabId: newTabs.first?.id)
132:         
133:         self.splitDirection = direction
134:         panes.append(newPane)
135:         
136:         // Recalculate ratios equally
137:         let ratio = 1.0 / CGFloat(panes.count)
138:         splitRatios = Array(repeating: ratio, count: panes.count)
139:         
140:         activePaneId = newPane.id
141:     }
142:     
143:     func closePane(id: UUID) {
144:         guard panes.count > 1 else { return } // Keep at least one pane
145:         guard let index = panes.firstIndex(where: { $0.id == id }) else { return }
146:         
147:         panes.remove(at: index)
148:         splitRatios.remove(at: index)
149:         
150:         // Normalize ratios
151:         let total = splitRatios.reduce(0, +)
152:         if total > 0 {
153:             splitRatios = splitRatios.map { $0 / total }
154:         } else {
155:             splitRatios = Array(repeating: 1.0 / CGFloat(panes.count), count: panes.count)
156:         }
157:         
158:         // Update active pane
159:         if activePaneId == id {
160:             activePaneId = panes.first?.id
161:         }
162:     }
163:     
164:     func moveTabToPane(tab: Tab, fromPaneId: UUID, toPaneId: UUID) {
165:         guard let fromPane = panes.first(where: { $0.id == fromPaneId }),
166:               let toPane = panes.first(where: { $0.id == toPaneId }) else { return }
167:         
168:         fromPane.closeTab(id: tab.id)
169:         
170:         // Create new tab (since Tab is a struct)
171:         let newTab = Tab(
172:             fileName: tab.fileName,
173:             content: tab.content,
174:             language: tab.language,
175:             url: tab.url,
176:             isUnsaved: tab.isUnsaved
177:         )
178:         toPane.addTab(newTab)
179:     }
180:     
181:     func moveTabToNewSplit(tab: Tab, fromPaneId: UUID, direction: SplitDirection) {
182:         guard let fromPane = panes.first(where: { $0.id == fromPaneId }) else { return }
183:         
184:         fromPane.closeTab(id: tab.id)
185:         
186:         let newTab = Tab(
187:             fileName: tab.fileName,
188:             content: tab.content,
189:             language: tab.language,
190:             url: tab.url,
191:             isUnsaved: tab.isUnsaved
192:         )
193:         
194:         let newPane = EditorPane(tabs: [newTab], activeTabId: newTab.id)
195:         self.splitDirection = direction
196:         panes.append(newPane)
197:         
198:         let ratio = 1.0 / CGFloat(panes.count)
199:         splitRatios = Array(repeating: ratio, count: panes.count)
200:         activePaneId = newPane.id
201:     }
202:     
203:     func updateRatio(at index: Int, delta: CGFloat, totalSize: CGFloat) {
204:         guard index < splitRatios.count - 1 else { return }
205:         
206:         let deltaRatio = delta / totalSize
207:         let minRatio: CGFloat = 0.15
208:         
209:         let newRatio1 = splitRatios[index] + deltaRatio
210:         let newRatio2 = splitRatios[index + 1] - deltaRatio
211:         
212:         if newRatio1 >= minRatio && newRatio2 >= minRatio {
213:             splitRatios[index] = newRatio1
214:             splitRatios[index + 1] = newRatio2
215:         }
216:     }
217:     
218:     // Sync scroll across panes
219:     func syncScrollOffset(_ offset: CGFloat, fromPaneId: UUID) {
220:         guard syncScroll else { return }
221:         for pane in panes where pane.id != fromPaneId {
222:             pane.scrollOffset = offset
223:         }
224:     }
225: }
226: 
227: // MARK: - Split Editor View
228: 
229: struct SplitEditorView: View {
230:     @ObservedObject var splitManager: SplitEditorManager
231:     @ObservedObject var editorCore: EditorCore
232:     
233:     var body: some View {
234:         GeometryReader { geometry in
235:             ZStack {
236:                 if splitManager.panes.count == 1 {
237:                     // Single pane - no split
238:                     if let pane = splitManager.panes.first {
239:                         SinglePaneView(pane: pane, splitManager: splitManager, editorCore: editorCore)
240:                     }
241:                 } else {
242:                     // Multiple panes with split
243:                     splitContent(geometry: geometry)
244:                 }
245:                 
246:                 // Hover Info Overlay
247:                 HoverInfoView()
248:             }
249:         }
250:     }
251:     
252:     @ViewBuilder
253:     private func splitContent(geometry: GeometryProxy) -> some View {
254:         let totalSize = splitManager.splitDirection == .horizontal ? geometry.size.width : geometry.size.height
255:         
256:         if splitManager.splitDirection == .horizontal {
257:             HStack(spacing: 0) {
258:                 ForEach(Array(splitManager.panes.enumerated()), id: \.element.id) { index, pane in
259:                     SinglePaneView(pane: pane, splitManager: splitManager, editorCore: editorCore)
260:                         .frame(width: totalSize * splitManager.splitRatios[index])


>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift","start_line":220,"end_line":340}
>>>END

---

## ðŸ”§ TOOL RESULTS

[read_file]
File: VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift (lines 221-340 of 1931)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
221:             let selectedRange = textView.selectedRange
222:             textView.text = text
223:             context.coordinator.applySyntaxHighlighting(to: textView)
224:             textView.selectedRange = selectedRange
225:         } else if context.coordinator.lastThemeId != ThemeManager.shared.currentTheme.id {
226:             // Re-apply highlighting if theme changed
227:             context.coordinator.applySyntaxHighlighting(to: textView)
228:         }
229:         
230:         // Handle minimap scrolling
231:         if scrollPosition != context.coordinator.lastKnownScrollPosition && scrollPosition >= 0 {
232:             // Update lastKnownScrollPosition FIRST to prevent race condition
233:             // where user scroll gets overridden by stale binding value
234:             context.coordinator.lastKnownScrollPosition = scrollPosition
235:             context.coordinator.scrollToLine(scrollPosition, in: textView)
236:         }
237: 
238:         // Handle line selection requests (e.g. tapping line numbers)
239:         if let requested = requestedLineSelection,
240:            requested != context.coordinator.lastRequestedLineSelection {
241:             context.coordinator.lastRequestedLineSelection = requested
242:             context.coordinator.scrollToAndSelectLine(requested, in: textView)
243:             // Defer @Binding update to avoid "Publishing changes from within view updates"
244:             DispatchQueue.main.async {
245:                 self.requestedLineSelection = nil
246:             }
247:         }
248: 
249:         // Handle cursor index requests (e.g. accepting autocomplete)
250:         if let requested = requestedCursorIndex,
251:            requested != context.coordinator.lastRequestedCursorIndex {
252:             context.coordinator.lastRequestedCursorIndex = requested
253:             textView.selectedRange = NSRange(location: max(0, requested), length: 0)
254:             // Defer @Binding update to avoid "Publishing changes from within view updates"
255:             DispatchQueue.main.async {
256:                 self.requestedCursorIndex = nil
257:             }
258: 
259:             // Update SwiftUI state
260:             context.coordinator.updateCursorPosition(textView)
261:             context.coordinator.updateScrollPosition(textView)
262:         }
263:         
264:         // Note: updateLineCount is called in textViewDidChange, no need to call here
265:         // as it causes unnecessary state churn on every updateUIView
266:     }
267:     
268:     // MARK: - Coordinator
269:     
270:     class Coordinator: NSObject, UITextViewDelegate {
271:         var parent: SyntaxHighlightingTextView
272:         var lastKnownScrollPosition: Int = 0
273:         var lastThemeId: String = ""
274:         var lastRequestedLineSelection: Int? = nil
275:         var lastRequestedCursorIndex: Int? = nil
276:         private var isUpdatingFromMinimap = false
277:         private var highlightDebouncer: Timer?
278:         weak var pinchGesture: UIPinchGestureRecognizer?
279:         private var initialFontSize: CGFloat = 0
280: 
281:         // FEAT-044: Matching bracket highlight state
282:         private var bracketHighlightRanges: [NSRange] = []
283:         
284:         init(_ parent: SyntaxHighlightingTextView) {
285:             self.parent = parent
286:         }
287:         
288:         func textViewDidBeginEditing(_ textView: UITextView) {
289:             // Ensure syntax highlighting is current when user begins editing
290:             // This handles cases where text was set but highlighting hasn't run yet
291:             applySyntaxHighlighting(to: textView)
292:         }
293:         
294:         func textViewDidChange(_ textView: UITextView) {
295:             // Update parent text
296:             parent.text = textView.text
297:             
298:             // Set typing attributes IMMEDIATELY so new characters have proper base styling
299:             // This prevents flicker during the debounce period
300:             let theme = ThemeManager.shared.currentTheme
301:             let fontSize = parent.editorCore.editorFontSize
302:             textView.typingAttributes = [
303:                 .font: UIFont.monospacedSystemFont(ofSize: fontSize, weight: .regular),
304:                 .foregroundColor: UIColor(theme.editorForeground)
305:             ]
306:             
307:             // Debounced syntax highlighting for performance (reduced from 0.15s to 0.08s)
308:             highlightDebouncer?.invalidate()
309:             highlightDebouncer = Timer.scheduledTimer(withTimeInterval: 0.08, repeats: false) { [weak self] _ in
310:                 DispatchQueue.main.async {
311:                     self?.applySyntaxHighlighting(to: textView)
312:                 }
313:             }
314:             
315:             updateLineCount(textView)
316:             updateCursorPosition(textView)
317:         }
318:         
319:         func textViewDidChangeSelection(_ textView: UITextView) {
320:             if !isUpdatingFromMinimap {
321:                 updateCursorPosition(textView)
322:                 updateScrollPosition(textView)
323: 
324:                 // FEAT-044: Matching bracket highlight
325:                 updateMatchingBracketHighlight(textView)
326: 
327:                 // Trigger redraw so current-line highlight/indent guides track the caret
328:                 (textView as? EditorTextView)?.setNeedsDisplay()
329: 
330:                 // Update selection in EditorCore for multi-cursor support
331:                 let range = textView.selectedRange
332:                 parent.editorCore.updateSelection(range: range, text: textView.text ?? "")
333: 
334:                 // If user clicks elsewhere (not multi-cursor operation), reset to single cursor
335:                 if !parent.editorCore.multiCursorState.isMultiCursor {
336:                     parent.editorCore.multiCursorState.reset(to: range.location + range.length)
337:                 }
338:             }
339:         }
340:         


>>>TOOL search
{"query":"textView.text =", "glob":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift"} 
>>>END

---

## ðŸ”§ TOOL RESULTS

[search]
Found 2 matches:
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:187: textView.text = text
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:222: textView.text = text


>>>TOOL get_symbols
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift"}
>>>END

---

## ðŸ”§ TOOL RESULTS

[get_symbols]
No symbols found in VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift (file may need to be opened first)


>>>TOOL search
{"query":"func applySyntaxHighlighting", "glob":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift"}
>>>END

---

## ðŸ”§ TOOL RESULTS

[search]
Found 1 matches:
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:446: func applySyntaxHighlighting(to textView: UITextView) {


>>>TOOL get_symbols
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift"}
>>>END

---

## ðŸ”§ TOOL RESULTS

[get_symbols]
No symbols found in VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift (file may need to be opened first)


>>>TOOL search
{"query":"applySyntaxHighlighting(to:", "glob":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift"}
>>>END

---

## ðŸ”§ TOOL RESULTS

[search]
Found 6 matches:
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:188: context.coordinator.applySyntaxHighlighting(to: textView)
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:208: context.coordinator.applySyntaxHighlighting(to: textView)
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:223: context.coordinator.applySyntaxHighlighting(to: textView)
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:227: context.coordinator.applySyntaxHighlighting(to: textView)
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:296: applySyntaxHighlighting(to: textView)
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:316: self?.applySyntaxHighlighting(to: textView)


>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift","start_line":410,"end_line":520}
>>>END

---

## ðŸ”§ TOOL RESULTS

[read_file]
File: VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift (lines 411-520 of 1946)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
411:             }
412:             
413:             if let position = textView.position(from: textView.beginningOfDocument, offset: characterPosition) {
414:                 let rect = textView.caretRect(for: position)
415:                 let targetY = max(0, rect.origin.y)
416:                 textView.setContentOffset(CGPoint(x: 0, y: targetY), animated: true)
417:             }
418:             
419:             DispatchQueue.main.asyncAfter(deadline: .now() + 0.3) {
420:                 self.isUpdatingFromMinimap = false
421:             }
422:         }
423: 
424:         func scrollToAndSelectLine(_ line: Int, in textView: UITextView) {
425:             let lines = textView.text.components(separatedBy: .newlines)
426:             guard line >= 0 && line < lines.count else { return }
427: 
428:             var characterPosition = 0
429:             for i in 0..<line {
430:                 characterPosition += lines[i].count + 1
431:             }
432: 
433:             // FEAT-041: select entire line (excluding trailing newline)
434:             let lineLength = (lines[line] as NSString).length
435:             let range = NSRange(location: characterPosition, length: lineLength)
436:             textView.selectedRange = range
437: 
438:             // Ensure it's visible
439:             scrollToLine(line, in: textView)
440: 
441:             // Update SwiftUI state
442:             updateCursorPosition(textView)
443:             updateScrollPosition(textView)
444:         }
445: 
446:         func applySyntaxHighlighting(to textView: UITextView) {
447:             let theme = ThemeManager.shared.currentTheme
448:             lastThemeId = theme.id
449: 
450:             let highlighter = VSCodeSyntaxHighlighter(theme: theme, fontSize: parent.editorCore.editorFontSize)
451:             let attributedText = highlighter.highlight(textView.text, filename: parent.filename)
452: 
453:             let selectedRange = textView.selectedRange
454:             textView.attributedText = attributedText
455:             textView.selectedRange = selectedRange
456: 
457:             // Set typing attributes so newly typed characters have correct base styling
458:             // This prevents flicker during the debounce period before full highlighting runs
459:             let fontSize = parent.editorCore.editorFontSize
460:             textView.typingAttributes = [
461:                 .font: UIFont.monospacedSystemFont(ofSize: fontSize, weight: .regular),
462:                 .foregroundColor: UIColor(theme.editorForeground)
463:             ]
464: 
465:             // FEAT-044: restore matching bracket highlight after re-attributing text
466:             updateMatchingBracketHighlight(textView)
467:         }
468:         
469:         func handlePeekDefinition(in textView: UITextView) {
470:             guard let selectedRange = textView.selectedTextRange else { return }
471:             let text = textView.text ?? ""
472:             
473:             if let range = textView.tokenizer.rangeEnclosingPosition(selectedRange.start, with: .word, inDirection: UITextDirection(rawValue: 1)) {
474:                  let location = textView.offset(from: textView.beginningOfDocument, to: range.start)
475:                  
476:                  let prefix = String(text.prefix(location))
477:                  let sourceLine = prefix.components(separatedBy: CharacterSet.newlines).count - 1
478:                  
479:                  parent.editorCore.triggerPeekDefinition(
480:                      file: parent.filename,
481:                      line: sourceLine,
482:                      content: text,
483:                      sourceLine: sourceLine
484:                  )
485:             }
486:         }
487:         
488:         func handleEscape() {
489:             if parent.editorCore.peekState != nil {
490:                 parent.editorCore.closePeekDefinition()
491:             } else {
492:                 parent.editorCore.escapeMultiCursor()
493:             }
494:         }
495:         
496:         func handleGoToDefinition(in textView: UITextView) {
497:             // Reuse the peek definition logic for now
498:             handlePeekDefinition(in: textView)
499:         }
500:         
501:         func handleFindReferences(in textView: UITextView) {
502:             guard let selectedRange = textView.selectedTextRange else { return }
503:             let text = textView.text ?? ""
504:             
505:             if let range = textView.tokenizer.rangeEnclosingPosition(selectedRange.start, with: .word, inDirection: UITextDirection(rawValue: 1)) {
506:                 let location = textView.offset(from: textView.beginningOfDocument, to: range.start)
507:                 
508:                 let prefix = String(text.prefix(location))
509:                 let sourceLine = prefix.components(separatedBy: CharacterSet.newlines).count - 1
510:                 
511:                 // TODO: Implement find references functionality in EditorCore
512:                 // For now, just trigger peek definition as a placeholder
513:                 parent.editorCore.triggerPeekDefinition(
514:                     file: parent.filename,
515:                     line: sourceLine,
516:                     content: text,
517:                     sourceLine: sourceLine
518:                 )
519:             }
520:         }


>>>TOOL search
{"query":"attributedText", "glob":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift"}
>>>END

---

## ðŸ”§ TOOL RESULTS

[search]
Found 2 matches:
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:451: let attributedText = highlighter.highlight(textView.text, filename: parent.filename)
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:454: textView.attributedText = attributedText


>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift","start_line":440,"end_line":480}
>>>END

---

## ðŸ”§ TOOL RESULTS

[read_file]
File: VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift (lines 441-480 of 1946)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
441:             // Update SwiftUI state
442:             updateCursorPosition(textView)
443:             updateScrollPosition(textView)
444:         }
445: 
446:         func applySyntaxHighlighting(to textView: UITextView) {
447:             let theme = ThemeManager.shared.currentTheme
448:             lastThemeId = theme.id
449: 
450:             let highlighter = VSCodeSyntaxHighlighter(theme: theme, fontSize: parent.editorCore.editorFontSize)
451:             let attributedText = highlighter.highlight(textView.text, filename: parent.filename)
452: 
453:             let selectedRange = textView.selectedRange
454:             textView.attributedText = attributedText
455:             textView.selectedRange = selectedRange
456: 
457:             // Set typing attributes so newly typed characters have correct base styling
458:             // This prevents flicker during the debounce period before full highlighting runs
459:             let fontSize = parent.editorCore.editorFontSize
460:             textView.typingAttributes = [
461:                 .font: UIFont.monospacedSystemFont(ofSize: fontSize, weight: .regular),
462:                 .foregroundColor: UIColor(theme.editorForeground)
463:             ]
464: 
465:             // FEAT-044: restore matching bracket highlight after re-attributing text
466:             updateMatchingBracketHighlight(textView)
467:         }
468:         
469:         func handlePeekDefinition(in textView: UITextView) {
470:             guard let selectedRange = textView.selectedTextRange else { return }
471:             let text = textView.text ?? ""
472:             
473:             if let range = textView.tokenizer.rangeEnclosingPosition(selectedRange.start, with: .word, inDirection: UITextDirection(rawValue: 1)) {
474:                  let location = textView.offset(from: textView.beginningOfDocument, to: range.start)
475:                  
476:                  let prefix = String(text.prefix(location))
477:                  let sourceLine = prefix.components(separatedBy: CharacterSet.newlines).count - 1
478:                  
479:                  parent.editorCore.triggerPeekDefinition(
480:                      file: parent.filename,


>>>TOOL search
{"query":"struct SyntaxHighlightingTextView", "glob":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor/*.swift"}
>>>END

---

## ðŸ”§ TOOL RESULTS

[search]
Found 1 matches:
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:12: struct SyntaxHighlightingTextView: UIViewRepresentable {


>>>TOOL search
{"query":"class EditorTextView", "glob":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift"}
>>>END

---

## ðŸ”§ TOOL RESULTS

[search]
Found 1 matches:
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:716: class EditorTextView: UITextView {


>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift","start_line":680,"end_line":820}
>>>END

---

## ðŸ”§ TOOL RESULTS

[read_file]
File: VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift (lines 681-820 of 1990)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
681:                 let c = nsText.character(at: idx)
682:                 if isBracket(c) {
683:                     bracketIndex = idx
684:                     bracketChar = c
685:                     break
686:                 }
687:             }
688: 
689:             guard let idx = bracketIndex else { return }
690: 
691:             // Define bracket pairs
692:             let openToClose: [unichar: unichar] = [123: 125, 40: 41, 91: 93] // { -> }, ( -> ), [ -> ]
693:             let closeToOpen: [unichar: unichar] = [125: 123, 41: 40, 93: 91] // } -> {, ) -> (, ] -> [
694: 
695:             let theme = ThemeManager.shared.currentTheme
696:             let bg = UIColor(theme.selection).withAlphaComponent(theme.isDark ? 0.35 : 0.22)
697: 
698:             var matchIndex: Int?
699: 
700:             if let close = openToClose[bracketChar] {
701:                 // Opening bracket: scan forward
702:                 var depth = 0
703:                 var i = idx + 1
704:                 while i < length {
705:                     let c = nsText.character(at: i)
706:                     if c == bracketChar {
707:                         depth += 1
708:                     } else if c == close {
709:                         if depth == 0 {
710:                             matchIndex = i
711:                             break
712:                         } else {
713:                             depth -= 1
714:                         }
715:                     }
716:                     i += 1
717:                 }
718:             } else if let open = closeToOpen[bracketChar] {
719:                 // Closing bracket: scan backward
720:                 var depth = 0
721:                 var i = idx - 1
722:                 while i >= 0 {
723:                     let c = nsText.character(at: i)
724:                     if c == bracketChar {
725:                         depth += 1
726:                     } else if c == open {
727:                         if depth == 0 {
728:                             matchIndex = i
729:                             break
730:                         } else {
731:                             depth -= 1
732:                         }
733:                     }
734:                     i -= 1
735:                 }
736:             }
737: 
738:             guard let match = matchIndex else { return }
739: 
740:             let r1 = NSRange(location: idx, length: 1)
741:             let r2 = NSRange(location: match, length: 1)
742: 
743:             textView.textStorage.addAttribute(.backgroundColor, value: bg, range: r1)
744:             textView.textStorage.addAttribute(.backgroundColor, value: bg, range: r2)
745: 
746:             textView.textStorage.addAttribute(.underlineStyle, value: NSUnderlineStyle.single.rawValue, range: r1)
747:             textView.textStorage.addAttribute(.underlineStyle, value: NSUnderlineStyle.single.rawValue, range: r2)
748: 
749:             bracketHighlightRanges = [r1, r2]
750:         }
751:     }
752: }
753: 
754: // Custom text view to handle key commands, indent guides, and line highlighting
755: class EditorTextView: UITextView {
756:     var onPeekDefinition: (() -> Void)?
757:     var onEscape: (() -> Void)?
758:     var onGoToLine: (() -> Void)?
759:     
760:     // Custom action closures for context menu
761:     var onGoToDefinition: (() -> Void)?
762:     var onFindReferences: (() -> Void)?
763:     var onFormatDocument: (() -> Void)?
764:     var onToggleComment: (() -> Void)?
765:     var onFold: (() -> Void)?
766:     var onUnfold: (() -> Void)?
767: 
768:     // Autocomplete key handling hooks (return true if handled)
769:     var onAcceptAutocomplete: (() -> Bool)?
770:     var onDismissAutocomplete: (() -> Bool)?
771:     
772:     // FEAT-039 & FEAT-043
773:     private var indentGuideColor: UIColor = .separator
774:     private var activeIndentGuideColor: UIColor = .label
775:     private var currentLineHighlightColor: UIColor = .clear
776:     
777:     override init(frame: CGRect, textContainer: NSTextContainer?) {
778:         super.init(frame: frame, textContainer: textContainer)
779:         setup()
780:     }
781:     
782:     required init?(coder: NSCoder) {
783:         super.init(coder: coder)
784:         setup()
785:     }
786:     
787:     private func setup() {
788:         // Ensure we redraw when bounds/selection change
789:         contentMode = .redraw
790:     }
791:     
792:     func updateThemeColors(theme: Theme) {
793:         self.indentGuideColor = UIColor(theme.indentGuide)
794:         self.activeIndentGuideColor = UIColor(theme.indentGuideActive)
795:         self.currentLineHighlightColor = UIColor(theme.currentLineHighlight)
796:         setNeedsDisplay()
797:     }
798:     
799:     override func draw(_ rect: CGRect) {
800:         guard let context = UIGraphicsGetCurrentContext(), let font = self.font else {
801:             super.draw(rect)
802:             return
803:         }
804:         
805:         // 1. Draw Current Line Highlight (FEAT-043)
806:         if let selectedRange = selectedTextRange {
807:             // Get the line rect for the cursor position
808:             let caretRect = self.caretRect(for: selectedRange.start)
809:             let lineRect = CGRect(x: 0, y: caretRect.minY, width: bounds.width, height: caretRect.height)
810:             
811:             context.setFillColor(currentLineHighlightColor.cgColor)
812:             context.fill(lineRect)
813:         }
814:         
815:         // 2. Draw Text (super implementation)
816:         super.draw(rect)
817:         
818:         // 3. Draw Indent Guides (FEAT-039)
819:         // We iterate visible lines and draw vertical lines for indentation
820:         // Optimization: Only draw for visible range


>>>TOOL search
{"query":"makeUIView(context", "glob":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift"}
>>>END

---

## ðŸ”§ TOOL RESULTS

[search]
Found 1 matches:
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:108: func makeUIView(context: Context) -> UITextView {


>>>TOOL search
{"query":"attributedText =", "glob":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift"}
>>>END

---

## ðŸ”§ TOOL RESULTS

[search]
Found 2 matches:
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:495: let attributedText = highlighter.highlight(textView.text, filename: parent.filename)
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:498: textView.attributedText = attributedText


>>>TOOL search
{"query":"isActive", "glob":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift"}
>>>END

---

## ðŸ”§ TOOL RESULTS

[search]
Found 5 matches:
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:29: let isActive: Bool
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:43: isActive: Bool,
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:59: self.isActive = isActive
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:78: isActive: Bool,
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:95: isActive: isActive,


>>>TOOL search
{"query":"SyntaxHighlightingTextView.swift", "glob":"**/SyntaxHighlightingTextView.swift"} 
>>>END

---

## ðŸ”§ TOOL RESULTS

[search]
Found 1 matches:
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:2: //  SyntaxHighlightingTextView.swift


>>>TOOL search
{"query":"applySyntaxHighlighting(to:", "glob":"VSCodeiPadOS/VSCodeiPadOS/**/*.swift"}
>>>END

---

## ðŸ”§ TOOL RESULTS

[search]
Found 7 matches:
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:188: context.coordinator.applySyntaxHighlighting(to: textView)
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:213: context.coordinator.applySyntaxHighlighting(to: textView)
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:228: context.coordinator.applySyntaxHighlighting(to: textView)
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:235: context.coordinator.applySyntaxHighlighting(to: textView)
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:239: context.coordinator.applySyntaxHighlighting(to: textView)
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:311: applySyntaxHighlighting(to: textView)
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:331: self?.applySyntaxHighlighting(to: textView)


>>>TOOL search
{"query":"SyntaxHighlightingTextView.swift", "glob":"**/*"} 
>>>END

---

## ðŸ”§ TOOL RESULTS

[search]
Found 30 matches:
FULL_FEATURE_TEST_PLAN.md:47: ## 2. SYNTAX HIGHLIGHTING (SyntaxHighlightingTextView.swift - 1503 lines)
Docs/GITFUTURE.md:693: | git-gutter-2 | Integrate gutter with editor | Views/Editor/SyntaxHighlightingTextView.swift |
.claudefluff/agents/worker-autocomplete-keys-2026-02-09T11-35-27-953Z.md:17: {"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift","start_line":1,"end_line":500}
.claudefluff/agents/worker-autocomplete-keys-2026-02-09T11-35-27-953Z.md:23: {"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift","start_line":1,"end_line":500}
.claudefluff/agents/worker-autocomplete-keys-2026-02-09T11-35-27-953Z.md:28: {"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift","start_line":1,"end_line":140}
.claudefluff/agents/worker-autocomplete-keys-2026-02-09T11-35-27-953Z.md:54: {"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift","start_line":1,"end_line":260}
.claudefluff/agents/worker-autocomplete-keys-2026-02-09T11-35-27-953Z.md:58: {"query":"editorCore", "glob":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift"}
.claudefluff/agents/worker-autocomplete-keys-2026-02-09T11-35-27-953Z.md:63: {"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift","start_line":1,"end_line":40}
.claudefluff/agents/worker-autocomplete-keys-2026-02-09T11-35-27-953Z.md:142: {"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift","start_line":1,"end_line":25}
.claudefluff/agents/worker-autocomplete-keys-2026-02-09T11-35-27-953Z.md:286: {"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift","start_line":1,"end_line":980}
.claudefluff/agents/worker-autocomplete-keys-2026-02-09T11-35-27-953Z.md:346: >>>FILE VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift
.claudefluff/agents/worker-autocomplete-keys-2026-02-09T11-35-27-953Z.md:381: >>>FILE VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift
.claudefluff/agents/worker-autocomplete-keys-2026-02-09T11-35-27-953Z.md:442: >>>FILE VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift
.claudefluff/agents/worker-autocomplete-keys-2026-02-09T11-35-27-953Z.md:471: >>>FILE VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift
.claudefluff/agents/worker-autocomplete-keys-2026-02-09T11-35-27-953Z.md:508: >>>FILE VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift
.claudefluff/agents/worker-autocomplete-keys-2026-02-09T11-35-27-953Z.md:520: >>>FILE VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift
.claudefluff/agents/worker-autocomplete-keys-2026-02-09T11-35-27-953Z.md:539: >>>FILE VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift
.claudefluff/agents/worker-autocomplete-keys-2026-02-09T11-35-27-953Z.md:589: >>>FILE VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift
.claudefluff/agents/worker-autocomplete-keys-2026-02-09T11-35-27-953Z.md:638: >>>FILE VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift
.claudefluff/agents/worker-autocomplete-keys-2026-02-09T11-35-27-953Z.md:654: >>>FILE VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift
.claudefluff/agents/worker-autocomplete-keys-2026-02-09T11-35-27-953Z.md:680: >>>FILE VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift
.claudefluff/agents/worker-autocomplete-keys-2026-02-09T11-35-27-953Z.md:692: >>>FILE VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift
.claudefluff/agents/worker-autocomplete-keys-2026-02-09T11-35-27-953Z.md:739: {"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift","start_line":8,"end_line":90}
.claudefluff/agents/worker-autocomplete-keys-2026-02-09T11-35-27-953Z.md:743: {"query":"self._requestedCursorIndex", "glob":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift"}
.claudefluff/agents/worker-autocomplete-keys-2026-02-09T11-35-27-953Z.md:747: {"query":"self.parent.currentColumn", "glob":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift"}
.claudefluff/agents/worker-autocomplete-keys-2026-02-09T11-35-27-953Z.md:777: >>>FILE VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift
.claudefluff/agents/worker-autocomplete-keys-2026-02-09T11-35-27-953Z.md:1044: {"query":"func updateCursorPosition(_ textView: UITextView)", "glob":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift"}
.claudefluff/agents/worker-autocomplete-keys-2026-02-09T11-35-27-953Z.md:1048: {"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift","start_line":220,"end_line":310}
.claudefluff/agents/worker-autocomplete-keys-2026-02-09T11-35-27-953Z.md:1083: >>>FILE VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift
.claudefluff/agents/worker-autocomplete-keys-2026-02-09T11-35-27-953Z.md:1104: >>>FILE VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift


>>>TOOL search
{"query":"SyntaxHighlightingTextView_Update", "glob":"VSCodeiPadOS/VSCodeiPadOS/**/*.swift"}
>>>END

---

## ðŸ”§ TOOL RESULTS

[search]
No matches found for "SyntaxHighlightingTextView_Update"


>>>TOOL get_errors
{}
>>>END

---

## ðŸ”§ TOOL RESULTS

[get_errors]
âœ… No errors or warnings


>>>TOOL search
{"query":"struct SyntaxHighlightingTextView: UIViewRepresentable", "glob":"**/*.swift"}
>>>END

---

## ðŸ”§ TOOL RESULTS

[search]
Found 1 matches:
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:12: struct SyntaxHighlightingTextView: UIViewRepresentable {


>>>REPORT
- Checked `VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift` for where initial text is set.
  - In `makeUIView(context:)`, initial text is set via `textView.text = text` and syntax highlighting is applied immediately after:
    - Lines **186-190**: `textView.text = text` then `context.coordinator.applySyntaxHighlighting(to: textView)` and `updateLineCount(textView)`. (from read_file lines 2-220)
  - In `updateUIView(_:context:)`, when text changes externally, it also re-applies highlighting:
    - Lines **221-224**: sets `textView.text = text` and calls `context.coordinator.applySyntaxHighlighting(to: textView)`. (from read_file lines 221-340)
  - `textViewDidBeginEditing(_:)` exists and triggers highlighting:
    - Lines **288-292**: `applySyntaxHighlighting(to: textView)` on begin editing. (from read_file lines 221-340)

- Build/diagnostics check:
  - `get_errors` returned **âœ… No errors or warnings**.
>>>END
