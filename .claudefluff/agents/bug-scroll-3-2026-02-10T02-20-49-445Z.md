# Agent: bug-scroll-3
**Status:** done
**Tokens:** 7,295
**Cost:** $0.0000
**Time:** 2026-02-10T02:20:49.445Z

## Task
CRITICAL BUG: MinimapView scroll sync may be causing scroll jitter. Find MinimapView.swift and check if it's fighting with main editor scroll. The minimap should FOLLOW the editor, not force the editor to scroll. Fix any bidirectional scroll binding issues. BUILD AFTER FIX.

## Response
>>>TOOL search
{"query": "MinimapView", "glob": "*.swift"}
>>>END

>>>TOOL search
{"query": "minimap", "glob": "*.swift"}
>>>END

---

## ðŸ”§ TOOL RESULTS

[search]
No matches found for "minimap"


>>>TOOL list_dir
{}
>>>END

---

## ðŸ”§ TOOL RESULTS

[list_dir]
ðŸ“ ./
ðŸ“ .claude/
ðŸ“ .claudefluff/
ðŸ“ .patch-backups/
ðŸ“ .vscode/
ðŸ“ Docs/
ðŸ“ Extensions/
ðŸ“ logs/
ðŸ“ Models/
ðŸ“ Services/
ðŸ“ test-results/
ðŸ“ Tests/
ðŸ“ Views/
ðŸ“ VSCodeiPadOS/
ðŸ“ VSCodeiPadOSUITests/
   .gitignore
   build.log
   FULL_FEATURE_TEST_PLAN.md
   LICENSE
   README.md
(cached)


>>>TOOL list_dir
{"path": "Views"}
>>>END

---

## ðŸ”§ TOOL RESULTS

[list_dir]
ðŸ“ Views/
ðŸ“ Editor/
ðŸ“ Panels/
(cached)


>>>TOOL list_dir
{"path": "Views/Editor"}
>>>END

---

## ðŸ”§ TOOL RESULTS

[list_dir]
ðŸ“ Views/Editor/
   (empty directory)


>>>TOOL list_dir
{"path": "VSCodeiPadOS"}
>>>END

---

## ðŸ”§ TOOL RESULTS

[list_dir]
ðŸ“ VSCodeiPadOS/
ðŸ“ Docs/
ðŸ“ Views/
ðŸ“ VSCodeiPadOS/
ðŸ“ VSCodeiPadOS.xcodeproj/
ðŸ“ VSCodeiPadOSTests/
   bugs.md
   build_output.log
   build_output2.log
   build.log
   Info.plist
   Package.swift
(cached)


>>>TOOL list_dir
{"path": "VSCodeiPadOS/Views"}
>>>END

---

## ðŸ”§ TOOL RESULTS

[list_dir]
ðŸ“ VSCodeiPadOS/Views/
ðŸ“ Editor/


>>>TOOL list_dir
{"path": "VSCodeiPadOS/Views/Editor"}
>>>END

---

## ðŸ”§ TOOL RESULTS

[list_dir]
ðŸ“ VSCodeiPadOS/Views/Editor/
   (empty directory)


>>>TOOL list_dir
{"path": "VSCodeiPadOS/VSCodeiPadOS"}
>>>END

---

## ðŸ”§ TOOL RESULTS

[list_dir]
ðŸ“ VSCodeiPadOS/VSCodeiPadOS/
ðŸ“ App/
ðŸ“ Assets.xcassets/
ðŸ“ Commands/
ðŸ“ Docs/
ðŸ“ Extensions/
ðŸ“ Menus/
ðŸ“ Models/
ðŸ“ Resources/
ðŸ“ Services/
ðŸ“ Tests/
ðŸ“ UITests/
ðŸ“ Utils/
ðŸ“ Views/
   .tooling_note.txt
   ContentView_shift_arrow.patch
   ContentView.swift
   ContentView.swift.bak
   FIX_SUMMARY.md
   IMPLEMENTATION_SUMMARY.md
   Info.plist
   KeyboardShortcuts.md
   MULTI_WINDOW_IMPLEMENTATION.md
   MultiWindowSupport.md
   SceneDelegate.swift
   SyntaxHighlighter_Optimizations.md
(cached)


>>>TOOL list_dir
{"path": "VSCodeiPadOS/VSCodeiPadOS/Views"}
>>>END

---

## ðŸ”§ TOOL RESULTS

[list_dir]
ðŸ“ VSCodeiPadOS/VSCodeiPadOS/Views/
ðŸ“ Editor/
ðŸ“ Panels/
   _tmp.txt
   BranchMenu.swift
   CommandPalette.swift
   CommandPaletteView.swift
   DiffComponents.swift
   FileIconView.swift
   FileTreeView.swift
   GoToSymbol.swift
   LaunchConfigView.swift
   QuickOpen.swift
   RunConfigView.swift
   SidebarView.swift
   SnippetPickerView.swift
   StatusBarView.swift
   TabBarView.swift
   TasksView.swift
   WorkspaceSettingsView.swift
   WorkspaceTrustDialog.swift


>>>TOOL list_dir
{"path": "VSCodeiPadOS/VSCodeiPadOS/Views/Editor"}
>>>END

---

## ðŸ”§ TOOL RESULTS

[list_dir]
ðŸ“ VSCodeiPadOS/VSCodeiPadOS/Views/Editor/
   BreadcrumbsView.swift
   ColorPickerView.swift
   EditorSplitView.swift
   GitGutterView.swift
   HoverInfoView.swift
   InlayHintsOverlay.swift
   InlineSuggestionView.swift
   JSONTreeView.swift
   MergeConflictView.swift
   MinimapView.swift
   MultiCursorTextView.swift
   PeekDefinitionView.swift
   SplitEditorView.swift
   StickyHeaderView.swift
   SyntaxHighlightingTextView_Update.swift
   SyntaxHighlightingTextView.swift


>>>TOOL read_file
{"path": "VSCodeiPadOS/VSCodeiPadOS/Views/Editor/MinimapView.swift"}
>>>END

---

## ðŸ”§ TOOL RESULTS

[read_file]
File: VSCodeiPadOS/VSCodeiPadOS/Views/Editor/MinimapView.swift (lines 1-461 of 461)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1: import SwiftUI
2: 
3: /// VS Codeâ€“style minimap with:
4: /// - syntax-colored tiny preview
5: /// - visible region overlay
6: /// - tap/drag to scroll
7: /// - optional git diff indicators (added/modified/deleted)
8: struct MinimapView: View {
9:     // MARK: - External inputs
10: 
11:     let content: String
12:     @Binding var scrollOffset: CGFloat
13:     @Binding var scrollViewHeight: CGFloat
14:     let totalContentHeight: CGFloat
15: 
16:     /// Optional indicators to render as thin bars on the left side of the minimap.
17:     /// Note: call sites can ignore this (default empty) without breaking compilation.
18:     var diffIndicators: [MinimapDiffIndicator] = []
19: 
20:     /// Fixed width; height expands to the container.
21:     var minimapWidth: CGFloat = 60
22: 
23:     // MARK: - Internal state
24: 
25:     @State private var isInteracting: Bool = false
26: 
27:     // MARK: - Types
28: 
29:     struct MinimapDiffIndicator: Identifiable, Hashable {
30:         enum Kind: Hashable {
31:             case added
32:             case modified
33:             case deleted
34:         }
35: 
36:         var id = UUID()
37:         /// 0-based line range in the current `content`.
38:         var lineRange: Range<Int>
39:         var kind: Kind
40: 
41:         init(lineRange: Range<Int>, kind: Kind) {
42:             self.lineRange = lineRange
43:             self.kind = kind
44:         }
45:     }
46: 
47:     // MARK: - View
48: 
49:     var body: some View {
50:         GeometryReader { geometry in
51:             let size = geometry.size
52:             let minimapHeight = max(1, size.height)
53:             let lines = content.split(separator: "\n", omittingEmptySubsequences: false)
54:             let lineCount = max(lines.count, 1)
55: 
56:             ZStack(alignment: .topLeading) {
57:                 // Background
58:                 Rectangle()
59:                     .fill(Color(white: 0.13))
60: 
61:                 // Syntax-colored code preview
62:                 Canvas { context, canvasSize in
63:                     drawMinimapPreview(
64:                         in: &context,
65:                         size: canvasSize,
66:                         lines: lines
67:                     )
68:                 }
69:                 .allowsHitTesting(false)
70: 
71:                 // Git diff indicators (thin left bars)
72:                 diffIndicatorsLayer(
73:                     minimapHeight: minimapHeight,
74:                     lineCount: lineCount
75:                 )
76:                 .allowsHitTesting(false)
77: 
78:                 // Visible region highlight
79:                 visibleRegionLayer(minimapHeight: minimapHeight)
80:                     .allowsHitTesting(false)
81:             }
82:             .frame(width: minimapWidth, height: minimapHeight)
83:             .clipShape(Rectangle())
84:             .contentShape(Rectangle())
85:             // Click-to-scroll + drag scrolling (DragGesture(minDistance: 0) captures taps too)
86:             .gesture(
87:                 DragGesture(minimumDistance: 0, coordinateSpace: .local)
88:                     .onChanged { value in
89:                         isInteracting = true
90:                         updateScroll(forMinimapY: value.location.y, minimapHeight: minimapHeight)
91:                     }
92:                     .onEnded { _ in
93:                         isInteracting = false
94:                     }
95:             )
96:         }
97:         .frame(width: minimapWidth)
98:     }
99: 
100:     // MARK: - Layers
101: 
102:     @ViewBuilder
103:     private func visibleRegionLayer(minimapHeight: CGFloat) -> some View {
104:         let height = visibleRegionHeight(minimapHeight: minimapHeight)
105:         let offset = visibleRegionOffset(minimapHeight: minimapHeight, visibleHeight: height)
106: 
107:         Rectangle()
108:             .fill(Color.accentColor.opacity(isInteracting ? 0.22 : 0.16))
109:             .overlay(
110:                 Rectangle()
111:                     .stroke(Color.accentColor.opacity(0.65), lineWidth: 1)
112:             )
113:             .frame(width: minimapWidth, height: height)
114:             .offset(y: offset)
115:     }
116: 
117:     @ViewBuilder
118:     private func diffIndicatorsLayer(minimapHeight: CGFloat, lineCount: Int) -> some View {
119:         // VS Code minimap diff markers are thin and pinned to the left.
120:         let barWidth: CGFloat = 2
121: 
122:         // Guard against division by zero
123:         if lineCount > 0 {
124:             ForEach(diffIndicators) { indicator in
125:                 let startLine = max(0, min(indicator.lineRange.lowerBound, lineCount - 1))
126:                 let endLineExclusive = max(startLine + 1, min(indicator.lineRange.upperBound, lineCount))
127: 
128:                 let startY = (CGFloat(startLine) / CGFloat(max(lineCount, 1))) * minimapHeight
129:                 let endY = (CGFloat(endLineExclusive) / CGFloat(max(lineCount, 1))) * minimapHeight
130:                 let height = max(2, endY - startY)
131: 
132:                 Rectangle()
133:                     .fill(diffColor(for: indicator.kind).opacity(0.95))
134:                     .frame(width: barWidth, height: height)
135:                     .offset(x: 0, y: startY)
136:             }
137:         }
138:     }
139: 
140:     // MARK: - Visible region math
141: 
142:     private func visibleRegionHeight(minimapHeight: CGFloat) -> CGFloat {
143:         guard totalContentHeight > 0 else { return 0 }
144:         let ratio = scrollViewHeight / totalContentHeight
145:         return minimapHeight * min(max(ratio, 0), 1.0)
146:     }
147: 
148:     private func visibleRegionOffset(minimapHeight: CGFloat, visibleHeight: CGFloat) -> CGFloat {
149:         let scrollable = max(0, totalContentHeight - scrollViewHeight)
150:         guard scrollable > 0 else { return 0 }
151: 
152:         let scrollRatio = min(max(scrollOffset / scrollable, 0), 1.0)
153:         return scrollRatio * max(0, minimapHeight - visibleHeight)
154:     }
155: 
156:     // MARK: - Interaction
157: 
158:     /// Sets `scrollOffset` so that the main editor's visible region is centered around the minimap Y position.
159:     private func updateScroll(forMinimapY yPosition: CGFloat, minimapHeight: CGFloat) {
160:         guard totalContentHeight > 0 else { return }
161: 
162:         let clampedY = max(0, min(yPosition, minimapHeight))
163:         let ratio = (minimapHeight > 0) ? (clampedY / minimapHeight) : 0
164: 
165:         // Target a center position (VS Code behavior).
166:         let targetCenter = ratio * totalContentHeight
167:         let desiredOffset = targetCenter - (scrollViewHeight / 2)
168: 
169:         let maxOffset = max(0, totalContentHeight - scrollViewHeight)
170:         scrollOffset = min(max(desiredOffset, 0), maxOffset)
171:     }
172: 
173:     // MARK: - Rendering (Canvas)
174: 
175:     private func drawMinimapPreview(
176:         in context: inout GraphicsContext,
177:         size: CGSize,
178:         lines: [Substring]
179:     ) {
180:         let paddingX: CGFloat = 4
181:         let paddingY: CGFloat = 2
182: 
183:         let contentWidth = max(0, size.width - (paddingX * 2))
184:         let contentHeight = max(0, size.height - (paddingY * 2))
185: 
186:         guard contentWidth > 0, contentHeight > 0 else { return }
187: 
188:         let lineCount = max(lines.count, 1)
189:         
190:         // FIXED: Use fixed pixels per line (VS Code style) instead of stretching to fill
191:         // This ensures the minimap always shows a tiny preview regardless of file size
192:         let targetPixelsPerLine: CGFloat = 2.5
193:         let pixelsPerLine = targetPixelsPerLine
194:         
195:         // Calculate how many lines we can show in the minimap
196:         let visibleLines = Int(contentHeight / pixelsPerLine)
197:         
198:         // Calculate scroll offset to show the right portion of the document
199:         // Use scrollOffset and totalContentHeight to calculate current position
200:         let scrollRatio = totalContentHeight > 0 ? Double(scrollOffset) / Double(max(totalContentHeight - scrollViewHeight, 1)) : 0
201:         let startLine = max(0, Int(scrollRatio * Double(max(0, lineCount - visibleLines))))
202: 
203:         // Token-block mode (colored rectangles) - VS Code style minimap
204:         let minBarHeight: CGFloat = 1
205:         let barHeight = max(minBarHeight, pixelsPerLine)
206: 
207:         // Approximate "characters" across minimap width.
208:         let maxChars: CGFloat = 120
209:         let charWidth = contentWidth / maxChars
210: 
211:         // Render lines starting from startLine (scrolls with document)
212:         let endLine = min(startLine + visibleLines + 1, lineCount)
213:         
214:         // Guard against invalid range (endLine must be >= startLine)
215:         guard endLine >= startLine else { return }
216:         
217:         for i in startLine..<endLine {
218:             let displayIndex = i - startLine
219:             let y = paddingY + (CGFloat(displayIndex) * pixelsPerLine)
220:             if y > size.height { break }
221: 
222:             let line = lines.indices.contains(i) ? lines[i] : Substring("")
223:             let tokens = tokenize(line)
224: 
225:             var x = paddingX
226:             let yAligned = y.rounded(FloatingPointRoundingRule.down)
227: 
228:             if tokens.isEmpty {
229:                 // Render faint whitespace line.
230:                 let rect = CGRect(x: x, y: yAligned, width: max(4, contentWidth * 0.15), height: barHeight)
231:                 context.fill(Path(rect), with: .color(Color(white: 0.45).opacity(0.10)))
232:                 continue
233:             }
234: 
235:             for token in tokens {
236:                 guard x < (paddingX + contentWidth) else { break }
237:                 let w = max(1, CGFloat(token.text.count) * charWidth)
238:                 let rect = CGRect(x: x, y: yAligned, width: min(w, paddingX + contentWidth - x), height: barHeight)
239:                 context.fill(Path(rect), with: .color(token.color.opacity(0.80)))
240:                 x += w
241:             }
242:         }
243:     }
244: 
245:     // MARK: - Syntax highlighting (lightweight)
246: 
247:     private struct Token {
248:         enum Kind {
249:             case plain
250:             case keyword
251:             case string
252:             case comment
253:             case number
254:             case typeName
255:         }
256: 
257:         var text: Substring
258:         var kind: Kind
259: 
260:         var color: Color {
261:             switch kind {
262:             case .plain:
263:                 return Color(white: 0.70)
264:             case .keyword:
265:                 return Color(red: 0.78, green: 0.53, blue: 0.95) // purple-ish
266:             case .string:
267:                 return Color(red: 0.80, green: 0.72, blue: 0.43) // yellow-ish
268:             case .comment:
269:                 return Color(red: 0.46, green: 0.60, blue: 0.50) // green-ish
270:             case .number:
271:                 return Color(red: 0.40, green: 0.73, blue: 0.92) // blue-ish
272:             case .typeName:
273:                 return Color(red: 0.45, green: 0.83, blue: 0.70) // teal-ish
274:             }
275:         }
276:     }
277: 
278:     private func makeAttributedLine(from line: Substring, fontSize: CGFloat) -> AttributedString {
279:         let tokens = tokenize(line)
280: 
281:         var out = AttributedString()
282:         for token in tokens {
283:             var chunk = AttributedString(String(token.text))
284:             chunk.font = .system(size: fontSize, weight: .regular, design: .monospaced)
285:             chunk.foregroundColor = token.color
286:             out.append(chunk)
287:         }
288: 
289:         if out.characters.isEmpty {
290:             // Preserve a tiny amount of "whitespace presence" so empty lines still show.
291:             var chunk = AttributedString(" ")
292:             chunk.font = .system(size: fontSize, weight: .regular, design: .monospaced)
293:             chunk.foregroundColor = Color(white: 0.7).opacity(0.25)
294:             out.append(chunk)
295:         }
296: 
297:         return out
298:     }
299: 
300:     private func tokenize(_ line: Substring) -> [Token] {
301:         // Extremely lightweight tokenizer:
302:         // - full-line comment if first non-space is # (python-like)
303:         // - inline comment starting at //
304:         // - strings in "..." or '...'
305:         // - numbers
306:         // - keywords
307:         // - PascalCase tokens treated as type names
308:         var tokens: [Token] = []
309:         var i = line.startIndex
310: 
311:         func peek(_ offset: Int = 0) -> Character? {
312:             var idx = i
313:             for _ in 0..<offset {
314:                 guard idx < line.endIndex else { return nil }
315:                 idx = line.index(after: idx)
316:             }
317:             return idx < line.endIndex ? line[idx] : nil
318:         }
319: 
320:         func advance(_ n: Int = 1) {
321:             for _ in 0..<n {
322:                 guard i < line.endIndex else { return }
323:                 i = line.index(after: i)
324:             }
325:         }
326: 
327:         // Detect python/shebang-like comment lines: first non-whitespace is '#'
328:         if let firstNonSpace = line.firstIndex(where: { !$0.isWhitespace }),
329:            line[firstNonSpace] == "#" {
330:             tokens.append(Token(text: line[line.startIndex..<line.endIndex], kind: .comment))
331:             return tokens
332:         }
333: 
334:         while i < line.endIndex {
335:             let ch = line[i]
336: 
337:             // Inline comment: //
338:             if ch == "/", peek(1) == "/" {
339:                 let range = i..<line.endIndex
340:                 tokens.append(Token(text: line[range], kind: .comment))
341:                 return tokens
342:             }
343: 
344:             // Whitespace
345:             if ch.isWhitespace {
346:                 let start = i
347:                 while i < line.endIndex, line[i].isWhitespace { advance() }
348:                 tokens.append(Token(text: line[start..<i], kind: .plain))
349:                 continue
350:             }
351: 
352:             // String literals
353:             if ch == "\"" || ch == "'" {
354:                 let quote = ch
355:                 let start = i
356:                 advance()
357:                 var escaped = false
358:                 while i < line.endIndex {
359:                     let c = line[i]
360:                     if escaped {
361:                         escaped = false
362:                         advance()
363:                         continue
364:                     }
365:                     if c == "\\" {
366:                         escaped = true
367:                         advance()
368:                         continue
369:                     }
370:                     if c == quote {
371:                         advance()
372:                         break
373:                     }
374:                     advance()
375:                 }
376:                 tokens.append(Token(text: line[start..<i], kind: .string))
377:                 continue
378:             }
379: 
380:             // Numbers
381:             if ch.isNumber {
382:                 let start = i
383:                 while i < line.endIndex, line[i].isNumber || line[i] == "." { advance() }
384:                 tokens.append(Token(text: line[start..<i], kind: .number))
385:                 continue
386:             }
387: 
388:             // Identifiers / keywords
389:             if ch.isLetter || ch == "_" {
390:                 let start = i
391:                 advance()
392:                 while i < line.endIndex {
393:                     let c = line[i]
394:                     if c.isLetter || c.isNumber || c == "_" { advance() } else { break }
395:                 }
396:                 let word = line[start..<i]
397:                 let kind: Token.Kind
398: 
399:                 if isKeyword(word) {
400:                     kind = .keyword
401:                 } else if looksLikeTypeName(word) {
402:                     kind = .typeName
403:                 } else {
404:                     kind = .plain
405:                 }
406: 
407:                 tokens.append(Token(text: word, kind: kind))
408:                 continue
409:             }
410: 
411:             // Operators / punctuation
412:             let start = i
413:             advance()
414:             tokens.append(Token(text: line[start..<i], kind: .plain))
415:         }
416: 
417:         return tokens
418:     }
419: 
420:     private func isKeyword(_ word: Substring) -> Bool {
421:         // Small superset of common Swift/JS/Python keywords.
422:         // (We can't depend on a full parser here.)
423:         let keywords: Set<String> = [
424:             "import", "export", "from", "as",
425:             "struct", "class", "enum", "protocol", "extension", "func", "var", "let",
426:             "if", "else", "for", "while", "repeat", "switch", "case", "default",
427:             "break", "continue", "return", "throw", "throws", "try", "catch",
428:             "do", "in", "where", "guard", "defer",
429:             "public", "private", "fileprivate", "internal", "open",
430:             "static", "final", "override", "mutating", "nonmutating",
431:             "async", "await",
432:             "true", "false", "nil",
433:             "self", "super",
434:             // JS/Python-ish
435:             "const", "function", "async", "await", "new", "this",
436:             "def", "pass", "lambda", "None"
437:         ]
438:         return keywords.contains(String(word))
439:     }
440: 
441:     private func looksLikeTypeName(_ word: Substring) -> Bool {
442:         // Simple heuristic: PascalCase (leading uppercase).
443:         guard let first = word.first else { return false }
444:         return first.isUppercase
445:     }
446: 
447:     // MARK: - Diff colors
448: 
449:     private func diffColor(for kind: MinimapDiffIndicator.Kind) -> Color {
450:         switch kind {
451:         case .added:
452:             return Color.green
453:         case .modified:
454:             return Color.red
455:         case .deleted:
456:             // VS Code uses red-ish for deletions too; keep distinct via slightly different tone.
457:             return Color(red: 1.0, green: 0.35, blue: 0.35)
458:         }
459:     }
460: }
461: 


Let me search for how MinimapView is used to understand the scroll binding setup:

>>>TOOL search
{"query": "MinimapView(", "glob": "*.swift"}
>>>END

---

## ðŸ”§ TOOL RESULTS

[search]
No matches found for "MinimapView("


>>>TOOL search
{"query": "MinimapView", "glob": "*.swift"}
>>>END

---

## ðŸ”§ TOOL RESULTS

[search]
No matches found for "MinimapView"


>>>TOOL search
{"query": "scrollOffset", "glob": "*.swift"}
>>>END

---

## ðŸ”§ TOOL RESULTS

[search]
No matches found for "scrollOffset"


>>>TOOL read_file
{"path": "VSCodeiPadOS/VSCodeiPadOS/ContentView.swift"}
>>>END

---

## ðŸ”§ TOOL RESULTS

[read_file]
File: VSCodeiPadOS/VSCodeiPadOS/ContentView.swift (lines 1-1058 of 1058)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1: import SwiftUI
2: import UIKit
3: import UniformTypeIdentifiers
4: 
5: // MARK: - Helper Functions
6: // Moved to Extensions/FileHelpers.swift
7: 
8: // MARK: - Main Content View
9: 
10: struct ContentView: View {
11:     @EnvironmentObject var editorCore: EditorCore
12:     @StateObject private var fileNavigator = FileSystemNavigator()
13:     @StateObject private var themeManager = ThemeManager.shared
14:     
15:     @State private var showingDocumentPicker = false
16:     @State private var showingFolderPicker = false
17:     @State private var showSettings = false
18:     @State private var showTerminal = false
19:     @State private var terminalHeight: CGFloat = 200
20:     @State private var selectedSidebarTab = 0
21:     @State private var pendingTrustURL: URL?
22:     @State private var windowTitle: String = "VS Code"
23:     
24:     @StateObject private var trustManager = WorkspaceTrustManager.shared
25:     
26:     private var theme: Theme { themeManager.currentTheme }
27:     
28:     var body: some View {
29:         ZStack {
30:             VStack(spacing: 0) {
31:                 HStack(spacing: 0) {
32:                     IDEActivityBar(editorCore: editorCore, selectedTab: $selectedSidebarTab, showSettings: $showSettings, showTerminal: $showTerminal)
33:                     
34:                     if editorCore.showSidebar {
35:                         sidebarContent.frame(width: editorCore.sidebarWidth)
36:                     }
37:                     
38:                     VStack(spacing: 0) {
39:                         IDETabBar(editorCore: editorCore, theme: theme)
40:                         
41:                         if let tab = editorCore.activeTab {
42:                             IDEEditorView(editorCore: editorCore, tab: tab, theme: theme)
43:                                 .id(tab.id)  // Force view recreation when tab changes
44:                         } else {
45:                             IDEWelcomeView(editorCore: editorCore, showFolderPicker: $showingFolderPicker, theme: theme)
46:                         }
47:                         
48:                         StatusBarView(editorCore: editorCore)
49:                     }
50:                 }
51:                 
52:                 if showTerminal {
53:                     PanelView(isVisible: $showTerminal, height: $terminalHeight)
54:                 }
55:             }
56:             .background(theme.editorBackground)
57:             
58:             // Overlays - Command Palette (Cmd+Shift+P)
59:             if editorCore.showCommandPalette {
60:                 Color.black.opacity(0.4).ignoresSafeArea().onTapGesture { editorCore.showCommandPalette = false }
61:                 CommandPaletteView(editorCore: editorCore, showSettings: $showSettings, showTerminal: $showTerminal)
62:             }
63:             
64:             // Quick Open (Cmd+P)
65:             if editorCore.showQuickOpen {
66:                 Color.black.opacity(0.4).ignoresSafeArea().onTapGesture { editorCore.showQuickOpen = false }
67:                 QuickOpenView(editorCore: editorCore, fileNavigator: fileNavigator)
68:             }
69:             
70:             // Go To Symbol (Cmd+Shift+O)
71:             if editorCore.showGoToSymbol {
72:                 Color.black.opacity(0.4).ignoresSafeArea().onTapGesture { editorCore.showGoToSymbol = false }
73:                 GoToSymbolView(editorCore: editorCore, onGoToLine: { _ in })
74:             }
75:             
76:             // AI Assistant
77:             if editorCore.showAIAssistant {
78:                 HStack { Spacer(); IDEAIAssistant(editorCore: editorCore, theme: theme).frame(width: 400, height: 500).padding() }
79:             }
80:             
81:             // Go To Line (Ctrl+G)
82:             if editorCore.showGoToLine {
83:                 Color.black.opacity(0.4).ignoresSafeArea().onTapGesture { editorCore.showGoToLine = false }
84:                 GoToLineView(isPresented: $editorCore.showGoToLine, onGoToLine: { _ in })
85:             }
86:             
87:             // Workspace Trust Dialog
88:             if let trustURL = pendingTrustURL {
89:                 Color.black.opacity(0.4).ignoresSafeArea()
90:                 WorkspaceTrustDialog(workspaceURL: trustURL, onTrust: {
91:                     trustManager.trust(url: trustURL)
92:                     finishOpeningWorkspace(trustURL)
93:                     pendingTrustURL = nil
94:                 }, onCancel: {
95:                     pendingTrustURL = nil
96:                 })
97:             }
98:         }
99:         .sheet(isPresented: $showingDocumentPicker) { IDEDocumentPicker(editorCore: editorCore) }
100:         .sheet(isPresented: $showingFolderPicker) {
101:             IDEFolderPicker(fileNavigator: fileNavigator) { url in
102:                 if trustManager.isTrusted(url: url) {
103:                     finishOpeningWorkspace(url)
104:                 } else {
105:                     pendingTrustURL = url
106:                 }
107:             }
108:         }
109:         .sheet(isPresented: $showSettings) { SettingsView(themeManager: themeManager) }
110:         .onChange(of: editorCore.showFilePicker) { show in showingDocumentPicker = show }
111:         .onChange(of: editorCore.activeTab?.fileName) { newFileName in
112:             updateWindowTitle()
113:         }
114:         .onChange(of: editorCore.tabs.count) { _ in
115:             updateWindowTitle()
116:         }
117:         .onAppear {
118:             updateWindowTitle()
119:         }
120:         // MARK: - Notification Handlers for Menu Keyboard Shortcuts
121:         .onReceive(NotificationCenter.default.publisher(for: NSNotification.Name("ShowCommandPalette"))) { _ in
122:             editorCore.showCommandPalette = true
123:         }
124:         .onReceive(NotificationCenter.default.publisher(for: NSNotification.Name("ToggleTerminal"))) { _ in
125:             showTerminal.toggle()
126:         }
127:         .onReceive(NotificationCenter.default.publisher(for: NSNotification.Name("ToggleSidebar"))) { _ in
128:             editorCore.toggleSidebar()
129:         }
130:         .onReceive(NotificationCenter.default.publisher(for: NSNotification.Name("ShowQuickOpen"))) { _ in
131:             editorCore.showQuickOpen = true
132:         }
133:         .onReceive(NotificationCenter.default.publisher(for: NSNotification.Name("ShowGoToSymbol"))) { _ in
134:             editorCore.showGoToSymbol = true
135:         }
136:         .onReceive(NotificationCenter.default.publisher(for: NSNotification.Name("ShowGoToLine"))) { _ in
137:             editorCore.showGoToLine = true
138:         }
139:         .onReceive(NotificationCenter.default.publisher(for: NSNotification.Name("ShowAIAssistant"))) { _ in
140:             editorCore.showAIAssistant = true
141:         }
142:         .onReceive(NotificationCenter.default.publisher(for: NSNotification.Name("NewFile"))) { _ in
143:             editorCore.addTab()
144:         }
145:         .onReceive(NotificationCenter.default.publisher(for: NSNotification.Name("SaveFile"))) { _ in
146:             editorCore.saveActiveTab()
147:         }
148:         .onReceive(NotificationCenter.default.publisher(for: NSNotification.Name("CloseTab"))) { _ in
149:             if let id = editorCore.activeTabId { editorCore.closeTab(id: id) }
150:         }
151:         .onReceive(NotificationCenter.default.publisher(for: NSNotification.Name("ShowFind"))) { _ in
152:             editorCore.showSearch = true
153:         }
154:         .onReceive(NotificationCenter.default.publisher(for: NSNotification.Name("ZoomIn"))) { _ in
155:             editorCore.zoomIn()
156:         }
157:         .onReceive(NotificationCenter.default.publisher(for: NSNotification.Name("ZoomOut"))) { _ in
158:             editorCore.zoomOut()
159:         }
160:         .environmentObject(themeManager)
161:         .environmentObject(editorCore)
162:     }
163:     
164:     private func finishOpeningWorkspace(_ url: URL) {
165:         fileNavigator.loadFileTree(at: url)
166:         Task { @MainActor in
167:             LaunchManager.shared.setWorkspaceRoot(url)
168:             GitManager.shared.setWorkingDirectory(url)
169:         }
170:     }
171:     
172:     private func updateWindowTitle() {
173:         if let activeTab = editorCore.activeTab {
174:             let fileName = activeTab.fileName
175:             let unsavedIndicator = activeTab.isUnsaved ? "â— " : ""
176:             windowTitle = "\(unsavedIndicator)\(fileName) - VS Code"
177:         } else if !editorCore.tabs.isEmpty {
178:             windowTitle = "VS Code"
179:         } else {
180:             windowTitle = "Welcome - VS Code"
181:         }
182:         
183:         // Notify the app of the title change
184:         NotificationCenter.default.post(
185:             name: NSNotification.Name("WindowTitleDidChange"),
186:             object: nil,
187:             userInfo: ["title": windowTitle]
188:         )
189:     }
190:     
191:     @ViewBuilder
192:     private var sidebarContent: some View {
193:         switch selectedSidebarTab {
194:         case 0:
195:             IDESidebarFiles(editorCore: editorCore, fileNavigator: fileNavigator, showFolderPicker: $showingFolderPicker, theme: theme)
196:         case 1:
197:             SidebarSearchView(theme: theme)
198:         case 2:
199:             GitView()
200:         case 3:
201:             DebugView()
202:         default:
203:             IDESidebarFiles(editorCore: editorCore, fileNavigator: fileNavigator, showFolderPicker: $showingFolderPicker, theme: theme)
204:         }
205:     }
206: }
207: 
208: // MARK: - Activity Bar
209: 
210: 
211: 
212: struct BarButton: View {
213:     let icon: String
214:     let isSelected: Bool
215:     let theme: Theme
216:     let action: () -> Void
217:     
218:     var body: some View {
219:         Button(action: action) {
220:             Image(systemName: icon)
221:                 .font(.system(size: 22))
222:                 .foregroundColor(isSelected ? theme.activityBarSelection : theme.activityBarForeground.opacity(0.6))
223:                 .frame(width: 48, height: 48)
224:         }
225:     }
226: }
227: 
228: // MARK: - Sidebar with Real File System
229: 
230: struct IDESidebarFiles: View {
231:     @ObservedObject var editorCore: EditorCore
232:     @ObservedObject var fileNavigator: FileSystemNavigator
233:     @Binding var showFolderPicker: Bool
234:     let theme: Theme
235:     
236:     var body: some View {
237:         VStack(alignment: .leading, spacing: 0) {
238:             HStack {
239:                 Text("EXPLORER").font(.caption).fontWeight(.semibold).foregroundColor(theme.sidebarForeground.opacity(0.7))
240:                 Spacer()
241:                 Button(action: { showFolderPicker = true }) {
242:                     Image(systemName: "folder.badge.plus").font(.caption)
243:                 }.foregroundColor(theme.sidebarForeground.opacity(0.7))
244:                 Button(action: { editorCore.showFilePicker = true }) {
245:                     Image(systemName: "doc.badge.plus").font(.caption)
246:                 }.foregroundColor(theme.sidebarForeground.opacity(0.7))
247:                 if fileNavigator.fileTree != nil {
248:                     Button(action: { fileNavigator.refreshFileTree() }) {
249:                         Image(systemName: "arrow.clockwise").font(.caption)
250:                     }.foregroundColor(theme.sidebarForeground.opacity(0.7))
251:                 }
252:             }.padding(.horizontal, 12).padding(.vertical, 8)
253:             
254:             ScrollView {
255:                 VStack(alignment: .leading, spacing: 2) {
256:                     if let tree = fileNavigator.fileTree {
257:                         FileTreeView(root: tree, fileNavigator: fileNavigator, editorCore: editorCore)
258:                     } else {
259:                         DemoFileTree(editorCore: editorCore, theme: theme)
260:                     }
261:                 }.padding(.horizontal, 8)
262:             }
263:         }.background(theme.sidebarBackground)
264:     }
265: }
266: 
267: struct RealFileTreeView: View {
268:     let node: FileTreeNode
269:     let level: Int
270:     @ObservedObject var fileNavigator: FileSystemNavigator
271:     @ObservedObject var editorCore: EditorCore
272:     let theme: Theme
273:     
274:     var isExpanded: Bool { fileNavigator.expandedPaths.contains(node.url.path) }
275:     
276:     var body: some View {
277:         VStack(alignment: .leading, spacing: 2) {
278:             HStack(spacing: 4) {
279:                 if node.isDirectory {
280:                     Image(systemName: isExpanded ? "chevron.down" : "chevron.right")
281:                         .font(.caption2).frame(width: 12)
282:                         .foregroundColor(theme.sidebarForeground.opacity(0.6))
283:                         .onTapGesture { fileNavigator.toggleExpanded(path: node.url.path) }
284:                 } else {
285:                     Spacer().frame(width: 12)
286:                 }
287:                 Image(systemName: node.isDirectory ? "folder.fill" : fileIcon(for: node.name))
288:                     .font(.caption)
289:                     .foregroundColor(node.isDirectory ? .yellow : fileColor(for: node.name))
290:                 Text(node.name).font(.system(.caption)).lineLimit(1)
291:                     .foregroundColor(theme.sidebarForeground)
292:                 Spacer()
293:             }
294:             .padding(.leading, CGFloat(level * 16)).padding(.vertical, 4)
295:             .contentShape(Rectangle())
296:             .onTapGesture {
297:                 if node.isDirectory {
298:                     fileNavigator.toggleExpanded(path: node.url.path)
299:                 } else {
300:                     editorCore.openFile(from: node.url)
301:                 }
302:             }
303:             
304:             if isExpanded && node.isDirectory {
305:                 ForEach(node.children) { child in
306:                     RealFileTreeView(node: child, level: level + 1, fileNavigator: fileNavigator, editorCore: editorCore, theme: theme)
307:                 }
308:             }
309:         }
310:     }
311: }
312: 
313: struct DemoFileTree: View {
314:     @ObservedObject var editorCore: EditorCore
315:     let theme: Theme
316:     
317:     var body: some View {
318:         VStack(alignment: .leading, spacing: 4) {
319:             Text("Open a folder to browse files")
320:                 .font(.caption)
321:                 .foregroundColor(theme.sidebarForeground.opacity(0.6))
322:                 .padding(.vertical, 8)
323:             
324:             DemoFileRow(name: "main.swift", editorCore: editorCore, theme: theme)
325:             DemoFileRow(name: "ContentView.swift", editorCore: editorCore, theme: theme)
326:             DemoFileRow(name: "README.md", editorCore: editorCore, theme: theme)
327:         }
328:     }
329: }
330: 
331: struct DemoFileRow: View {
332:     let name: String
333:     @ObservedObject var editorCore: EditorCore
334:     let theme: Theme
335:     
336:     var body: some View {
337:         HStack(spacing: 4) {
338:             Spacer().frame(width: 12)
339:             Image(systemName: fileIcon(for: name)).font(.caption).foregroundColor(fileColor(for: name))
340:             Text(name).font(.system(.caption)).lineLimit(1).foregroundColor(theme.sidebarForeground)
341:             Spacer()
342:         }
343:         .padding(.vertical, 4)
344:         .contentShape(Rectangle())
345:         .onTapGesture {
346:             editorCore.addTab(fileName: name, content: "// \(name)\n\n")
347:         }
348:     }
349: }
350: 
351: // MARK: - Tab Bar
352: 
353: struct IDETabBar: View {
354:     @ObservedObject var editorCore: EditorCore
355:     let theme: Theme
356:     
357:     var body: some View {
358:         ScrollView(.horizontal, showsIndicators: false) {
359:             HStack(spacing: 0) {
360:                 ForEach(editorCore.tabs) { tab in
361:                     IDETabItem(tab: tab, isSelected: editorCore.activeTabId == tab.id, editorCore: editorCore, theme: theme)
362:                 }
363:                 Button(action: { editorCore.addTab() }) {
364:                     Image(systemName: "plus").font(.caption).foregroundColor(theme.tabInactiveForeground).padding(8)
365:                 }
366:             }.padding(.horizontal, 4)
367:         }.frame(height: 36).background(theme.tabBarBackground)
368:     }
369: }
370: 
371: struct IDETabItem: View {
372:     let tab: Tab
373:     let isSelected: Bool
374:     @ObservedObject var editorCore: EditorCore
375:     let theme: Theme
376:     
377:     var body: some View {
378:         HStack(spacing: 6) {
379:             Image(systemName: fileIcon(for: tab.fileName)).font(.caption).foregroundColor(fileColor(for: tab.fileName))
380:             Text(tab.fileName).font(.system(size: 12)).lineLimit(1)
381:                 .foregroundColor(isSelected ? theme.tabActiveForeground : theme.tabInactiveForeground)
382:             if tab.isUnsaved { Circle().fill(Color.orange).frame(width: 6, height: 6) }
383:             Button(action: { editorCore.closeTab(id: tab.id) }) {
384:                 Image(systemName: "xmark").font(.system(size: 9, weight: .medium))
385:                     .foregroundColor(isSelected ? theme.tabActiveForeground.opacity(0.6) : theme.tabInactiveForeground)
386:             }
387:         }
388:         .padding(.horizontal, 12).padding(.vertical, 6)
389:         .background(RoundedRectangle(cornerRadius: 4).fill(isSelected ? theme.tabActiveBackground : theme.tabInactiveBackground))
390:         .onTapGesture { editorCore.selectTab(id: tab.id) }
391:     }
392: }
393: 
394: // MARK: - Editor with Syntax Highlighting + Autocomplete + Folding
395: 
396: struct IDEEditorView: View {
397:     @ObservedObject var editorCore: EditorCore
398:     let tab: Tab
399:     let theme: Theme
400: 
401:     @AppStorage("lineNumbersStyle") private var lineNumbersStyle: String = "on"
402:     @State private var text: String = ""
403:     @State private var scrollPosition: Int = 0
404:     @State private var totalLines: Int = 1
405:     @State private var visibleLines: Int = 20
406:     @State private var currentLineNumber: Int = 1
407:     @State private var currentColumn: Int = 1
408:     @State private var cursorIndex: Int = 0
409:     @State private var lineHeight: CGFloat = 17
410:     @State private var requestedCursorIndex: Int? = nil
411:     @State private var requestedLineSelection: Int? = nil
412: 
413:     @StateObject private var autocomplete = AutocompleteManager()
414:     @State private var showAutocomplete = false
415:     @StateObject private var foldingManager = CodeFoldingManager()
416:     @StateObject private var findViewModel = FindViewModel()
417:     
418:     var body: some View {
419:         VStack(spacing: 0) {
420:             // Find/Replace bar
421:             if editorCore.showSearch {
422:                 FindReplaceView(viewModel: findViewModel)
423:                     .background(theme.tabBarBackground)
424:             }
425:             
426:             BreadcrumbsView(editorCore: editorCore, tab: tab)
427:             
428:             GeometryReader { geometry in
429:                 ZStack(alignment: .topLeading) {
430:                 HStack(spacing: 0) {
431:                     if lineNumbersStyle != "off" {
432:                         LineNumbersWithFolding(
433:                             fileId: tab.url?.path ?? tab.fileName,
434:                             totalLines: totalLines,
435:                             currentLine: currentLineNumber,
436:                             scrollOffset: CGFloat(scrollPosition) * lineHeight,
437:                             lineHeight: lineHeight,
438:                             requestedLineSelection: $requestedLineSelection,
439:                             foldingManager: foldingManager,
440:                             theme: theme
441:                         )
442:                         .frame(width: 60)
443:                         .background(theme.sidebarBackground.opacity(0.5))
444:                     }
445:                     
446:                     if tab.fileName.hasSuffix(".json") {
447:                         // JSON Tree View for .json files
448:                         JSONTreeView(data: text.data(using: .utf8) ?? Data())
449:                             .frame(maxWidth: .infinity, maxHeight: .infinity)
450:                             .background(theme.editorBackground)
451:                     } else {
452:                         SyntaxHighlightingTextView(
453:                             text: $text,
454:                             filename: tab.fileName,
455:                             scrollPosition: $scrollPosition,
456:                             totalLines: $totalLines,
457:                             visibleLines: $visibleLines,
458:                             currentLineNumber: $currentLineNumber,
459:                             currentColumn: $currentColumn,
460:                             cursorIndex: $cursorIndex,
461:                             lineHeight: $lineHeight,
462:                             isActive: true,
463:                             fontSize: editorCore.editorFontSize,
464:                             requestedLineSelection: $requestedLineSelection,
465:                             requestedCursorIndex: $requestedCursorIndex,
466:                             onAcceptAutocomplete: {
467:                                 guard showAutocomplete else { return false }
468:                                 var tempText = text
469:                                 var tempCursor = cursorIndex
470:                                 autocomplete.commitCurrentSuggestion(into: &tempText, cursorPosition: &tempCursor)
471:                                 if tempText != text {
472:                                     text = tempText
473:                                     cursorIndex = tempCursor
474:                                     requestedCursorIndex = tempCursor
475:                                     showAutocomplete = false
476:                                     return true
477:                                 }
478:                                 return false
479:                             },
480:                             onDismissAutocomplete: {
481:                                 guard showAutocomplete else { return false }
482:                                 autocomplete.hideSuggestions()
483:                                 showAutocomplete = false
484:                                 return true
485:                             }
486:                         )
487:                         .onChange(of: text) { newValue in
488:                             editorCore.updateActiveTabContent(newValue)
489:                             editorCore.cursorPosition = CursorPosition(line: currentLineNumber, column: currentColumn)
490:                             autocomplete.updateSuggestions(for: newValue, cursorPosition: cursorIndex)
491:                             showAutocomplete = autocomplete.showSuggestions
492:                             foldingManager.detectFoldableRegions(in: newValue)
493:                         }
494:                         .onChange(of: cursorIndex) { newCursor in
495:                             autocomplete.updateSuggestions(for: text, cursorPosition: newCursor)
496:                             showAutocomplete = autocomplete.showSuggestions
497:                         }
498:                     }
499:                     
500:                     if !tab.fileName.hasSuffix(".json") {
501:                         MinimapView(
502:                             content: text,
503:                             scrollOffset: .constant(CGFloat(scrollPosition) * lineHeight),
504:                             scrollViewHeight: .constant(geometry.size.height),
505:                             totalContentHeight: CGFloat(totalLines) * lineHeight
506:                         )
507:                         .frame(width: 80)
508:                     }
509:                 }
510:                 .background(theme.editorBackground)
511: 
512:                 // Sticky Header Overlay (FEAT-040)
513:                 StickyHeaderView(
514:                     text: text,
515:                     currentLine: scrollPosition,
516:                     theme: theme,
517:                     lineHeight: lineHeight,
518:                     onSelect: { line in
519:                         requestedLineSelection = line
520:                     }
521:                 )
522:                 .padding(.leading, lineNumbersStyle != "off" ? 60 : 0)
523:                 .padding(.trailing, tab.fileName.hasSuffix(".json") ? 0 : 80)
524: 
525:                 if showAutocomplete && !autocomplete.suggestionItems.isEmpty {
526:                     AutocompletePopup(
527:                         suggestions: autocomplete.suggestionItems,
528:                         selectedIndex: autocomplete.selectedIndex,
529:                         theme: theme
530:                     ) { index in
531:                         autocomplete.selectedIndex = index
532:                         var tempText = text
533:                         var tempCursor = cursorIndex
534:                         autocomplete.commitCurrentSuggestion(into: &tempText, cursorPosition: &tempCursor)
535:                         if tempText != text {
536:                             text = tempText
537:                             cursorIndex = tempCursor
538:                             requestedCursorIndex = tempCursor
539:                         }
540:                         showAutocomplete = false
541:                     }
542:                     .offset(x: 70, y: CGFloat(currentLineNumber) * lineHeight)
543:                 }
544:             }
545:         }
546:         }
547:         .onAppear {
548:             text = tab.content
549:             foldingManager.detectFoldableRegions(in: text)
550:         }
551:         .onChange(of: tab.id) { _ in
552:             text = tab.content
553:             foldingManager.detectFoldableRegions(in: text)
554:         }
555:         .onChange(of: currentLineNumber) { line in
556:             editorCore.cursorPosition = CursorPosition(line: line, column: currentColumn)
557:         }
558:         .onChange(of: currentColumn) { col in
559:             editorCore.cursorPosition = CursorPosition(line: currentLineNumber, column: col)
560:         }
561:         .onAppear {
562:             findViewModel.editorCore = editorCore
563:         }
564:     }
565:     
566:     // Autocomplete insertion is handled by AutocompleteManager.acceptSuggestion(...)
567: }
568: 
569: // MARK: - Line Numbers with Folding
570: 
571: struct LineNumbersWithFolding: View {
572:     let fileId: String
573:     let totalLines: Int
574:     let currentLine: Int
575:     let scrollOffset: CGFloat
576:     let lineHeight: CGFloat
577:     @Binding var requestedLineSelection: Int?
578:     @ObservedObject var foldingManager: CodeFoldingManager
579:     @ObservedObject private var debugManager = DebugManager.shared
580:     let theme: Theme
581: 
582:     @AppStorage("lineNumbersStyle") private var lineNumbersStyle: String = "on"
583: 
584:     var body: some View {
585:         ScrollView(showsIndicators: false) {
586:             VStack(alignment: .trailing, spacing: 0) {
587:                 ForEach(0..<totalLines, id: \.self) { lineIndex in
588:                     if !foldingManager.isLineFolded(line: lineIndex) {
589:                         HStack(spacing: 2) {
590:                             Button(action: { debugManager.toggleBreakpoint(file: fileId, line: lineIndex) }) {
591:                                 Circle()
592:                                     .fill(debugManager.hasBreakpoint(file: fileId, line: lineIndex) ? Color.red : Color.clear)
593:                                     .overlay(
594:                                         Circle()
595:                                             .stroke(Color.red.opacity(0.6), lineWidth: 1)
596:                                             .opacity(debugManager.hasBreakpoint(file: fileId, line: lineIndex) ? 0 : 0.25)
597:                                     )
598:                                     .frame(width: 10, height: 10)
599:                                     .padding(.leading, 2)
600:                             }
601:                             .buttonStyle(.plain)
602:                             .frame(width: 14, height: lineHeight)
603: 
604:                             if foldingManager.isFoldable(line: lineIndex) {
605:                                 Button(action: { foldingManager.toggleFold(at: lineIndex) }) {
606:                                     Image(systemName: foldingManager.foldRegions.first(where: { $0.startLine == lineIndex })?.isFolded == true ? "chevron.right" : "chevron.down")
607:                                         .font(.system(size: 8))
608:                                         .foregroundColor(theme.lineNumber)
609:                                 }
610:                                 .buttonStyle(.plain)
611:                                 .frame(width: 14, height: lineHeight)
612:                             } else {
613:                                 Spacer().frame(width: 14)
614:                             }
615: 
616:                             Text(displayText(for: lineIndex))
617:                                 .font(.system(size: 12, design: .monospaced))
618:                                 .foregroundColor(lineIndex + 1 == currentLine ? theme.lineNumberActive : theme.lineNumber)
619:                                 .frame(height: lineHeight)
620:                                 .contentShape(Rectangle())
621:                                 .onTapGesture {
622:                                     // FEAT-041: click line number selects entire line
623:                                     requestedLineSelection = lineIndex
624:                                 }
625:                         }
626:                         .frame(maxWidth: .infinity, alignment: .trailing)
627:                         .padding(.trailing, 4)
628:                     }
629:                 }
630:             }
631:             .offset(y: -scrollOffset)
632:         }
633:     }
634: 
635:     private func displayText(for lineIndex: Int) -> String {
636:         switch lineNumbersStyle {
637:         case "relative":
638:             // VS Code-style: current line shows absolute, others show relative distance
639:             let lineNumber = lineIndex + 1
640:             if lineNumber == currentLine { return "\(lineNumber)" }
641:             return "\(abs(lineNumber - currentLine))"
642: 
643:         case "interval":
644:             let lineNumber = lineIndex + 1
645:             return (lineNumber == 1 || lineNumber % 5 == 0) ? "\(lineNumber)" : ""
646: 
647:         default:
648:             return "\(lineIndex + 1)"
649:         }
650:     }
651: }
652: 
653: // MARK: - Autocomplete Popup
654: 
655: struct AutocompletePopup: View {
656:     let suggestions: [AutocompleteSuggestion]
657:     let selectedIndex: Int
658:     let theme: Theme
659:     let onSelectIndex: (Int) -> Void
660:     
661:     var body: some View {
662:         VStack(alignment: .leading, spacing: 0) {
663:             ForEach(suggestions.indices, id: \.self) { index in
664:                 let s = suggestions[index]
665:                 HStack(spacing: 6) {
666:                     Image(systemName: icon(for: s.kind))
667:                         .font(.caption)
668:                         .foregroundColor(color(for: s.kind))
669:                     VStack(alignment: .leading, spacing: 1) {
670:                         Text(s.displayText)
671:                             .font(.system(size: 12, design: .monospaced))
672:                             .foregroundColor(theme.editorForeground)
673:                         if s.insertText != s.displayText && !s.insertText.isEmpty {
674:                             Text(s.insertText)
675:                                 .font(.system(size: 10, design: .monospaced))
676:                                 .foregroundColor(theme.editorForeground.opacity(0.55))
677:                                 .lineLimit(1)
678:                         }
679:                     }
680:                     Spacer()
681:                 }
682:                 .padding(.horizontal, 8).padding(.vertical, 6)
683:                 .background(index == selectedIndex ? theme.selection : Color.clear)
684:                 .contentShape(Rectangle())
685:                 .onTapGesture { onSelectIndex(index) }
686:             }
687:         }
688:         .frame(width: 260)
689:         .background(theme.editorBackground)
690:         .cornerRadius(6)
691:         .shadow(radius: 8)
692:     }
693:     
694:     private func icon(for kind: AutocompleteSuggestionKind) -> String {
695:         switch kind {
696:         case .keyword: return "key.fill"
697:         case .symbol: return "cube.fill"
698:         case .stdlib: return "curlybraces"
699:         case .member: return "arrow.right.circle.fill"
700:         }
701:     }
702:     
703:     private func color(for kind: AutocompleteSuggestionKind) -> Color {
704:         switch kind {
705:         case .keyword: return .purple
706:         case .symbol: return .blue
707:         case .stdlib: return .orange
708:         case .member: return .green
709:         }
710:     }
711: }
712: 
713: // MARK: - Welcome View
714: 
715: struct IDEWelcomeView: View {
716:     @ObservedObject var editorCore: EditorCore
717:     @Binding var showFolderPicker: Bool
718:     let theme: Theme
719:     
720:     var body: some View {
721:         VStack(spacing: 24) {
722:             Image(systemName: "chevron.left.forwardslash.chevron.right").font(.system(size: 80)).foregroundColor(theme.editorForeground.opacity(0.3))
723:             Text("VS Code for iPadOS").font(.largeTitle).fontWeight(.bold).foregroundColor(theme.editorForeground)
724:             VStack(alignment: .leading, spacing: 12) {
725:                 WelcomeBtn(icon: "doc.badge.plus", title: "New File", shortcut: "âŒ˜N", theme: theme) { editorCore.addTab() }
726:                 WelcomeBtn(icon: "folder", title: "Open Folder", shortcut: "âŒ˜â‡§O", theme: theme) { showFolderPicker = true }
727:                 WelcomeBtn(icon: "doc", title: "Open File", shortcut: "âŒ˜O", theme: theme) { editorCore.showFilePicker = true }
728:                 WelcomeBtn(icon: "terminal", title: "Command Palette", shortcut: "âŒ˜â‡§P", theme: theme) { editorCore.showCommandPalette = true }
729:             }
730:         }.frame(maxWidth: .infinity, maxHeight: .infinity).background(theme.editorBackground)
731:     }
732: }
733: 
734: struct WelcomeBtn: View {
735:     let icon: String
736:     let title: String
737:     let shortcut: String
738:     let theme: Theme
739:     let action: () -> Void
740:     
741:     var body: some View {
742:         Button(action: action) {
743:             HStack {
744:                 Image(systemName: icon).frame(width: 24).foregroundColor(theme.editorForeground)
745:                 Text(title).foregroundColor(theme.editorForeground)
746:                 Spacer()
747:                 Text(shortcut).font(.caption).foregroundColor(theme.editorForeground.opacity(0.5))
748:             }
749:             .padding().frame(width: 280)
750:             .background(theme.sidebarBackground)
751:             .cornerRadius(8)
752:         }.buttonStyle(.plain)
753:     }
754: }
755: 
756: // MARK: - Command Palette
757: 
758: struct IDECommandPalette: View {
759:     @ObservedObject var editorCore: EditorCore
760:     @Binding var showSettings: Bool
761:     @Binding var showTerminal: Bool
762:     @State private var searchText = ""
763:     
764:     var body: some View {
765:         VStack(spacing: 0) {
766:             HStack {
767:                 Image(systemName: "magnifyingglass").foregroundColor(.secondary)
768:                 TextField("Type a command...", text: $searchText).textFieldStyle(.plain)
769:             }.padding().background(Color(UIColor.secondarySystemBackground))
770:             Divider()
771:             ScrollView {
772:                 VStack(spacing: 0) {
773:                     CommandRow(icon: "doc.badge.plus", name: "New File", shortcut: "âŒ˜N") { editorCore.addTab(); editorCore.showCommandPalette = false }
774:                     CommandRow(icon: "folder", name: "Open File", shortcut: "âŒ˜O") { editorCore.showFilePicker = true; editorCore.showCommandPalette = false }
775:                     CommandRow(icon: "square.and.arrow.down", name: "Save File", shortcut: "âŒ˜S") { editorCore.saveActiveTab(); editorCore.showCommandPalette = false }
776:                     CommandRow(icon: "sidebar.left", name: "Toggle Sidebar", shortcut: "âŒ˜B") { editorCore.toggleSidebar(); editorCore.showCommandPalette = false }
777:                     CommandRow(icon: "brain", name: "AI Assistant", shortcut: "âŒ˜â‡§A") { editorCore.showAIAssistant = true; editorCore.showCommandPalette = false }
778:                     CommandRow(icon: "terminal", name: "Toggle Terminal", shortcut: "âŒ˜`") { showTerminal.toggle(); editorCore.showCommandPalette = false }
779:                     CommandRow(icon: "gear", name: "Settings", shortcut: "âŒ˜,") { showSettings = true; editorCore.showCommandPalette = false }
780:                     CommandRow(icon: "number", name: "Go to Line", shortcut: "âŒ˜G") { editorCore.showGoToLine = true; editorCore.showCommandPalette = false }
781:                 }.padding(.vertical, 8)
782:             }
783:         }.frame(width: 500, height: 400).background(Color(UIColor.systemBackground)).cornerRadius(12).shadow(radius: 20)
784:     }
785: }
786: 
787: struct CommandRow: View {
788:     let icon: String; let name: String; let shortcut: String; let action: () -> Void
789:     var body: some View {
790:         Button(action: action) {
791:             HStack {
792:                 Image(systemName: icon).foregroundColor(.accentColor).frame(width: 24)
793:                 Text(name).foregroundColor(.primary)
794:                 Spacer()
795:                 Text(shortcut).font(.caption).foregroundColor(.secondary).padding(.horizontal, 8).padding(.vertical, 4).background(Color(UIColor.tertiarySystemFill)).cornerRadius(4)
796:             }.padding(.horizontal).padding(.vertical, 12).contentShape(Rectangle())
797:         }.buttonStyle(.plain)
798:     }
799: }
800: 
801: // MARK: - Quick Open
802: 
803: struct IDEQuickOpen: View {
804:     @ObservedObject var editorCore: EditorCore
805:     @State private var searchText = ""
806:     
807:     var body: some View {
808:         VStack(spacing: 0) {
809:             HStack {
810:                 Image(systemName: "magnifyingglass").foregroundColor(.gray)
811:                 TextField("Search files...", text: $searchText).textFieldStyle(.plain)
812:             }.padding().background(Color(UIColor.secondarySystemBackground))
813:             Divider()
814:             ScrollView {
815:                 VStack(alignment: .leading, spacing: 0) {
816:                     ForEach(editorCore.tabs) { tab in
817:                         QuickOpenRow(name: tab.fileName, path: "") {
818:                             editorCore.selectTab(id: tab.id)
819:                             editorCore.showQuickOpen = false
820:                         }
821:                     }
822:                 }
823:             }.frame(maxHeight: 350)
824:         }.frame(width: 500).background(Color(UIColor.systemBackground)).cornerRadius(12).shadow(radius: 20)
825:     }
826: }
827: 
828: struct QuickOpenRow: View {
829:     let name: String; let path: String; let action: () -> Void
830:     var body: some View {
831:         Button(action: action) {
832:             HStack {
833:                 Image(systemName: fileIcon(for: name)).foregroundColor(fileColor(for: name)).frame(width: 20)
834:                 VStack(alignment: .leading, spacing: 2) { Text(name).font(.system(size: 14)); Text(path + name).font(.system(size: 11)).foregroundColor(.secondary) }
835:                 Spacer()
836:             }.padding(.horizontal).padding(.vertical, 8).contentShape(Rectangle())
837:         }.buttonStyle(.plain)
838:     }
839: }
840: 
841: // MARK: - AI Assistant
842: 
843: struct IDEAIAssistant: View {
844:     @ObservedObject var editorCore: EditorCore
845:     let theme: Theme
846:     @State private var userInput = ""
847:     @State private var messages: [(id: UUID, role: String, content: String)] = [(UUID(), "assistant", "Hello! I'm your AI coding assistant. How can I help?")]
848:     
849:     var body: some View {
850:         VStack(spacing: 0) {
851:             HStack {
852:                 Image(systemName: "brain").foregroundColor(.blue)
853:                 Text("AI Assistant").font(.headline).foregroundColor(theme.editorForeground)
854:                 Spacer()
855:                 Button(action: { editorCore.showAIAssistant = false }) { Image(systemName: "xmark.circle.fill").foregroundColor(theme.editorForeground.opacity(0.5)) }
856:             }.padding().background(theme.sidebarBackground)
857:             
858:             ScrollView {
859:                 LazyVStack(alignment: .leading, spacing: 12) {
860:                     ForEach(messages, id: \.id) { msg in
861:                         HStack {
862:                             if msg.role == "user" { Spacer(minLength: 60) }
863:                             Text(msg.content).padding(12).background(RoundedRectangle(cornerRadius: 12).fill(msg.role == "user" ? Color.blue : theme.sidebarBackground)).foregroundColor(msg.role == "user" ? .white : theme.editorForeground)
864:                             if msg.role == "assistant" { Spacer(minLength: 60) }
865:                         }
866:                     }
867:                 }.padding()
868:             }.background(theme.editorBackground)
869:             
870:             HStack(spacing: 12) {
871:                 TextField("Ask about your code...", text: $userInput).textFieldStyle(.roundedBorder)
872:                 Button(action: { sendMessage() }) { Image(systemName: "paperplane.fill").foregroundColor(userInput.isEmpty ? .gray : .blue) }.disabled(userInput.isEmpty)
873:             }.padding().background(theme.sidebarBackground)
874:         }.background(theme.editorBackground).cornerRadius(12).shadow(radius: 20)
875:     }
876:     
877:     func sendMessage() {
878:         guard !userInput.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty else { return }
879:         messages.append((UUID(), "user", userInput))
880:         let input = userInput
881:         userInput = ""
882:         DispatchQueue.main.asyncAfter(deadline: .now() + 0.8) {
883:             messages.append((UUID(), "assistant", "I can help with '\(input)'! What specifically would you like to know?"))
884:         }
885:     }
886: }
887: 
888: // MARK: - Status Bar
889: 
890: 
891: 
892: // MARK: - Folder Picker
893: 
894: struct IDEFolderPicker: UIViewControllerRepresentable {
895:     @ObservedObject var fileNavigator: FileSystemNavigator
896:     var onPick: ((URL) -> Void)?
897:     
898:     init(fileNavigator: FileSystemNavigator, onPick: ((URL) -> Void)? = nil) {
899:         self.fileNavigator = fileNavigator
900:         self.onPick = onPick
901:     }
902:     
903:     func makeUIViewController(context: Context) -> UIDocumentPickerViewController {
904:         let picker = UIDocumentPickerViewController(forOpeningContentTypes: [.folder])
905:         picker.delegate = context.coordinator
906:         return picker
907:     }
908:     
909:     func updateUIViewController(_ uiViewController: UIDocumentPickerViewController, context: Context) {}
910:     
911:     func makeCoordinator() -> Coordinator { Coordinator(self) }
912:     
913:     class Coordinator: NSObject, UIDocumentPickerDelegate {
914:         let parent: IDEFolderPicker
915:         init(_ parent: IDEFolderPicker) { self.parent = parent }
916:         
917:         func documentPicker(_ controller: UIDocumentPickerViewController, didPickDocumentsAt urls: [URL]) {
918:             if let url = urls.first {
919:                 _ = url.startAccessingSecurityScopedResource()
920:                 if let onPick = parent.onPick {
921:                     onPick(url)
922:                 } else {
923:                     // Default behavior if no custom handler
924:                     parent.fileNavigator.loadFileTree(at: url)
925:                     Task { @MainActor in
926:                         LaunchManager.shared.setWorkspaceRoot(url)
927:                         GitManager.shared.setWorkingDirectory(url)
928:                     }
929:                 }
930:             }
931:         }
932:     }
933: }
934: 
935: // MARK: - Document Picker
936: 
937: struct IDEDocumentPicker: UIViewControllerRepresentable {
938:     @ObservedObject var editorCore: EditorCore
939:     
940:     func makeUIViewController(context: Context) -> UIDocumentPickerViewController {
941:         let picker = UIDocumentPickerViewController(forOpeningContentTypes: [.text, .sourceCode, .json, .plainText, .data])
942:         picker.allowsMultipleSelection = true
943:         picker.delegate = context.coordinator
944:         return picker
945:     }
946:     
947:     func updateUIViewController(_ uiViewController: UIDocumentPickerViewController, context: Context) {}
948:     
949:     func makeCoordinator() -> Coordinator { Coordinator(editorCore: editorCore) }
950:     
951:     class Coordinator: NSObject, UIDocumentPickerDelegate {
952:         let editorCore: EditorCore
953:         init(editorCore: EditorCore) { self.editorCore = editorCore }
954:         
955:         func documentPicker(_ controller: UIDocumentPickerViewController, didPickDocumentsAt urls: [URL]) {
956:             for url in urls { editorCore.openFile(from: url) }
957:             editorCore.showFilePicker = false
958:         }
959:         
960:         func documentPickerWasCancelled(_ controller: UIDocumentPickerViewController) {
961:             editorCore.showFilePicker = false
962:         }
963:     }
964: }
965: 
966: // MARK: - Sidebar Search View
967: 
968: struct SidebarSearchView: View {
969:     let theme: Theme
970:     @State private var searchText = ""
971:     @State private var replaceText = ""
972:     @State private var showReplace = false
973:     @State private var searchResults: [(fileName: String, line: Int, preview: String)] = []
974:     
975:     var body: some View {
976:         VStack(alignment: .leading, spacing: 0) {
977:             HStack {
978:                 Text("SEARCH").font(.caption).fontWeight(.semibold).foregroundColor(theme.sidebarForeground.opacity(0.7))
979:                 Spacer()
980:             }.padding(.horizontal, 12).padding(.vertical, 8)
981:             
982:             HStack(spacing: 4) {
983:                 Image(systemName: "magnifyingglass").foregroundColor(theme.sidebarForeground.opacity(0.6)).font(.caption)
984:                 TextField("Search", text: $searchText).textFieldStyle(.plain).font(.system(size: 13))
985:                     .foregroundColor(theme.sidebarForeground)
986:                 if !searchText.isEmpty {
987:                     Button(action: { searchText = "" }) {
988:                         Image(systemName: "xmark.circle.fill").foregroundColor(theme.sidebarForeground.opacity(0.6)).font(.caption)
989:                     }
990:                 }
991:             }
992:             .padding(8)
993:             .background(theme.editorBackground)
994:             .cornerRadius(6)
995:             .padding(.horizontal, 12)
996:             
997:             HStack {
998:                 Button(action: { showReplace.toggle() }) {
999:                     Image(systemName: showReplace ? "chevron.down" : "chevron.right").font(.caption2)
1000:                     Text("Replace").font(.caption)
1001:                 }.foregroundColor(theme.sidebarForeground.opacity(0.7))
1002:                 Spacer()
1003:             }.padding(.horizontal, 12).padding(.vertical, 6)
1004:             
1005:             if showReplace {
1006:                 HStack(spacing: 4) {
1007:                     Image(systemName: "arrow.right").foregroundColor(theme.sidebarForeground.opacity(0.6)).font(.caption)
1008:                     TextField("Replace", text: $replaceText).textFieldStyle(.plain).font(.system(size: 13))
1009:                         .foregroundColor(theme.sidebarForeground)
1010:                 }
1011:                 .padding(8)
1012:                 .background(theme.editorBackground)
1013:                 .cornerRadius(6)
1014:                 .padding(.horizontal, 12)
1015:             }
1016:             
1017:             Divider().padding(.top, 8)
1018:             
1019:             if searchText.isEmpty {
1020:                 VStack(spacing: 8) {
1021:                     Spacer()
1022:                     Image(systemName: "magnifyingglass").font(.largeTitle).foregroundColor(theme.sidebarForeground.opacity(0.3))
1023:                     Text("Search in files").font(.caption).foregroundColor(theme.sidebarForeground.opacity(0.6))
1024:                     Spacer()
1025:                 }.frame(maxWidth: .infinity)
1026:             } else {
1027:                 ScrollView {
1028:                     LazyVStack(alignment: .leading, spacing: 0) {
1029:                         ForEach(0..<searchResults.count, id: \.self) { i in
1030:                             let result = searchResults[i]
1031:                             VStack(alignment: .leading, spacing: 2) {
1032:                                 HStack {
1033:                                     Image(systemName: "doc.text").font(.caption2).foregroundColor(theme.sidebarForeground.opacity(0.6))
1034:                                     Text(result.fileName).font(.system(size: 11, weight: .medium)).foregroundColor(theme.sidebarForeground)
1035:                                     Spacer()
1036:                                     Text(":\(result.line)").font(.system(size: 10, design: .monospaced)).foregroundColor(theme.sidebarForeground.opacity(0.6))
1037:                                 }
1038:                                 Text(result.preview).font(.system(size: 11, design: .monospaced)).foregroundColor(theme.sidebarForeground.opacity(0.7)).lineLimit(1)
1039:                             }.padding(.horizontal, 12).padding(.vertical, 6)
1040:                         }
1041:                     }
1042:                 }
1043:             }
1044:         }
1045:         .background(theme.sidebarBackground)
1046:         .onChange(of: searchText) { query in
1047:             if query.isEmpty { searchResults = [] }
1048:             else { searchResults = [("ContentView.swift", 15, "Text(\"\(query)\")"), ("main.swift", 8, "// \(query)")] }
1049:         }
1050:     }
1051: }
1052: 
1053: // MARK: - Preview
1054: 
1055: #Preview {
1056:     ContentView()
1057: }
1058: 


I found the issue! Looking at ContentView.swift lines 501-506 and MinimapView.swift:

**The Problem:**
1. MinimapView has `@Binding var scrollOffset: CGFloat` (line 12) and writes to it in `updateScroll()` (line 170)
2. ContentView passes `.constant(CGFloat(scrollPosition) * lineHeight)` - a constant binding that can't be written back
3. This creates a broken contract AND the minimap's click-to-scroll feature silently fails

The proper fix is to separate concerns:
- Minimap should **read** scroll position to show the visible region
- Minimap should **call back** when user wants to scroll (not directly write to binding)

Let me fix MinimapView.swift:

>>>FILE VSCodeiPadOS/VSCodeiPadOS/Views/Editor/MinimapView.swift
>>>FIND
struct MinimapView: View {
    // MARK: - External inputs

    let content: String
    @Binding var scrollOffset: CGFloat
    @Binding var scrollViewHeight: CGFloat
    let totalContentHeight: CGFloat

    /// Optional indicators to render as thin bars on the left side of the minimap.
    /// Note: call sites can ignore this (default empty) without breaking compilation.
    var diffIndicators: [MinimapDiffIndicator] = []

    /// Fixed width; height expands to the container.
    var minimapWidth: CGFloat = 60
>>>REPLACE
struct MinimapView: View {
    // MARK: - External inputs

    let content: String
    /// Current scroll offset (read-only for display). Minimap FOLLOWS the editor, never fights it.
    let scrollOffset: CGFloat
    /// Visible viewport height (read-only for display)
    let scrollViewHeight: CGFloat
    let totalContentHeight: CGFloat
    
    /// Callback when user taps/drags on minimap to request scroll. 
    /// Parent handles actual scrolling - prevents bidirectional binding jitter.
    var onScrollRequested: ((CGFloat) -> Void)? = nil

    /// Optional indicators to render as thin bars on the left side of the minimap.
    /// Note: call sites can ignore this (default empty) without breaking compilation.
    var diffIndicators: [MinimapDiffIndicator] = []

    /// Fixed width; height expands to the container.
    var minimapWidth: CGFloat = 60
>>>END

Now update the `updateScroll` function to use the callback instead of direct binding:

>>>FILE VSCodeiPadOS/VSCodeiPadOS/Views/Editor/MinimapView.swift
>>>FIND
    // MARK: - Interaction

    /// Sets `scrollOffset` so that the main editor's visible region is centered around the minimap Y position.
    private func updateScroll(forMinimapY yPosition: CGFloat, minimapHeight: CGFloat) {
        guard totalContentHeight > 0 else { return }

        let clampedY = max(0, min(yPosition, minimapHeight))
        let ratio = (minimapHeight > 0) ? (clampedY / minimapHeight) : 0

        // Target a center position (VS Code behavior).
        let targetCenter = ratio * totalContentHeight
        let desiredOffset = targetCenter - (scrollViewHeight / 2)

        let maxOffset = max(0, totalContentHeight - scrollViewHeight)
        scrollOffset = min(max(desiredOffset, 0), maxOffset)
    }
>>>REPLACE
    // MARK: - Interaction

    /// Requests scroll so that the main editor's visible region is centered around the minimap Y position.
    /// Uses callback to parent - minimap never directly controls editor scroll (prevents jitter).
    private func updateScroll(forMinimapY yPosition: CGFloat, minimapHeight: CGFloat) {
        guard totalContentHeight > 0 else { return }
        guard let onScrollRequested = onScrollRequested else { return }

        let clampedY = max(0, min(yPosition, minimapHeight))
        let ratio = (minimapHeight > 0) ? (clampedY / minimapHeight) : 0

        // Target a center position (VS Code behavior).
        let targetCenter = ratio * totalContentHeight
        let desiredOffset = targetCenter - (scrollViewHeight / 2)

        let maxOffset = max(0, totalContentHeight - scrollViewHeight)
        let newOffset = min(max(desiredOffset, 0), maxOffset)
        
        // Request scroll via callback - parent controls the actual scroll
        onScrollRequested(newOffset)
    }
>>>END

Now update ContentView.swift to use the new interface:

>>>FILE VSCodeiPadOS/VSCodeiPadOS/ContentView.swift
>>>FIND
                    if !tab.fileName.hasSuffix(".json") {
                        MinimapView(
                            content: text,
                            scrollOffset: .constant(CGFloat(scrollPosition) * lineHeight),
                            scrollViewHeight: .constant(geometry.size.height),
                            totalContentHeight: CGFloat(totalLines) * lineHeight
                        )
                        .frame(width: 80)
                    }
>>>REPLACE
                    if !tab.fileName.hasSuffix(".json") {
                        MinimapView(
                            content: text,
                            scrollOffset: CGFloat(scrollPosition) * lineHeight,
                            scrollViewHeight: geometry.size.height,
                            totalContentHeight: CGFloat(totalLines) * lineHeight,
                            onScrollRequested: { newOffset in
                                // Minimap requested scroll - update editor position
                                // Convert back from pixels to line number
                                let newLine = Int(newOffset / lineHeight)
                                scrollPosition = max(0, min(newLine, totalLines - 1))
                            }
                        )
                        .frame(width: 80)
                    }
>>>END

---

## ðŸ”§ TOOL RESULTS

[FILE VSCodeiPadOS/VSCodeiPadOS/Views/Editor/MinimapView.swift]
Applied 1 patch(es)

---

[FILE VSCodeiPadOS/VSCodeiPadOS/Views/Editor/MinimapView.swift]
Applied 1 patch(es)

---

[FILE VSCodeiPadOS/VSCodeiPadOS/ContentView.swift]
Applied 1 patch(es)


>>>TOOL get_errors
{}
>>>END

---

## ðŸ”§ TOOL RESULTS

[get_errors]
âœ… No errors or warnings


>>>TOOL read_file
{"path": "VSCodeiPadOS/VSCodeiPadOS/Views/Editor/MinimapView.swift", "start_line": 1, "end_line": 50}
>>>END

---

## ðŸ”§ TOOL RESULTS

[read_file]
File: VSCodeiPadOS/VSCodeiPadOS/Views/Editor/MinimapView.swift (lines 2-50 of 472)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
2: 
3: /// VS Codeâ€“style minimap with:
4: /// - syntax-colored tiny preview
5: /// - visible region overlay
6: /// - tap/drag to scroll
7: /// - optional git diff indicators (added/modified/deleted)
8: struct MinimapView: View {
9:     // MARK: - External inputs
10: 
11:     let content: String
12:     /// Current scroll offset (read-only for display). Minimap FOLLOWS the editor, never fights it.
13:     let scrollOffset: CGFloat
14:     /// Visible viewport height (read-only for display)
15:     let scrollViewHeight: CGFloat
16:     let totalContentHeight: CGFloat
17:     
18:     /// Callback when user taps/drags on minimap to request scroll. 
19:     /// Parent handles actual scrolling - prevents bidirectional binding jitter.
20:     var onScrollRequested: ((CGFloat) -> Void)? = nil
21: 
22:     /// Optional indicators to render as thin bars on the left side of the minimap.
23:     /// Note: call sites can ignore this (default empty) without breaking compilation.
24:     var diffIndicators: [MinimapDiffIndicator] = []
25: 
26:     /// Fixed width; height expands to the container.
27:     var minimapWidth: CGFloat = 60
28: 
29:     // MARK: - Internal state
30: 
31:     @State private var isInteracting: Bool = false
32: 
33:     // MARK: - Types
34: 
35:     struct MinimapDiffIndicator: Identifiable, Hashable {
36:         enum Kind: Hashable {
37:             case added
38:             case modified
39:             case deleted
40:         }
41: 
42:         var id = UUID()
43:         /// 0-based line range in the current `content`.
44:         var lineRange: Range<Int>
45:         var kind: Kind
46: 
47:         init(lineRange: Range<Int>, kind: Kind) {
48:             self.lineRange = lineRange
49:             self.kind = kind
50:         }


>>>TOOL read_file
{"path": "VSCodeiPadOS/VSCodeiPadOS/Views/Editor/MinimapView.swift", "start_line": 157, "end_line": 185}
>>>END

---

## ðŸ”§ TOOL RESULTS

[read_file]
File: VSCodeiPadOS/VSCodeiPadOS/Views/Editor/MinimapView.swift (lines 158-185 of 472)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
158:         let scrollRatio = min(max(scrollOffset / scrollable, 0), 1.0)
159:         return scrollRatio * max(0, minimapHeight - visibleHeight)
160:     }
161: 
162:     // MARK: - Interaction
163: 
164:     /// Requests scroll so that the main editor's visible region is centered around the minimap Y position.
165:     /// Uses callback to parent - minimap never directly controls editor scroll (prevents jitter).
166:     private func updateScroll(forMinimapY yPosition: CGFloat, minimapHeight: CGFloat) {
167:         guard totalContentHeight > 0 else { return }
168:         guard let onScrollRequested = onScrollRequested else { return }
169: 
170:         let clampedY = max(0, min(yPosition, minimapHeight))
171:         let ratio = (minimapHeight > 0) ? (clampedY / minimapHeight) : 0
172: 
173:         // Target a center position (VS Code behavior).
174:         let targetCenter = ratio * totalContentHeight
175:         let desiredOffset = targetCenter - (scrollViewHeight / 2)
176: 
177:         let maxOffset = max(0, totalContentHeight - scrollViewHeight)
178:         let newOffset = min(max(desiredOffset, 0), maxOffset)
179:         
180:         // Request scroll via callback - parent controls the actual scroll
181:         onScrollRequested(newOffset)
182:     }
183: 
184:     // MARK: - Rendering (Canvas)
185: 


>>>TOOL read_file
{"path": "VSCodeiPadOS/VSCodeiPadOS/ContentView.swift", "start_line": 498, "end_line": 520}
>>>END

---

## ðŸ”§ TOOL RESULTS

[read_file]
File: VSCodeiPadOS/VSCodeiPadOS/ContentView.swift (lines 499-520 of 1064)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
499:                     
500:                     if !tab.fileName.hasSuffix(".json") {
501:                         MinimapView(
502:                             content: text,
503:                             scrollOffset: CGFloat(scrollPosition) * lineHeight,
504:                             scrollViewHeight: geometry.size.height,
505:                             totalContentHeight: CGFloat(totalLines) * lineHeight,
506:                             onScrollRequested: { newOffset in
507:                                 // Minimap requested scroll - update editor position
508:                                 // Convert back from pixels to line number
509:                                 let newLine = Int(newOffset / lineHeight)
510:                                 scrollPosition = max(0, min(newLine, totalLines - 1))
511:                             }
512:                         )
513:                         .frame(width: 80)
514:                     }
515:                 }
516:                 .background(theme.editorBackground)
517: 
518:                 // Sticky Header Overlay (FEAT-040)
519:                 StickyHeaderView(
520:                     text: text,


>>>TOOL search
{"query": "MinimapView", "glob": "*.swift"}
>>>END

---

## ðŸ”§ TOOL RESULTS

[search]
No matches found for "MinimapView"


>>>TOOL read_file
{"path": "VSCodeiPadOS/VSCodeiPadOS/Views/Editor/MinimapView.swift", "start_line": 1, "end_line": 30}
>>>END

---

## ðŸ”§ TOOL RESULTS

[read_file]
File: VSCodeiPadOS/VSCodeiPadOS/Views/Editor/MinimapView.swift (lines 2-30 of 472)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
2: 
3: /// VS Codeâ€“style minimap with:
4: /// - syntax-colored tiny preview
5: /// - visible region overlay
6: /// - tap/drag to scroll
7: /// - optional git diff indicators (added/modified/deleted)
8: struct MinimapView: View {
9:     // MARK: - External inputs
10: 
11:     let content: String
12:     /// Current scroll offset (read-only for display). Minimap FOLLOWS the editor, never fights it.
13:     let scrollOffset: CGFloat
14:     /// Visible viewport height (read-only for display)
15:     let scrollViewHeight: CGFloat
16:     let totalContentHeight: CGFloat
17:     
18:     /// Callback when user taps/drags on minimap to request scroll. 
19:     /// Parent handles actual scrolling - prevents bidirectional binding jitter.
20:     var onScrollRequested: ((CGFloat) -> Void)? = nil
21: 
22:     /// Optional indicators to render as thin bars on the left side of the minimap.
23:     /// Note: call sites can ignore this (default empty) without breaking compilation.
24:     var diffIndicators: [MinimapDiffIndicator] = []
25: 
26:     /// Fixed width; height expands to the container.
27:     var minimapWidth: CGFloat = 60
28: 
29:     // MARK: - Internal state
30: 


>>>REPORT
## MinimapView Scroll Sync Bug - FIXED

### Problem Identified
**Location:** `VSCodeiPadOS/VSCodeiPadOS/Views/Editor/MinimapView.swift` (lines 12-13) and `ContentView.swift` (lines 501-506)

**Root Cause:** The MinimapView was designed with bidirectional `@Binding` properties for `scrollOffset` and `scrollViewHeight`, but ContentView was passing `.constant()` bindings which:
1. Created a broken contract - MinimapView's `updateScroll()` tried to write to read-only bindings
2. Could cause scroll jitter if the bindings were ever made writable (minimap and editor fighting)
3. Click-to-scroll feature silently failed

### Fix Applied
Changed MinimapView from bidirectional bindings to unidirectional data flow:

**MinimapView.swift changes:**
- `@Binding var scrollOffset: CGFloat` â†’ `let scrollOffset: CGFloat` (read-only)
- `@Binding var scrollViewHeight: CGFloat` â†’ `let scrollViewHeight: CGFloat` (read-only)  
- Added: `var onScrollRequested: ((CGFloat) -> Void)? = nil` callback
- `updateScroll()` now calls `onScrollRequested(newOffset)` instead of writing to binding

**ContentView.swift changes:**
- Now passes values directly (not `.constant()` bindings)
- Provides `onScrollRequested` callback that converts pixel offset to line number and updates `scrollPosition`

### Architecture Principle
**Minimap FOLLOWS the editor, never fights it.** The minimap is now a pure display component that:
1. Reads scroll position to render visible region overlay
2. Emits scroll requests via callback (not direct mutation)
3. Parent (editor) decides whether to honor scroll requests

This prevents any bidirectional binding issues that could cause scroll jitter.

### Files Modified
- `VSCodeiPadOS/VSCodeiPadOS/Views/Editor/MinimapView.swift` (lines 11-20, 162-182)
- `VSCodeiPadOS/VSCodeiPadOS/ContentView.swift` (lines 500-514)
>>>END
