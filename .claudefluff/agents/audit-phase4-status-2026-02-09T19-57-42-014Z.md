# Agent: audit-phase4-status
**Status:** done
**Tokens:** 2,901
**Cost:** $0.0000
**Time:** 2026-02-09T19:57:42.014Z

## Task
Quick audit - list all files in:
1. VSCodeiPadOS/VSCodeiPadOS/UITests/
2. VSCodeiPadOS/VSCodeiPadOS/Tests/

Report total test coverage we have.

## Response
>>>TOOL list_dir
{"path":"VSCodeiPadOS/VSCodeiPadOS/UITests"}
>>>END

>>>TOOL list_dir
{"path":"VSCodeiPadOS/VSCodeiPadOS/Tests"}
>>>END


>>>TOOL get_symbols
{"path":"VSCodeiPadOS/VSCodeiPadOS/UITests/ActivityBarUITests.swift"}
>>>END
>>>TOOL get_symbols
{"path":"VSCodeiPadOS/VSCodeiPadOS/UITests/BreadcrumbsUITests.swift"}
>>>END
>>>TOOL get_symbols
{"path":"VSCodeiPadOS/VSCodeiPadOS/UITests/CommandPaletteUITests.swift"}
>>>END
>>>TOOL get_symbols
{"path":"VSCodeiPadOS/VSCodeiPadOS/UITests/CommandSearchUITests.swift"}
>>>END
>>>TOOL get_symbols
{"path":"VSCodeiPadOS/VSCodeiPadOS/UITests/FileSelectionUITests.swift"}
>>>END
>>>TOOL get_symbols
{"path":"VSCodeiPadOS/VSCodeiPadOS/UITests/GoToLineUITests.swift"}
>>>END
>>>TOOL get_symbols
{"path":"VSCodeiPadOS/VSCodeiPadOS/UITests/QuickOpenUITests.swift"}
>>>END
>>>TOOL get_symbols
{"path":"VSCodeiPadOS/VSCodeiPadOS/UITests/SidebarToggleUITests.swift"}
>>>END
>>>END>>>TOOL get_symbols
{"path":"VSCodeiPadOS/VSCodeiPadOS/UITests/ActivityBarUITests.swift"}
>>>END
>>>TOOL get_symbols
{"path":"VSCodeiPadOS/VSCodeiPadOS/UITests/BreadcrumbsUITests.swift"}
>>>END
>>>TOOL get_symbols
{"path":"VSCodeiPadOS/VSCodeiPadOS/UITests/CommandPaletteUITests.swift"}
>>>END
>>>TOOL get_symbols
{"path":"VSCodeiPadOS/VSCodeiPadOS/UITests/CommandSearchUITests.swift"}
>>>END
>>>TOOL get_symbols
{"path":"VSCodeiPadOS/VSCodeiPadOS/UITests/FileSelectionUITests.swift"}
>>>END
>>>TOOL get_symbols
{"path":"VSCodeiPadOS/VSCodeiPadOS/UITests/GoToLineUITests.swift"}
>>>END
>>>TOOL get_symbols
{"path":"VSCodeiPadOS/VSCodeiPadOS/UITests/QuickOpenUITests.swift"}
>>>END
>>>TOOL get_symbols
{"path":"VSCodeiPadOS/VSCodeiPadOS/UITests/SidebarToggleUITests.swift"}
>>>END

---

## ðŸ”§ TOOL RESULTS

[get_symbols]
No symbols found in VSCodeiPadOS/VSCodeiPadOS/UITests/ActivityBarUITests.swift (file may need to be opened first)

---

[get_symbols]
No symbols found in VSCodeiPadOS/VSCodeiPadOS/UITests/BreadcrumbsUITests.swift (file may need to be opened first)

---

[get_symbols]
No symbols found in VSCodeiPadOS/VSCodeiPadOS/UITests/CommandPaletteUITests.swift (file may need to be opened first)

---

[get_symbols]
No symbols found in VSCodeiPadOS/VSCodeiPadOS/UITests/CommandSearchUITests.swift (file may need to be opened first)

---

[get_symbols]
No symbols found in VSCodeiPadOS/VSCodeiPadOS/UITests/FileSelectionUITests.swift (file may need to be opened first)

---

[get_symbols]
No symbols found in VSCodeiPadOS/VSCodeiPadOS/UITests/GoToLineUITests.swift (file may need to be opened first)

---

[get_symbols]
No symbols found in VSCodeiPadOS/VSCodeiPadOS/UITests/QuickOpenUITests.swift (file may need to be opened first)

---

[get_symbols]
No symbols found in VSCodeiPadOS/VSCodeiPadOS/UITests/SidebarToggleUITests.swift (file may need to be opened first)


>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/UITests/ActivityBarUITests.swift"}
>>>END
>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/UITests/BreadcrumbsUITests.swift"}
>>>END

---

## ðŸ”§ TOOL RESULTS

[read_file]
File: VSCodeiPadOS/VSCodeiPadOS/UITests/ActivityBarUITests.swift (lines 1-105 of 105)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1: import XCTest
2: 
3: /// UI tests for verifying activity bar interactions switch/toggle the sidebar panels.
4: ///
5: /// These tests rely on accessibility identifiers set in `SidebarView.swift` for:
6: /// - Activity bar icons: `activityBar.<panel>`
7: /// - Sidebar title: `sidebar.header.title`
8: /// - Sidebar container: `sidebar.panel`
9: final class ActivityBarUITests: XCTestCase {
10: 
11:     private var app: XCUIApplication!
12: 
13:     override func setUp() {
14:         super.setUp()
15:         continueAfterFailure = false
16: 
17:         app = XCUIApplication()
18:         app.launchArguments += ["-ui-testing"]
19:         app.launch()
20: 
21:         // Ensure activity bar is present.
22:         XCTAssertTrue(app.buttons["activityBar.explorer"].waitForExistence(timeout: 10))
23:     }
24: 
25:     // MARK: - Helpers
26: 
27:     private func waitForSidebar(visible: Bool, timeout: TimeInterval = 5, file: StaticString = #filePath, line: UInt = #line) {
28:         let sidebar = app.otherElements["sidebar.panel"]
29:         let predicate = NSPredicate(format: "exists == %@", NSNumber(value: visible))
30:         expectation(for: predicate, evaluatedWith: sidebar)
31:         waitForExpectations(timeout: timeout)
32:         XCTAssertEqual(sidebar.exists, visible, file: file, line: line)
33:     }
34: 
35:     @discardableResult
36:     private func tapActivity(_ id: String, expectedTitle: String, file: StaticString = #filePath, line: UInt = #line) -> XCUIElement {
37:         let button = app.buttons[id]
38:         XCTAssertTrue(button.waitForExistence(timeout: 5), "Missing activity bar button: \(id)", file: file, line: line)
39:         button.tap()
40: 
41:         let sidebar = app.otherElements["sidebar.panel"]
42:         XCTAssertTrue(sidebar.waitForExistence(timeout: 5), "Sidebar should be visible after tapping \(id)", file: file, line: line)
43: 
44:         let title = app.staticTexts["sidebar.header.title"]
45:         XCTAssertTrue(title.waitForExistence(timeout: 5), "Sidebar title should exist", file: file, line: line)
46:         XCTAssertEqual(title.label, expectedTitle, file: file, line: line)
47:         return button
48:     }
49: 
50:     private func ensureSidebarVisible(file: StaticString = #filePath, line: UInt = #line) {
51:         let sidebar = app.otherElements["sidebar.panel"]
52:         if !sidebar.exists {
53:             app.buttons["activityBar.explorer"].tap()
54:         }
55:         XCTAssertTrue(app.otherElements["sidebar.panel"].waitForExistence(timeout: 5), file: file, line: line)
56:     }
57: 
58:     // MARK: - Tests
59: 
60:     func testSwitchToExplorer() {
61:         tapActivity("activityBar.explorer", expectedTitle: "EXPLORER")
62:     }
63: 
64:     func testSwitchToSearch() {
65:         tapActivity("activityBar.search", expectedTitle: "SEARCH")
66:     }
67: 
68:     func testSwitchToGit() {
69:         tapActivity("activityBar.sourceControl", expectedTitle: "SOURCE CONTROL")
70:     }
71: 
72:     func testSwitchToDebug() {
73:         tapActivity("activityBar.runAndDebug", expectedTitle: "RUN AND DEBUG")
74:     }
75: 
76:     func testSwitchToExtensions() {
77:         tapActivity("activityBar.extensions", expectedTitle: "EXTENSIONS")
78:     }
79: 
80:     func testSwitchToTesting() {
81:         tapActivity("activityBar.testing", expectedTitle: "TESTING")
82:     }
83: 
84:     func testToggleSidebarByReclick() {
85:         // Ensure sidebar is visible and Explorer selected.
86:         tapActivity("activityBar.explorer", expectedTitle: "EXPLORER")
87:         ensureSidebarVisible()
88: 
89:         let sidebar = app.otherElements["sidebar.panel"]
90:         XCTAssertTrue(sidebar.exists)
91: 
92:         // Re-clicking the selected icon should toggle the sidebar hidden.
93:         app.buttons["activityBar.explorer"].tap()
94:         waitForSidebar(visible: false)
95: 
96:         // Clicking again should reveal it.
97:         app.buttons["activityBar.explorer"].tap()
98:         waitForSidebar(visible: true)
99: 
100:         let title = app.staticTexts["sidebar.header.title"]
101:         XCTAssertTrue(title.waitForExistence(timeout: 5))
102:         XCTAssertEqual(title.label, "EXPLORER")
103:     }
104: }
105: 

---

[read_file]
File: VSCodeiPadOS/VSCodeiPadOS/UITests/BreadcrumbsUITests.swift (lines 1-127 of 127)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1: import XCTest
2: import Foundation
3: 
4: /// UI tests for the editor breadcrumbs bar.
5: ///
6: /// Notes:
7: /// - The app currently does not expose explicit accessibility identifiers for breadcrumb elements.
8: ///   These tests therefore use best-effort heuristics against the SwiftUI view hierarchy.
9: /// - The breadcrumbs UI is implemented as a horizontal `ScrollView` containing multiple `Text` nodes.
10: final class BreadcrumbsUITests: XCTestCase {
11: 
12:     private var app: XCUIApplication!
13: 
14:     override func setUp() {
15:         super.setUp()
16:         continueAfterFailure = false
17: 
18:         app = XCUIApplication()
19:         app.launchArguments += ["-ui-testing"]
20:         app.launch()
21:     }
22: 
23:     // MARK: - Helpers
24: 
25:     /// Returns the most likely breadcrumb labels found in the UI.
26:     ///
27:     /// Heuristic: pick the scroll view that contains the most "breadcrumb-like" static texts.
28:     private func breadcrumbLabels() -> [XCUIElement] {
29:         let scrollViews = app.scrollViews.allElementsBoundByIndex
30: 
31:         func isProbablyNotBreadcrumbLabel(_ label: String) -> Bool {
32:             let trimmed = label.trimmingCharacters(in: .whitespacesAndNewlines)
33:             if trimmed.isEmpty { return true }
34: 
35:             // Exclude a few well-known non-breadcrumb labels in this app.
36:             if trimmed.hasPrefix("Ln ") { return true }
37:             if trimmed.hasPrefix("Spaces:") { return true }
38:             if trimmed == "UTF-8" { return true }
39:             if trimmed == "LF" { return true }
40:             return false
41:         }
42: 
43:         var best: [XCUIElement] = []
44:         for sv in scrollViews {
45:             let labels = sv.staticTexts.allElementsBoundByIndex.filter { el in
46:                 !isProbablyNotBreadcrumbLabel(el.label)
47:             }
48:             if labels.count > best.count {
49:                 best = labels
50:             }
51:         }
52: 
53:         return best
54:     }
55: 
56:     /// Attempts to tap an element even when it isn't considered hittable by XCTest.
57:     private func forceTap(_ element: XCUIElement) {
58:         if element.isHittable {
59:             element.tap()
60:         } else {
61:             element.coordinate(withNormalizedOffset: CGVector(dx: 0.5, dy: 0.5)).tap()
62:         }
63:     }
64: 
65:     // MARK: - Tests
66: 
67:     /// Verifies breadcrumbs are visible and reflect a path hierarchy (multiple components).
68:     func testBreadcrumbDisplay() {
69:         XCTAssertTrue(app.wait(for: .runningForeground, timeout: 10))
70: 
71:         let labels = breadcrumbLabels()
72:         XCTAssertGreaterThanOrEqual(
73:             labels.count,
74:             2,
75:             "Expected breadcrumbs to show a path hierarchy with 2+ components (found: \(labels.map(\\.label)))."
76:         )
77:     }
78: 
79:     /// Verifies a breadcrumb item can be tapped.
80:     func testBreadcrumbClick() {
81:         XCTAssertTrue(app.wait(for: .runningForeground, timeout: 10))
82: 
83:         let labels = breadcrumbLabels()
84:         XCTAssertFalse(labels.isEmpty, "Expected breadcrumb labels to exist before tapping.")
85: 
86:         // Prefer a non-last element (directory-like) when possible.
87:         let target = labels.count >= 2 ? labels[0] : labels[labels.count - 1]
88:         XCTAssertTrue(target.exists, "Expected a breadcrumb label to exist.")
89: 
90:         forceTap(target)
91: 
92:         // Breadcrumbs should still be present after a tap.
93:         XCTAssertGreaterThanOrEqual(breadcrumbLabels().count, 2, "Expected breadcrumbs to remain visible after tapping a breadcrumb item.")
94:     }
95: 
96:     /// Verifies a breadcrumb dropdown (if implemented) can be opened.
97:     ///
98:     /// The current `BreadcrumbsView` implementation uses `.onTapGesture` and may not expose a
99:     /// dropdown menu. This test performs a long-press and *skips* if no menu UI surfaces.
100:     func testBreadcrumbDropdown() throws {
101:         XCTAssertTrue(app.wait(for: .runningForeground, timeout: 10))
102: 
103:         let labels = breadcrumbLabels()
104:         guard let target = labels.last else {
105:             XCTFail("Expected at least one breadcrumb label to test dropdown.")
106:             return
107:         }
108: 
109:         target.press(forDuration: 1.0)
110: 
111:         let menu = app.menus.firstMatch
112:         let sheet = app.sheets.firstMatch
113:         let popover = app.popovers.firstMatch
114: 
115:         let appeared =
116:             menu.waitForExistence(timeout: 2) ||
117:             sheet.waitForExistence(timeout: 2) ||
118:             popover.waitForExistence(timeout: 2)
119: 
120:         guard appeared else {
121:             throw XCTSkip("No breadcrumb dropdown surfaced (menu/sheet/popover). Dropdown may not be implemented or not accessible.")
122:         }
123: 
124:         XCTAssertTrue(menu.exists || sheet.exists || popover.exists)
125:     }
126: }
127: 


>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/UITests/CommandPaletteUITests.swift"}
>>>END
>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/UITests/CommandSearchUITests.swift"}
>>>END
>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/UITests/FileSelectionUITests.swift"}
>>>END
>>>END

---

## ðŸ”§ TOOL RESULTS

[read_file]
File: VSCodeiPadOS/VSCodeiPadOS/UITests/CommandPaletteUITests.swift (lines 1-205 of 205)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1: import XCTest
2: 
3: class CommandPaletteUITests: XCTestCase {
4:     
5:     var app: XCUIApplication!
6:     
7:     override func setUpWithError() throws {
8:         continueAfterFailure = false
9:         app = XCUIApplication()
10:         app.launch()
11:         
12:         // Wait for app to fully load
13:         let expectation = XCTNSPredicateExpectation(
14:             predicate: NSPredicate(format: "exists == true"),
15:             object: app.windows.firstMatch
16:         )
17:         let result = XCTWaiter.wait(for: [expectation], timeout: 5.0)
18:         XCTAssertEqual(result, .completed, "App failed to launch")
19:     }
20:     
21:     override func tearDownWithError() throws {
22:         app = nil
23:     }
24:     
25:     // MARK: - Test Cases
26:     
27:     /// Test: Cmd+Shift+P opens the command palette
28:     func testOpenWithKeyboard() throws {
29:         // Send Cmd+Shift+P keyboard shortcut to open command palette
30:         app.keys["command"].press(forDuration: 0.1, thenTap: app.keys["shift"])
31:         app.keys["p"].tap()
32:         
33:         // Alternative approach: use key press combination
34:         // Use menu or keyboard shortcut simulation
35:         let commandPaletteNavBar = app.navigationBars["Command Palette"]
36:         
37:         // Wait for command palette to appear
38:         XCTAssertTrue(commandPaletteNavBar.waitForExistence(timeout: 2.0), 
39:                       "Command Palette should appear after Cmd+Shift+P")
40:         
41:         // Verify the search field exists
42:         let searchField = app.searchFields["Search commands..."]
43:         XCTAssertTrue(searchField.exists, "Search field should be present in Command Palette")
44:         
45:         // Clean up: close the palette
46:         closeCommandPalette()
47:     }
48:     
49:     /// Test: Search filters commands correctly
50:     func testSearchFiltering() throws {
51:         // Open command palette first
52:         openCommandPalette()
53:         
54:         let searchField = app.searchFields["Search commands..."]
55:         XCTAssertTrue(searchField.exists, "Search field should exist")
56:         
57:         // Tap search field and enter search term
58:         searchField.tap()
59:         searchField.typeText("collapse")
60:         
61:         // Wait for filtering to apply
62:         sleep(1)
63:         
64:         // Verify "Collapse All" command is visible
65:         let collapseAllButton = app.buttons["Collapse All"]
66:         XCTAssertTrue(collapseAllButton.exists, "'Collapse All' command should appear when searching 'collapse'")
67:         
68:         // Verify other commands are filtered out (e.g., "Zoom In" should not be visible)
69:         let zoomInButton = app.buttons["Zoom In"]
70:         XCTAssertFalse(zoomInButton.exists, "'Zoom In' should be filtered out when searching 'collapse'")
71:         
72:         // Clear search and verify all commands return
73:         searchField.tap()
74:         searchField.clearAndEnterText(text: "")
75:         sleep(1)
76:         
77:         // After clearing, multiple categories should be visible
78:         let editorSection = app.staticTexts["Editor"]
79:         let viewSection = app.staticTexts["View"]
80:         XCTAssertTrue(editorSection.exists, "Editor section should reappear after clearing search")
81:         
82:         closeCommandPalette()
83:     }
84:     
85:     /// Test: Selecting a command executes its action
86:     func testCommandExecution() throws {
87:         // Open command palette
88:         openCommandPalette()
89:         
90:         // Search for a specific command
91:         let searchField = app.searchFields["Search commands..."]
92:         searchField.tap()
93:         searchField.typeText("toggle sidebar")
94:         
95:         sleep(1)
96:         
97:         // Find and tap the "Toggle Sidebar" command
98:         let toggleSidebarButton = app.buttons["Toggle Sidebar"]
99:         XCTAssertTrue(toggleSidebarButton.waitForExistence(timeout: 2.0), 
100:                       "Toggle Sidebar command should be found")
101:         
102:         // Tap the command to execute it
103:         toggleSidebarButton.tap()
104:         
105:         // Verify command palette is dismissed after execution
106:         let commandPaletteNavBar = app.navigationBars["Command Palette"]
107:         XCTAssertFalse(commandPaletteNavBar.waitForExistence(timeout: 2.0),
108:                        "Command Palette should dismiss after command execution")
109:     }
110:     
111:     /// Test: Escape key closes the command palette
112:     func testCloseOnEscape() throws {
113:         // Open command palette
114:         openCommandPalette()
115:         
116:         let commandPaletteNavBar = app.navigationBars["Command Palette"]
117:         XCTAssertTrue(commandPaletteNavBar.exists, "Command Palette should be open")
118:         
119:         // Press Escape key to close
120:         app.keys["escape"].tap()
121:         
122:         // Verify palette is closed
123:         XCTAssertFalse(commandPaletteNavBar.waitForExistence(timeout: 2.0),
124:                        "Command Palette should close on Escape key")
125:     }
126:     
127:     // MARK: - Helper Methods
128:     
129:     private func openCommandPalette() {
130:         // Try to open via keyboard shortcut
131:         // Note: On iPad with keyboard, Cmd+Shift+P should trigger
132:         
133:         // Alternative: Use accessibility to find a trigger if available
134:         // For testing, we can also use the app's menu or button if exposed
135:         
136:         // Simulate keyboard shortcut
137:         let keyP = app.keys["p"]
138:         let keyShift = app.keys["shift"]
139:         let keyCommand = app.keys["command"]
140:         
141:         // Press Cmd+Shift+P
142:         keyCommand.press(forDuration: 0.1, thenTap: keyShift)
143:         keyP.tap()
144:         
145:         // Wait for palette to appear
146:         let commandPaletteNavBar = app.navigationBars["Command Palette"]
147:         let appeared = commandPaletteNavBar.waitForExistence(timeout: 3.0)
148:         
149:         // If keyboard shortcut didn't work, try alternative method
150:         if !appeared {
151:             // Look for a command palette button in the UI if available
152:             let paletteButton = app.buttons["Command Palette"]
153:             if paletteButton.exists {
154:                 paletteButton.tap()
155:             }
156:         }
157:         
158:         XCTAssertTrue(commandPaletteNavBar.waitForExistence(timeout: 2.0),
159:                       "Failed to open Command Palette")
160:     }
161:     
162:     private func closeCommandPalette() {
163:         // Try Escape key first
164:         app.keys["escape"].tap()
165:         
166:         let commandPaletteNavBar = app.navigationBars["Command Palette"]
167:         
168:         // If still exists, try Close button
169:         if commandPaletteNavBar.exists {
170:             let closeButton = app.buttons["Close"]
171:             if closeButton.exists {
172:                 closeButton.tap()
173:             }
174:         }
175:         
176:         // Wait for dismissal
177:         _ = commandPaletteNavBar.waitForNonExistence(timeout: 2.0)
178:     }
179: }
180: 
181: // MARK: - XCUIElement Extensions
182: 
183: extension XCUIElement {
184:     func clearAndEnterText(text: String) {
185:         guard let stringValue = self.value as? String else {
186:             XCTFail("Failed to get string value from element")
187:             return
188:         }
189:         
190:         // Clear existing text
191:         let deleteString = String(repeating: XCUIKeyboardKey.delete.rawValue, count: stringValue.count)
192:         self.typeText(deleteString)
193:         
194:         // Enter new text
195:         self.typeText(text)
196:     }
197:     
198:     func waitForNonExistence(timeout: TimeInterval) -> Bool {
199:         let predicate = NSPredicate(format: "exists == false")
200:         let expectation = XCTNSPredicateExpectation(predicate: predicate, object: self)
201:         let result = XCTWaiter.wait(for: [expectation], timeout: timeout)
202:         return result == .completed
203:     }
204: }
205: 

---

[read_file]
File: VSCodeiPadOS/VSCodeiPadOS/UITests/CommandSearchUITests.swift (lines 1-745 of 745)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1: import XCTest
2: 
3: import XCTest
4: import Foundation
5: 
6: final class CommandSearchUITests: XCTestCase {
7: 
8:     override func setUp() {
9:         super.setUp()
10:         continueAfterFailure = false
11:     }
12: 
13:     // Keep this list aligned with the app's accessibility identifiers.
14:     private let preferredIdentifiers = [
15:         "commandSearchInput",
16:         "command-search-input",
17:         "CommandSearchInput",
18:         "commandPaletteSearchField",
19:         "command-palette-search",
20:         "Command Palette",
21:         "Command Search"
22:     ]
23: 
24:     // Keep this list aligned with the app's search panel accessibility identifiers.
25:     private let searchPanelIdentifiers = [
26:         "searchPanelInput",
27:         "search-panel-input",
28:         "SearchPanelInput",
29:         "globalSearchInput",
30:         "global-search-input",
31:         "GlobalSearchInput",
32:         "searchQuery",
33:         "search-query",
34:         "SearchQuery"
35:     ]
36: 
37:     private func findCommandSearchElement(in app: XCUIApplication) -> XCUIElement {
38:         for id in preferredIdentifiers {
39:             let tf = app.textFields[id]
40:             if tf.exists { return tf }
41:             let sf = app.searchFields[id]
42:             if sf.exists { return sf }
43:         }
44: 
45:         // Fallback: first visible searchField/textField.
46:         if app.searchFields.count > 0 {
47:             return app.searchFields.element(boundBy: 0)
48:         }
49:         return app.textFields.element(boundBy: 0)
50:     }
51: 
52:     private func findSearchPanelElement(in app: XCUIApplication) -> XCUIElement {
53:         for id in searchPanelIdentifiers {
54:             let tf = app.textFields[id]
55:             if tf.exists { return tf }
56:             let sf = app.searchFields[id]
57:             if sf.exists { return sf }
58:         }
59: 
60:         // Fallback: first visible searchField/textField.
61:         if app.searchFields.count > 0 {
62:             return app.searchFields.element(boundBy: 0)
63:         }
64:         return app.textFields.element(boundBy: 0)
65:     }
66: 
67:     private func openCommandPalette(in app: XCUIApplication, timeout: TimeInterval = 10) -> XCUIElement {
68:         app.typeKey("p", modifierFlags: [.command, .shift])
69: 
70:         let searchField = findCommandSearchElement(in: app)
71:         XCTAssertTrue(searchField.waitForExistence(timeout: timeout), "Expected command palette search input to appear")
72:         return searchField
73:     }
74: 
75:     private func openGlobalSearch(in app: XCUIApplication, timeout: TimeInterval = 10) {
76:         // Primary: keyboard shortcut (common in VS Code): Cmd+Shift+F.
77:         app.typeKey("f", modifierFlags: [.command, .shift])
78: 
79:         let searchField = findGlobalSearchField(in: app)
80:         if searchField.waitForExistence(timeout: timeout) {
81:             return
82:         }
83: 
84:         // Fallback: try a visible Search/Find button.
85:         let likelyButtons = [
86:             "Search",
87:             "Find",
88:             "Find in Files",
89:             "Search in Files"
90:         ]
91: 
92:         for label in likelyButtons {
93:             let b = app.buttons[label]
94:             if b.waitForExistence(timeout: 2) {
95:                 b.tap()
96:                 if findGlobalSearchField(in: app).waitForExistence(timeout: timeout) {
97:                     return
98:                 }
99:             }
100:         }
101: 
102:         XCTFail("Unable to open global search UI")
103:     }
104: 
105:     private func findGlobalSearchField(in app: XCUIApplication) -> XCUIElement {
106:         let likelyLabels = [
107:             "Search",
108:             "Find",
109:             "Find in Files",
110:             "Search in Files",
111:             "Search Files",
112:             "Search query",
113:             "SearchQuery",
114:             "searchQuery",
115:             "globalSearchInput"
116:         ]
117: 
118:         for label in likelyLabels {
119:             let sf = app.searchFields[label]
120:             if sf.exists { return sf }
121:             let tf = app.textFields[label]
122:             if tf.exists { return tf }
123:         }
124: 
125:         if app.searchFields.count > 0 { return app.searchFields.element(boundBy: 0) }
126:         return app.textFields.element(boundBy: 0)
127:     }
128: 
129:     private func waitForAnyElementToExist(_ elements: [XCUIElement], timeout: TimeInterval) -> Bool {
130:         let deadline = Date().addingTimeInterval(timeout)
131:         while Date() < deadline {
132:             if elements.contains(where: { $0.exists }) { return true }
133:             RunLoop.current.run(until: Date().addingTimeInterval(0.1))
134:         }
135:         return false
136:     }
137: 
138:     private func findSearchResultElement(in app: XCUIApplication, fileName: String) -> XCUIElement {
139:         // Prefer tapping a cell (common for result lists).
140:         let cell = app.cells.containing(NSPredicate(format: "label CONTAINS[c] %@", fileName)).firstMatch
141:         if cell.exists { return cell }
142: 
143:         // Fallbacks.
144:         let button = app.buttons.containing(NSPredicate(format: "label CONTAINS[c] %@", fileName)).firstMatch
145:         if button.exists { return button }
146: 
147:         let staticText = app.staticTexts.containing(NSPredicate(format: "label CONTAINS[c] %@", fileName)).firstMatch
148:         if staticText.exists { return staticText }
149: 
150:         return app.cells.firstMatch
151:     }
152: 
153:     func testCmdShiftPOpensCommandPalette() {
154:         let app = XCUIApplication()
155:         app.launch()
156: 
157:         XCTAssertTrue(app.wait(for: .runningForeground, timeout: 10))
158: 
159:         // Cmd+Shift+P should open the command palette.
160:         app.typeKey("p", modifierFlags: [.command, .shift])
161: 
162:         let commandSearchElement = findCommandSearchElement(in: app)
163:         XCTAssertTrue(
164:             commandSearchElement.waitForExistence(timeout: 10),
165:             "Expected command palette search input to appear after Cmd+Shift+P"
166:         )
167:     }
168: 
169:     func testEscapeClosesCommandPalette() {
170:         let app = XCUIApplication()
171:         app.launch()
172: 
173:         XCTAssertTrue(app.wait(for: .runningForeground, timeout: 10))
174: 
175:         let searchField = openCommandPalette(in: app)
176: 
177:         app.typeKey(XCUIKeyboardKey.escape, modifierFlags: [])
178: 
179:         let deadline = Date().addingTimeInterval(5)
180:         while Date() < deadline, searchField.exists {
181:             RunLoop.current.run(until: Date().addingTimeInterval(0.1))
182:         }
183: 
184:         XCTAssertFalse(searchField.exists, "Expected Escape to close command palette")
185:     }
186: 
187:     func testCommandExecutionFromPaletteClosesPalette() {
188:         let app = XCUIApplication()
189:         app.launch()
190: 
191:         XCTAssertTrue(app.wait(for: .runningForeground, timeout: 10))
192: 
193:         let searchField = openCommandPalette(in: app)
194: 
195:         let commandToRun = "Format Document"
196:         searchField.tap()
197:         searchField.typeText(commandToRun)
198: 
199:         let firstCommand = app.cells.containing(NSPredicate(format: "label CONTAINS[c] %@", commandToRun)).firstMatch
200:         XCTAssertTrue(firstCommand.waitForExistence(timeout: 10), "Expected to find '\(commandToRun)' in command palette results")
201: 
202:         firstCommand.tap()
203: 
204:         let deadline = Date().addingTimeInterval(5)
205:         while Date() < deadline, searchField.exists {
206:             RunLoop.current.run(until: Date().addingTimeInterval(0.1))
207:         }
208: 
209:         XCTAssertFalse(searchField.exists, "Expected executing a command to dismiss/close the command palette")
210:     }
211: 
212:     func testEnteringTextIntoSearchInputWorks() {
213:         let app = XCUIApplication()
214:         app.launch()
215: 
216:         XCTAssertTrue(app.wait(for: .runningForeground, timeout: 10))
217: 
218:         let searchElement = openCommandPalette(in: app)
219: 
220:         searchElement.tap()
221: 
222:         let textToEnter = "format"
223:         searchElement.typeText(textToEnter)
224: 
225:         // Validate the entered text is reflected in the field.
226:         // Some UIKit controls expose their content via `value`.
227:         let valueString = (searchElement.value as? String) ?? ""
228:         XCTAssertTrue(valueString.contains(textToEnter), "Expected search input value to contain '\(textToEnter)'. Actual value: '\(valueString)'.")
229:     }
230: 
231:     func testCmdShiftFOpensSearchPanel() {
232:         let app = XCUIApplication()
233:         app.launch()
234: 
235:         XCTAssertTrue(app.wait(for: .runningForeground, timeout: 10))
236: 
237:         // Cmd+Shift+F should open the search panel.
238:         app.typeKey("f", modifierFlags: [.command, .shift])
239: 
240:         let searchPanelElement = findSearchPanelElement(in: app)
241:         XCTAssertTrue(
242:             searchPanelElement.waitForExistence(timeout: 10),
243:             "Expected search panel search input to appear after Cmd+Shift+F"
244:         )
245:     }
246: 
247:     func testSearchInputAcceptsText() {
248:         let app = XCUIApplication()
249:         app.launch()
250: 
251:         XCTAssertTrue(app.wait(for: .runningForeground, timeout: 10))
252: 
253:         openGlobalSearch(in: app)
254: 
255:         let searchField = findGlobalSearchField(in: app)
256:         XCTAssertTrue(searchField.waitForExistence(timeout: 10), "Expected global search field to exist")
257: 
258:         searchField.tap()
259:         let query = "hello"
260:         searchField.typeText(query)
261: 
262:         let valueString = (searchField.value as? String) ?? ""
263:         XCTAssertTrue(
264:             valueString.isEmpty || valueString.localizedCaseInsensitiveContains(query),
265:             "Expected search field value to contain '\(query)' (if exposed). Actual value: '\(valueString)'"
266:         )
267:     }
268: 
269:     func testSearchResultsDisplay() {
270:         let app = XCUIApplication()
271:         app.launch()
272: 
273:         XCTAssertTrue(app.wait(for: .runningForeground, timeout: 10))
274: 
275:         openGlobalSearch(in: app)
276: 
277:         let searchField = findGlobalSearchField(in: app)
278:         XCTAssertTrue(searchField.waitForExistence(timeout: 10), "Expected global search field to exist")
279: 
280:         searchField.tap()
281:         searchField.typeText("hello")
282: 
283:         let expectedFileName = "ContentView.swift"
284:         let result = findSearchResultElement(in: app, fileName: expectedFileName)
285: 
286:         XCTAssertTrue(
287:             result.waitForExistence(timeout: 10),
288:             "Expected at least one search result to appear (e.g. containing '\(expectedFileName)')"
289:         )
290:     }
291: 
292:     func testRecentCommandsAppearFirstInCommandPalette() {
293:         let app = XCUIApplication()
294:         app.launch()
295: 
296:         // Wait for app to be running
297:         XCTAssertTrue(app.wait(for: .runningForeground, timeout: 10))
298: 
299:         // Open command palette with Cmd+Shift+P
300:         app.typeKey("p", modifierFlags: [.command, .shift])
301: 
302:         let searchElement = findCommandSearchElement(in: app)
303:         XCTAssertTrue(searchElement.waitForExistence(timeout: 10), "Expected command palette search input to appear")
304: 
305:         // Search for and select a specific command (e.g., "Format Document")
306:         let commandToRun = "Format Document"
307:         searchElement.tap()
308:         searchElement.typeText(commandToRun)
309: 
310:         // Wait for command results to appear and select the first matching command
311:         let firstCommand = app.cells.containing(NSPredicate(format: "label CONTAINS[c] %@", commandToRun)).element(boundBy: 0)
312:         XCTAssertTrue(firstCommand.waitForExistence(timeout: 5), "Expected to find '\(commandToRun)' command")
313: 
314:         // Store the full label of the command we're about to run
315:         let commandLabel = firstCommand.label
316: 
317:         // Execute the command by tapping it
318:         firstCommand.tap()
319: 
320:         // Wait a moment for command to execute and command palette to close
321:         sleep(1)
322: 
323:         // Reopen command palette - recent commands should appear at the top when reopened with empty search
324:         app.typeKey("p", modifierFlags: [.command, .shift])
325: 
326:         let secondSearchElement = findCommandSearchElement(in: app)
327:         XCTAssertTrue(secondSearchElement.waitForExistence(timeout: 10), "Expected command palette to reopen")
328: 
329:         // Wait a moment for the command list to populate with recent commands
330:         sleep(1)
331: 
332:         // Get all command cells - recent commands should appear first in the list
333:         let allCells = app.cells.allElementsBoundByIndex
334:         XCTAssertGreaterThan(allCells.count, 0, "Expected at least one command in palette")
335: 
336:         // When command palette is reopened, recent commands should appear at the top
337:         // The most recently executed command should be first (or very prominent) in the list
338:         let firstCell = allCells[0]
339:         let firstCellLabel = firstCell.label
340: 
341:         // Verify that the recently run command appears at the very top of the list
342:         // This validates the "recent commands appear first" requirement
343:         XCTAssertTrue(
344:             firstCellLabel.contains(commandLabel) || firstCellLabel.contains(commandToRun),
345:             "Expected recent command '\(commandLabel)' to appear first in command palette, but first item was '\(firstCellLabel)'"
346:         )
347: 
348:         // Additional verification: search for the command again and verify it still appears
349:         // This ensures the command is still available and the palette is functioning correctly
350:         secondSearchElement.tap()
351:         secondSearchElement.typeText(commandToRun)
352: 
353:         let recentCommandInSearch = app.cells.containing(NSPredicate(format: "label CONTAINS[c] %@", commandToRun)).element(boundBy: 0)
354:         XCTAssertTrue(recentCommandInSearch.waitForExistence(timeout: 5), "Expected '\(commandToRun)' to still be searchable after running it")
355:     }
356: 
357:     func testTappingSearchResultNavigatesToFileInEditor() {
358:         let app = XCUIApplication()
359:         app.launch()
360: 
361:         XCTAssertTrue(app.wait(for: .runningForeground, timeout: 10))
362: 
363:         openGlobalSearch(in: app)
364: 
365:         let searchField = findGlobalSearchField(in: app)
366:         XCTAssertTrue(searchField.waitForExistence(timeout: 10), "Expected global search field to exist")
367: 
368:         searchField.tap()
369:         let query = "hello"
370:         searchField.typeText(query)
371: 
372:         // Wait for results and tap one.
373:         let fileName = "ContentView.swift"
374:         let result = findSearchResultElement(in: app, fileName: fileName)
375:         XCTAssertTrue(result.waitForExistence(timeout: 10), "Expected a search result for '\(fileName)' to appear")
376:         result.tap()
377: 
378:         // Verify navigation occurred by checking for an editor and/or visible file title.
379:         let editor = app.textViews["Editor"]
380:         let fileTitleStaticText = app.staticTexts.matching(NSPredicate(format: "label CONTAINS[c] %@", fileName)).firstMatch
381:         let fileTitleButton = app.buttons.matching(NSPredicate(format: "label CONTAINS[c] %@", fileName)).firstMatch
382:         let fileTitleNavBar = app.navigationBars.matching(NSPredicate(format: "identifier CONTAINS[c] %@ OR label CONTAINS[c] %@", fileName, fileName)).firstMatch
383: 
384:         XCTAssertTrue(
385:             waitForAnyElementToExist([editor, fileTitleStaticText, fileTitleButton, fileTitleNavBar], timeout: 10),
386:             "Expected tapping a search result to navigate to an editor location for '\(fileName)'"
387:         )
388: 
389:         // If the editor exposes text, ensure the query appears somewhere (best-effort assertion).
390:         if editor.exists {
391:             let editorValue = (editor.value as? String) ?? ""
392:             XCTAssertTrue(
393:                 editorValue.isEmpty || editorValue.localizedCaseInsensitiveContains(query),
394:                 "Expected editor text to contain query '\(query)' (if exposed). Actual value: '\(editorValue)'"
395:             )
396:         }
397:     }
398: 
399:     func testCommandPaletteFilteringNarrowsResults() {
400:         let app = XCUIApplication()
401:         app.launch()
402: 
403:         // Wait for app to be running
404:         XCTAssertTrue(app.wait(for: .runningForeground, timeout: 10))
405: 
406:         // Open command palette with Cmd+Shift+P
407:         app.typeKey("p", modifierFlags: [.command, .shift])
408:         
409:         let searchElement = findCommandSearchElement(in: app)
410:         XCTAssertTrue(searchElement.waitForExistence(timeout: 10), "Expected command palette search input to appear")
411: 
412:         // First, check that all commands are visible when search is empty
413:         sleep(1) // Allow command list to populate
414:         let initialAllCells = app.cells.allElementsBoundByIndex
415:         let initialCommandCount = initialAllCells.count
416:         XCTAssertGreaterThan(initialCommandCount, 1, "Expected multiple commands to be available in the palette initially")
417: 
418:         // Type a specific search term that should narrow results
419:         let searchTerm = "format"
420:         searchElement.tap()
421:         searchElement.typeText(searchTerm)
422: 
423:         // Wait for filtering to apply
424:         sleep(1)
425: 
426:         // Check that filtered results are fewer than initial results
427:         let filteredAllCells = app.cells.allElementsBoundByIndex
428:         let filteredCommandCount = filteredAllCells.count
429:         
430:         // Assert that filtering reduced the number of results
431:         XCTAssertLessThan(filteredCommandCount, initialCommandCount, 
432:             "Expected filtered results (\(filteredCommandCount)) to be fewer than initial results (\(initialCommandCount)) when searching for '\(searchTerm)'")
433: 
434:         // Assert that all remaining results contain the search term (case insensitive)
435:         for cell in filteredAllCells {
436:             let cellLabel = cell.label.lowercased()
437:             XCTAssertTrue(cellLabel.contains(searchTerm.lowercased()), 
438:                 "Expected filtered command '\(cell.label)' to contain search term '\(searchTerm)'")
439:         }
440: 
441:         // Clear the search and verify results expand again
442:         // Select all text and delete
443:         searchElement.typeKey("a", modifierFlags: .command)
444:         searchElement.typeKey(XCUIKeyboardKey.delete.rawValue)
445: 
446:         // Wait for results to reset
447:         sleep(1)
448: 
449:         let clearedAllCells = app.cells.allElementsBoundByIndex
450:         let clearedCommandCount = clearedAllCells.count
451:         
452:         // After clearing search, results should be close to original count
453:         XCTAssertGreaterThanOrEqual(clearedCommandCount, filteredCommandCount, 
454:             "Expected clearing search to show more results than filtered count. Filtered: \(filteredCommandCount), Cleared: \(clearedCommandCount)")
455:     }
456: 
457:     // MARK: - Replace UI Elements Tests
458: 
459:     /// Test that replace UI elements are shown when accessing find/replace functionality
460:     func testReplaceUIElementsShowWhenFindReplaceOpened() {
461:         let app = XCUIApplication()
462:         app.launch()
463: 
464:         XCTAssertTrue(app.wait(for: .runningForeground, timeout: 10))
465: 
466:         // Open find/replace with Cmd+H (common shortcut for find/replace)
467:         app.typeKey("h", modifierFlags: [.command])
468: 
469:         // Wait for find/replace UI to appear
470:         sleep(1)
471: 
472:         // Look for replace-related UI elements using multiple identifier strategies
473:         let replaceIdentifiers = [
474:             "replaceInput",
475:             "replace-input",
476:             "ReplaceInput",
477:             "replaceField",
478:             "replace-field",
479:             "ReplaceField",
480:             "replaceTextField",
481:             "replaceText",
482:             "Replace"
483:         ]
484: 
485:         var replaceElement: XCUIElement?
486:         for id in replaceIdentifiers {
487:             let tf = app.textFields[id]
488:             if tf.waitForExistence(timeout: 2) {
489:                 replaceElement = tf
490:                 break
491:             }
492:             let sf = app.searchFields[id]
493:             if sf.waitForExistence(timeout: 2) {
494:                 replaceElement = sf
495:                 break
496:             }
497:             let tv = app.textViews[id]
498:             if tv.waitForExistence(timeout: 2) {
499:                 replaceElement = tv
500:                 break
501:             }
502:         }
503: 
504:         // If not found by identifier, look for any text field after the first search field
505:         if replaceElement == nil {
506:             let allTextFields = app.textFields.allElementsBoundByIndex
507:             if allTextFields.count >= 2 {
508:                 replaceElement = allTextFields[1] // Second text field is often replace
509:             }
510:         }
511: 
512:         XCTAssertNotNil(replaceElement, "Expected replace input field to exist when find/replace is opened")
513:         XCTAssertTrue(replaceElement!.exists, "Replace input field should be visible")
514:     }
515: 
516:     /// Test that replace action changes content or confirms UI state changes
517:     func testReplaceActionChangesContentOrConfirmsUI() {
518:         let app = XCUIApplication()
519:         app.launch()
520: 
521:         XCTAssertTrue(app.wait(for: .runningForeground, timeout: 10))
522: 
523:         // First, open a file in the editor
524:         let sampleFile = "ContentView.swift"
525:         
526:         // Try to open the file via quick open or file tree
527:         app.typeKey("p", modifierFlags: [.command]) // Quick open
528:         
529:         let quickOpenField = app.textFields["quickOpenInput"]
530:         if quickOpenField.waitForExistence(timeout: 5) {
531:             quickOpenField.tap()
532:             quickOpenField.typeText(sampleFile)
533:             sleep(1)
534:             
535:             let fileCell = app.cells.containing(NSPredicate(format: "label CONTAINS[c] %@", sampleFile)).firstMatch
536:             if fileCell.waitForExistence(timeout: 5) {
537:                 fileCell.tap()
538:             }
539:         }
540: 
541:         // Wait for editor to load
542:         sleep(2)
543: 
544:         // Capture initial editor state
545:         let editor = app.textViews["Editor"]
546:         let initialEditorValue = (editor.value as? String) ?? ""
547: 
548:         // Open find/replace
549:         app.typeKey("h", modifierFlags: [.command])
550:         sleep(1)
551: 
552:         // Find the replace input field
553:         var replaceField: XCUIElement?
554:         let replaceIdentifiers = ["replaceInput", "replace-input", "ReplaceInput", "replaceField", "replaceTextField", "Replace"]
555:         for id in replaceIdentifiers {
556:             let tf = app.textFields[id]
557:             if tf.waitForExistence(timeout: 2) {
558:                 replaceField = tf
559:                 break
560:             }
561:         }
562:         
563:         // Fallback: try to find any text field after search field
564:         if replaceField == nil {
565:             let textFields = app.textFields.allElementsBoundByIndex
566:             if textFields.count >= 2 {
567:                 replaceField = textFields[1]
568:             }
569:         }
570: 
571:         // If we found a replace field, test the replace action
572:         if let replaceInput = replaceField {
573:             // Enter text in replace field
574:             let replacementText = "REPLACED_TEXT"
575:             replaceInput.tap()
576:             replaceInput.typeText(replacementText)
577: 
578:             // Verify replace field contains our text
579:             let replaceValue = (replaceInput.value as? String) ?? ""
580:             XCTAssertTrue(replaceValue.contains(replacementText) || replaceInput.exists,
581:                 "Replace field should contain entered text or exist after input")
582: 
583:             // Look for replace action buttons
584:             let replaceButtonIdentifiers = [
585:                 "replaceButton",
586:                 "replace-button",
587:                 "ReplaceButton",
588:                 "replaceAll",
589:                 "replace-all",
590:                 "ReplaceAll",
591:                 "replaceNext",
592:                 "replace-next",
593:                 "ReplaceNext",
594:                 "Replace",
595:                 "Replace All",
596:                 "Replace Next"
597:             ]
598: 
599:             var replaceActionButton: XCUIElement?
600:             for id in replaceButtonIdentifiers {
601:                 let btn = app.buttons[id]
602:                 if btn.waitForExistence(timeout: 2) {
603:                     replaceActionButton = btn
604:                     break
605:                 }
606:             }
607: 
608:             // If we found a replace button, tap it and verify UI changes
609:             if let actionButton = replaceActionButton {
610:                 // Store pre-action state
611:                 let preActionReplaceValue = (replaceInput.value as? String) ?? ""
612: 
613:                 // Tap the replace action button
614:                 actionButton.tap()
615:                 sleep(1)
616: 
617:                 // Verify UI responded - either button changed, field changed, or some other UI element appeared
618:                 let postActionReplaceValue = (replaceInput.value as? String) ?? ""
619:                 let buttonStillExists = actionButton.exists
620:                 
621:                 // Check for replace confirmation UI elements
622:                 let confirmationElements = [
623:                     app.staticTexts["Replaced"],
624:                     app.staticTexts["Replacement complete"],
625:                     app.staticTexts["Replace complete"],
626:                     app.staticTexts.matching(NSPredicate(format: "label CONTAINS[c] %@", "replaced")).firstMatch,
627:                     app.staticTexts.matching(NSPredicate(format: "label CONTAINS[c] %@", "replacement")).firstMatch
628:                 ]
629: 
630:                 let hasConfirmation = confirmationElements.contains { $0.exists }
631: 
632:                 // Check for editor content change
633:                 let currentEditorValue = (editor.value as? String) ?? ""
634:                 let contentChanged = currentEditorValue != initialEditorValue
635: 
636:                 // The test passes if any of these UI changes occurred
637:                 XCTAssertTrue(
638:                     buttonStillExists || hasConfirmation || contentChanged || postActionReplaceValue != preActionReplaceValue,
639:                     "Replace action should cause UI change: content modified, confirmation shown, or UI state updated"
640:                 )
641:             } else {
642:                 // If no replace button found, at least verify the replace field accepts input
643:                 XCTAssertTrue(replaceInput.exists, "Replace input should exist and accept text input")
644:             }
645:         } else {
646:             // If no replace field found, verify find UI exists as fallback
647:             let findField = findGlobalSearchField(in: app)
648:             XCTAssertTrue(findField.exists, "Expected at least find functionality to be available")
649:         }
650:     }
651: 
652:     /// Test that replace UI toggles visibility when activated/deactivated
653:     func testReplaceUITogglesVisibility() {
654:         let app = XCUIApplication()
655:         app.launch()
656: 
657:         XCTAssertTrue(app.wait(for: .runningForeground, timeout: 10))
658: 
659:         // Open find (not replace yet)
660:         app.typeKey("f", modifierFlags: [.command])
661:         sleep(1)
662: 
663:         // Capture initial state - should have search field but possibly no replace
664:         let initialSearchField = findGlobalSearchField(in: app)
665:         XCTAssertTrue(initialSearchField.exists, "Search field should exist")
666: 
667:         // Look for replace toggle button or expand button
668:         let expandIdentifiers = [
669:             "expandReplace",
670:             "expand-replace",
671:             "toggleReplace",
672:             "toggle-replace",
673:             "showReplace",
674:             "show-replace",
675:             "ReplaceToggle",
676:             "replaceToggle"
677:         ]
678: 
679:         var expandButton: XCUIElement?
680:         for id in expandIdentifiers {
681:             let btn = app.buttons[id]
682:             if btn.waitForExistence(timeout: 2) {
683:                 expandButton = btn
684:                 break
685:             }
686:         }
687: 
688:         // Also check for chevron/disclosure indicators
689:         if expandButton == nil {
690:             let chevronButton = app.buttons.element(matching: NSPredicate(format: "label CONTAINS[c] %@ OR accessibilityLabel CONTAINS[c] %@", "replace", "Replace"))
691:             if chevronButton.waitForExistence(timeout: 2) {
692:                 expandButton = chevronButton
693:             }
694:         }
695: 
696:         // If we have an expand button, test toggling
697:         if let toggleBtn = expandButton {
698:             // Tap to expand replace UI
699:             toggleBtn.tap()
700:             sleep(1)
701: 
702:             // Verify replace field appears
703:             var replaceField: XCUIElement?
704:             for id in ["replaceInput", "replace-field", "ReplaceField", "replaceTextField"] {
705:                 let tf = app.textFields[id]
706:                 if tf.waitForExistence(timeout: 2) {
707:                     replaceField = tf
708:                     break
709:                 }
710:             }
711: 
712:             XCTAssertNotNil(replaceField, "Replace field should appear after expanding replace section")
713:             
714:             if let rf = replaceField {
715:                 XCTAssertTrue(rf.exists, "Replace field should be visible after toggle")
716:                 
717:                 // Tap toggle again to collapse
718:                 toggleBtn.tap()
719:                 sleep(1)
720:                 
721:                 // Verify replace field is no longer easily accessible or visible
722:                 // Note: It may still exist in hierarchy but should not be the focused/main element
723:                 let stillVisible = rf.isHittable && rf.frame != .zero
724:                 XCTAssertFalse(stillVisible, "Replace field should be hidden or collapsed after toggling off")
725:             }
726:         } else {
727:             // If no toggle button, find/replace might be always visible together
728:             // Just verify both search and replace fields exist
729:             let searchExists = initialSearchField.exists
730:             
731:             var replaceExists = false
732:             for id in ["replaceInput", "replace-field", "Replace", "replaceTextField"] {
733:                 let el = app.textFields[id]
734:                 if el.waitForExistence(timeout: 2) {
735:                     replaceExists = true
736:                     break
737:                 }
738:             }
739:             
740:             // In unified find/replace, both should exist
741:             XCTAssertTrue(searchExists, "Search field should exist in find/replace UI")
742:         }
743:     }
744: }
745: 

---

[read_file]
File: VSCodeiPadOS/VSCodeiPadOS/UITests/FileSelectionUITests.swift (lines 1-230 of 230)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1: import XCTest
2: 
3: // MARK: - File Selection UI Tests
4: /// Tests file selection behavior in the file tree and editor integration
5: /// Verifies that clicking files opens them in the editor and creates tabs
6: class FileSelectionUITests: XCTestCase {
7:     
8:     var app: XCUIApplication!
9:     
10:     // MARK: - Setup & Teardown
11:     
12:     override func setUpWithError() throws {
13:         continueAfterFailure = false
14:         app = XCUIApplication()
15:         app.launch()
16:         
17:         // Wait for app to fully load
18:         XCTAssertTrue(app.wait(for: .runningForeground, timeout: 5))
19:     }
20:     
21:     override func tearDownWithError() throws {
22:         app = nil
23:     }
24:     
25:     // MARK: - Test Helpers
26:     
27:     /// Finds the file tree view in the sidebar
28:     private var fileTreeView: XCUIElement {
29:         // File tree is in a scroll view with file rows
30:         return app.scrollViews.firstMatch
31:     }
32:     
33:     /// Finds a file row by name in the file tree
34:     /// - Parameter name: The display name of the file
35:     /// - Returns: The file row element
36:     private func fileRow(named name: String) -> XCUIElement {
37:         // File rows contain text with the file name and a doc icon
38:         return app.staticTexts[name].firstMatch
39:     }
40:     
41:     /// Finds the editor area
42:     private var editorArea: XCUIElement {
43:         return app.otherElements["EditorArea"].firstMatch
44:     }
45:     
46:     /// Finds the tab bar
47:     private var tabBar: XCUIElement {
48:         return app.otherElements["TabBar"].firstMatch
49:     }
50:     
51:     /// Finds a tab by file name
52:     /// - Parameter name: The file name shown in the tab
53:     /// - Returns: The tab element
54:     private func tab(named name: String) -> XCUIElement {
55:         return app.buttons[name].firstMatch
56:     }
57:     
58:     /// Expands a directory in the file tree to show its children
59:     /// - Parameter directoryName: The name of the directory to expand
60:     private func expandDirectory(named directoryName: String) {
61:         let directoryRow = app.buttons.matching(identifier: "Expand\(directoryName)").firstMatch
62:         if directoryRow.exists && directoryRow.isHittable {
63:             directoryRow.tap()
64:         }
65:     }
66:     
67:     // MARK: - Tests
68:     
69:     /// Tests that clicking a file in the file tree opens it in the editor
70:     /// Reference: FileTreeView.swift line 86-93 - onTapGesture calls editorCore.openFile(from:)
71:     func testFileClickOpensEditor() throws {
72:         // Given: App is launched with file tree visible
73:         let fileTree = fileTreeView
74:         XCTAssertTrue(fileTree.waitForExistence(timeout: 3), "File tree should be visible")
75:         
76:         // When: User taps on a file (not directory) in the tree
77:         // Look for a file with a doc icon (not folder)
78:         let fileElement = app.images["doc"].firstMatch
79:         XCTAssertTrue(fileElement.waitForExistence(timeout: 2), "A file should exist in the tree")
80:         
81:         // Get the parent row containing the file icon
82:         let fileRow = fileElement.parentElement()
83:         XCTAssertTrue(fileRow.exists, "File row should exist")
84:         
85:         // Tap on the file row
86:         fileRow.tap()
87:         
88:         // Then: Editor area should become active with content
89:         let editor = editorArea
90:         XCTAssertTrue(editor.waitForExistence(timeout: 2), "Editor area should appear after file selection")
91:         
92:         // Verify editor shows content placeholder or actual content
93:         let editorContent = app.textViews.firstMatch
94:         XCTAssertTrue(editorContent.exists || app.otherElements["EditorContent"].exists, 
95:                       "Editor should show content area")
96:     }
97:     
98:     /// Tests that clicking a file creates a new tab in the tab bar
99:     /// Reference: EditorCore.openFile(from:) should create a new tab
100:     func testFileCreatesTab() throws {
101:         // Given: Initial state with no tabs or single welcome tab
102:         let initialTabCount = app.buttons.count
103:         
104:         // When: User clicks on a file in the tree
105:         let fileTree = fileTreeView
106:         XCTAssertTrue(fileTree.waitForExistence(timeout: 3))
107:         
108:         // Find and tap a file
109:         let fileIcon = app.images["doc"].firstMatch
110:         XCTAssertTrue(fileIcon.waitForExistence(timeout: 2))
111:         
112:         let fileRow = fileIcon.parentElement()
113:         fileRow.tap()
114:         
115:         // Then: A new tab should be created
116:         let tabBar = self.tabBar
117:         XCTAssertTrue(tabBar.waitForExistence(timeout: 2), "Tab bar should exist")
118:         
119:         // Verify at least one tab exists with file content
120:         let tabs = app.buttons.allElementsBoundByIndex.filter { button in
121:             // Tabs typically have close buttons or specific identifiers
122:             button.identifier.contains("Tab") || 
123:             button.label.contains(".") // File extension indicator
124:         }
125:         
126:         XCTAssertGreaterThan(tabs.count, 0, "At least one tab should exist after opening a file")
127:         
128:         // Verify the tab shows file name
129:         let hasFileTab = app.buttons.allElementsBoundByIndex.contains { button in
130:             // Check if any button represents an open file
131:             let label = button.label.lowercased()
132:             return label.hasSuffix(".swift") || 
133:                    label.hasSuffix(".js") || 
134:                    label.hasSuffix(".ts") ||
135:                    label.hasSuffix(".json") ||
136:                    label.hasSuffix(".md")
137:         }
138:         XCTAssertTrue(hasFileTab, "A tab with a file name should exist")
139:     }
140:     
141:     /// Tests selecting multiple files creates multiple tabs
142:     /// Verifies that each file click opens a separate tab
143:     func testMultipleFileSelection() throws {
144:         // Given: File tree with multiple files
145:         let fileTree = fileTreeView
146:         XCTAssertTrue(fileTree.waitForExistence(timeout: 3))
147:         
148:         // Find all file icons (doc images) in the tree
149:         let fileIcons = app.images.matching(identifier: "doc")
150:         XCTAssertGreaterThanOrEqual(fileIcons.count, 2, "Should have at least 2 files to test")
151:         
152:         // When: Click first file
153:         let firstFile = fileIcons.element(boundBy: 0)
154:         XCTAssertTrue(firstFile.exists)
155:         let firstRow = firstFile.parentElement()
156:         firstRow.tap()
157:         
158:         // Wait for first tab to appear
159:         sleep(1)
160:         
161:         // Then: First tab should exist
162:         let tabCountAfterFirst = countFileTabs()
163:         XCTAssertGreaterThanOrEqual(tabCountAfterFirst, 1, "Should have at least 1 tab after first click")
164:         
165:         // When: Click second file
166:         let secondFile = fileIcons.element(boundBy: 1)
167:         XCTAssertTrue(secondFile.exists)
168:         let secondRow = secondFile.parentElement()
169:         secondRow.tap()
170:         
171:         // Wait for second tab
172:         sleep(1)
173:         
174:         // Then: Should have 2 tabs now
175:         let tabCountAfterSecond = countFileTabs()
176:         XCTAssertEqual(tabCountAfterSecond, 2, "Should have 2 tabs after opening 2 files")
177:         
178:         // Verify both tabs are still accessible
179:         let tabs = getAllFileTabs()
180:         XCTAssertEqual(tabs.count, 2, "Should be able to access both tabs")
181:         
182:         // Verify switching between tabs works
183:         if tabs.count >= 2 {
184:             tabs[0].tap()
185:             sleep(0.5)
186:             tabs[1].tap()
187:             sleep(0.5)
188:             // If we can tap both without crash, switching works
189:         }
190:     }
191:     
192:     // MARK: - Private Helpers
193:     
194:     /// Counts the number of file tabs currently open
195:     private func countFileTabs() -> Int {
196:         // Tabs are buttons with file-like identifiers or containing file extensions
197:         let tabBar = self.tabBar
198:         guard tabBar.exists else { return 0 }
199:         
200:         // Count buttons that look like tabs (have file extension patterns)
201:         return app.buttons.allElementsBoundByIndex.filter { button in
202:             let label = button.label.lowercased()
203:             return label.contains(".") && !label.isEmpty
204:         }.count
205:     }
206:     
207:     /// Gets all file tab elements
208:     private func getAllFileTabs() -> [XCUIElement] {
209:         return app.buttons.allElementsBoundByIndex.filter { button in
210:             let label = button.label.lowercased()
211:             return label.contains(".") && !label.isEmpty
212:         }
213:     }
214: }
215: 
216: // MARK: - XCUIElement Extensions
217: 
218: extension XCUIElement {
219:     /// Returns the parent element of this element
220:     func parentElement() -> XCUIElement {
221:         // Navigate up to parent using query
222:         return self.parents(matching: .any).firstMatch
223:     }
224:     
225:     /// Checks if element has a specific descendant
226:     func hasDescendant(matching type: XCUIElement.ElementType, identifier: String) -> Bool {
227:         return self.descendants(matching: type).matching(identifier: identifier).firstMatch.exists
228:     }
229: }
230: 


>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/UITests/GoToLineUITests.swift"}
>>>END
>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/UITests/QuickOpenUITests.swift"}
>>>END
>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/UITests/SidebarToggleUITests.swift"}
>>>END

---

## ðŸ”§ TOOL RESULTS

[read_file]
File: VSCodeiPadOS/VSCodeiPadOS/UITests/GoToLineUITests.swift (lines 1-295 of 295)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1: import XCTest
2: 
3: /// UI Tests for the "Go To Line" feature (Ctrl+G / Cmd+G)
4: /// Tests the dialog opening, line number input, validation, and dismissal
5: class GoToLineUITests: XCTestCase {
6:     
7:     var app: XCUIApplication!
8:     
9:     override func setUpWithError() throws {
10:         continueAfterFailure = false
11:         app = XCUIApplication()
12:         app.launch()
13:     }
14:     
15:     override func tearDownWithError() throws {
16:         app = nil
17:     }
18:     
19:     // MARK: - Test: Open with Keyboard Shortcut
20:     
21:     /// Tests that Ctrl+G (or Cmd+G) opens the Go To Line dialog
22:     func testOpenWithKeyboard() throws {
23:         // Ensure we have an active editor tab by creating a new file
24:         createNewFileIfNeeded()
25:         
26:         // Verify the dialog is not initially visible
27:         XCTAssertFalse(goToLineDialogExists(), "Go to line dialog should not be visible initially")
28:         
29:         // Send Ctrl+G keyboard shortcut to open the dialog
30:         // On iPad with external keyboard, Ctrl+G triggers the dialog
31:         let keyboard = app.keyboards.element(boundBy: 0)
32:         if keyboard.exists {
33:             keyboard.typeKey("g", modifierFlags: .control)
34:         } else {
35:             // Fallback: Try using key command simulation
36:             app.keyboards.keys["ctrl"].press(forDuration: 0.1, thenDragTo: app.keyboards.keys["g"])
37:         }
38:         
39:         // Alternative: Use the Command Palette to trigger Go to Line
40:         // This is more reliable in UI tests
41:         openGoToLineViaCommandPalette()
42:         
43:         // Verify the dialog appears
44:         XCTAssertTrue(goToLineDialogExists(), "Go to line dialog should appear after Ctrl+G shortcut")
45:     }
46:     
47:     // MARK: - Test: Enter Line Number and Navigate
48:     
49:     /// Tests that entering a valid line number navigates to that line
50:     func testEnterLineNumber() throws {
51:         // Create a file with multiple lines to test navigation
52:         createNewFileIfNeeded()
53:         
54:         // Open the Go To Line dialog
55:         openGoToLineViaCommandPalette()
56:         
57:         // Verify dialog is open
58:         XCTAssertTrue(goToLineDialogExists(), "Go to line dialog should be open")
59:         
60:         // Find the line number input field
61:         let inputField = app.textFields.element(matching: .any, identifier: "GoToLineInput")
62:         
63:         // If not found by identifier, try finding by placeholder or position
64:         let textField = inputField.exists ? inputField : app.textFields.firstMatch
65:         
66:         XCTAssertTrue(textField.waitForExistence(timeout: 2), "Line number input field should exist")
67:         
68:         // Enter a line number (e.g., line 10)
69:         textField.tap()
70:         textField.clearAndEnterText("10")
71:         
72:         // Submit the input (press Return/Enter)
73:         app.buttons["Go"].firstMatch.tapIfExists()
74:         
75:         // Alternative: Press keyboard return
76:         // app.keyboards.buttons["return"].tap()
77:         
78:         // Verify the dialog closes after successful navigation
79:         XCTAssertFalse(goToLineDialogExists(timeout: 2), "Go to line dialog should close after entering valid line number")
80:     }
81:     
82:     // MARK: - Test: Invalid Line Number Handling
83:     
84:     /// Tests that entering an invalid line number shows appropriate feedback
85:     func testInvalidLineNumber() throws {
86:         // Create a file to have context
87:         createNewFileIfNeeded()
88:         
89:         // Open the Go To Line dialog
90:         openGoToLineViaCommandPalette()
91:         
92:         // Find the input field
93:         let textField = app.textFields.firstMatch
94:         XCTAssertTrue(textField.waitForExistence(timeout: 2), "Line number input field should exist")
95:         
96:         // Test with invalid input: negative number
97:         textField.tap()
98:         textField.clearAndEnterText("-5")
99:         app.buttons["Go"].firstMatch.tapIfExists()
100:         
101:         // Dialog should still be open (invalid input shouldn't dismiss it)
102:         XCTAssertTrue(goToLineDialogExists(), "Dialog should remain open for invalid input")
103:         
104:         // Clear and test with zero
105:         textField.tap()
106:         textField.clearAndEnterText("0")
107:         app.buttons["Go"].firstMatch.tapIfExists()
108:         
109:         // Dialog should still be open
110:         XCTAssertTrue(goToLineDialogExists(), "Dialog should remain open for line 0 (invalid)")
111:         
112:         // Test with non-numeric input
113:         textField.tap()
114:         textField.clearAndEnterText("abc")
115:         
116:         // Verify the field either rejects non-numeric input or handles it gracefully
117:         // The text should either be empty or only contain the numeric portion
118:         let textValue = textField.value as? String ?? ""
119:         XCTAssertTrue(textValue.isEmpty || Int(textValue) != nil, "Input should not contain non-numeric characters or should be empty")
120:     }
121:     
122:     // MARK: - Test: Close on Escape
123:     
124:     /// Tests that pressing Escape (or tapping outside) closes the dialog
125:     func testCloseOnEscape() throws {
126:         // Create a file
127:         createNewFileIfNeeded()
128:         
129:         // Open the Go To Line dialog
130:         openGoToLineViaCommandPalette()
131:         
132:         // Verify dialog is open
133:         XCTAssertTrue(goToLineDialogExists(), "Go to line dialog should be open")
134:         
135:         // Test 1: Tap on the semi-transparent overlay outside the dialog
136:         // Based on ContentView.swift line 82, there's a black opacity overlay
137:         let overlay = app.otherElements.matching(identifier: "GoToLineOverlay").firstMatch
138:         if overlay.exists {
139:             overlay.tap()
140:         } else {
141:             // Tap on a dark area that represents the overlay
142:             // The overlay covers the full screen, so tap outside the dialog center
143:             let screenWidth = app.windows.firstMatch.frame.width
144:             let screenHeight = app.windows.firstMatch.frame.height
145:             app.tap(at: CGPoint(x: screenWidth * 0.1, y: screenHeight * 0.1))
146:         }
147:         
148:         // Verify the dialog closes
149:         XCTAssertFalse(goToLineDialogExists(timeout: 2), "Go to line dialog should close when tapping outside")
150:         
151:         // Test 2: Reopen and test Escape key
152:         openGoToLineViaCommandPalette()
153:         XCTAssertTrue(goToLineDialogExists(), "Go to line dialog should be open again")
154:         
155:         // Send Escape key
156:         if app.keyboards.buttons["Escape"].exists {
157:             app.keyboards.buttons["Escape"].tap()
158:         } else {
159:             // Simulate escape key
160:             app.keyboards.buttons["return"].press(forDuration: 0.1, thenDragTo: app.keyboards.buttons["delete"])
161:         }
162:         
163:         // Verify the dialog closes
164:         XCTAssertFalse(goToLineDialogExists(timeout: 2), "Go to line dialog should close on Escape key")
165:     }
166:     
167:     // MARK: - Helper Methods
168:     
169:     /// Checks if the Go To Line dialog exists
170:     private func goToLineDialogExists(timeout: TimeInterval = 1) -> Bool {
171:         // The GoToLineView is identified by its visual elements
172:         // Based on typical SwiftUI modal patterns from ContentView.swift
173:         
174:         // Look for the dialog container
175:         let dialog = app.otherElements.matching(identifier: "GoToLineDialog").firstMatch
176:         if dialog.waitForExistence(timeout: timeout) {
177:             return true
178:         }
179:         
180:         // Fallback: Look for key UI elements of the Go To Line dialog
181:         let inputField = app.textFields.matching(identifier: "GoToLineInput").firstMatch
182:         if inputField.waitForExistence(timeout: timeout) {
183:             return true
184:         }
185:         
186:         // Another fallback: Look for text containing "Go to Line"
187:         let label = app.staticTexts.containing(NSPredicate(format: "label CONTAINS[c] 'Go to Line'")).element(boundBy: 0)
188:         if label.waitForExistence(timeout: timeout) {
189:             return true
190:         }
191:         
192:         return false
193:     }
194:     
195:     /// Opens the Go To Line dialog via Command Palette (reliable method)
196:     private func openGoToLineViaCommandPalette() {
197:         // Based on ContentView.swift line 738: Command Palette has "Go to Line" option
198:         // Cmd+Shift+P opens Command Palette
199:         app.keyboards.keys["command"].press(forDuration: 0.1, thenDragTo: app.keyboards.keys["shift"])
200:         app.keyboards.keys["p"].tap()
201:         
202:         // Wait for Command Palette to appear
203:         let commandPalette = app.otherElements.matching(identifier: "CommandPalette").firstMatch
204:         if commandPalette.waitForExistence(timeout: 2) {
205:             // Search for "Go to Line"
206:             let searchField = app.searchFields.firstMatch
207:             if searchField.exists {
208:                 searchField.tap()
209:                 searchField.typeText("Go to Line")
210:             }
211:             
212:             // Tap on the "Go to Line" row
213:             let goToLineRow = app.buttons.containing(NSPredicate(format: "label CONTAINS[c] 'Go to Line'")).element(boundBy: 0)
214:             if goToLineRow.waitForExistence(timeout: 1) {
215:                 goToLineRow.tap()
216:             }
217:         }
218:     }
219:     
220:     /// Creates a new file if no tab is currently active
221:     private func createNewFileIfNeeded() {
222:         // Check if we have an active tab by looking for editor elements
223:         let editorExists = app.textViews.matching(identifier: "EditorTextView").firstMatch.exists
224:         let noEditorMessage = app.staticTexts.containing(NSPredicate(format: "label CONTAINS[c] 'Welcome'")).element(boundBy: 0).exists
225:         
226:         if !editorExists || noEditorMessage {
227:             // Tap New File button or use Cmd+N
228:             let newFileButton = app.buttons["New File"].firstMatch
229:             if newFileButton.exists {
230:                 newFileButton.tap()
231:             } else {
232:                 // Use keyboard shortcut Cmd+N
233:                 app.keyboards.keys["command"].press(forDuration: 0.1, thenDragTo: app.keyboards.keys["n"])
234:             }
235:             
236:             // Wait for editor to appear
237:             let textView = app.textViews.firstMatch
238:             XCTAssertTrue(textView.waitForExistence(timeout: 2), "Editor should appear after creating new file")
239:             
240:             // Add some content with multiple lines for testing
241:             let content = """
242:                 Line 1: First line
243:                 Line 2: Second line
244:                 Line 3: Third line
245:                 Line 4: Fourth line
246:                 Line 5: Fifth line
247:                 Line 6: Sixth line
248:                 Line 7: Seventh line
249:                 Line 8: Eighth line
250:                 Line 9: Ninth line
251:                 Line 10: Tenth line
252:                 Line 11: Eleventh line
253:                 Line 12: Twelfth line
254:                 Line 13: Thirteenth line
255:                 Line 14: Fourteenth line
256:                 Line 15: Fifteenth line
257:                 """
258:             textView.tap()
259:             textView.typeText(content)
260:         }
261:     }
262: }
263: 
264: // MARK: - XCTestCase Extensions
265: 
266: extension XCTestCase {
267:     /// Taps an element if it exists, otherwise does nothing
268:     func tapIfExists(_ element: XCUIElement) {
269:         if element.exists {
270:             element.tap()
271:         }
272:     }
273: }
274: 
275: extension XCUIElement {
276:     /// Taps the element if it exists
277:     func tapIfExists() {
278:         if self.exists {
279:             self.tap()
280:         }
281:     }
282:     
283:     /// Clears the text field and enters new text
284:     func clearAndEnterText(_ text: String) {
285:         // Clear existing text
286:         if let currentValue = self.value as? String, !currentValue.isEmpty {
287:             self.doubleTap()
288:             self.typeText(String(repeating: XCUIKeyboardKey.delete.rawValue, count: currentValue.count))
289:         }
290:         
291:         // Enter new text
292:         self.typeText(text)
293:     }
294: }
295: 

---

[read_file]
File: VSCodeiPadOS/VSCodeiPadOS/UITests/QuickOpenUITests.swift (lines 1-98 of 98)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1: import XCTest
2: 
3: final class QuickOpenUITests: XCTestCase {
4:     private var app: XCUIApplication!
5: 
6:     override func setUp() {
7:         super.setUp()
8:         continueAfterFailure = false
9: 
10:         app = XCUIApplication()
11:         // Enables deterministic Quick Open content via ProcessInfo argument handling in QuickOpenView.
12:         app.launchArguments += ["-uiTesting"]
13:         app.launch()
14:     }
15: 
16:     // MARK: - Helpers
17: 
18:     @discardableResult
19:     private func openQuickOpen() -> XCUIElement {
20:         app.typeKey("p", modifierFlags: [.command])
21:         let quickOpen = app.otherElements["QuickOpen.Root"]
22:         XCTAssertTrue(quickOpen.waitForExistence(timeout: 5), "Quick Open overlay did not appear")
23:         return quickOpen
24:     }
25: 
26:     @discardableResult
27:     private func waitForNonExistence(_ element: XCUIElement, timeout: TimeInterval) -> Bool {
28:         let predicate = NSPredicate(format: "exists == false")
29:         let exp = expectation(for: predicate, evaluatedWith: element)
30:         return XCTWaiter.wait(for: [exp], timeout: timeout) == .completed
31:     }
32: 
33:     // MARK: - Tests
34: 
35:     func testOpenWithKeyboard() {
36:         _ = openQuickOpen()
37: 
38:         let searchField = app.textFields["QuickOpen.SearchField"]
39:         XCTAssertTrue(searchField.waitForExistence(timeout: 2))
40:     }
41: 
42:     func testFileSearch() {
43:         _ = openQuickOpen()
44: 
45:         let searchField = app.textFields["QuickOpen.SearchField"]
46:         XCTAssertTrue(searchField.waitForExistence(timeout: 2))
47:         searchField.tap()
48:         searchField.typeText("UITest-B")
49: 
50:         XCTAssertTrue(app.otherElements["QuickOpen.Row.UITest-B.txt"].waitForExistence(timeout: 2))
51:         XCTAssertFalse(app.otherElements["QuickOpen.Row.UITest-A.txt"].exists)
52:     }
53: 
54:     func testKeyboardNavigation() {
55:         _ = openQuickOpen()
56: 
57:         let searchField = app.textFields["QuickOpen.SearchField"]
58:         XCTAssertTrue(searchField.waitForExistence(timeout: 2))
59:         searchField.tap()
60: 
61:         let rowA = app.otherElements["QuickOpen.Row.UITest-A.txt"]
62:         let rowB = app.otherElements["QuickOpen.Row.UITest-B.txt"]
63: 
64:         XCTAssertTrue(rowA.waitForExistence(timeout: 2))
65:         XCTAssertTrue(rowB.waitForExistence(timeout: 2))
66: 
67:         // Default selection should be first row.
68:         XCTAssertEqual(rowA.value as? String, "selected")
69:         XCTAssertEqual(rowB.value as? String, "unselected")
70: 
71:         searchField.typeKey(.downArrow, modifierFlags: [])
72: 
73:         XCTAssertEqual(rowA.value as? String, "unselected")
74:         XCTAssertEqual(rowB.value as? String, "selected")
75: 
76:         searchField.typeKey(.upArrow, modifierFlags: [])
77: 
78:         XCTAssertEqual(rowA.value as? String, "selected")
79:         XCTAssertEqual(rowB.value as? String, "unselected")
80:     }
81: 
82:     func testFileOpen() {
83:         let quickOpen = openQuickOpen()
84: 
85:         let searchField = app.textFields["QuickOpen.SearchField"]
86:         XCTAssertTrue(searchField.waitForExistence(timeout: 2))
87:         searchField.tap()
88:         searchField.typeText("UITest-B")
89: 
90:         XCTAssertTrue(app.otherElements["QuickOpen.Row.UITest-B.txt"].waitForExistence(timeout: 2))
91: 
92:         // Enter should open the selected file and dismiss Quick Open.
93:         searchField.typeKey(.return, modifierFlags: [])
94: 
95:         XCTAssertTrue(waitForNonExistence(quickOpen, timeout: 5), "Quick Open did not dismiss after pressing Enter")
96:     }
97: }
98: 

---

[read_file]
File: VSCodeiPadOS/VSCodeiPadOS/UITests/SidebarToggleUITests.swift (lines 1-118 of 118)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1: import XCTest
2: 
3: final class SidebarToggleUITests: XCTestCase {
4:     private var app: XCUIApplication!
5: 
6:     override func setUpWithError() throws {
7:         continueAfterFailure = false
8:         app = XCUIApplication()
9:         app.launch()
10: 
11:         // Ensure the app has focus so Cmd+B is delivered.
12:         app.tap()
13:     }
14: 
15:     // MARK: - Elements
16: 
17:     private var sidebarPanel: XCUIElement {
18:         app.otherElements["sidebar.panel"]
19:     }
20: 
21:     private var explorerActivityBarButton: XCUIElement {
22:         app.buttons["activityBar.explorer"]
23:     }
24: 
25:     // MARK: - Helpers
26: 
27:     private func waitForSidebar(exists: Bool, timeout: TimeInterval = 5) {
28:         let predicate = NSPredicate(format: "exists == %@", NSNumber(value: exists))
29:         expectation(for: predicate, evaluatedWith: sidebarPanel)
30:         waitForExpectations(timeout: timeout)
31:     }
32: 
33:     private func ensureSidebarVisible(timeout: TimeInterval = 5) {
34:         if sidebarPanel.exists { return }
35: 
36:         XCTAssertTrue(explorerActivityBarButton.waitForExistence(timeout: timeout), "Explorer activity bar button must exist")
37:         explorerActivityBarButton.tap()
38:         waitForSidebar(exists: true, timeout: timeout)
39:     }
40: 
41:     private func toggleSidebarWithKeyboard() {
42:         // Cmd+B
43:         app.typeKey("b", modifierFlags: .command)
44:     }
45: 
46:     private func currentSidebarWidthOrZero() -> CGFloat {
47:         sidebarPanel.exists ? sidebarPanel.frame.size.width : 0
48:     }
49: 
50:     // MARK: - Tests
51: 
52:     func testToggleSidebarWithKeyboard() throws {
53:         ensureSidebarVisible()
54: 
55:         let visibleWidth = currentSidebarWidthOrZero()
56:         XCTAssertGreaterThan(visibleWidth, 1, "Expected sidebar to be visible with non-zero width")
57: 
58:         toggleSidebarWithKeyboard()
59:         waitForSidebar(exists: false)
60: 
61:         let hiddenWidth = currentSidebarWidthOrZero()
62:         XCTAssertEqual(hiddenWidth, 0, "Expected sidebar width to be 0 when hidden")
63:         XCTAssertNotEqual(hiddenWidth, visibleWidth, "Expected sidebar width to change after toggle")
64: 
65:         toggleSidebarWithKeyboard()
66:         waitForSidebar(exists: true)
67: 
68:         let restoredWidth = currentSidebarWidthOrZero()
69:         XCTAssertGreaterThan(restoredWidth, 1, "Expected sidebar to be visible after toggling back on")
70:     }
71: 
72:     func testToggleSidebarWithButton() throws {
73:         ensureSidebarVisible()
74: 
75:         let visibleWidth = currentSidebarWidthOrZero()
76:         XCTAssertGreaterThan(visibleWidth, 1)
77: 
78:         XCTAssertTrue(explorerActivityBarButton.waitForExistence(timeout: 5), "Explorer activity bar button must exist")
79: 
80:         // If Explorer is already selected, one tap hides.
81:         // If not selected, first tap selects Explorer (sidebar remains visible), second tap hides.
82:         explorerActivityBarButton.tap()
83:         if sidebarPanel.exists {
84:             explorerActivityBarButton.tap()
85:         }
86:         waitForSidebar(exists: false)
87: 
88:         let hiddenWidth = currentSidebarWidthOrZero()
89:         XCTAssertEqual(hiddenWidth, 0)
90: 
91:         // Show again.
92:         explorerActivityBarButton.tap()
93:         waitForSidebar(exists: true)
94: 
95:         let restoredWidth = currentSidebarWidthOrZero()
96:         XCTAssertGreaterThan(restoredWidth, 1)
97:     }
98: 
99:     func testSidebarVisibilityState() throws {
100:         ensureSidebarVisible()
101: 
102:         let initialWidth = currentSidebarWidthOrZero()
103:         XCTAssertGreaterThan(initialWidth, 1)
104: 
105:         toggleSidebarWithKeyboard()
106:         waitForSidebar(exists: false)
107: 
108:         toggleSidebarWithKeyboard()
109:         waitForSidebar(exists: true)
110: 
111:         let restoredWidth = currentSidebarWidthOrZero()
112:         XCTAssertGreaterThan(restoredWidth, 1)
113: 
114:         // editorCore.sidebarWidth should be preserved across show/hide.
115:         XCTAssertEqual(restoredWidth, initialWidth, accuracy: 2.0)
116:     }
117: }
118: 


>>>REPORT
## 1) Files in `VSCodeiPadOS/VSCodeiPadOS/UITests/`
(from `list_dir` tool result)
- ActivityBarUITests.swift
- BreadcrumbsUITests.swift
- CommandPaletteUITests.swift
- CommandSearchUITests.swift
- FileSelectionUITests.swift
- GoToLineUITests.swift
- QuickOpenUITests.swift
- SidebarToggleUITests.swift

## 2) Files in `VSCodeiPadOS/VSCodeiPadOS/Tests/`
(from `list_dir` tool result)
- (empty directory)

## Total test coverage we have (by test count present in repo)
Only UI tests exist (no unit tests in `Tests/`).

### UI test methods (XCTest `func test...`)
- `UITests/ActivityBarUITests.swift`: 7 tests (lines 60, 64, 68, 72, 76, 80, 84)
- `UITests/BreadcrumbsUITests.swift`: 3 tests (lines 68, 80, 100)
- `UITests/CommandPaletteUITests.swift`: 4 tests (lines 28, 50, 86, 112)
- `UITests/CommandSearchUITests.swift`: 13 tests (lines 153, 169, 187, 212, 231, 247, 269, 292, 357, 399, 460, 517, 653)
- `UITests/FileSelectionUITests.swift`: 3 tests (lines 71, 100, 143)
- `UITests/GoToLineUITests.swift`: 4 tests (lines 22, 50, 85, 125)
- `UITests/QuickOpenUITests.swift`: 4 tests (lines 35, 42, 54, 82)
- `UITests/SidebarToggleUITests.swift`: 3 tests (lines 52, 72, 99)

**Total UI tests:** 41  
**Total unit tests in `Tests/`:** 0  
**Total tests in repo (these directories):** 41
>>>END
