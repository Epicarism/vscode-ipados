# Agent: agent-git-gutter-blame
**Status:** done
**Tokens:** 60,109
**Cost:** $0.0000
**Time:** 2026-02-09T10:55:38.191Z

## Task
Implement FEAT-071 gutter indicators (added/modified/deleted) and FEAT-072 inline blame UI/logic. Create Views/Editor/GitGutterView.swift. Use existing git diff/blame services if present; otherwise add minimal git command wrappers. Ensure integrated with editor view.

## Response
>>>TOOL list_dir
{"path":""}
>>>END>>>TOOL list_dir
{"path":"Views"}
>>>END>>>TOOL list_dir
{"path":"Views/Editor"}
>>>END>>>TOOL search
{"query":"GitGutterView", "glob":"**/*"}
>>>END>>>TOOL search
{"query":"blame", "glob":"**/*.swift"}
>>>END>>>TOOL search
{"query":"diff", "glob":"**/*.swift"}
>>>END>>>TOOL search
{"query":"git", "glob":"**/*.swift"}
>>>END>>>TOOL read_file
{"path":"Views/Editor","start_line":1,"end_line":200}
>>>END


>>>TOOL list_dir
{"path":"Views"}
>>>END>>>TOOL search
{"query":"EditorView", "glob":"**/*.swift"}
>>>END>>>TOOL search
{"query":"CodeEditor", "glob":"**/*.swift"}
>>>END>>>TOOL search
{"query":"TextEditor", "glob":"**/*.swift"}
>>>END>>>TOOL search
{"query":"Source", "glob":"Views/**/*.swift"}
>>>END>>>TOOL list_dir
{"path":"Views/Editor"}
>>>END>>>TOOL search
{"query":"gutter", "glob":"**/*.swift"}
>>>END>>>TOOL search
{"query":"blame", "glob":"**/*"}
>>>END


>>>TOOL create_file
{"path":"Views/Editor/GitGutterView.swift","content":"import Foundation\nimport SwiftUI\n\n// MARK: - FEAT-071 Git gutter indicators (added/modified/deleted)\n// MARK: - FEAT-072 Inline blame UI/logic\n//\n// This file is intentionally self-contained:\n// - Provides minimal git command wrappers using Process (no external services required).\n// - Parses `git diff --unified=0` for per-line change markers.\n// - Parses `git blame --line-porcelain` for inline blame.\n//\n// Integration expectation:\n// Place GitGutterView to the left of your code editor and keep `text`, `fileURL`,\n// and (optionally) `visibleLineRange` updated as the editor scrolls.\n\n// MARK: - Public Types\n\npublic enum GitGutterChangeKind: Sendable, Equatable {\n    case added\n    case modified\n    case deleted\n}\n\npublic struct GitBlameLine: Sendable, Equatable {\n    public let sha: String\n    public let author: String\n    public let summary: String\n    public let authorTime: TimeInterval?\n\n    public init(sha: String, author: String, summary: String, authorTime: TimeInterval?) {\n        self.sha = sha\n        self.author = author\n        self.summary = summary\n        self.authorTime = authorTime\n    }\n}\n\npublic struct GitGutterLineAnnotation: Sendable, Equatable {\n    public let line: Int // 1-based line index in the *current* buffer\n    public let kind: GitGutterChangeKind\n\n    /// Deletions in a diff don’t map cleanly to a new-buffer line. We anchor them to a line number\n    /// in the new file (typically the hunk's +start), and this represents how many lines were deleted\n    /// at that anchor.\n    public let deletionCount: Int\n\n    public init(line: Int, kind: GitGutterChangeKind, deletionCount: Int = 0) {\n        self.line = line\n        self.kind = kind\n        self.deletionCount = deletionCount\n    }\n}\n\n// MARK: - GitGutterView\n\npublic struct GitGutterView: View {\n    public struct Configuration: Sendable, Equatable {\n        public var lineHeight: CGFloat\n        public var indicatorWidth: CGFloat\n        public var blameFont: Font\n        public var blameColor: Color\n        public var addedColor: Color\n        public var modifiedColor: Color\n        public var deletedColor: Color\n\n        public init(\n            lineHeight: CGFloat = 18,\n            indicatorWidth: CGFloat = 4,\n            blameFont: Font = .system(size: 11, weight: .regular, design: .monospaced),\n            blameColor: Color = .secondary,\n            addedColor: Color = .green,\n            modifiedColor: Color = .orange,\n            deletedColor: Color = .red\n        ) {\n            self.lineHeight = lineHeight\n            self.indicatorWidth = indicatorWidth\n            self.blameFont = blameFont\n            self.blameColor = blameColor\n            self.addedColor = addedColor\n            self.modifiedColor = modifiedColor\n            self.deletedColor = deletedColor\n        }\n    }\n\n    private let workspaceURL: URL\n    private let fileURL: URL\n\n    /// Current buffer text. Used to compute line count and to allow the gutter to size itself.\n    private let text: String\n\n    /// Provide a visible line range (1-based, inclusive) when possible to keep rendering light.\n    /// If nil, the view renders all lines.\n    private let visibleLineRange: ClosedRange<Int>?\n\n    private let showsBlame: Bool\n    private let configuration: Configuration\n\n    @StateObject private var model = GitGutterViewModel()\n\n    public init(\n        workspaceURL: URL,\n        fileURL: URL,\n        text: String,\n        visibleLineRange: ClosedRange<Int>? = nil,\n        showsBlame: Bool,\n        configuration: Configuration = .init()\n    ) {\n        self.workspaceURL = workspaceURL\n        self.fileURL = fileURL\n        self.text = text\n        self.visibleLineRange = visibleLineRange\n        self.showsBlame = showsBlame\n        self.configuration = configuration\n    }\n\n    public var body: some View {\n        let lineCount = text._vsc_numberOfLines\n        let range = visibleLineRange ?? (lineCount > 0 ? 1...lineCount : 1...1)\n\n        // Keep width stable when blame toggles to avoid layout jitter in parent.\n        let blameColumnMinWidth: CGFloat = showsBlame ? 160 : 0\n\n        ScrollViewReader { _ in\n            LazyVStack(alignment: .leading, spacing: 0) {\n                ForEach(Array(range), id: \\.self) { line in\n                    GitGutterLineRow(\n                        line: line,\n                        annotation: model.diffAnnotations[line],\n                        blame: showsBlame ? model.blameLines[line] : nil,\n                        showsBlame: showsBlame,\n                        configuration: configuration\n                    )\n                    .frame(height: configuration.lineHeight)\n                }\n            }\n            .frame(maxWidth: .infinity, alignment: .leading)\n            .background(Color.clear)\n            .onAppear {\n                model.setContext(workspaceURL: workspaceURL, fileURL: fileURL)\n                model.refresh(textLineCount: lineCount, wantBlame: showsBlame)\n            }\n            .onChange(of: fileURL) { _, newValue in\n                model.setContext(workspaceURL: workspaceURL, fileURL: newValue)\n                model.refresh(textLineCount: lineCount, wantBlame: showsBlame)\n            }\n            .onChange(of: text) { _, _ in\n                // Diff is against working tree file contents; this gutter is for repo state.\n                // Still refresh as line count might change and to keep anchors sane.\n                model.refresh(textLineCount: lineCount, wantBlame: showsBlame)\n            }\n            .onChange(of: showsBlame) { _, newValue in\n                model.refresh(textLineCount: lineCount, wantBlame: newValue)\n            }\n            .frame(minWidth: configuration.indicatorWidth + 10 + blameColumnMinWidth, alignment: .leading)\n        }\n        .accessibilityLabel(\"Git gutter\")\n    }\n}\n\nprivate struct GitGutterLineRow: View {\n    let line: Int\n    let annotation: GitGutterLineAnnotation?\n    let blame: GitBlameLine?\n    let showsBlame: Bool\n    let configuration: GitGutterView.Configuration\n\n    var body: some View {\n        HStack(spacing: 8) {\n            indicator\n                .frame(width: configuration.indicatorWidth, height: configuration.lineHeight)\n\n            if showsBlame {\n                blameText\n                    .lineLimit(1)\n                    .truncationMode(.tail)\n                    .frame(maxWidth: .infinity, alignment: .leading)\n            } else {\n                Spacer(minLength: 0)\n            }\n        }\n        .padding(.leading, 6)\n        .padding(.trailing, 6)\n        .contentShape(Rectangle())\n        .accessibilityElement(children: .combine)\n        .accessibilityLabel(accessibilityLabel)\n    }\n\n    private var indicator: some View {\n        ZStack(alignment: .leading) {\n            if let annotation {\n                switch annotation.kind {\n                case .added:\n                    Rectangle().fill(configuration.addedColor.opacity(0.95))\n                case .modified:\n                    Rectangle().fill(configuration.modifiedColor.opacity(0.95))\n                case .deleted:\n                    DeletedIndicator(color: configuration.deletedColor.opacity(0.95), deletionCount: annotation.deletionCount)\n                }\n            } else {\n                Rectangle().fill(Color.clear)\n            }\n        }\n    }\n\n    @ViewBuilder\n    private var blameText: some View {\n        if let blame {\n            // Keep it compact. Typical inline blame: \"author • summary\".\n            Text(\"\\(blame.author) • \\(blame.summary)\")\n                .font(configuration.blameFont)\n                .foregroundStyle(configuration.blameColor)\n        } else {\n            // Maintain row height without drawing.\n            Text(\"\")\n                .font(configuration.blameFont)\n                .foregroundStyle(configuration.blameColor)\n        }\n    }\n\n    private var accessibilityLabel: String {\n        var parts: [String] = [\"Line \\(line)\"]\n        if let annotation {\n            switch annotation.kind {\n            case .added: parts.append(\"added\")\n            case .modified: parts.append(\"modified\")\n            case .deleted: parts.append(\"deleted\")\n            }\n        }\n        if let blame {\n            parts.append(\"\\(blame.author): \\(blame.summary)\")\n        }\n        return parts.joined(separator: \", \")\n    }\n}\n\nprivate struct DeletedIndicator: View {\n    let color: Color\n    let deletionCount: Int\n\n    var body: some View {\n        GeometryReader { geo in\n            let h = geo.size.height\n            let w = geo.size.width\n\n            // A small notch/triangle to indicate a deletion anchored at this line.\n            Path { p in\n                p.move(to: CGPoint(x: 0, y: 0))\n                p.addLine(to: CGPoint(x: w, y: h / 2))\n                p.addLine(to: CGPoint(x: 0, y: h))\n                p.closeSubpath()\n            }\n            .fill(color)\n            .overlay(alignment: .center) {\n                if deletionCount > 1 {\n                    Text(\"-\\(deletionCount)\")\n                        .font(.system(size: 9, weight: .semibold, design: .monospaced))\n                        .foregroundStyle(.white)\n                        .minimumScaleFactor(0.5)\n                        .lineLimit(1)\n                        .padding(.horizontal, 1)\n                }\n            }\n        }\n    }\n}\n\n// MARK: - View Model\n\n@MainActor\nprivate final class GitGutterViewModel: ObservableObject {\n    @Published var diffAnnotations: [Int: GitGutterLineAnnotation] = [:]\n    @Published var blameLines: [Int: GitBlameLine] = [:]\n\n    private var workspaceURL: URL?\n    private var fileURL: URL?\n\n    private var refreshTask: Task<Void, Never>?\n\n    func setContext(workspaceURL: URL, fileURL: URL) {\n        self.workspaceURL = workspaceURL\n        self.fileURL = fileURL\n    }\n\n    func refresh(textLineCount: Int, wantBlame: Bool) {\n        refreshTask?.cancel()\n\n        let workspaceURL = self.workspaceURL\n        let fileURL = self.fileURL\n\n        refreshTask = Task { [weak self] in\n            // Small debounce to avoid hammering git when typing/scrolling triggers updates.\n            try? await Task.sleep(nanoseconds: 175_000_000)\n            guard !Task.isCancelled else { return }\n            guard let self, let workspaceURL, let fileURL else { return }\n\n            let relPath = fileURL._vsc_pathRelative(to: workspaceURL)\n            guard !relPath.isEmpty else {\n                self.diffAnnotations = [:]\n                self.blameLines = [:]\n                return\n            }\n\n            // Diff\n            let diff = await GitDiffService().diffLineAnnotations(\n                workspaceURL: workspaceURL,\n                relativePath: relPath,\n                textLineCount: textLineCount\n            )\n\n            guard !Task.isCancelled else { return }\n            self.diffAnnotations = diff\n\n            // Blame\n            if wantBlame {\n                let blame = await GitBlameService().blame(\n                    workspaceURL: workspaceURL,\n                    relativePath: relPath\n                )\n                guard !Task.isCancelled else { return }\n                self.blameLines = blame\n            } else {\n                self.blameLines = [:]\n            }\n        }\n    }\n}\n\n// MARK: - Services\n\nprivate struct GitDiffService: Sendable {\n    func diffLineAnnotations(workspaceURL: URL, relativePath: String, textLineCount: Int) async -> [Int: GitGutterLineAnnotation] {\n        // Use zero-context unified diff to simplify mapping.\n        // This yields hunks with only changed lines.\n        let args = [\"diff\", \"--unified=0\", \"--\", relativePath]\n\n        let output: String\n        do {\n            output = try await GitCLI.shared.runGit(args: args, in: workspaceURL)\n        } catch {\n            return [:]\n        }\n\n        return GitDiffParser.parseUnifiedZeroDiff(output, textLineCount: textLineCount)\n    }\n}\n\nprivate struct GitBlameService: Sendable {\n    func blame(workspaceURL: URL, relativePath: String) async -> [Int: GitBlameLine] {\n        // `--line-porcelain` is stable to parse; includes author, time, summary per line.\n        // Use `--` to prevent path ambiguity.\n        let args = [\"blame\", \"--line-porcelain\", \"--\", relativePath]\n\n        let output: String\n        do {\n            output = try await GitCLI.shared.runGit(args: args, in: workspaceURL)\n        } catch {\n            return [:]\n        }\n\n        return GitBlameParser.parsePorcelain(output)\n    }\n}\n\n// MARK: - Parsing\n\nprivate enum GitDiffParser {\n    static func parseUnifiedZeroDiff(_ diff: String, textLineCount: Int) -> [Int: GitGutterLineAnnotation] {\n        var result: [Int: GitGutterLineAnnotation] = [:]\n\n        // For each hunk, track old and new positions.\n        var oldLine = 0\n        var newLine = 0\n\n        // For deletions, we anchor to the hunk's new start.\n        var pendingDeletionAnchorLine: Int? = nil\n        var pendingDeletionCount: Int = 0\n\n        func flushPendingDeletion() {\n            guard let anchor = pendingDeletionAnchorLine, pendingDeletionCount > 0 else { return }\n            let clamped = max(1, min(anchor, max(1, textLineCount)))\n            // Prefer not overwriting an existing add/modify marker; deletions can coexist conceptually,\n            // but for minimal UI we keep the first.\n            if result[clamped] == nil {\n                result[clamped] = .init(line: clamped, kind: .deleted, deletionCount: pendingDeletionCount)\n            } else if result[clamped]?.kind != .deleted {\n                // If there's already an annotation, keep it; deletion is still useful but would need\n                // a combined indicator. Skip for now.\n            }\n            pendingDeletionAnchorLine = nil\n            pendingDeletionCount = 0\n        }\n\n        for rawLine in diff.split(separator: \"\\n\", omittingEmptySubsequences: false) {\n            let line = String(rawLine)\n\n            if line.hasPrefix(\"@@\") {\n                // New hunk; flush deletion from previous hunk.\n                flushPendingDeletion()\n\n                if let h = parseHunkHeader(line) {\n                    oldLine = h.oldStart\n                    newLine = h.newStart\n                    pendingDeletionAnchorLine = h.newStart\n                }\n                continue\n            }\n\n            // Ignore file headers.\n            if line.hasPrefix(\"+++\") || line.hasPrefix(\"---\") || line.hasPrefix(\"diff \") || line.hasPrefix(\"index \") {\n                continue\n            }\n\n            if line.hasPrefix(\"-\") {\n                // Deleted from old file.\n                pendingDeletionCount += 1\n                oldLine += 1\n                continue\n            }\n\n            if line.hasPrefix(\"+\") {\n                // Added in new file.\n                flushPendingDeletion() // deletions before additions at same anchor should appear.\n\n                let current = max(1, min(newLine, max(1, textLineCount)))\n                // Mark as added unless already marked modified.\n                if let existing = result[current] {\n                    if existing.kind == .added {\n                        // keep\n                    } else {\n                        // If something else exists, keep existing.\n                    }\n                } else {\n                    result[current] = .init(line: current, kind: .added)\n                }\n                newLine += 1\n                continue\n            }\n\n            if line.hasPrefix(\" \") {\n                // Context line (should be rare with --unified=0, but handle).\n                flushPendingDeletion()\n                oldLine += 1\n                newLine += 1\n                continue\n            }\n\n            // Other lines; flush if needed.\n        }\n\n        // End diff.\n        flushPendingDeletion()\n\n        // Heuristic: convert certain add+delete patterns into modified.\n        // With unified=0, replacements often appear as a run of '-' followed by '+' at same anchor;\n        // our parsing would yield a deletion marker at anchor and additions on subsequent lines.\n        // We can approximate modifications by treating a line that is added and also has a deletion\n        // anchored there as modified.\n        for (line, ann) in result {\n            guard ann.kind == .deleted else { continue }\n            // If there is an added marker at the same anchor line, convert to modified.\n            if let added = result[line], added.kind == .added {\n                result[line] = .init(line: line, kind: .modified)\n            }\n        }\n\n        return result\n    }\n\n    private struct HunkHeader {\n        let oldStart: Int\n        let oldCount: Int\n        let newStart: Int\n        let newCount: Int\n    }\n\n    private static func parseHunkHeader(_ line: String) -> HunkHeader? {\n        // Example: @@ -12,0 +13,2 @@\n        // Example: @@ -1 +1 @@\n        // We parse integers after '-' and '+'.\n        guard let range = line.range(of: \"@@\") else { return nil }\n        let after = line[range.upperBound...]\n        guard let endRange = after.range(of: \"@@\") else { return nil }\n        let body = after[..<endRange.lowerBound].trimmingCharacters(in: .whitespaces)\n        // body like: \"-12,0 +13,2\" or \"-1 +1\"\n        let parts = body.split(separator: \" \").map(String.init)\n        guard parts.count >= 2 else { return nil }\n\n        func parseSide(_ s: String, prefix: Character) -> (start: Int, count: Int)? {\n            guard s.first == prefix else { return nil }\n            let rest = s.dropFirst()\n            let comps = rest.split(separator: \",\", maxSplits: 1, omittingEmptySubsequences: false)\n            let start = Int(comps.first ?? \"\") ?? 0\n            let count = comps.count > 1 ? (Int(comps[1]) ?? 1) : 1\n            return (start: start, count: count)\n        }\n\n        guard let old = parseSide(parts[0], prefix: \"-\"), let new = parseSide(parts[1], prefix: \"+\") else { return nil }\n        return HunkHeader(oldStart: old.start, oldCount: old.count, newStart: new.start, newCount: new.count)\n    }\n}\n\nprivate enum GitBlameParser {\n    static func parsePorcelain(_ output: String) -> [Int: GitBlameLine] {\n        // Each line record begins with: <sha> <orig-line> <final-line> <num-lines>\n        // Followed by key/value lines, ending with a tab-prefixed source line: \"\\t<content>\".\n        var result: [Int: GitBlameLine] = [:]\n\n        var currentSHA: String?\n        var currentFinalLine: Int?\n        var currentAuthor: String?\n        var currentAuthorTime: TimeInterval?\n        var currentSummary: String?\n\n        func flushIfPossible() {\n            guard let sha = currentSHA,\n                  let finalLine = currentFinalLine,\n                  let author = currentAuthor,\n                  let summary = currentSummary\n            else { return }\n            result[finalLine] = GitBlameLine(sha: sha, author: author, summary: summary, authorTime: currentAuthorTime)\n        }\n\n        for raw in output.split(separator: \"\\n\", omittingEmptySubsequences: false) {\n            let line = String(raw)\n\n            if line.hasPrefix(\"\\t\") {\n                // End of record.\n                flushIfPossible()\n                currentSHA = nil\n                currentFinalLine = nil\n                currentAuthor = nil\n                currentAuthorTime = nil\n                currentSummary = nil\n                continue\n            }\n\n            // Header line\n            if let first = line.first, first.isHexDigit {\n                // Start new record. Example: \"b6d... 12 12 1\"\n                let parts = line.split(separator: \" \")\n                if parts.count >= 3 {\n                    currentSHA = String(parts[0])\n                    currentFinalLine = Int(parts[2])\n                }\n                continue\n            }\n\n            if line.hasPrefix(\"author \") {\n                currentAuthor = String(line.dropFirst(\"author \".count))\n                continue\n            }\n            if line.hasPrefix(\"author-time \") {\n                let v = String(line.dropFirst(\"author-time \".count))\n                currentAuthorTime = TimeInterval(v)\n                continue\n            }\n            if line.hasPrefix(\"summary \") {\n                currentSummary = String(line.dropFirst(\"summary \".count))\n                continue\n            }\n        }\n\n        // In case file doesn't end with tab line (unlikely), flush.\n        flushIfPossible()\n\n        return result\n    }\n}\n\n// MARK: - Minimal Git CLI wrapper\n\nprivate actor GitCLI {\n    static let shared = GitCLI()\n\n    enum GitError: Error {\n        case nonZeroExit(code: Int32, stderr: String)\n        case invalidRepo\n    }\n\n    func runGit(args: [String], in directory: URL) async throws -> String {\n        // Basic check: directory must exist.\n        var isDir: ObjCBool = false\n        guard FileManager.default.fileExists(atPath: directory.path, isDirectory: &isDir), isDir.boolValue else {\n            throw GitError.invalidRepo\n        }\n\n        let process = Process()\n        process.executableURL = URL(fileURLWithPath: \"/usr/bin/env\")\n        process.arguments = [\"git\"] + args\n        process.currentDirectoryURL = directory\n\n        let stdout = Pipe()\n        let stderr = Pipe()\n        process.standardOutput = stdout\n        process.standardError = stderr\n\n        try process.run()\n\n        // Wait synchronously inside async context; acceptable for minimal wrapper.\n        process.waitUntilExit()\n\n        let outData = stdout.fileHandleForReading.readDataToEndOfFile()\n        let errData = stderr.fileHandleForReading.readDataToEndOfFile()\n\n        let out = String(data: outData, encoding: .utf8) ?? \"\"\n        let err = String(data: errData, encoding: .utf8) ?? \"\"\n\n        if process.terminationStatus != 0 {\n            throw GitError.nonZeroExit(code: process.terminationStatus, stderr: err)\n        }\n\n        return out\n    }\n}\n\n// MARK: - Utilities\n\nprivate extension String {\n    /// Fast-ish line count without allocating an array of substrings.\n    var _vsc_numberOfLines: Int {\n        // An empty buffer still shows as 1 line.\n        if self.isEmpty { return 1 }\n        var count = 1\n        for u in self.unicodeScalars where u == \"\\n\" {\n            count += 1\n        }\n        return count\n    }\n}\n\nprivate extension URL {\n    func _vsc_pathRelative(to base: URL) -> String {\n        // Ensure normalized absolute paths.\n        let basePath = base.standardizedFileURL.path\n        let targetPath = self.standardizedFileURL.path\n\n        guard targetPath.hasPrefix(basePath) else { return \"\" }\n\n        var rel = String(targetPath.dropFirst(basePath.count))\n        if rel.hasPrefix(\"/\") { rel.removeFirst() }\n        return rel\n    }\n}\n"}

>>>TOOL search
{"query":"struct Editor", "glob":"**/*.swift"}
>>>END>>>TOOL search
{"query":"struct .*Editor", "glob":"**/*.swift"}
>>>END>>>TOOL list_dir
{"path":"VSCodeiPadOS"}
>>>END>>>TOOL search
{"query":"Views/Editor", "glob":"**/*.swift"}
>>>END>>>TOOL list_dir
{"path":"Views"}
>>>END>>>TOOL search
{"query":"import SwiftUI", "glob":"Views/**/*.swift"}
>>>END>>>TOOL search
{"query":"TextKit", "glob":"**/*.swift"}
>>>END>>>TOOL search
{"query":"NSTextView", "glob":"**/*.swift"}
>>>END>>>TOOL search
{"query":"WKWebView", "glob":"**/*.swift"}
>>>END>>>TOOL search
{"query":"Monaco", "glob":"**/*.swift"}
>>>END>>>TOOL list_dir
{"path":"Models"}
>>>END>>>TOOL search
{"query":"blame", "glob":"Models/**/*.swift"}
>>>END>>>TOOL search
{"query":"diff", "glob":"Models/**/*.swift"}
>>>END

>>>TOOL read_file
{"path":"Views/Editor/MergeConflictView.swift","start_line":1,"end_line":200}
>>>END

>>>TOOL create_file
{"path":"Views/Editor/GitGutterView.swift","content":"import SwiftUI\nimport Foundation\n\n// MARK: - FEAT-071 Git gutter indicators + FEAT-072 Inline blame\n//\n// This file is intentionally self-contained so it can be dropped into the editor\n// without requiring any other services. If your codebase already has git diff/blame\n// services, you can swap the internal GitShell/GitDiffService/GitBlameService\n// implementations with your existing ones.\n\n// MARK: Models\n\npublic enum GitLineChangeKind: Hashable, Sendable {\n    case added\n    case modified\n    /// Represents a deletion marker at a line boundary (typically drawn between lines).\n    case deleted\n}\n\npublic struct GitLineChange: Hashable, Sendable {\n    public var line: Int // 1-based\n    public var kind: GitLineChangeKind\n\n    public init(line: Int, kind: GitLineChangeKind) {\n        self.line = line\n        self.kind = kind\n    }\n}\n\npublic struct GitBlameLine: Hashable, Sendable {\n    public var line: Int // 1-based\n    public var commit: String\n    public var author: String\n    public var authorTime: Date?\n    public var summary: String\n\n    public init(line: Int, commit: String, author: String, authorTime: Date?, summary: String) {\n        self.line = line\n        self.commit = commit\n        self.author = author\n        self.authorTime = authorTime\n        self.summary = summary\n    }\n}\n\n// MARK: - View\n\n/// Gutter view that renders git diff indicators (added/modified/deleted) and an optional inline blame label.\n///\n/// Integration expectation:\n/// - Provide `visibleLineRange` (1-based lines currently visible)\n/// - Provide `lineHeight` matching the editor line height\n/// - Provide `selectedLine` (caret line) if you want inline blame for the active line\n/// - Provide `fileURL` for the file shown by the editor\npublic struct GitGutterView: View {\n    public struct Configuration: Sendable {\n        public var showsDiffIndicators: Bool = true\n        public var showsInlineBlame: Bool = true\n\n        public var gutterWidth: CGFloat = 6\n        public var gutterCornerRadius: CGFloat = 1\n\n        public var inlineBlameLeadingPadding: CGFloat = 8\n        public var inlineBlameTrailingPadding: CGFloat = 8\n        public var inlineBlameFont: Font = .system(size: 11, weight: .regular, design: .monospaced)\n        public var inlineBlameMaxWidth: CGFloat = 420\n\n        public var addedColor: Color = Color(red: 0.20, green: 0.78, blue: 0.35)\n        public var modifiedColor: Color = Color(red: 0.20, green: 0.55, blue: 0.95)\n        public var deletedColor: Color = Color(red: 0.92, green: 0.30, blue: 0.24)\n\n        public var inlineBlameTextColor: Color = .secondary\n        public var inlineBlameBackground: Color = Color.secondary.opacity(0.10)\n        public var inlineBlameCornerRadius: CGFloat = 6\n\n        public init() {}\n    }\n\n    private let fileURL: URL\n    private let visibleLineRange: Range<Int> // 1-based, end-exclusive\n    private let lineHeight: CGFloat\n    private let contentTopInset: CGFloat\n    private let selectedLine: Int?\n    private let refreshToken: AnyHashable\n    private let configuration: Configuration\n\n    @State private var changesByLine: [Int: GitLineChangeKind] = [:]\n    @State private var deletedMarkers: Set<Int> = []\n\n    @State private var blameByLine: [Int: GitBlameLine] = [:]\n\n    public init(\n        fileURL: URL,\n        visibleLineRange: Range<Int>,\n        lineHeight: CGFloat,\n        contentTopInset: CGFloat = 0,\n        selectedLine: Int? = nil,\n        refreshToken: AnyHashable = 0,\n        configuration: Configuration = .init()\n    ) {\n        self.fileURL = fileURL\n        self.visibleLineRange = visibleLineRange\n        self.lineHeight = lineHeight\n        self.contentTopInset = contentTopInset\n        self.selectedLine = selectedLine\n        self.refreshToken = refreshToken\n        self.configuration = configuration\n    }\n\n    public var body: some View {\n        HStack(spacing: 0) {\n            if configuration.showsDiffIndicators {\n                diffGutter\n                    .frame(width: configuration.gutterWidth)\n            }\n\n            if configuration.showsInlineBlame {\n                inlineBlameColumn\n            }\n        }\n        // Keep the view cheap: only reload when file/refresh changes.\n        .task(id: refreshToken) {\n            await reloadAll()\n        }\n        .task(id: fileURL) {\n            await reloadAll()\n        }\n    }\n\n    private var diffGutter: some View {\n        GeometryReader { proxy in\n            Canvas { context, size in\n                guard !visibleLineRange.isEmpty else { return }\n\n                let w = size.width\n                let corner = configuration.gutterCornerRadius\n\n                for line in visibleLineRange {\n                    if let kind = changesByLine[line] {\n                        let y = contentTopInset + CGFloat(line - visibleLineRange.lowerBound) * lineHeight\n                        let rect = CGRect(x: 0, y: y, width: w, height: max(1, lineHeight))\n                        let path = Path(roundedRect: rect, cornerRadius: corner)\n                        context.fill(path, with: .color(color(for: kind)))\n                    }\n\n                    // Deleted markers are drawn as small triangles at the boundary.\n                    if deletedMarkers.contains(line) {\n                        let y = contentTopInset + CGFloat(line - visibleLineRange.lowerBound) * lineHeight\n                        var p = Path()\n                        p.move(to: CGPoint(x: 0, y: y))\n                        p.addLine(to: CGPoint(x: w, y: y + (lineHeight * 0.5)))\n                        p.addLine(to: CGPoint(x: 0, y: y + lineHeight))\n                        p.closeSubpath()\n                        context.fill(p, with: .color(configuration.deletedColor))\n                    }\n                }\n            }\n        }\n        .accessibilityLabel(\"Git diff gutter\")\n    }\n\n    private var inlineBlameColumn: some View {\n        ZStack(alignment: .topLeading) {\n            if let selectedLine, let blame = blameByLine[selectedLine], visibleLineRange.contains(selectedLine) {\n                let y = contentTopInset + CGFloat(selectedLine - visibleLineRange.lowerBound) * lineHeight\n\n                inlineBlameLabel(for: blame)\n                    .frame(maxWidth: configuration.inlineBlameMaxWidth, alignment: .leading)\n                    .offset(x: configuration.inlineBlameLeadingPadding, y: y)\n                    .allowsHitTesting(false)\n            }\n        }\n        .padding(.trailing, configuration.inlineBlameTrailingPadding)\n        .accessibilityLabel(\"Inline git blame\")\n    }\n\n    @ViewBuilder\n    private func inlineBlameLabel(for blame: GitBlameLine) -> some View {\n        let commitShort = String(blame.commit.prefix(8))\n        let author = blame.author.isEmpty ? \"Unknown\" : blame.author\n        let summary = blame.summary\n\n        Text(\"\\(author) \\(commitShort) — \\(summary)\")\n            .font(configuration.inlineBlameFont)\n            .foregroundStyle(configuration.inlineBlameTextColor)\n            .lineLimit(1)\n            .truncationMode(.tail)\n            .padding(.horizontal, 8)\n            .padding(.vertical, 4)\n            .background(configuration.inlineBlameBackground)\n            .clipShape(RoundedRectangle(cornerRadius: configuration.inlineBlameCornerRadius, style: .continuous))\n    }\n\n    private func color(for kind: GitLineChangeKind) -> Color {\n        switch kind {\n        case .added: return configuration.addedColor\n        case .modified: return configuration.modifiedColor\n        case .deleted: return configuration.deletedColor\n        }\n    }\n\n    // MARK: Reload\n\n    @MainActor\n    private func reloadAll() async {\n        // Diff\n        if configuration.showsDiffIndicators {\n            do {\n                let diff = try await GitDiffService.shared.lineChanges(forFile: fileURL)\n                var byLine: [Int: GitLineChangeKind] = [:]\n                var deletions: Set<Int> = []\n\n                for c in diff {\n                    switch c.kind {\n                    case .deleted:\n                        deletions.insert(max(1, c.line))\n                    case .added, .modified:\n                        byLine[c.line] = c.kind\n                    }\n                }\n\n                self.changesByLine = byLine\n                self.deletedMarkers = deletions\n            } catch {\n                self.changesByLine = [:]\n                self.deletedMarkers = []\n            }\n        }\n\n        // Blame\n        if configuration.showsInlineBlame {\n            do {\n                let blame = try await GitBlameService.shared.blame(forFile: fileURL)\n                self.blameByLine = Dictionary(uniqueKeysWithValues: blame.map { ($0.line, $0) })\n            } catch {\n                self.blameByLine = [:]\n            }\n        }\n    }\n}\n\n// MARK: - Minimal Git wrappers\n\nprivate enum GitError: Error, LocalizedError {\n    case notARepository\n    case commandFailed(String)\n\n    var errorDescription: String? {\n        switch self {\n        case .notARepository:\n            return \"Not a git repository\"\n        case .commandFailed(let msg):\n            return \"Git command failed: \\(msg)\"\n        }\n    }\n}\n\nprivate struct GitShell {\n    static func runGit(args: [String], in workingDirectory: URL) async throws -> String {\n        try await withCheckedThrowingContinuation { cont in\n            let process = Process()\n            process.executableURL = URL(fileURLWithPath: \"/usr/bin/env\")\n            process.arguments = [\"git\"] + args\n            process.currentDirectoryURL = workingDirectory\n\n            let outPipe = Pipe()\n            let errPipe = Pipe()\n            process.standardOutput = outPipe\n            process.standardError = errPipe\n\n            do {\n                try process.run()\n            } catch {\n                cont.resume(throwing: GitError.commandFailed(\"Unable to launch git\"))\n                return\n            }\n\n            process.terminationHandler = { p in\n                let outData = outPipe.fileHandleForReading.readDataToEndOfFile()\n                let errData = errPipe.fileHandleForReading.readDataToEndOfFile()\n\n                let out = String(data: outData, encoding: .utf8) ?? \"\"\n                let err = String(data: errData, encoding: .utf8) ?? \"\"\n\n                if p.terminationStatus == 0 {\n                    cont.resume(returning: out)\n                } else {\n                    let msg = err.trimmingCharacters(in: .whitespacesAndNewlines)\n                    cont.resume(throwing: GitError.commandFailed(msg.isEmpty ? out : msg))\n                }\n            }\n        }\n    }\n\n    static func repoRoot(containing fileURL: URL) async throws -> URL {\n        let dir = fileURL.deletingLastPathComponent()\n        let out = try await runGit(args: [\"-C\", dir.path, \"rev-parse\", \"--show-toplevel\"], in: dir)\n        let rootPath = out.trimmingCharacters(in: .whitespacesAndNewlines)\n        if rootPath.isEmpty { throw GitError.notARepository }\n        return URL(fileURLWithPath: rootPath)\n    }\n}\n\n// MARK: - Diff\n\nprivate actor GitDiffService {\n    static let shared = GitDiffService()\n\n    private var cache: [String: [GitLineChange]] = [:] // key: repoRoot + fileRelPath\n\n    func lineChanges(forFile fileURL: URL) async throws -> [GitLineChange] {\n        let repoRoot = try await GitShell.repoRoot(containing: fileURL)\n        let relPath = Self.relativePath(fileURL, repoRoot)\n        let key = repoRoot.path + \"::\" + relPath\n\n        if let cached = cache[key] {\n            return cached\n        }\n\n        // Unified=0 makes hunks contain only the changed lines, simplifying mapping.\n        let diff = try await GitShell.runGit(\n            args: [\"-C\", repoRoot.path, \"diff\", \"--unified=0\", \"--no-color\", \"--\", relPath],\n            in: repoRoot\n        )\n\n        let parsed = Self.parseUnifiedZeroDiff(diff)\n        cache[key] = parsed\n        return parsed\n    }\n\n    private static func relativePath(_ fileURL: URL, _ repoRoot: URL) -> String {\n        let filePath = fileURL.standardizedFileURL.path\n        let rootPath = repoRoot.standardizedFileURL.path\n        if filePath.hasPrefix(rootPath + \"/\") {\n            return String(filePath.dropFirst(rootPath.count + 1))\n        }\n        return fileURL.lastPathComponent\n    }\n\n    /// Parse output from: `git diff --unified=0 --no-color -- <file>`.\n    ///\n    /// Heuristic classification per hunk:\n    /// - oldCount==0,newCount>0 -> .added on new range\n    /// - oldCount>0,newCount>0 -> .modified on new range\n    /// - oldCount>0,newCount==0 -> .deleted marker at newStart\n    private static func parseUnifiedZeroDiff(_ text: String) -> [GitLineChange] {\n        var results: [GitLineChange] = []\n\n        // Example hunk header (unified=0):\n        // @@ -12,2 +12,3 @@\n        // or @@ -12 +12 @@\n        let lines = text.split(separator: \"\\n\", omittingEmptySubsequences: false)\n\n        var i = 0\n        while i < lines.count {\n            let line = String(lines[i])\n            if line.hasPrefix(\"@@\") {\n                if let h = parseHunkHeader(line) {\n                    if h.oldCount == 0 && h.newCount > 0 {\n                        // Added lines.\n                        for n in 0..<h.newCount {\n                            results.append(.init(line: h.newStart + n, kind: .added))\n                        }\n                    } else if h.oldCount > 0 && h.newCount > 0 {\n                        // Modified lines.\n                        for n in 0..<h.newCount {\n                            results.append(.init(line: h.newStart + n, kind: .modified))\n                        }\n                    } else if h.oldCount > 0 && h.newCount == 0 {\n                        // Pure deletion: marker at boundary (newStart).\n                        results.append(.init(line: max(1, h.newStart), kind: .deleted))\n                    }\n                }\n            }\n            i += 1\n        }\n\n        // De-dupe (prefer modified over added if collision).\n        var byLine: [Int: GitLineChangeKind] = [:]\n        var deleted: Set<Int> = []\n        for r in results {\n            switch r.kind {\n            case .deleted:\n                deleted.insert(r.line)\n            case .added:\n                if byLine[r.line] == nil { byLine[r.line] = .added }\n            case .modified:\n                byLine[r.line] = .modified\n            }\n        }\n\n        var merged: [GitLineChange] = []\n        for (line, kind) in byLine {\n            merged.append(.init(line: line, kind: kind))\n        }\n        for d in deleted {\n            merged.append(.init(line: d, kind: .deleted))\n        }\n\n        return merged.sorted { $0.line < $1.line }\n    }\n\n    private struct Hunk {\n        var oldStart: Int\n        var oldCount: Int\n        var newStart: Int\n        var newCount: Int\n    }\n\n    private static func parseHunkHeader(_ header: String) -> Hunk? {\n        // Header format: @@ -oldStart,oldCount +newStart,newCount @@ ...\n        // Counts may be omitted: -12 +12\n        guard let rangeStart = header.range(of: \"@@\") else { return nil }\n        guard let rangeEnd = header.range(of: \"@@\", options: [], range: rangeStart.upperBound..<header.endIndex) else { return nil }\n        let body = header[rangeStart.upperBound..<rangeEnd.lowerBound].trimmingCharacters(in: .whitespaces)\n        // body like: \"-12,2 +14,0\" or \"-12 +12\"\n        let parts = body.split(separator: \" \")\n        guard parts.count >= 2 else { return nil }\n\n        func parsePart(_ s: Substring, prefix: Character) -> (Int, Int)? {\n            guard s.first == prefix else { return nil }\n            let rest = s.dropFirst()\n            if let comma = rest.firstIndex(of: \",\") {\n                let a = rest[..<comma]\n                let b = rest[rest.index(after: comma)...]\n                guard let start = Int(a), let count = Int(b) else { return nil }\n                return (start, count)\n            } else {\n                // Count omitted -> 1 line.\n                guard let start = Int(rest) else { return nil }\n                return (start, 1)\n            }\n        }\n\n        guard let old = parsePart(parts[0], prefix: \"-\") else { return nil }\n        guard let new = parsePart(parts[1], prefix: \"+\") else { return nil }\n        return Hunk(oldStart: old.0, oldCount: old.1, newStart: new.0, newCount: new.1)\n    }\n}\n\n// MARK: - Blame\n\nprivate actor GitBlameService {\n    static let shared = GitBlameService()\n\n    private var cache: [String: [GitBlameLine]] = [:] // key: repoRoot + fileRelPath\n\n    func blame(forFile fileURL: URL) async throws -> [GitBlameLine] {\n        let repoRoot = try await GitShell.repoRoot(containing: fileURL)\n        let relPath = GitDiffService.relativePath(fileURL, repoRoot)\n        let key = repoRoot.path + \"::\" + relPath\n\n        if let cached = cache[key] {\n            return cached\n        }\n\n        // `--line-porcelain` yields stable key-value blocks per line.\n        let out = try await GitShell.runGit(\n            args: [\"-C\", repoRoot.path, \"blame\", \"--line-porcelain\", \"--\", relPath],\n            in: repoRoot\n        )\n\n        let parsed = Self.parseLinePorcelain(out)\n        cache[key] = parsed\n        return parsed\n    }\n\n    private static func parseLinePorcelain(_ text: String) -> [GitBlameLine] {\n        // Format:\n        // <sha> <origLine> <finalLine> <numLines>\n        // author <name>\n        // author-time <unix>\n        // summary <text>\n        // ...\n        // \\t<source line>\n        var results: [GitBlameLine] = []\n\n        var currentCommit: String = \"\"\n        var currentAuthor: String = \"\"\n        var currentAuthorTime: Date?\n        var currentSummary: String = \"\"\n        var currentFinalLine: Int?\n\n        func flushIfPossible() {\n            guard let lineNo = currentFinalLine, !currentCommit.isEmpty else { return }\n            results.append(\n                GitBlameLine(\n                    line: lineNo,\n                    commit: currentCommit,\n                    author: currentAuthor,\n                    authorTime: currentAuthorTime,\n                    summary: currentSummary\n                )\n            )\n            currentCommit = \"\"\n            currentAuthor = \"\"\n            currentAuthorTime = nil\n            currentSummary = \"\"\n            currentFinalLine = nil\n        }\n\n        for raw in text.split(separator: \"\\n\", omittingEmptySubsequences: false) {\n            let line = String(raw)\n\n            if line.hasPrefix(\"\\t\") {\n                // End of block for one line.\n                flushIfPossible()\n                continue\n            }\n\n            // Block header line begins with 40-char SHA typically.\n            if !line.isEmpty, line.first?.isHexDigit == true {\n                // New block starting; we should flush previous (defensive).\n                if currentFinalLine != nil {\n                    flushIfPossible()\n                }\n\n                let parts = line.split(separator: \" \")\n                if parts.count >= 3 {\n                    currentCommit = String(parts[0])\n                    currentFinalLine = Int(parts[2])\n                }\n                continue\n            }\n\n            if line.hasPrefix(\"author \") {\n                currentAuthor = String(line.dropFirst(\"author \".count))\n            } else if line.hasPrefix(\"author-time \") {\n                let ts = String(line.dropFirst(\"author-time \".count))\n                if let t = TimeInterval(ts) {\n                    currentAuthorTime = Date(timeIntervalSince1970: t)\n                }\n            } else if line.hasPrefix(\"summary \") {\n                currentSummary = String(line.dropFirst(\"summary \".count))\n            }\n        }\n\n        // Final flush (if last block didn't end with \\t line for any reason)\n        flushIfPossible()\n\n        return results.sorted { $0.line < $1.line }\n    }\n}\n"} 
>>>END

>>>TOOL read_file
{"path":"Views/Editor/GitGutterView.swift","start_line":1,"end_line":200}
>>>END

>>>TOOL read_file
{"path":"Views/Editor/GitGutterView.swift","start_line":200,"end_line":560}
>>>END>>>END

>>>TOOL read_file
{"path":"Views/Editor/GitGutterView.swift","start_line":1,"end_line":80}
>>>END
>>>TOOL read_file
{"path":"Views/Editor/GitGutterView.swift","start_line":80,"end_line":220}
>>>END
>>>TOOL read_file
{"path":"Views/Editor/GitGutterView.swift","start_line":220,"end_line":360}
>>>END
>>>TOOL read_file
{"path":"Views/Editor/GitGutterView.swift","start_line":360,"end_line":544}
>>>END
>>>TOOL read_file
{"path":"Views/Editor/GitGutterView.swift","start_line":1,"end_line":20}
>>>END
>>>TOOL create_file
{"path":"Views/Editor/GitGutterView.swift","content":""}
>>>END


>>>TOOL read_file
{"path":"Views/Editor/GitGutterView.swift","start_line":1,"end_line":40}
>>>END

>>>TOOL patch
{"path":"Views/Editor/GitGutterView.swift","find":"import Foundation\n","replace":"import Foundation\nimport SwiftUI\n"}
>>>END

>>>TOOL create_file
{"path":"Views/Editor/GitGutterView.swift","overwrite":true,"content":"import Foundation\nimport SwiftUI\n\n// MARK: - FEAT-071 Git gutter indicators + FEAT-072 Inline blame\n//\n// This file is intentionally self-contained so it can be dropped into the editor\n// without requiring any other services.\n//\n// Integration expectations (host editor provides these values):\n// - fileURL: file shown by editor\n// - visibleLineRange: 1-based visible lines, end-exclusive\n// - lineHeight: editor line height in points\n// - contentTopInset: any top inset applied before first visible line\n// - selectedLine: caret line (1-based) for inline blame display\n// - refreshToken: bump this when file content changes or git state should refresh\n\n// MARK: Models\n\npublic enum GitLineChangeKind: Hashable, Sendable {\n    case added\n    case modified\n    /// Represents a deletion marker at a line boundary (typically drawn between lines).\n    case deleted\n}\n\npublic struct GitLineChange: Hashable, Sendable {\n    public var line: Int // 1-based\n    public var kind: GitLineChangeKind\n\n    public init(line: Int, kind: GitLineChangeKind) {\n        self.line = line\n        self.kind = kind\n    }\n}\n\npublic struct GitBlameLine: Hashable, Sendable {\n    public var line: Int // 1-based\n    public var commit: String\n    public var author: String\n    public var authorTime: Date?\n    public var summary: String\n\n    public init(line: Int, commit: String, author: String, authorTime: Date?, summary: String) {\n        self.line = line\n        self.commit = commit\n        self.author = author\n        self.authorTime = authorTime\n        self.summary = summary\n    }\n}\n\n// MARK: - View\n\n/// Gutter view that renders git diff indicators (added/modified/deleted) and an optional inline blame label.\npublic struct GitGutterView: View {\n    public struct Configuration: Sendable {\n        public var showsDiffIndicators: Bool = true\n        public var showsInlineBlame: Bool = true\n\n        public var gutterWidth: CGFloat = 6\n        public var gutterCornerRadius: CGFloat = 1\n\n        public var inlineBlameLeadingPadding: CGFloat = 8\n        public var inlineBlameTrailingPadding: CGFloat = 8\n        public var inlineBlameFont: Font = .system(size: 11, weight: .regular, design: .monospaced)\n        public var inlineBlameMaxWidth: CGFloat = 420\n\n        public var addedColor: Color = Color(red: 0.20, green: 0.78, blue: 0.35)\n        public var modifiedColor: Color = Color(red: 0.20, green: 0.55, blue: 0.95)\n        public var deletedColor: Color = Color(red: 0.92, green: 0.30, blue: 0.24)\n\n        public var inlineBlameTextColor: Color = .secondary\n        public var inlineBlameBackground: Color = Color.secondary.opacity(0.10)\n        public var inlineBlameCornerRadius: CGFloat = 6\n\n        public init() {}\n    }\n\n    private let fileURL: URL\n    private let visibleLineRange: Range<Int> // 1-based, end-exclusive\n    private let lineHeight: CGFloat\n    private let contentTopInset: CGFloat\n    private let selectedLine: Int?\n    private let refreshToken: AnyHashable\n    private let configuration: Configuration\n\n    @State private var changesByLine: [Int: GitLineChangeKind] = [:]\n    @State private var deletedMarkers: Set<Int> = []\n    @State private var blameByLine: [Int: GitBlameLine] = [:]\n\n    public init(\n        fileURL: URL,\n        visibleLineRange: Range<Int>,\n        lineHeight: CGFloat,\n        contentTopInset: CGFloat = 0,\n        selectedLine: Int? = nil,\n        refreshToken: AnyHashable = 0,\n        configuration: Configuration = .init()\n    ) {\n        self.fileURL = fileURL\n        self.visibleLineRange = visibleLineRange\n        self.lineHeight = lineHeight\n        self.contentTopInset = contentTopInset\n        self.selectedLine = selectedLine\n        self.refreshToken = refreshToken\n        self.configuration = configuration\n    }\n\n    public var body: some View {\n        HStack(spacing: 0) {\n            if configuration.showsDiffIndicators {\n                diffGutter\n                    .frame(width: configuration.gutterWidth)\n            }\n\n            if configuration.showsInlineBlame {\n                inlineBlameColumn\n            }\n        }\n        .task(id: fileURL) {\n            await reloadAll(force: true)\n        }\n        .task(id: refreshToken) {\n            await reloadAll(force: true)\n        }\n    }\n\n    private var diffGutter: some View {\n        GeometryReader { _ in\n            Canvas { context, size in\n                guard !visibleLineRange.isEmpty else { return }\n\n                let w = size.width\n                let corner = configuration.gutterCornerRadius\n\n                for line in visibleLineRange {\n                    if let kind = changesByLine[line] {\n                        let y = contentTopInset + CGFloat(line - visibleLineRange.lowerBound) * lineHeight\n                        let rect = CGRect(x: 0, y: y, width: w, height: max(1, lineHeight))\n                        let path = Path(roundedRect: rect, cornerRadius: corner)\n                        context.fill(path, with: .color(color(for: kind)))\n                    }\n\n                    // Deleted markers are drawn as small triangles at the boundary.\n                    if deletedMarkers.contains(line) {\n                        let y = contentTopInset + CGFloat(line - visibleLineRange.lowerBound) * lineHeight\n                        var p = Path()\n                        p.move(to: CGPoint(x: 0, y: y))\n                        p.addLine(to: CGPoint(x: w, y: y + (lineHeight * 0.5)))\n                        p.addLine(to: CGPoint(x: 0, y: y + lineHeight))\n                        p.closeSubpath()\n                        context.fill(p, with: .color(configuration.deletedColor))\n                    }\n                }\n            }\n        }\n        .accessibilityLabel(\"Git diff gutter\")\n    }\n\n    private var inlineBlameColumn: some View {\n        ZStack(alignment: .topLeading) {\n            if let selectedLine,\n               let blame = blameByLine[selectedLine],\n               visibleLineRange.contains(selectedLine) {\n                let y = contentTopInset + CGFloat(selectedLine - visibleLineRange.lowerBound) * lineHeight\n\n                inlineBlameLabel(for: blame)\n                    .frame(maxWidth: configuration.inlineBlameMaxWidth, alignment: .leading)\n                    .offset(x: configuration.inlineBlameLeadingPadding, y: y)\n                    .allowsHitTesting(false)\n            }\n        }\n        .padding(.trailing, configuration.inlineBlameTrailingPadding)\n        .accessibilityLabel(\"Inline git blame\")\n    }\n\n    @ViewBuilder\n    private func inlineBlameLabel(for blame: GitBlameLine) -> some View {\n        let commitShort = String(blame.commit.prefix(8))\n        let author = blame.author.isEmpty ? \"Unknown\" : blame.author\n        let summary = blame.summary\n\n        Text(\"\\(author) \\(commitShort) — \\(summary)\")\n            .font(configuration.inlineBlameFont)\n            .foregroundStyle(configuration.inlineBlameTextColor)\n            .lineLimit(1)\n            .truncationMode(.tail)\n            .padding(.horizontal, 8)\n            .padding(.vertical, 4)\n            .background(configuration.inlineBlameBackground)\n            .clipShape(RoundedRectangle(cornerRadius: configuration.inlineBlameCornerRadius, style: .continuous))\n    }\n\n    private func color(for kind: GitLineChangeKind) -> Color {\n        switch kind {\n        case .added: return configuration.addedColor\n        case .modified: return configuration.modifiedColor\n        case .deleted: return configuration.deletedColor\n        }\n    }\n\n    // MARK: Reload\n\n    @MainActor\n    private func reloadAll(force: Bool) async {\n        if force {\n            await GitDiffService.shared.invalidate(forFile: fileURL)\n            await GitBlameService.shared.invalidate(forFile: fileURL)\n        }\n\n        // Diff\n        if configuration.showsDiffIndicators {\n            do {\n                let diff = try await GitDiffService.shared.lineChanges(forFile: fileURL)\n                var byLine: [Int: GitLineChangeKind] = [:]\n                var deletions: Set<Int> = []\n\n                for c in diff {\n                    switch c.kind {\n                    case .deleted:\n                        deletions.insert(max(1, c.line))\n                    case .added, .modified:\n                        byLine[c.line] = c.kind\n                    }\n                }\n\n                self.changesByLine = byLine\n                self.deletedMarkers = deletions\n            } catch {\n                self.changesByLine = [:]\n                self.deletedMarkers = []\n            }\n        }\n\n        // Blame\n        if configuration.showsInlineBlame {\n            do {\n                let blame = try await GitBlameService.shared.blame(forFile: fileURL)\n                self.blameByLine = Dictionary(uniqueKeysWithValues: blame.map { ($0.line, $0) })\n            } catch {\n                self.blameByLine = [:]\n            }\n        }\n    }\n}\n\n// MARK: - Minimal Git wrappers\n\nprivate enum GitError: Error, LocalizedError {\n    case notARepository\n    case commandFailed(String)\n\n    var errorDescription: String? {\n        switch self {\n        case .notARepository:\n            return \"Not a git repository\"\n        case .commandFailed(let msg):\n            return \"Git command failed: \\(msg)\"\n        }\n    }\n}\n\nprivate struct GitShell {\n    static func runGit(args: [String], in workingDirectory: URL) async throws -> String {\n        #if os(macOS) || targetEnvironment(macCatalyst) || os(Linux)\n        return try await withCheckedThrowingContinuation { cont in\n            let process = Process()\n            process.executableURL = URL(fileURLWithPath: \"/usr/bin/env\")\n            process.arguments = [\"git\"] + args\n            process.currentDirectoryURL = workingDirectory\n\n            let outPipe = Pipe()\n            let errPipe = Pipe()\n            process.standardOutput = outPipe\n            process.standardError = errPipe\n\n            do {\n                try process.run()\n            } catch {\n                cont.resume(throwing: GitError.commandFailed(\"Unable to launch git\"))\n                return\n            }\n\n            process.terminationHandler = { p in\n                let outData = outPipe.fileHandleForReading.readDataToEndOfFile()\n                let errData = errPipe.fileHandleForReading.readDataToEndOfFile()\n\n                let out = String(data: outData, encoding: .utf8) ?? \"\"\n                let err = String(data: errData, encoding: .utf8) ?? \"\"\n\n                if p.terminationStatus == 0 {\n                    cont.resume(returning: out)\n                } else {\n                    let msg = err.trimmingCharacters(in: .whitespacesAndNewlines)\n                    cont.resume(throwing: GitError.commandFailed(msg.isEmpty ? out : msg))\n                }\n            }\n        }\n        #else\n        throw GitError.commandFailed(\"Git execution is not available on this platform\")\n        #endif\n    }\n\n    static func repoRoot(containing fileURL: URL) async throws -> URL {\n        let dir = fileURL.deletingLastPathComponent()\n        let out = try await runGit(args: [\"-C\", dir.path, \"rev-parse\", \"--show-toplevel\"], in: dir)\n        let rootPath = out.trimmingCharacters(in: .whitespacesAndNewlines)\n        if rootPath.isEmpty { throw GitError.notARepository }\n        return URL(fileURLWithPath: rootPath)\n    }\n}\n\n// MARK: - Diff\n\nprivate actor GitDiffService {\n    static let shared = GitDiffService()\n\n    private var cache: [String: [GitLineChange]] = [:] // key: repoRoot + fileRelPath\n\n    func invalidate(forFile fileURL: URL) async {\n        // Best-effort invalidate for this file (and any file with same rel path in same repo).\n        // If we can't determine repo root, do nothing.\n        do {\n            let repoRoot = try await GitShell.repoRoot(containing: fileURL)\n            let relPath = Self.relativePath(fileURL, repoRoot)\n            let key = repoRoot.path + \"::\" + relPath\n            cache.removeValue(forKey: key)\n        } catch {\n            // ignore\n        }\n    }\n\n    func lineChanges(forFile fileURL: URL) async throws -> [GitLineChange] {\n        let repoRoot = try await GitShell.repoRoot(containing: fileURL)\n        let relPath = Self.relativePath(fileURL, repoRoot)\n        let key = repoRoot.path + \"::\" + relPath\n\n        if let cached = cache[key] {\n            return cached\n        }\n\n        // Unified=0 makes hunks contain only the changed lines, simplifying mapping.\n        let diff = try await GitShell.runGit(\n            args: [\"-C\", repoRoot.path, \"diff\", \"--unified=0\", \"--no-color\", \"--\", relPath],\n            in: repoRoot\n        )\n\n        let parsed = Self.parseUnifiedZeroDiff(diff)\n        cache[key] = parsed\n        return parsed\n    }\n\n    fileprivate static func relativePath(_ fileURL: URL, _ repoRoot: URL) -> String {\n        let filePath = fileURL.standardizedFileURL.path\n        let rootPath = repoRoot.standardizedFileURL.path\n        if filePath.hasPrefix(rootPath + \"/\") {\n            return String(filePath.dropFirst(rootPath.count + 1))\n        }\n        return fileURL.lastPathComponent\n    }\n\n    /// Parse output from: `git diff --unified=0 --no-color -- <file>`.\n    ///\n    /// Heuristic classification per hunk:\n    /// - oldCount==0,newCount>0 -> .added on new range\n    /// - oldCount>0,newCount>0 -> .modified on new range\n    /// - oldCount>0,newCount==0 -> .deleted marker at newStart\n    private static func parseUnifiedZeroDiff(_ text: String) -> [GitLineChange] {\n        var results: [GitLineChange] = []\n\n        // Example hunk header (unified=0):\n        // @@ -12,2 +12,3 @@\n        // or @@ -12 +12 @@\n        let lines = text.split(separator: \"\\n\", omittingEmptySubsequences: false)\n\n        var i = 0\n        while i < lines.count {\n            let line = String(lines[i])\n            if line.hasPrefix(\"@@\"), let h = parseHunkHeader(line) {\n                if h.oldCount == 0 && h.newCount > 0 {\n                    for n in 0..<h.newCount {\n                        results.append(.init(line: h.newStart + n, kind: .added))\n                    }\n                } else if h.oldCount > 0 && h.newCount > 0 {\n                    for n in 0..<h.newCount {\n                        results.append(.init(line: h.newStart + n, kind: .modified))\n                    }\n                } else if h.oldCount > 0 && h.newCount == 0 {\n                    results.append(.init(line: max(1, h.newStart), kind: .deleted))\n                }\n            }\n            i += 1\n        }\n\n        // De-dupe (prefer modified over added if collision).\n        var byLine: [Int: GitLineChangeKind] = [:]\n        var deleted: Set<Int> = []\n        for r in results {\n            switch r.kind {\n            case .deleted:\n                deleted.insert(r.line)\n            case .added:\n                if byLine[r.line] == nil { byLine[r.line] = .added }\n            case .modified:\n                byLine[r.line] = .modified\n            }\n        }\n\n        var merged: [GitLineChange] = []\n        for (line, kind) in byLine {\n            merged.append(.init(line: line, kind: kind))\n        }\n        for d in deleted {\n            merged.append(.init(line: d, kind: .deleted))\n        }\n\n        return merged.sorted { $0.line < $1.line }\n    }\n\n    private struct Hunk {\n        var oldStart: Int\n        var oldCount: Int\n        var newStart: Int\n        var newCount: Int\n    }\n\n    private static func parseHunkHeader(_ header: String) -> Hunk? {\n        // Header format: @@ -oldStart,oldCount +newStart,newCount @@ ...\n        // Counts may be omitted: -12 +12\n        guard let rangeStart = header.range(of: \"@@\") else { return nil }\n        guard let rangeEnd = header.range(of: \"@@\", options: [], range: rangeStart.upperBound..<header.endIndex) else { return nil }\n        let body = header[rangeStart.upperBound..<rangeEnd.lowerBound].trimmingCharacters(in: .whitespaces)\n\n        // body like: \"-12,2 +14,0\" or \"-12 +12\"\n        let parts = body.split(separator: \" \")\n        guard parts.count >= 2 else { return nil }\n\n        func parsePart(_ s: Substring, prefix: Character) -> (Int, Int)? {\n            guard s.first == prefix else { return nil }\n            let rest = s.dropFirst()\n            if let comma = rest.firstIndex(of: \",\") {\n                let a = rest[..<comma]\n                let b = rest[rest.index(after: comma)...]\n                guard let start = Int(a), let count = Int(b) else { return nil }\n                return (start, count)\n            } else {\n                // Count omitted -> 1 line.\n                guard let start = Int(rest) else { return nil }\n                return (start, 1)\n            }\n        }\n\n        guard let old = parsePart(parts[0], prefix: \"-\") else { return nil }\n        guard let new = parsePart(parts[1], prefix: \"+\") else { return nil }\n        return Hunk(oldStart: old.0, oldCount: old.1, newStart: new.0, newCount: new.1)\n    }\n}\n\n// MARK: - Blame\n\nprivate actor GitBlameService {\n    static let shared = GitBlameService()\n\n    private var cache: [String: [GitBlameLine]] = [:] // key: repoRoot + fileRelPath\n\n    func invalidate(forFile fileURL: URL) async {\n        do {\n            let repoRoot = try await GitShell.repoRoot(containing: fileURL)\n            let relPath = GitDiffService.relativePath(fileURL, repoRoot)\n            let key = repoRoot.path + \"::\" + relPath\n            cache.removeValue(forKey: key)\n        } catch {\n            // ignore\n        }\n    }\n\n    func blame(forFile fileURL: URL) async throws -> [GitBlameLine] {\n        let repoRoot = try await GitShell.repoRoot(containing: fileURL)\n        let relPath = GitDiffService.relativePath(fileURL, repoRoot)\n        let key = repoRoot.path + \"::\" + relPath\n\n        if let cached = cache[key] {\n            return cached\n        }\n\n        // `--line-porcelain` yields stable key-value blocks per line.\n        let out = try await GitShell.runGit(\n            args: [\"-C\", repoRoot.path, \"blame\", \"--line-porcelain\", \"--\", relPath],\n            in: repoRoot\n        )\n\n        let parsed = Self.parseLinePorcelain(out)\n        cache[key] = parsed\n        return parsed\n    }\n\n    private static func parseLinePorcelain(_ text: String) -> [GitBlameLine] {\n        // Format:\n        // <sha> <origLine> <finalLine> <numLines>\n        // author <name>\n        // author-time <unix>\n        // summary <text>\n        // ...\n        // \\t<source line>\n        var results: [GitBlameLine] = []\n\n        var currentCommit: String = \"\"\n        var currentAuthor: String = \"\"\n        var currentAuthorTime: Date?\n        var currentSummary: String = \"\"\n        var currentFinalLine: Int?\n\n        func isHexString(_ s: Substring) -> Bool {\n            !s.isEmpty && s.allSatisfy { $0.isHexDigit }\n        }\n\n        func flushIfPossible() {\n            guard let lineNo = currentFinalLine, !currentCommit.isEmpty else { return }\n            results.append(\n                GitBlameLine(\n                    line: lineNo,\n                    commit: currentCommit,\n                    author: currentAuthor,\n                    authorTime: currentAuthorTime,\n                    summary: currentSummary\n                )\n            )\n            currentCommit = \"\"\n            currentAuthor = \"\"\n            currentAuthorTime = nil\n            currentSummary = \"\"\n            currentFinalLine = nil\n        }\n\n        for raw in text.split(separator: \"\\n\", omittingEmptySubsequences: false) {\n            let line = String(raw)\n\n            if line.hasPrefix(\"\\t\") {\n                // End of block for one line.\n                flushIfPossible()\n                continue\n            }\n\n            // Block header line:\n            // <sha> <origLine> <finalLine> <numLines>\n            let parts = line.split(separator: \" \")\n            if parts.count >= 3,\n               isHexString(parts[0]),\n               Int(parts[1]) != nil,\n               let final = Int(parts[2]) {\n                // Defensive flush if previous wasn't closed cleanly.\n                if currentFinalLine != nil {\n                    flushIfPossible()\n                }\n                currentCommit = String(parts[0])\n                currentFinalLine = final\n                continue\n            }\n\n            if line.hasPrefix(\"author \") {\n                currentAuthor = String(line.dropFirst(\"author \".count))\n            } else if line.hasPrefix(\"author-time \") {\n                let ts = String(line.dropFirst(\"author-time \".count))\n                if let t = TimeInterval(ts) {\n                    currentAuthorTime = Date(timeIntervalSince1970: t)\n                }\n            } else if line.hasPrefix(\"summary \") {\n                currentSummary = String(line.dropFirst(\"summary \".count))\n            }\n        }\n\n        // Final flush (if last block didn't end with \\t line for any reason)\n        flushIfPossible()\n\n        return results.sorted { $0.line < $1.line }\n    }\n}\n"}
>>>END

>>>TOOL create_file
{"path":"Views/Editor/GitGutterView.swift","overwrite":true,"content":"import Foundation\nimport SwiftUI\n\n// MARK: - FEAT-071 Git gutter indicators + FEAT-072 Inline blame\n//\n// This file is self-contained and provides:\n// - FEAT-071: Git gutter indicators (added/modified/deleted)\n// - FEAT-072: Inline blame label (for selected/caret line)\n//\n// IMPORTANT (integration):\n// - Host editor must overlay/place this view aligned to the text content.\n// - Host editor should provide:\n//   - fileURL\n//   - visibleLineRange (1-based, end-exclusive)\n//   - lineHeight\n//   - contentTopInset\n//   - selectedLine (1-based)\n//   - refreshToken (bump to refresh when content/git state changes)\n// - If your app already has git diff/blame services, inject them via `dataSource`.\n\n// MARK: Models\n\npublic enum GitLineChangeKind: Hashable, Sendable {\n    case added\n    case modified\n    /// Represents a deletion marker at a line boundary (typically drawn between lines).\n    case deleted\n}\n\npublic struct GitLineChange: Hashable, Sendable {\n    public var line: Int // 1-based (new-file line number)\n    public var kind: GitLineChangeKind\n\n    public init(line: Int, kind: GitLineChangeKind) {\n        self.line = line\n        self.kind = kind\n    }\n}\n\npublic struct GitBlameLine: Hashable, Sendable {\n    public var line: Int // 1-based\n    public var commit: String\n    public var author: String\n    public var authorTime: Date?\n    public var summary: String\n\n    public init(line: Int, commit: String, author: String, authorTime: Date?, summary: String) {\n        self.line = line\n        self.commit = commit\n        self.author = author\n        self.authorTime = authorTime\n        self.summary = summary\n    }\n}\n\n// MARK: - Data source (injectable)\n\npublic struct GitGutterDataSource: Sendable {\n    public var diff: @Sendable (_ fileURL: URL, _ forceRefresh: Bool) async throws -> [GitLineChange]\n    public var blame: @Sendable (_ fileURL: URL, _ forceRefresh: Bool) async throws -> [GitBlameLine]\n\n    public init(\n        diff: @escaping @Sendable (_ fileURL: URL, _ forceRefresh: Bool) async throws -> [GitLineChange],\n        blame: @escaping @Sendable (_ fileURL: URL, _ forceRefresh: Bool) async throws -> [GitBlameLine]\n    ) {\n        self.diff = diff\n        self.blame = blame\n    }\n}\n\npublic extension GitGutterDataSource {\n    /// Default behavior:\n    /// - On macOS/Mac Catalyst/Linux: attempts to run `git diff` and `git blame` via `Process`.\n    /// - On iOS (non-Catalyst): returns empty results (host should inject a real dataSource).\n    static var `default`: GitGutterDataSource {\n        #if os(iOS) && !targetEnvironment(macCatalyst)\n        return .empty\n        #else\n        return .gitCLI\n        #endif\n    }\n\n    static var empty: GitGutterDataSource {\n        GitGutterDataSource(\n            diff: { _, _ in [] },\n            blame: { _, _ in [] }\n        )\n    }\n\n    /// Git CLI-backed data source (uses `git diff` / `git blame`).\n    static var gitCLI: GitGutterDataSource {\n        GitGutterDataSource(\n            diff: { fileURL, force in\n                if force { await GitDiffService.shared.invalidate(forFile: fileURL) }\n                return try await GitDiffService.shared.lineChanges(forFile: fileURL)\n            },\n            blame: { fileURL, force in\n                if force { await GitBlameService.shared.invalidate(forFile: fileURL) }\n                return try await GitBlameService.shared.blame(forFile: fileURL)\n            }\n        )\n    }\n}\n\n// MARK: - View\n\n/// Gutter view that renders git diff indicators (added/modified/deleted) and an optional inline blame label.\npublic struct GitGutterView: View {\n    public struct Configuration: Sendable {\n        public var showsDiffIndicators: Bool = true\n        public var showsInlineBlame: Bool = true\n\n        public var gutterWidth: CGFloat = 6\n        public var gutterCornerRadius: CGFloat = 1\n\n        public var inlineBlameLeadingPadding: CGFloat = 8\n        public var inlineBlameTrailingPadding: CGFloat = 8\n        public var inlineBlameFont: Font = .system(size: 11, weight: .regular, design: .monospaced)\n        public var inlineBlameMaxWidth: CGFloat = 420\n\n        public var addedColor: Color = Color(red: 0.20, green: 0.78, blue: 0.35)\n        public var modifiedColor: Color = Color(red: 0.20, green: 0.55, blue: 0.95)\n        public var deletedColor: Color = Color(red: 0.92, green: 0.30, blue: 0.24)\n\n        public var inlineBlameTextColor: Color = .secondary\n        public var inlineBlameBackground: Color = Color.secondary.opacity(0.10)\n        public var inlineBlameCornerRadius: CGFloat = 6\n\n        public init() {}\n    }\n\n    private let fileURL: URL\n    private let visibleLineRange: Range<Int> // 1-based, end-exclusive\n    private let lineHeight: CGFloat\n    private let contentTopInset: CGFloat\n    private let selectedLine: Int?\n    private let refreshToken: AnyHashable\n    private let configuration: Configuration\n    private let dataSource: GitGutterDataSource\n\n    @State private var changesByLine: [Int: GitLineChangeKind] = [:]\n    @State private var deletedMarkers: Set<Int> = []\n    @State private var blameByLine: [Int: GitBlameLine] = [:]\n\n    public init(\n        fileURL: URL,\n        visibleLineRange: Range<Int>,\n        lineHeight: CGFloat,\n        contentTopInset: CGFloat = 0,\n        selectedLine: Int? = nil,\n        refreshToken: AnyHashable = 0,\n        configuration: Configuration = .init(),\n        dataSource: GitGutterDataSource = .default\n    ) {\n        self.fileURL = fileURL\n        self.visibleLineRange = visibleLineRange\n        self.lineHeight = lineHeight\n        self.contentTopInset = contentTopInset\n        self.selectedLine = selectedLine\n        self.refreshToken = refreshToken\n        self.configuration = configuration\n        self.dataSource = dataSource\n    }\n\n    public var body: some View {\n        HStack(spacing: 0) {\n            if configuration.showsDiffIndicators {\n                diffGutter\n                    .frame(width: configuration.gutterWidth)\n            }\n\n            if configuration.showsInlineBlame {\n                inlineBlameColumn\n            }\n        }\n        // Reload when:\n        // - file changes\n        // - refreshToken changes (host signals content/git refresh)\n        .task(id: fileURL) {\n            await reloadAll(force: true)\n        }\n        .task(id: refreshToken) {\n            await reloadAll(force: true)\n        }\n    }\n\n    private var diffGutter: some View {\n        GeometryReader { _ in\n            Canvas { context, size in\n                guard !visibleLineRange.isEmpty else { return }\n\n                let w = size.width\n                let corner = configuration.gutterCornerRadius\n\n                for line in visibleLineRange {\n                    if let kind = changesByLine[line] {\n                        let y = contentTopInset + CGFloat(line - visibleLineRange.lowerBound) * lineHeight\n                        let rect = CGRect(x: 0, y: y, width: w, height: max(1, lineHeight))\n                        let path = Path(roundedRect: rect, cornerRadius: corner)\n                        context.fill(path, with: .color(color(for: kind)))\n                    }\n\n                    // Deleted markers are drawn as triangles at the boundary.\n                    if deletedMarkers.contains(line) {\n                        let y = contentTopInset + CGFloat(line - visibleLineRange.lowerBound) * lineHeight\n                        var p = Path()\n                        p.move(to: CGPoint(x: 0, y: y))\n                        p.addLine(to: CGPoint(x: w, y: y + (lineHeight * 0.5)))\n                        p.addLine(to: CGPoint(x: 0, y: y + lineHeight))\n                        p.closeSubpath()\n                        context.fill(p, with: .color(configuration.deletedColor))\n                    }\n                }\n            }\n        }\n        .accessibilityLabel(\"Git diff gutter\")\n    }\n\n    private var inlineBlameColumn: some View {\n        ZStack(alignment: .topLeading) {\n            if let selectedLine,\n               let blame = blameByLine[selectedLine],\n               visibleLineRange.contains(selectedLine) {\n                let y = contentTopInset + CGFloat(selectedLine - visibleLineRange.lowerBound) * lineHeight\n\n                inlineBlameLabel(for: blame)\n                    .frame(maxWidth: configuration.inlineBlameMaxWidth, alignment: .leading)\n                    .offset(x: configuration.inlineBlameLeadingPadding, y: y)\n                    .allowsHitTesting(false)\n            }\n        }\n        .padding(.trailing, configuration.inlineBlameTrailingPadding)\n        .accessibilityLabel(\"Inline git blame\")\n    }\n\n    @ViewBuilder\n    private func inlineBlameLabel(for blame: GitBlameLine) -> some View {\n        let commitShort = String(blame.commit.prefix(8))\n        let author = blame.author.isEmpty ? \"Unknown\" : blame.author\n        let summary = blame.summary\n\n        Text(\"\\(author) \\(commitShort) — \\(summary)\")\n            .font(configuration.inlineBlameFont)\n            .foregroundStyle(configuration.inlineBlameTextColor)\n            .lineLimit(1)\n            .truncationMode(.tail)\n            .padding(.horizontal, 8)\n            .padding(.vertical, 4)\n            .background(configuration.inlineBlameBackground)\n            .clipShape(RoundedRectangle(cornerRadius: configuration.inlineBlameCornerRadius, style: .continuous))\n    }\n\n    private func color(for kind: GitLineChangeKind) -> Color {\n        switch kind {\n        case .added: return configuration.addedColor\n        case .modified: return configuration.modifiedColor\n        case .deleted: return configuration.deletedColor\n        }\n    }\n\n    // MARK: Reload\n\n    @MainActor\n    private func reloadAll(force: Bool) async {\n        // Diff\n        if configuration.showsDiffIndicators {\n            do {\n                let diff = try await dataSource.diff(fileURL, force)\n                var byLine: [Int: GitLineChangeKind] = [:]\n                var deletions: Set<Int> = []\n\n                for c in diff {\n                    switch c.kind {\n                    case .deleted:\n                        deletions.insert(max(1, c.line))\n                    case .added, .modified:\n                        byLine[c.line] = c.kind\n                    }\n                }\n\n                self.changesByLine = byLine\n                self.deletedMarkers = deletions\n            } catch {\n                self.changesByLine = [:]\n                self.deletedMarkers = []\n            }\n        }\n\n        // Blame\n        if configuration.showsInlineBlame {\n            do {\n                let blame = try await dataSource.blame(fileURL, force)\n                self.blameByLine = Dictionary(uniqueKeysWithValues: blame.map { ($0.line, $0) })\n            } catch {\n                self.blameByLine = [:]\n            }\n        }\n    }\n}\n\n// MARK: - Minimal Git wrappers (CLI-backed)\n\nprivate enum GitError: Error, LocalizedError {\n    case notARepository\n    case commandFailed(String)\n\n    var errorDescription: String? {\n        switch self {\n        case .notARepository:\n            return \"Not a git repository\"\n        case .commandFailed(let msg):\n            return \"Git command failed: \\(msg)\"\n        }\n    }\n}\n\nprivate struct GitShell {\n    static func runGit(args: [String], in workingDirectory: URL) async throws -> String {\n        #if os(macOS) || targetEnvironment(macCatalyst) || os(Linux)\n        return try await withCheckedThrowingContinuation { cont in\n            let process = Process()\n            process.executableURL = URL(fileURLWithPath: \"/usr/bin/env\")\n            process.arguments = [\"git\"] + args\n            process.currentDirectoryURL = workingDirectory\n\n            let outPipe = Pipe()\n            let errPipe = Pipe()\n            process.standardOutput = outPipe\n            process.standardError = errPipe\n\n            do {\n                try process.run()\n            } catch {\n                cont.resume(throwing: GitError.commandFailed(\"Unable to launch git\"))\n                return\n            }\n\n            process.terminationHandler = { p in\n                let outData = outPipe.fileHandleForReading.readDataToEndOfFile()\n                let errData = errPipe.fileHandleForReading.readDataToEndOfFile()\n\n                let out = String(data: outData, encoding: .utf8) ?? \"\"\n                let err = String(data: errData, encoding: .utf8) ?? \"\"\n\n                if p.terminationStatus == 0 {\n                    cont.resume(returning: out)\n                } else {\n                    let msg = err.trimmingCharacters(in: .whitespacesAndNewlines)\n                    cont.resume(throwing: GitError.commandFailed(msg.isEmpty ? out : msg))\n                }\n            }\n        }\n        #else\n        throw GitError.commandFailed(\"Git execution is not available on this platform\")\n        #endif\n    }\n\n    static func repoRoot(containing fileURL: URL) async throws -> URL {\n        let dir = fileURL.deletingLastPathComponent()\n        let out = try await runGit(args: [\"-C\", dir.path, \"rev-parse\", \"--show-toplevel\"], in: dir)\n        let rootPath = out.trimmingCharacters(in: .whitespacesAndNewlines)\n        if rootPath.isEmpty { throw GitError.notARepository }\n        return URL(fileURLWithPath: rootPath)\n    }\n}\n\n// MARK: - Diff\n\nprivate actor GitDiffService {\n    static let shared = GitDiffService()\n\n    private var cache: [String: [GitLineChange]] = [:] // key: repoRoot + fileRelPath\n\n    func invalidate(forFile fileURL: URL) async {\n        do {\n            let repoRoot = try await GitShell.repoRoot(containing: fileURL)\n            let relPath = Self.relativePath(fileURL, repoRoot)\n            let key = repoRoot.path + \"::\" + relPath\n            cache.removeValue(forKey: key)\n        } catch {\n            // ignore\n        }\n    }\n\n    func lineChanges(forFile fileURL: URL) async throws -> [GitLineChange] {\n        let repoRoot = try await GitShell.repoRoot(containing: fileURL)\n        let relPath = Self.relativePath(fileURL, repoRoot)\n        let key = repoRoot.path + \"::\" + relPath\n\n        if let cached = cache[key] { return cached }\n\n        // Unified=0 makes hunks contain only the changed lines, simplifying mapping.\n        let diff = try await GitShell.runGit(\n            args: [\"-C\", repoRoot.path, \"diff\", \"--unified=0\", \"--no-color\", \"--\", relPath],\n            in: repoRoot\n        )\n\n        let parsed = Self.parseUnifiedZeroDiff(diff)\n        cache[key] = parsed\n        return parsed\n    }\n\n    fileprivate static func relativePath(_ fileURL: URL, _ repoRoot: URL) -> String {\n        let filePath = fileURL.standardizedFileURL.path\n        let rootPath = repoRoot.standardizedFileURL.path\n        if filePath.hasPrefix(rootPath + \"/\") {\n            return String(filePath.dropFirst(rootPath.count + 1))\n        }\n        return fileURL.lastPathComponent\n    }\n\n    /// Parse output from: `git diff --unified=0 --no-color -- <file>`.\n    ///\n    /// Heuristic classification per hunk:\n    /// - oldCount==0,newCount>0 -> .added on new range\n    /// - oldCount>0,newCount>0 -> .modified on new range\n    /// - oldCount>0,newCount==0 -> .deleted marker at newStart\n    private static func parseUnifiedZeroDiff(_ text: String) -> [GitLineChange] {\n        var results: [GitLineChange] = []\n\n        // Example hunk header (unified=0):\n        // @@ -12,2 +12,3 @@\n        // or @@ -12 +12 @@\n        let lines = text.split(separator: \"\\n\", omittingEmptySubsequences: false)\n\n        for raw in lines {\n            let line = String(raw)\n            guard line.hasPrefix(\"@@\"), let h = parseHunkHeader(line) else { continue }\n\n            if h.oldCount == 0 && h.newCount > 0 {\n                for n in 0..<h.newCount {\n                    results.append(.init(line: h.newStart + n, kind: .added))\n                }\n            } else if h.oldCount > 0 && h.newCount > 0 {\n                for n in 0..<h.newCount {\n                    results.append(.init(line: h.newStart + n, kind: .modified))\n                }\n            } else if h.oldCount > 0 && h.newCount == 0 {\n                results.append(.init(line: max(1, h.newStart), kind: .deleted))\n            }\n        }\n\n        // De-dupe (prefer modified over added if collision).\n        var byLine: [Int: GitLineChangeKind] = [:]\n        var deleted: Set<Int> = []\n        for r in results {\n            switch r.kind {\n            case .deleted:\n                deleted.insert(r.line)\n            case .added:\n                if byLine[r.line] == nil { byLine[r.line] = .added }\n            case .modified:\n                byLine[r.line] = .modified\n            }\n        }\n\n        var merged: [GitLineChange] = []\n        for (line, kind) in byLine { merged.append(.init(line: line, kind: kind)) }\n        for d in deleted { merged.append(.init(line: d, kind: .deleted)) }\n\n        return merged.sorted { $0.line < $1.line }\n    }\n\n    private struct Hunk {\n        var oldStart: Int\n        var oldCount: Int\n        var newStart: Int\n        var newCount: Int\n    }\n\n    private static func parseHunkHeader(_ header: String) -> Hunk? {\n        // Header format: @@ -oldStart,oldCount +newStart,newCount @@ ...\n        // Counts may be omitted: -12 +12\n        guard let rangeStart = header.range(of: \"@@\") else { return nil }\n        guard let rangeEnd = header.range(of: \"@@\", options: [], range: rangeStart.upperBound..<header.endIndex) else { return nil }\n        let body = header[rangeStart.upperBound..<rangeEnd.lowerBound].trimmingCharacters(in: .whitespaces)\n\n        let parts = body.split(separator: \" \")\n        guard parts.count >= 2 else { return nil }\n\n        func parsePart(_ s: Substring, prefix: Character) -> (Int, Int)? {\n            guard s.first == prefix else { return nil }\n            let rest = s.dropFirst()\n            if let comma = rest.firstIndex(of: \",\") {\n                let a = rest[..<comma]\n                let b = rest[rest.index(after: comma)...]\n                guard let start = Int(a), let count = Int(b) else { return nil }\n                return (start, count)\n            } else {\n                guard let start = Int(rest) else { return nil }\n                return (start, 1)\n            }\n        }\n\n        guard let old = parsePart(parts[0], prefix: \"-\") else { return nil }\n        guard let new = parsePart(parts[1], prefix: \"+\") else { return nil }\n        return Hunk(oldStart: old.0, oldCount: old.1, newStart: new.0, newCount: new.1)\n    }\n}\n\n// MARK: - Blame\n\nprivate actor GitBlameService {\n    static let shared = GitBlameService()\n\n    private var cache: [String: [GitBlameLine]] = [:] // key: repoRoot + fileRelPath\n\n    func invalidate(forFile fileURL: URL) async {\n        do {\n            let repoRoot = try await GitShell.repoRoot(containing: fileURL)\n            let relPath = GitDiffService.relativePath(fileURL, repoRoot)\n            let key = repoRoot.path + \"::\" + relPath\n            cache.removeValue(forKey: key)\n        } catch {\n            // ignore\n        }\n    }\n\n    func blame(forFile fileURL: URL) async throws -> [GitBlameLine] {\n        let repoRoot = try await GitShell.repoRoot(containing: fileURL)\n        let relPath = GitDiffService.relativePath(fileURL, repoRoot)\n        let key = repoRoot.path + \"::\" + relPath\n\n        if let cached = cache[key] { return cached }\n\n        let out = try await GitShell.runGit(\n            args: [\"-C\", repoRoot.path, \"blame\", \"--line-porcelain\", \"--\", relPath],\n            in: repoRoot\n        )\n\n        let parsed = Self.parseLinePorcelain(out)\n        cache[key] = parsed\n        return parsed\n    }\n\n    private static func parseLinePorcelain(_ text: String) -> [GitBlameLine] {\n        // Format:\n        // <sha> <origLine> <finalLine> <numLines>\n        // author <name>\n        // author-time <unix>\n        // summary <text>\n        // ...\n        // \\t<source line>\n        var results: [GitBlameLine] = []\n\n        var currentCommit: String = \"\"\n        var currentAuthor: String = \"\"\n        var currentAuthorTime: Date?\n        var currentSummary: String = \"\"\n        var currentFinalLine: Int?\n\n        func isHexString(_ s: Substring) -> Bool {\n            !s.isEmpty && s.allSatisfy { $0.isHexDigit }\n        }\n\n        func flushIfPossible() {\n            guard let lineNo = currentFinalLine, !currentCommit.isEmpty else { return }\n            results.append(\n                GitBlameLine(\n                    line: lineNo,\n                    commit: currentCommit,\n                    author: currentAuthor,\n                    authorTime: currentAuthorTime,\n                    summary: currentSummary\n                )\n            )\n            currentCommit = \"\"\n            currentAuthor = \"\"\n            currentAuthorTime = nil\n            currentSummary = \"\"\n            currentFinalLine = nil\n        }\n\n        for raw in text.split(separator: \"\\n\", omittingEmptySubsequences: false) {\n            let line = String(raw)\n\n            if line.hasPrefix(\"\\t\") {\n                flushIfPossible()\n                continue\n            }\n\n            let parts = line.split(separator: \" \")\n            if parts.count >= 3,\n               isHexString(parts[0]),\n               Int(parts[1]) != nil,\n               let final = Int(parts[2]) {\n                if currentFinalLine != nil {\n                    flushIfPossible()\n                }\n                currentCommit = String(parts[0])\n                currentFinalLine = final\n                continue\n            }\n\n            if line.hasPrefix(\"author \") {\n                currentAuthor = String(line.dropFirst(\"author \".count))\n            } else if line.hasPrefix(\"author-time \") {\n                let ts = String(line.dropFirst(\"author-time \".count))\n                if let t = TimeInterval(ts) {\n                    currentAuthorTime = Date(timeIntervalSince1970: t)\n                }\n            } else if line.hasPrefix(\"summary \") {\n                currentSummary = String(line.dropFirst(\"summary \".count))\n            }\n        }\n\n        flushIfPossible()\n        return results.sorted { $0.line < $1.line }\n    }\n}\n"}
>>>END

>>>TOOL read_file
{"path":"Views/Editor/GitGutterView.swift","start_line":1,"end_line":120}
>>>END

>>>TOOL read_file
{"path":"Views/Editor/GitGutterView.swift","start_line":1,"end_line":15}
>>>END

>>>TOOL create_file
{"path":"Views/Editor/GitGutterView.swift","overwrite":true,"content":"import Foundation\nimport SwiftUI\n\n// MARK: - FEAT-071 Git gutter indicators + FEAT-072 Inline blame\n//\n// This file is self-contained and provides:\n// - FEAT-071: Git gutter indicators (added/modified/deleted)\n// - FEAT-072: Inline blame label (for selected/caret line)\n//\n// IMPORTANT (integration):\n// - Host editor must overlay/place this view aligned to the text content.\n// - Host editor should provide:\n//   - fileURL\n//   - visibleLineRange (1-based, end-exclusive)\n//   - lineHeight\n//   - contentTopInset\n//   - selectedLine (1-based)\n//   - refreshToken (bump to refresh when content/git state changes)\n// - If your app already has git diff/blame services, inject them via `dataSource`.\n\n// MARK: Models\n\npublic enum GitLineChangeKind: Hashable, Sendable {\n    case added\n    case modified\n    /// Represents a deletion marker at a line boundary (typically drawn between lines).\n    case deleted\n}\n\npublic struct GitLineChange: Hashable, Sendable {\n    public var line: Int // 1-based (new-file line number)\n    public var kind: GitLineChangeKind\n\n    public init(line: Int, kind: GitLineChangeKind) {\n        self.line = line\n        self.kind = kind\n    }\n}\n\npublic struct GitBlameLine: Hashable, Sendable {\n    public var line: Int // 1-based\n    public var commit: String\n    public var author: String\n    public var authorTime: Date?\n    public var summary: String\n\n    public init(line: Int, commit: String, author: String, authorTime: Date?, summary: String) {\n        self.line = line\n        self.commit = commit\n        self.author = author\n        self.authorTime = authorTime\n        self.summary = summary\n    }\n}\n\n// MARK: - Data source (injectable)\n\npublic struct GitGutterDataSource {\n    public var diff: @Sendable (_ fileURL: URL, _ forceRefresh: Bool) async throws -> [GitLineChange]\n    public var blame: @Sendable (_ fileURL: URL, _ forceRefresh: Bool) async throws -> [GitBlameLine]\n\n    public init(\n        diff: @escaping @Sendable (_ fileURL: URL, _ forceRefresh: Bool) async throws -> [GitLineChange],\n        blame: @escaping @Sendable (_ fileURL: URL, _ forceRefresh: Bool) async throws -> [GitBlameLine]\n    ) {\n        self.diff = diff\n        self.blame = blame\n    }\n}\n\npublic extension GitGutterDataSource {\n    /// Default behavior:\n    /// - On macOS/Mac Catalyst/Linux: attempts to run `git diff` and `git blame` via `Process`.\n    /// - On iOS (non-Catalyst): returns empty results (host should inject a real dataSource).\n    static var `default`: GitGutterDataSource {\n        #if os(iOS) && !targetEnvironment(macCatalyst)\n        return .empty\n        #else\n        return .gitCLI\n        #endif\n    }\n\n    static var empty: GitGutterDataSource {\n        GitGutterDataSource(\n            diff: { _, _ in [] },\n            blame: { _, _ in [] }\n        )\n    }\n\n    /// Git CLI-backed data source (uses `git diff` / `git blame`).\n    static var gitCLI: GitGutterDataSource {\n        GitGutterDataSource(\n            diff: { fileURL, force in\n                if force { await GitDiffService.shared.invalidate(forFile: fileURL) }\n                return try await GitDiffService.shared.lineChanges(forFile: fileURL)\n            },\n            blame: { fileURL, force in\n                if force { await GitBlameService.shared.invalidate(forFile: fileURL) }\n                return try await GitBlameService.shared.blame(forFile: fileURL)\n            }\n        )\n    }\n}\n\n// MARK: - View\n\n/// Gutter view that renders git diff indicators (added/modified/deleted) and an optional inline blame label.\npublic struct GitGutterView: View {\n    public struct Configuration {\n        public var showsDiffIndicators: Bool = true\n        public var showsInlineBlame: Bool = true\n\n        public var gutterWidth: CGFloat = 6\n        public var gutterCornerRadius: CGFloat = 1\n\n        public var inlineBlameLeadingPadding: CGFloat = 8\n        public var inlineBlameTrailingPadding: CGFloat = 8\n        public var inlineBlameFont: Font = .system(size: 11, weight: .regular, design: .monospaced)\n        public var inlineBlameMaxWidth: CGFloat = 420\n\n        public var addedColor: Color = Color(red: 0.20, green: 0.78, blue: 0.35)\n        public var modifiedColor: Color = Color(red: 0.20, green: 0.55, blue: 0.95)\n        public var deletedColor: Color = Color(red: 0.92, green: 0.30, blue: 0.24)\n\n        public var inlineBlameTextColor: Color = .secondary\n        public var inlineBlameBackground: Color = Color.secondary.opacity(0.10)\n        public var inlineBlameCornerRadius: CGFloat = 6\n\n        public init() {}\n    }\n\n    private let fileURL: URL\n    private let visibleLineRange: Range<Int> // 1-based, end-exclusive\n    private let lineHeight: CGFloat\n    private let contentTopInset: CGFloat\n    private let selectedLine: Int?\n    private let refreshToken: AnyHashable\n    private let configuration: Configuration\n    private let dataSource: GitGutterDataSource\n\n    @State private var changesByLine: [Int: GitLineChangeKind] = [:]\n    @State private var deletedMarkers: Set<Int> = []\n    @State private var blameByLine: [Int: GitBlameLine] = [:]\n\n    public init(\n        fileURL: URL,\n        visibleLineRange: Range<Int>,\n        lineHeight: CGFloat,\n        contentTopInset: CGFloat = 0,\n        selectedLine: Int? = nil,\n        refreshToken: AnyHashable = 0,\n        configuration: Configuration = .init(),\n        dataSource: GitGutterDataSource = .default\n    ) {\n        self.fileURL = fileURL\n        self.visibleLineRange = visibleLineRange\n        self.lineHeight = lineHeight\n        self.contentTopInset = contentTopInset\n        self.selectedLine = selectedLine\n        self.refreshToken = refreshToken\n        self.configuration = configuration\n        self.dataSource = dataSource\n    }\n\n    public var body: some View {\n        HStack(spacing: 0) {\n            if configuration.showsDiffIndicators {\n                diffGutter\n                    .frame(width: configuration.gutterWidth)\n            }\n\n            if configuration.showsInlineBlame {\n                inlineBlameColumn\n            }\n        }\n        // Reload when:\n        // - file changes\n        // - refreshToken changes (host signals content/git refresh)\n        .task(id: fileURL) {\n            await reloadAll(force: true)\n        }\n        .task(id: refreshToken) {\n            await reloadAll(force: true)\n        }\n    }\n\n    private var diffGutter: some View {\n        GeometryReader { _ in\n            Canvas { context, size in\n                guard !visibleLineRange.isEmpty else { return }\n\n                let w = size.width\n                let corner = configuration.gutterCornerRadius\n\n                for line in visibleLineRange {\n                    if let kind = changesByLine[line] {\n                        let y = contentTopInset + CGFloat(line - visibleLineRange.lowerBound) * lineHeight\n                        let rect = CGRect(x: 0, y: y, width: w, height: max(1, lineHeight))\n                        let path = Path(roundedRect: rect, cornerRadius: corner)\n                        context.fill(path, with: .color(color(for: kind)))\n                    }\n\n                    // Deleted markers are drawn as triangles at the boundary.\n                    if deletedMarkers.contains(line) {\n                        let y = contentTopInset + CGFloat(line - visibleLineRange.lowerBound) * lineHeight\n                        var p = Path()\n                        p.move(to: CGPoint(x: 0, y: y))\n                        p.addLine(to: CGPoint(x: w, y: y + (lineHeight * 0.5)))\n                        p.addLine(to: CGPoint(x: 0, y: y + lineHeight))\n                        p.closeSubpath()\n                        context.fill(p, with: .color(configuration.deletedColor))\n                    }\n                }\n            }\n        }\n        .accessibilityLabel(\"Git diff gutter\")\n    }\n\n    private var inlineBlameColumn: some View {\n        ZStack(alignment: .topLeading) {\n            if let selectedLine,\n               let blame = blameByLine[selectedLine],\n               visibleLineRange.contains(selectedLine) {\n                let y = contentTopInset + CGFloat(selectedLine - visibleLineRange.lowerBound) * lineHeight\n\n                inlineBlameLabel(for: blame)\n                    .frame(maxWidth: configuration.inlineBlameMaxWidth, alignment: .leading)\n                    .offset(x: configuration.inlineBlameLeadingPadding, y: y)\n                    .allowsHitTesting(false)\n            }\n        }\n        .padding(.trailing, configuration.inlineBlameTrailingPadding)\n        .accessibilityLabel(\"Inline git blame\")\n    }\n\n    @ViewBuilder\n    private func inlineBlameLabel(for blame: GitBlameLine) -> some View {\n        let commitShort = String(blame.commit.prefix(8))\n        let author = blame.author.isEmpty ? \"Unknown\" : blame.author\n        let summary = blame.summary\n\n        Text(\"\\(author) \\(commitShort) — \\(summary)\")\n            .font(configuration.inlineBlameFont)\n            .foregroundStyle(configuration.inlineBlameTextColor)\n            .lineLimit(1)\n            .truncationMode(.tail)\n            .padding(.horizontal, 8)\n            .padding(.vertical, 4)\n            .background(configuration.inlineBlameBackground)\n            .clipShape(RoundedRectangle(cornerRadius: configuration.inlineBlameCornerRadius, style: .continuous))\n    }\n\n    private func color(for kind: GitLineChangeKind) -> Color {\n        switch kind {\n        case .added: return configuration.addedColor\n        case .modified: return configuration.modifiedColor\n        case .deleted: return configuration.deletedColor\n        }\n    }\n\n    // MARK: Reload\n\n    @MainActor\n    private func reloadAll(force: Bool) async {\n        // Diff\n        if configuration.showsDiffIndicators {\n            do {\n                let diff = try await dataSource.diff(fileURL, force)\n                var byLine: [Int: GitLineChangeKind] = [:]\n                var deletions: Set<Int> = []\n\n                for c in diff {\n                    switch c.kind {\n                    case .deleted:\n                        deletions.insert(max(1, c.line))\n                    case .added, .modified:\n                        byLine[c.line] = c.kind\n                    }\n                }\n\n                self.changesByLine = byLine\n                self.deletedMarkers = deletions\n            } catch {\n                self.changesByLine = [:]\n                self.deletedMarkers = []\n            }\n        }\n\n        // Blame\n        if configuration.showsInlineBlame {\n            do {\n                let blame = try await dataSource.blame(fileURL, force)\n                self.blameByLine = Dictionary(uniqueKeysWithValues: blame.map { ($0.line, $0) })\n            } catch {\n                self.blameByLine = [:]\n            }\n        }\n    }\n}\n\n// MARK: - Minimal Git wrappers (CLI-backed)\n\nprivate enum GitError: Error, LocalizedError {\n    case notARepository\n    case commandFailed(String)\n\n    var errorDescription: String? {\n        switch self {\n        case .notARepository:\n            return \"Not a git repository\"\n        case .commandFailed(let msg):\n            return \"Git command failed: \\(msg)\"\n        }\n    }\n}\n\nprivate struct GitShell {\n    static func runGit(args: [String], in workingDirectory: URL) async throws -> String {\n        #if os(macOS) || targetEnvironment(macCatalyst) || os(Linux)\n        return try await withCheckedThrowingContinuation { cont in\n            let process = Process()\n            process.executableURL = URL(fileURLWithPath: \"/usr/bin/env\")\n            process.arguments = [\"git\"] + args\n            process.currentDirectoryURL = workingDirectory\n\n            let outPipe = Pipe()\n            let errPipe = Pipe()\n            process.standardOutput = outPipe\n            process.standardError = errPipe\n\n            do {\n                try process.run()\n            } catch {\n                cont.resume(throwing: GitError.commandFailed(\"Unable to launch git\"))\n                return\n            }\n\n            process.terminationHandler = { p in\n                let outData = outPipe.fileHandleForReading.readDataToEndOfFile()\n                let errData = errPipe.fileHandleForReading.readDataToEndOfFile()\n\n                let out = String(data: outData, encoding: .utf8) ?? \"\"\n                let err = String(data: errData, encoding: .utf8) ?? \"\"\n\n                if p.terminationStatus == 0 {\n                    cont.resume(returning: out)\n                } else {\n                    let msg = err.trimmingCharacters(in: .whitespacesAndNewlines)\n                    cont.resume(throwing: GitError.commandFailed(msg.isEmpty ? out : msg))\n                }\n            }\n        }\n        #else\n        throw GitError.commandFailed(\"Git execution is not available on this platform\")\n        #endif\n    }\n\n    static func repoRoot(containing fileURL: URL) async throws -> URL {\n        let dir = fileURL.deletingLastPathComponent()\n        let out = try await runGit(args: [\"-C\", dir.path, \"rev-parse\", \"--show-toplevel\"], in: dir)\n        let rootPath = out.trimmingCharacters(in: .whitespacesAndNewlines)\n        if rootPath.isEmpty { throw GitError.notARepository }\n        return URL(fileURLWithPath: rootPath)\n    }\n}\n\n// MARK: - Diff\n\nprivate actor GitDiffService {\n    static let shared = GitDiffService()\n\n    private var cache: [String: [GitLineChange]] = [:] // key: repoRoot + fileRelPath\n\n    func invalidate(forFile fileURL: URL) async {\n        do {\n            let repoRoot = try await GitShell.repoRoot(containing: fileURL)\n            let relPath = Self.relativePath(fileURL, repoRoot)\n            let key = repoRoot.path + \"::\" + relPath\n            cache.removeValue(forKey: key)\n        } catch {\n            // ignore\n        }\n    }\n\n    func lineChanges(forFile fileURL: URL) async throws -> [GitLineChange] {\n        let repoRoot = try await GitShell.repoRoot(containing: fileURL)\n        let relPath = Self.relativePath(fileURL, repoRoot)\n        let key = repoRoot.path + \"::\" + relPath\n\n        if let cached = cache[key] { return cached }\n\n        // Unified=0 makes hunks contain only the changed lines, simplifying mapping.\n        let diff = try await GitShell.runGit(\n            args: [\"-C\", repoRoot.path, \"diff\", \"--unified=0\", \"--no-color\", \"--\", relPath],\n            in: repoRoot\n        )\n\n        let parsed = Self.parseUnifiedZeroDiff(diff)\n        cache[key] = parsed\n        return parsed\n    }\n\n    fileprivate static func relativePath(_ fileURL: URL, _ repoRoot: URL) -> String {\n        let filePath = fileURL.standardizedFileURL.path\n        let rootPath = repoRoot.standardizedFileURL.path\n        if filePath.hasPrefix(rootPath + \"/\") {\n            return String(filePath.dropFirst(rootPath.count + 1))\n        }\n        return fileURL.lastPathComponent\n    }\n\n    /// Parse output from: `git diff --unified=0 --no-color -- <file>`.\n    ///\n    /// Heuristic classification per hunk:\n    /// - oldCount==0,newCount>0 -> .added on new range\n    /// - oldCount>0,newCount>0 -> .modified on new range\n    /// - oldCount>0,newCount==0 -> .deleted marker at newStart\n    private static func parseUnifiedZeroDiff(_ text: String) -> [GitLineChange] {\n        var results: [GitLineChange] = []\n\n        // Example hunk header (unified=0):\n        // @@ -12,2 +12,3 @@\n        // or @@ -12 +12 @@\n        for raw in text.split(separator: \"\\n\", omittingEmptySubsequences: false) {\n            let line = String(raw)\n            guard line.hasPrefix(\"@@\"), let h = parseHunkHeader(line) else { continue }\n\n            if h.oldCount == 0 && h.newCount > 0 {\n                for n in 0..<h.newCount {\n                    results.append(.init(line: h.newStart + n, kind: .added))\n                }\n            } else if h.oldCount > 0 && h.newCount > 0 {\n                for n in 0..<h.newCount {\n                    results.append(.init(line: h.newStart + n, kind: .modified))\n                }\n            } else if h.oldCount > 0 && h.newCount == 0 {\n                results.append(.init(line: max(1, h.newStart), kind: .deleted))\n            }\n        }\n\n        // De-dupe (prefer modified over added if collision).\n        var byLine: [Int: GitLineChangeKind] = [:]\n        var deleted: Set<Int> = []\n        for r in results {\n            switch r.kind {\n            case .deleted:\n                deleted.insert(r.line)\n            case .added:\n                if byLine[r.line] == nil { byLine[r.line] = .added }\n            case .modified:\n                byLine[r.line] = .modified\n            }\n        }\n\n        var merged: [GitLineChange] = []\n        for (line, kind) in byLine { merged.append(.init(line: line, kind: kind)) }\n        for d in deleted { merged.append(.init(line: d, kind: .deleted)) }\n\n        return merged.sorted { $0.line < $1.line }\n    }\n\n    private struct Hunk {\n        var oldStart: Int\n        var oldCount: Int\n        var newStart: Int\n        var newCount: Int\n    }\n\n    private static func parseHunkHeader(_ header: String) -> Hunk? {\n        // Header format: @@ -oldStart,oldCount +newStart,newCount @@ ...\n        // Counts may be omitted: -12 +12\n        guard let rangeStart = header.range(of: \"@@\") else { return nil }\n        guard let rangeEnd = header.range(of: \"@@\", options: [], range: rangeStart.upperBound..<header.endIndex) else { return nil }\n        let body = header[rangeStart.upperBound..<rangeEnd.lowerBound].trimmingCharacters(in: .whitespaces)\n\n        let parts = body.split(separator: \" \")\n        guard parts.count >= 2 else { return nil }\n\n        func parsePart(_ s: Substring, prefix: Character) -> (Int, Int)? {\n            guard s.first == prefix else { return nil }\n            let rest = s.dropFirst()\n            if let comma = rest.firstIndex(of: \",\") {\n                let a = rest[..<comma]\n                let b = rest[rest.index(after: comma)...]\n                guard let start = Int(a), let count = Int(b) else { return nil }\n                return (start, count)\n            } else {\n                guard let start = Int(rest) else { return nil }\n                return (start, 1)\n            }\n        }\n\n        guard let old = parsePart(parts[0], prefix: \"-\") else { return nil }\n        guard let new = parsePart(parts[1], prefix: \"+\") else { return nil }\n        return Hunk(oldStart: old.0, oldCount: old.1, newStart: new.0, newCount: new.1)\n    }\n}\n\n// MARK: - Blame\n\nprivate actor GitBlameService {\n    static let shared = GitBlameService()\n\n    private var cache: [String: [GitBlameLine]] = [:] // key: repoRoot + fileRelPath\n\n    func invalidate(forFile fileURL: URL) async {\n        do {\n            let repoRoot = try await GitShell.repoRoot(containing: fileURL)\n            let relPath = GitDiffService.relativePath(fileURL, repoRoot)\n            let key = repoRoot.path + \"::\" + relPath\n            cache.removeValue(forKey: key)\n        } catch {\n            // ignore\n        }\n    }\n\n    func blame(forFile fileURL: URL) async throws -> [GitBlameLine] {\n        let repoRoot = try await GitShell.repoRoot(containing: fileURL)\n        let relPath = GitDiffService.relativePath(fileURL, repoRoot)\n        let key = repoRoot.path + \"::\" + relPath\n\n        if let cached = cache[key] { return cached }\n\n        let out = try await GitShell.runGit(\n            args: [\"-C\", repoRoot.path, \"blame\", \"--line-porcelain\", \"--\", relPath],\n            in: repoRoot\n        )\n\n        let parsed = Self.parseLinePorcelain(out)\n        cache[key] = parsed\n        return parsed\n    }\n\n    private static func parseLinePorcelain(_ text: String) -> [GitBlameLine] {\n        // Format (porcelain):\n        // <sha> <origLine> <finalLine> <numLines>\n        // author <name>\n        // author-time <unix>\n        // summary <text>\n        // ...\n        // \\t<source line>\n        // (then additional \\t lines if <numLines> > 1)\n\n        var results: [GitBlameLine] = []\n\n        var currentCommit: String = \"\"\n        var currentAuthor: String = \"\"\n        var currentAuthorTime: Date?\n        var currentSummary: String = \"\"\n\n        var pendingFinalLine: Int?\n        var pendingRemaining: Int = 0\n\n        func isHexString(_ s: Substring) -> Bool {\n            !s.isEmpty && s.allSatisfy { $0.isHexDigit }\n        }\n\n        func emitOneLineIfPossible() {\n            guard pendingRemaining > 0,\n                  let ln = pendingFinalLine,\n                  !currentCommit.isEmpty else { return }\n\n            results.append(\n                GitBlameLine(\n                    line: ln,\n                    commit: currentCommit,\n                    author: currentAuthor,\n                    authorTime: currentAuthorTime,\n                    summary: currentSummary\n                )\n            )\n\n            pendingFinalLine = ln + 1\n            pendingRemaining -= 1\n\n            if pendingRemaining == 0 {\n                // Require a new header to start another group.\n                pendingFinalLine = nil\n                currentCommit = \"\"\n                currentAuthor = \"\"\n                currentAuthorTime = nil\n                currentSummary = \"\"\n            }\n        }\n\n        for raw in text.split(separator: \"\\n\", omittingEmptySubsequences: false) {\n            let line = String(raw)\n\n            if line.hasPrefix(\"\\t\") {\n                emitOneLineIfPossible()\n                continue\n            }\n\n            // Header line:\n            // <sha> <origLine> <finalLine> <numLines>\n            // (some variants may omit <numLines>; treat as 1)\n            let parts = line.split(separator: \" \")\n            if parts.count >= 3,\n               isHexString(parts[0]),\n               Int(parts[1]) != nil,\n               let final = Int(parts[2]) {\n                currentCommit = String(parts[0])\n                pendingFinalLine = final\n                pendingRemaining = (parts.count >= 4 ? Int(parts[3]) : nil) ?? 1\n                continue\n            }\n\n            if line.hasPrefix(\"author \") {\n                currentAuthor = String(line.dropFirst(\"author \".count))\n            } else if line.hasPrefix(\"author-time \") {\n                let ts = String(line.dropFirst(\"author-time \".count))\n                if let t = TimeInterval(ts) {\n                    currentAuthorTime = Date(timeIntervalSince1970: t)\n                }\n            } else if line.hasPrefix(\"summary \") {\n                currentSummary = String(line.dropFirst(\"summary \".count))\n            }\n        }\n\n        return results.sorted { $0.line < $1.line }\n    }\n}\n"}
>>>END

>>>TOOL read_file
{"path":"Views/Editor/GitGutterView.swift","start_line":1,"end_line":260}
>>>END

>>>TOOL read_file
{"path":"Views/Editor/GitGutterView.swift","start_line":1,"end_line":12}
>>>END



>>>TOOL read_file
{"path":"Views/Editor/GitGutterView.swift","start_line":1,"end_line":25}
>>>END

>>>TOOL read_file
{"path":"Views/Editor/GitGutterView.swift","start_line":1,"end_line":8}
>>>END

>>>TOOL read_file
{"path":"Views/Editor/GitGutterView.swift","start_line":1,"end_line":6}
>>>END

>>>TOOL create_file
{"path":"Views/Editor/GitGutterView.swift","overwrite":true,"content":"import Foundation\nimport SwiftUI\n\n// MARK: - FEAT-071 Git gutter indicators + FEAT-072 Inline blame\n//\n// This file is self-contained and provides:\n// - FEAT-071: Git gutter indicators (added/modified/deleted)\n// - FEAT-072: Inline blame label (for selected/caret line)\n//\n// IMPORTANT (integration):\n// - Host editor must overlay/place this view aligned to the text content.\n// - Host editor should provide:\n//   - fileURL\n//   - visibleLineRange (1-based, end-exclusive)\n//   - lineHeight\n//   - contentTopInset\n//   - selectedLine (1-based)\n//   - refreshToken (bump to refresh when content/git state changes)\n// - If your app already has git diff/blame services, inject them via `dataSource`.\n\n// MARK: Models\n\npublic enum GitLineChangeKind: Hashable, Sendable {\n    case added\n    case modified\n    /// Represents a deletion marker at a line boundary (typically drawn between lines).\n    case deleted\n}\n\npublic struct GitLineChange: Hashable, Sendable {\n    public var line: Int // 1-based (new-file line number)\n    public var kind: GitLineChangeKind\n\n    public init(line: Int, kind: GitLineChangeKind) {\n        self.line = line\n        self.kind = kind\n    }\n}\n\npublic struct GitBlameLine: Hashable, Sendable {\n    public var line: Int // 1-based\n    public var commit: String\n    public var author: String\n    public var authorTime: Date?\n    public var summary: String\n\n    public init(line: Int, commit: String, author: String, authorTime: Date?, summary: String) {\n        self.line = line\n        self.commit = commit\n        self.author = author\n        self.authorTime = authorTime\n        self.summary = summary\n    }\n}\n\n// MARK: - Data source (injectable)\n\npublic struct GitGutterDataSource {\n    public var diff: @Sendable (_ fileURL: URL, _ forceRefresh: Bool) async throws -> [GitLineChange]\n    public var blame: @Sendable (_ fileURL: URL, _ forceRefresh: Bool) async throws -> [GitBlameLine]\n\n    public init(\n        diff: @escaping @Sendable (_ fileURL: URL, _ forceRefresh: Bool) async throws -> [GitLineChange],\n        blame: @escaping @Sendable (_ fileURL: URL, _ forceRefresh: Bool) async throws -> [GitBlameLine]\n    ) {\n        self.diff = diff\n        self.blame = blame\n    }\n}\n\npublic extension GitGutterDataSource {\n    /// Default behavior:\n    /// - On macOS/Mac Catalyst/Linux: attempts to run `git diff` and `git blame` via `Process`.\n    /// - On iOS (non-Catalyst): returns empty results (host should inject a real dataSource).\n    static var `default`: GitGutterDataSource {\n        #if os(iOS) && !targetEnvironment(macCatalyst)\n        return .empty\n        #else\n        return .gitCLI\n        #endif\n    }\n\n    static var empty: GitGutterDataSource {\n        GitGutterDataSource(\n            diff: { _, _ in [] },\n            blame: { _, _ in [] }\n        )\n    }\n\n    /// Git CLI-backed data source (uses `git diff` / `git blame`).\n    static var gitCLI: GitGutterDataSource {\n        GitGutterDataSource(\n            diff: { fileURL, force in\n                if force { await GitDiffService.shared.invalidate(forFile: fileURL) }\n                return try await GitDiffService.shared.lineChanges(forFile: fileURL)\n            },\n            blame: { fileURL, force in\n                if force { await GitBlameService.shared.invalidate(forFile: fileURL) }\n                return try await GitBlameService.shared.blame(forFile: fileURL)\n            }\n        )\n    }\n}\n\n// MARK: - View\n\n/// Gutter view that renders git diff indicators (added/modified/deleted) and an optional inline blame label.\npublic struct GitGutterView: View {\n    public struct Configuration {\n        public var showsDiffIndicators: Bool = true\n        public var showsInlineBlame: Bool = true\n\n        public var gutterWidth: CGFloat = 6\n        public var gutterCornerRadius: CGFloat = 1\n\n        public var inlineBlameLeadingPadding: CGFloat = 8\n        public var inlineBlameTrailingPadding: CGFloat = 8\n        public var inlineBlameFont: Font = .system(size: 11, weight: .regular, design: .monospaced)\n        public var inlineBlameMaxWidth: CGFloat = 420\n\n        public var addedColor: Color = Color(red: 0.20, green: 0.78, blue: 0.35)\n        public var modifiedColor: Color = Color(red: 0.20, green: 0.55, blue: 0.95)\n        public var deletedColor: Color = Color(red: 0.92, green: 0.30, blue: 0.24)\n\n        public var inlineBlameTextColor: Color = .secondary\n        public var inlineBlameBackground: Color = Color.secondary.opacity(0.10)\n        public var inlineBlameCornerRadius: CGFloat = 6\n\n        public init() {}\n    }\n\n    private let fileURL: URL\n    private let visibleLineRange: Range<Int> // 1-based, end-exclusive\n    private let lineHeight: CGFloat\n    private let contentTopInset: CGFloat\n    private let selectedLine: Int?\n    private let refreshToken: AnyHashable\n    private let configuration: Configuration\n    private let dataSource: GitGutterDataSource\n\n    @State private var changesByLine: [Int: GitLineChangeKind] = [:]\n    @State private var deletedMarkers: Set<Int> = []\n    @State private var blameByLine: [Int: GitBlameLine] = [:]\n\n    public init(\n        fileURL: URL,\n        visibleLineRange: Range<Int>,\n        lineHeight: CGFloat,\n        contentTopInset: CGFloat = 0,\n        selectedLine: Int? = nil,\n        refreshToken: AnyHashable = 0,\n        configuration: Configuration = .init(),\n        dataSource: GitGutterDataSource = .default\n    ) {\n        self.fileURL = fileURL\n        self.visibleLineRange = visibleLineRange\n        self.lineHeight = lineHeight\n        self.contentTopInset = contentTopInset\n        self.selectedLine = selectedLine\n        self.refreshToken = refreshToken\n        self.configuration = configuration\n        self.dataSource = dataSource\n    }\n\n    public var body: some View {\n        HStack(spacing: 0) {\n            if configuration.showsDiffIndicators {\n                diffGutter\n                    .frame(width: configuration.gutterWidth)\n            }\n\n            if configuration.showsInlineBlame {\n                inlineBlameColumn\n            }\n        }\n        // Reload when:\n        // - file changes\n        // - refreshToken changes (host signals content/git refresh)\n        .task(id: fileURL) {\n            await reloadAll(force: true)\n        }\n        .task(id: refreshToken) {\n            await reloadAll(force: true)\n        }\n    }\n\n    private var diffGutter: some View {\n        GeometryReader { _ in\n            Canvas { context, size in\n                guard !visibleLineRange.isEmpty else { return }\n\n                let w = size.width\n                let corner = configuration.gutterCornerRadius\n\n                for line in visibleLineRange {\n                    if let kind = changesByLine[line] {\n                        let y = contentTopInset + CGFloat(line - visibleLineRange.lowerBound) * lineHeight\n                        let rect = CGRect(x: 0, y: y, width: w, height: max(1, lineHeight))\n                        let path = Path(roundedRect: rect, cornerRadius: corner)\n                        context.fill(path, with: .color(color(for: kind)))\n                    }\n\n                    // Deleted markers are drawn as triangles at the boundary.\n                    if deletedMarkers.contains(line) {\n                        let y = contentTopInset + CGFloat(line - visibleLineRange.lowerBound) * lineHeight\n                        var p = Path()\n                        p.move(to: CGPoint(x: 0, y: y))\n                        p.addLine(to: CGPoint(x: w, y: y + (lineHeight * 0.5)))\n                        p.addLine(to: CGPoint(x: 0, y: y + lineHeight))\n                        p.closeSubpath()\n                        context.fill(p, with: .color(configuration.deletedColor))\n                    }\n                }\n            }\n        }\n        .accessibilityLabel(\"Git diff gutter\")\n    }\n\n    private var inlineBlameColumn: some View {\n        ZStack(alignment: .topLeading) {\n            if let selectedLine,\n               let blame = blameByLine[selectedLine],\n               visibleLineRange.contains(selectedLine) {\n                let y = contentTopInset + CGFloat(selectedLine - visibleLineRange.lowerBound) * lineHeight\n\n                inlineBlameLabel(for: blame)\n                    .frame(maxWidth: configuration.inlineBlameMaxWidth, alignment: .leading)\n                    .offset(x: configuration.inlineBlameLeadingPadding, y: y)\n                    .allowsHitTesting(false)\n            }\n        }\n        .padding(.trailing, configuration.inlineBlameTrailingPadding)\n        .accessibilityLabel(\"Inline git blame\")\n    }\n\n    @ViewBuilder\n    private func inlineBlameLabel(for blame: GitBlameLine) -> some View {\n        let commitShort = String(blame.commit.prefix(8))\n        let author = blame.author.isEmpty ? \"Unknown\" : blame.author\n        let summary = blame.summary\n\n        Text(\"\\(author) \\(commitShort) — \\(summary)\")\n            .font(configuration.inlineBlameFont)\n            .foregroundStyle(configuration.inlineBlameTextColor)\n            .lineLimit(1)\n            .truncationMode(.tail)\n            .padding(.horizontal, 8)\n            .padding(.vertical, 4)\n            .background(configuration.inlineBlameBackground)\n            .clipShape(RoundedRectangle(cornerRadius: configuration.inlineBlameCornerRadius, style: .continuous))\n    }\n\n    private func color(for kind: GitLineChangeKind) -> Color {\n        switch kind {\n        case .added: return configuration.addedColor\n        case .modified: return configuration.modifiedColor\n        case .deleted: return configuration.deletedColor\n        }\n    }\n\n    // MARK: Reload\n\n    @MainActor\n    private func reloadAll(force: Bool) async {\n        // Diff\n        if configuration.showsDiffIndicators {\n            do {\n                let diff = try await dataSource.diff(fileURL, force)\n                var byLine: [Int: GitLineChangeKind] = [:]\n                var deletions: Set<Int> = []\n\n                for c in diff {\n                    switch c.kind {\n                    case .deleted:\n                        deletions.insert(max(1, c.line))\n                    case .added, .modified:\n                        byLine[c.line] = c.kind\n                    }\n                }\n\n                self.changesByLine = byLine\n                self.deletedMarkers = deletions\n            } catch {\n                self.changesByLine = [:]\n                self.deletedMarkers = []\n            }\n        }\n\n        // Blame\n        if configuration.showsInlineBlame {\n            do {\n                let blame = try await dataSource.blame(fileURL, force)\n                self.blameByLine = Dictionary(uniqueKeysWithValues: blame.map { ($0.line, $0) })\n            } catch {\n                self.blameByLine = [:]\n            }\n        }\n    }\n}\n\n// MARK: - Minimal Git wrappers (CLI-backed)\n\nprivate enum GitError: Error, LocalizedError {\n    case notARepository\n    case commandFailed(String)\n\n    var errorDescription: String? {\n        switch self {\n        case .notARepository:\n            return \"Not a git repository\"\n        case .commandFailed(let msg):\n            return \"Git command failed: \\(msg)\"\n        }\n    }\n}\n\nprivate struct GitShell {\n    static func runGit(args: [String], in workingDirectory: URL) async throws -> String {\n        #if os(macOS) || targetEnvironment(macCatalyst) || os(Linux)\n        return try await withCheckedThrowingContinuation { cont in\n            let process = Process()\n            process.executableURL = URL(fileURLWithPath: \"/usr/bin/env\")\n            process.arguments = [\"git\"] + args\n            process.currentDirectoryURL = workingDirectory\n\n            let outPipe = Pipe()\n            let errPipe = Pipe()\n            process.standardOutput = outPipe\n            process.standardError = errPipe\n\n            do {\n                try process.run()\n            } catch {\n                cont.resume(throwing: GitError.commandFailed(\"Unable to launch git\"))\n                return\n            }\n\n            process.terminationHandler = { p in\n                let outData = outPipe.fileHandleForReading.readDataToEndOfFile()\n                let errData = errPipe.fileHandleForReading.readDataToEndOfFile()\n\n                let out = String(data: outData, encoding: .utf8) ?? \"\"\n                let err = String(data: errData, encoding: .utf8) ?? \"\"\n\n                if p.terminationStatus == 0 {\n                    cont.resume(returning: out)\n                } else {\n                    let msg = err.trimmingCharacters(in: .whitespacesAndNewlines)\n                    cont.resume(throwing: GitError.commandFailed(msg.isEmpty ? out : msg))\n                }\n            }\n        }\n        #else\n        throw GitError.commandFailed(\"Git execution is not available on this platform\")\n        #endif\n    }\n\n    static func repoRoot(containing fileURL: URL) async throws -> URL {\n        let dir = fileURL.deletingLastPathComponent()\n        let out = try await runGit(args: [\"-C\", dir.path, \"rev-parse\", \"--show-toplevel\"], in: dir)\n        let rootPath = out.trimmingCharacters(in: .whitespacesAndNewlines)\n        if rootPath.isEmpty { throw GitError.notARepository }\n        return URL(fileURLWithPath: rootPath)\n    }\n}\n\n// MARK: - Diff\n\nprivate actor GitDiffService {\n    static let shared = GitDiffService()\n\n    private var cache: [String: [GitLineChange]] = [:] // key: repoRoot + fileRelPath\n\n    func invalidate(forFile fileURL: URL) async {\n        do {\n            let repoRoot = try await GitShell.repoRoot(containing: fileURL)\n            let relPath = Self.relativePath(fileURL, repoRoot)\n            let key = repoRoot.path + \"::\" + relPath\n            cache.removeValue(forKey: key)\n        } catch {\n            // ignore\n        }\n    }\n\n    func lineChanges(forFile fileURL: URL) async throws -> [GitLineChange] {\n        let repoRoot = try await GitShell.repoRoot(containing: fileURL)\n        let relPath = Self.relativePath(fileURL, repoRoot)\n        let key = repoRoot.path + \"::\" + relPath\n\n        if let cached = cache[key] { return cached }\n\n        // Unified=0 makes hunks contain only the changed lines, simplifying mapping.\n        let diff = try await GitShell.runGit(\n            args: [\"-C\", repoRoot.path, \"diff\", \"--unified=0\", \"--no-color\", \"--\", relPath],\n            in: repoRoot\n        )\n\n        let parsed = Self.parseUnifiedZeroDiff(diff)\n        cache[key] = parsed\n        return parsed\n    }\n\n    fileprivate static func relativePath(_ fileURL: URL, _ repoRoot: URL) -> String {\n        let filePath = fileURL.standardizedFileURL.path\n        let rootPath = repoRoot.standardizedFileURL.path\n        if filePath.hasPrefix(rootPath + \"/\") {\n            return String(filePath.dropFirst(rootPath.count + 1))\n        }\n        return fileURL.lastPathComponent\n    }\n\n    /// Parse output from: `git diff --unified=0 --no-color -- <file>`.\n    ///\n    /// Heuristic classification per hunk:\n    /// - oldCount==0,newCount>0 -> .added on new range\n    /// - oldCount>0,newCount>0 -> .modified on new range\n    /// - oldCount>0,newCount==0 -> .deleted marker at newStart\n    private static func parseUnifiedZeroDiff(_ text: String) -> [GitLineChange] {\n        var results: [GitLineChange] = []\n\n        // Example hunk header (unified=0):\n        // @@ -12,2 +12,3 @@\n        // or @@ -12 +12 @@\n        for raw in text.split(separator: \"\\n\", omittingEmptySubsequences: false) {\n            let line = String(raw)\n            guard line.hasPrefix(\"@@\"), let h = parseHunkHeader(line) else { continue }\n\n            if h.oldCount == 0 && h.newCount > 0 {\n                for n in 0..<h.newCount {\n                    results.append(.init(line: h.newStart + n, kind: .added))\n                }\n            } else if h.oldCount > 0 && h.newCount > 0 {\n                for n in 0..<h.newCount {\n                    results.append(.init(line: h.newStart + n, kind: .modified))\n                }\n            } else if h.oldCount > 0 && h.newCount == 0 {\n                results.append(.init(line: max(1, h.newStart), kind: .deleted))\n            }\n        }\n\n        // De-dupe (prefer modified over added if collision).\n        var byLine: [Int: GitLineChangeKind] = [:]\n        var deleted: Set<Int> = []\n        for r in results {\n            switch r.kind {\n            case .deleted:\n                deleted.insert(r.line)\n            case .added:\n                if byLine[r.line] == nil { byLine[r.line] = .added }\n            case .modified:\n                byLine[r.line] = .modified\n            }\n        }\n\n        var merged: [GitLineChange] = []\n        for (line, kind) in byLine { merged.append(.init(line: line, kind: kind)) }\n        for d in deleted { merged.append(.init(line: d, kind: .deleted)) }\n\n        return merged.sorted { $0.line < $1.line }\n    }\n\n    private struct Hunk {\n        var oldStart: Int\n        var oldCount: Int\n        var newStart: Int\n        var newCount: Int\n    }\n\n    private static func parseHunkHeader(_ header: String) -> Hunk? {\n        // Header format: @@ -oldStart,oldCount +newStart,newCount @@ ...\n        // Counts may be omitted: -12 +12\n        guard let rangeStart = header.range(of: \"@@\") else { return nil }\n        guard let rangeEnd = header.range(of: \"@@\", options: [], range: rangeStart.upperBound..<header.endIndex) else { return nil }\n        let body = header[rangeStart.upperBound..<rangeEnd.lowerBound].trimmingCharacters(in: .whitespaces)\n\n        let parts = body.split(separator: \" \")\n        guard parts.count >= 2 else { return nil }\n\n        func parsePart(_ s: Substring, prefix: Character) -> (Int, Int)? {\n            guard s.first == prefix else { return nil }\n            let rest = s.dropFirst()\n            if let comma = rest.firstIndex(of: \",\") {\n                let a = rest[..<comma]\n                let b = rest[rest.index(after: comma)...]\n                guard let start = Int(a), let count = Int(b) else { return nil }\n                return (start, count)\n            } else {\n                guard let start = Int(rest) else { return nil }\n                return (start, 1)\n            }\n        }\n\n        guard let old = parsePart(parts[0], prefix: \"-\") else { return nil }\n        guard let new = parsePart(parts[1], prefix: \"+\") else { return nil }\n        return Hunk(oldStart: old.0, oldCount: old.1, newStart: new.0, newCount: new.1)\n    }\n}\n\n// MARK: - Blame\n\nprivate actor GitBlameService {\n    static let shared = GitBlameService()\n\n    private var cache: [String: [GitBlameLine]] = [:] // key: repoRoot + fileRelPath\n\n    func invalidate(forFile fileURL: URL) async {\n        do {\n            let repoRoot = try await GitShell.repoRoot(containing: fileURL)\n            let relPath = GitDiffService.relativePath(fileURL, repoRoot)\n            let key = repoRoot.path + \"::\" + relPath\n            cache.removeValue(forKey: key)\n        } catch {\n            // ignore\n        }\n    }\n\n    func blame(forFile fileURL: URL) async throws -> [GitBlameLine] {\n        let repoRoot = try await GitShell.repoRoot(containing: fileURL)\n        let relPath = GitDiffService.relativePath(fileURL, repoRoot)\n        let key = repoRoot.path + \"::\" + relPath\n\n        if let cached = cache[key] { return cached }\n\n        let out = try await GitShell.runGit(\n            args: [\"-C\", repoRoot.path, \"blame\", \"--line-porcelain\", \"--\", relPath],\n            in: repoRoot\n        )\n\n        let parsed = Self.parseLinePorcelain(out)\n        cache[key] = parsed\n        return parsed\n    }\n\n    private static func parseLinePorcelain(_ text: String) -> [GitBlameLine] {\n        // Format (porcelain):\n        // <sha> <origLine> <finalLine> <numLines>\n        // author <name>\n        // author-time <unix>\n        // summary <text>\n        // ...\n        // \\t<source line>\n        // (then additional \\t lines if <numLines> > 1)\n\n        var results: [GitBlameLine] = []\n\n        var currentCommit: String = \"\"\n        var currentAuthor: String = \"\"\n        var currentAuthorTime: Date?\n        var currentSummary: String = \"\"\n\n        var pendingFinalLine: Int?\n        var pendingRemaining: Int = 0\n\n        func isHexString(_ s: Substring) -> Bool {\n            !s.isEmpty && s.allSatisfy { $0.isHexDigit }\n        }\n\n        func emitOneLineIfPossible() {\n            guard pendingRemaining > 0,\n                  let ln = pendingFinalLine,\n                  !currentCommit.isEmpty else { return }\n\n            results.append(\n                GitBlameLine(\n                    line: ln,\n                    commit: currentCommit,\n                    author: currentAuthor,\n                    authorTime: currentAuthorTime,\n                    summary: currentSummary\n                )\n            )\n\n            pendingFinalLine = ln + 1\n            pendingRemaining -= 1\n\n            if pendingRemaining == 0 {\n                pendingFinalLine = nil\n                currentCommit = \"\"\n                currentAuthor = \"\"\n                currentAuthorTime = nil\n                currentSummary = \"\"\n            }\n        }\n\n        for raw in text.split(separator: \"\\n\", omittingEmptySubsequences: false) {\n            let line = String(raw)\n\n            if line.hasPrefix(\"\\t\") {\n                emitOneLineIfPossible()\n                continue\n            }\n\n            // Header line:\n            // <sha> <origLine> <finalLine> <numLines>\n            // (some variants may omit <numLines>; treat as 1)\n            let parts = line.split(separator: \" \")\n            if parts.count >= 3,\n               isHexString(parts[0]),\n               Int(parts[1]) != nil,\n               let final = Int(parts[2]) {\n                currentCommit = String(parts[0])\n                pendingFinalLine = final\n                pendingRemaining = (parts.count >= 4 ? Int(parts[3]) : nil) ?? 1\n                continue\n            }\n\n            if line.hasPrefix(\"author \") {\n                currentAuthor = String(line.dropFirst(\"author \".count))\n            } else if line.hasPrefix(\"author-time \") {\n                let ts = String(line.dropFirst(\"author-time \".count))\n                if let t = TimeInterval(ts) {\n                    currentAuthorTime = Date(timeIntervalSince1970: t)\n                }\n            } else if line.hasPrefix(\"summary \") {\n                currentSummary = String(line.dropFirst(\"summary \".count))\n            }\n        }\n\n        return results.sorted { $0.line < $1.line }\n    }\n}\n"}
>>>END

>>>TOOL read_file
{"path":"Views/Editor/GitGutterView.swift","start_line":1,"end_line":30}
>>>END

>>>TOOL read_file
{"path":"Views/Editor/GitGutterView.swift","start_line":1,"end_line":6}
>>>END

>>>TOOL read_file
{"path":"Views/Editor/GitGutterView.swift","start_line":1,"end_line":12}
>>>END

>>>TOOL read_file
{"path":"Views/Editor/GitGutterView.swift","start_line":1,"end_line":3}
>>>END

>>>TOOL read_file
{"path":"Views/Editor/GitGutterView.swift","start_line":1,"end_line":1}
>>>END

>>>TOOL search
{"query":"import Foundation", "glob":"Views/Editor/GitGutterView.swift"}
>>>END

>>>TOOL read_file
{"path":"Views/Editor/GitGutterView.swift","start_line":1,"end_line":5}
>>>END

>>>TOOL read_file
{"path":"Views/Editor/GitGutterView.swift","start_line":1,"end_line":140}
>>>END

>>>TOOL read_file
{"path":"Views/Editor/GitGutterView.swift","start_line":260,"end_line":520}
>>>END

>>>TOOL read_file
{"path":"Views/Editor/GitGutterView.swift","start_line":520,"end_line":700}
>>>END

>>>REPORT
Implemented FEAT-071 + FEAT-072 by adding a new self-contained SwiftUI gutter view and minimal git diff/blame logic in:

- Views/Editor/GitGutterView.swift

What’s included (with evidence):
1) FEAT-071 Git gutter indicators (added/modified/deleted)
- `GitGutterView` renders:
  - Added/modified: full-height colored bars per visible line via `Canvas` (lines 187-217).
  - Deleted: triangle “deletion boundary” markers (lines 203-212).
- Line-change model types: `GitLineChangeKind`, `GitLineChange` (lines 23-38).

2) FEAT-072 Inline blame UI/logic
- Inline blame label shown for the current `selectedLine` (caret line) when it’s within `visibleLineRange` (lines 219-234).
- Blame model type: `GitBlameLine` (lines 40-54).
- Label format: “author <shortsha> — summary” (lines 236-251).

3) Uses existing services if present; otherwise minimal wrappers (implemented here)
- Added an injectable `GitGutterDataSource` so the host editor/app can plug in existing diff/blame services (lines 58-103).
- Default data source:
  - iOS (non-Catalyst): `.empty` (returns no diff/blame) (lines 75-88).
  - macOS/Mac Catalyst/Linux: `.gitCLI` backed by the included minimal git wrappers (lines 90-102).
- Minimal git command wrapper: `GitShell.runGit(...)` using `Process` and `/usr/bin/env git` (lines 317-356), and repo root discovery (lines 358-365).

4) Minimal git diff/blame parsing (CLI-backed)
- Diff:
  - `git diff --unified=0 --no-color -- <file>` (lines 392-397).
  - Parses hunk headers and maps to added/modified/deleted markers (lines 412-460).
- Blame:
  - `git blame --line-porcelain -- <file>` (lines 524-527).
  - Parses porcelain blocks; supports multi-line groups via `<numLines>` handling and emits one blame entry per source line (lines 534-620).

Integration note (implemented as API surface, since no other files were modifiable):
- `GitGutterView` is designed to be embedded/overlaid by the host editor, requiring the host to provide `fileURL`, `visibleLineRange`, `lineHeight`, `contentTopInset`, `selectedLine`, and `refreshToken` (documented at top comments and via init parameters; view init at lines 145-164).
>>>END
