# Agent: minimap-worker
**Status:** done
**Tokens:** 28,694
**Cost:** $0.0000
**Time:** 2026-02-09T10:50:21.233Z

## Task
FEAT-131: Enhance MinimapView.swift with proper code preview on right side. Update VSCodeiPadOS/VSCodeiPadOS/Views/Editor/MinimapView.swift to include: (1) Actual syntax-colored code preview with tiny font rendering, (2) Highlight current visible region with semi-transparent overlay, (3) Click-to-scroll to position, (4) Drag scrolling, (5) Show git diff indicators (red/green bars for changes). Make it look like VS Code's minimap with actual colored code blocks representing syntax.

## Response
>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor/MinimapView.swift"} 
>>>END>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor/MinimapView.swift"} 
>>>END

>>>TOOL search
{"query":"MinimapView(", "glob":"VSCodeiPadOS/VSCodeiPadOS/**/*.swift"} 
>>>END>>>TOOL search
{"query":"git diff", "glob":"VSCodeiPadOS/VSCodeiPadOS/**/*.swift"} 
>>>END>>>TOOL search
{"query":"diffIndicators", "glob":"VSCodeiPadOS/VSCodeiPadOS/**/*.swift"} 
>>>END>>>TOOL search
{"query":"Diff", "glob":"VSCodeiPadOS/VSCodeiPadOS/**/*.swift"} 
>>>END>>>END


>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/ContentView.swift","start_line":340,"end_line":450}
>>>END

>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SplitEditorView.swift","start_line":520,"end_line":620}
>>>END

>>>TOOL search
{"query":"EnvironmentObject", "glob":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor/*.swift"}
>>>END

>>>TOOL search
{"query":"Syntax", "glob":"VSCodeiPadOS/VSCodeiPadOS/**/*.swift"}
>>>END

>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor/MinimapView.swift","start_line":1,"end_line":200}
>>>END>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor/MinimapView.swift","start_line":1,"end_line":200}
>>>END

>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/ContentView.swift","start_line":360,"end_line":430}
>>>END

>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SplitEditorView.swift","start_line":520,"end_line":610}
>>>END

>>>TOOL search
{"query":"EnvironmentObject", "glob":"VSCodeiPadOS/VSCodeiPadOS/**/*.swift"}
>>>END

>>>TOOL search
{"query":"diff", "glob":"VSCodeiPadOS/VSCodeiPadOS/**/*.swift"}
>>>END

>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor/MinimapView.swift","start_line":1,"end_line":120} 
>>>END

>>>TOOL create_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor/MinimapView.swift","content":"import SwiftUI\n\n/// A lightweight VS Code–style minimap.\n///\n/// Notes:\n/// - Renders a tiny syntax-colored code preview (heuristic highlighting).\n/// - Shows the current visible editor region.\n/// - Supports click-to-scroll and drag-to-scroll.\n/// - Optionally shows git diff indicators (added/modified/deleted) as colored bars.\nstruct MinimapView: View {\n    let content: String\n    @Binding var scrollOffset: CGFloat\n    @Binding var scrollViewHeight: CGFloat\n    let totalContentHeight: CGFloat\n\n    /// Optional git diff indicators keyed by line index (0-based).\n    /// If your diff data is 1-based, pass `line - 1`.\n    let diffLines: [Int: GitDiffKind] = [:]\n\n    enum GitDiffKind {\n        case added\n        case modified\n        case deleted\n\n        var color: Color {\n            switch self {\n            case .added:\n                return Color.green\n            case .modified:\n                // VS Code commonly uses yellow/orange for modifications.\n                return Color.orange\n            case .deleted:\n                return Color.red\n            }\n        }\n    }\n\n    @State private var isDragging = false\n    /// Finger offset inside the visible-region rectangle while dragging.\n    @State private var dragOffset: CGFloat = 0\n\n    private let minimapHeight: CGFloat = 300\n    private let minimapWidth: CGFloat = 60\n\n    var body: some View {\n        // Keep empty lines so the minimap’s vertical mapping matches the editor.\n        let lines = content.split(whereSeparator: \\.\n            isNewline, omittingEmptySubsequences: false)\n        let lineCount = max(lines.count, 1)\n\n        ZStack(alignment: .topLeading) {\n            // Background\n            Rectangle()\n                .fill(Color(white: 0.12))\n\n            // Code preview (tiny, syntax-colored)\n            Canvas { context, size in\n                let lineHeight = size.height / CGFloat(lineCount)\n\n                // If there are too many lines, sample to keep draw work reasonable.\n                // (The minimap remains visually faithful at this scale.)\n                let strideBy = max(1, Int(ceil(1.0 / max(lineHeight, 0.001))))\n                let fontSize = minimapFontSize(for: lineHeight)\n\n                for i in Swift.stride(from: 0, to: lineCount, by: strideBy) {\n                    let y = CGFloat(i) * lineHeight\n                    let line = lines.indices.contains(i) ? lines[i] : Substring(\"\")\n                    let attr = highlighted(line: line, fontSize: fontSize)\n                    let text = Text(attr)\n\n                    // Draw anchored at top-leading, with a small inset like VS Code.\n                    context.draw(\n                        text,\n                        at: CGPoint(x: 4, y: y + 1),\n                        anchor: .topLeading\n                    )\n                }\n            }\n            .allowsHitTesting(false)\n\n            // Git diff indicators\n            // Drawn as vertical bars aligned to the corresponding line’s Y position.\n            Canvas { context, size in\n                guard !diffLines.isEmpty else { return }\n\n                let lineHeight = size.height / CGFloat(lineCount)\n                let markerWidth: CGFloat = 2\n                let x: CGFloat = 0\n\n                for (lineIndex, kind) in diffLines {\n                    guard lineIndex >= 0 && lineIndex < lineCount else { continue }\n                    let y = CGFloat(lineIndex) * lineHeight\n                    let h = max(lineHeight, 1)\n                    let rect = CGRect(x: x, y: y, width: markerWidth, height: h)\n                    context.fill(Path(rect), with: .color(kind.color))\n                }\n            }\n            .allowsHitTesting(false)\n\n            // Visible region indicator (semi-transparent overlay)\n            Rectangle()\n                .fill(Color.blue.opacity(0.18))\n                .overlay(\n                    Rectangle()\n                        .stroke(Color.blue.opacity(0.7), lineWidth: 1)\n                )\n                .frame(width: minimapWidth, height: visibleRegionHeight)\n                .offset(y: visibleRegionOffset)\n                .allowsHitTesting(false)\n        }\n        .frame(width: minimapWidth, height: minimapHeight)\n        .clipShape(Rectangle())\n        .overlay(\n            Rectangle()\n                .stroke(Color.white.opacity(0.08), lineWidth: 1)\n        )\n        .contentShape(Rectangle())\n        // Click-to-scroll + drag scrolling\n        .gesture(\n            DragGesture(minimumDistance: 0, coordinateSpace: .local)\n                .onChanged { value in\n                    handleDrag(value: value)\n                }\n                .onEnded { _ in\n                    isDragging = false\n                }\n        )\n    }\n\n    // MARK: - Visible region mapping\n\n    private var maxScrollOffset: CGFloat {\n        max(totalContentHeight - scrollViewHeight, 0)\n    }\n\n    private var visibleRegionHeight: CGFloat {\n        guard totalContentHeight > 0 else { return 0 }\n        let ratio = scrollViewHeight / totalContentHeight\n        return minimapHeight * min(max(ratio, 0), 1.0)\n    }\n\n    private var visibleRegionOffset: CGFloat {\n        let trackHeight = minimapHeight - visibleRegionHeight\n        guard maxScrollOffset > 0, trackHeight > 0 else { return 0 }\n        let scrollRatio = (scrollOffset / maxScrollOffset).clamped(to: 0...1)\n        return scrollRatio * trackHeight\n    }\n\n    private func handleDrag(value: DragGesture.Value) {\n        let y = value.location.y\n\n        // Initialize drag behavior on first movement (also covers taps).\n        if !isDragging {\n            isDragging = true\n\n            let top = visibleRegionOffset\n            let bottom = top + visibleRegionHeight\n\n            if y >= top && y <= bottom {\n                // Dragging the visible region itself.\n                dragOffset = y - top\n            } else {\n                // Clicking outside: jump and center the visible region around the click.\n                dragOffset = visibleRegionHeight / 2\n            }\n        }\n\n        updateScroll(for: y)\n    }\n\n    private func updateScroll(for yPosition: CGFloat) {\n        guard maxScrollOffset > 0 else {\n            scrollOffset = 0\n            return\n        }\n\n        let trackHeight = max(minimapHeight - visibleRegionHeight, 0.0001)\n        let desiredTop = (yPosition - dragOffset).clamped(to: 0...trackHeight)\n        let ratio = desiredTop / trackHeight\n        scrollOffset = ratio * maxScrollOffset\n    }\n\n    // MARK: - Syntax highlighting (heuristic)\n\n    private func minimapFontSize(for lineHeight: CGFloat) -> CGFloat {\n        // Tuned to look like VS Code minimap: tiny but still produces colored blocks.\n        // Keep a lower bound so text still renders.\n        let proposed = lineHeight * 1.25\n        return max(1.6, min(proposed, 4.0))\n    }\n\n    private func highlighted(line: Substring, fontSize: CGFloat) -> AttributedString {\n        let string = String(line)\n        var attr = AttributedString(string)\n\n        // Base styling\n        attr.font = .system(size: fontSize, design: .monospaced)\n        attr.foregroundColor = Color(white: 0.72)\n\n        // Apply more specific tokens over the base styling.\n        // Order matters: comments should override other matches.\n        apply(pattern: \"(//.*$|#.*$)\", in: string, to: &attr, color: Color(white: 0.55))\n        apply(pattern: #\"\\\"([^\\\"\\\\]|\\\\.)*\\\"\"#, in: string, to: &attr, color: Color(red: 0.85, green: 0.65, blue: 0.25))\n        apply(pattern: #\"'([^'\\\\]|\\\\.)*'\"#, in: string, to: &attr, color: Color(red: 0.85, green: 0.65, blue: 0.25))\n\n        // Keywords across a few common languages (Swift/JS/TS/Python/etc.)\n        let keywordPattern = \"\\\\b(abstract|as|async|await|break|case|catch|class|const|continue|defer|default|delete|do|else|enum|export|extends|false|final|finally|for|foreach|from|func|function|get|guard|if|import|in|init|interface|internal|let|macro|mutating|new|null|of|open|operator|override|package|private|protocol|public|raise|repeat|required|return|self|set|static|struct|super|switch|this|throw|throws|true|try|typealias|typeof|var|where|while|with|yield)\\\\b\"\n        apply(pattern: keywordPattern, in: string, to: &attr, color: Color(red: 0.45, green: 0.75, blue: 0.98))\n\n        // Numbers\n        apply(pattern: \"\\\\b(0x[0-9A-Fa-f]+|\\\\d+(?:\\\\.\\\\d+)?)\\\\b\", in: string, to: &attr, color: Color(red: 0.72, green: 0.85, blue: 0.55))\n\n        // Types (simple heuristic: Capitalized identifiers)\n        apply(pattern: \"\\\\b[A-Z][A-Za-z0-9_]*\\\\b\", in: string, to: &attr, color: Color(red: 0.78, green: 0.62, blue: 0.95))\n\n        return attr\n    }\n\n    private func apply(pattern: String, in string: String, to attr: inout AttributedString, color: Color) {\n        guard let regex = try? NSRegularExpression(pattern: pattern, options: [.anchorsMatchLines]) else { return }\n        let range = NSRange(string.startIndex..<string.endIndex, in: string)\n\n        for match in regex.matches(in: string, options: [], range: range) {\n            guard let stringRange = Range(match.range, in: string) else { continue }\n            guard let lower = AttributedString.Index(stringRange.lowerBound, within: attr),\n                  let upper = AttributedString.Index(stringRange.upperBound, within: attr) else { continue }\n\n            let attrRange = lower..<upper\n            attr[attrRange].foregroundColor = color\n        }\n    }\n}\n\n// MARK: - Helpers\n\nprivate extension Comparable {\n    func clamped(to limits: ClosedRange<Self>) -> Self {\n        min(max(self, limits.lowerBound), limits.upperBound)\n    }\n}\n"} 
>>>END

>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor/MinimapView.swift","start_line":1,"end_line":140}
>>>END

>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor/MinimapView.swift","start_line":1,"end_line":30}
>>>END

>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor/MinimapView.swift","start_line":1,"end_line":120}
>>>END

>>>FILE VSCodeiPadOS/VSCodeiPadOS/Views/Editor/MinimapView.swift
>>>FIND
import SwiftUI

struct MinimapView: View {
    let content: String
    @Binding var scrollOffset: CGFloat
    @Binding var scrollViewHeight: CGFloat
    let totalContentHeight: CGFloat
    
    @State private var isDragging = false
    @State private var dragOffset: CGFloat = 0
    
    private let minimapHeight: CGFloat = 300
    private let minimapWidth: CGFloat = 60
    private let lineHeight: CGFloat = 2
    private let spacing: CGFloat = 1
    
    var body: some View {
        GeometryReader { geometry in
            ZStack(alignment: .topLeading) {
                // Background
                Rectangle()
                    .fill(Color(white: 0.15))
                
                // Code preview lines
                VStack(alignment: .leading, spacing: spacing) {
                    ForEach(Array(content.split(separator: "\n").prefix(100).enumerated()), id: \.offset) { index, line in
                        Rectangle()
                            .fill(Color(white: 0.3).opacity(lineOpacity(for: String(line))))
                            .frame(width: lineWidth(for: String(line)), height: lineHeight)
                    }
                }
                .padding(.horizontal, 4)
                .padding(.vertical, 2)
                
                // Visible region indicator box
                Rectangle()
                    .fill(Color.blue.opacity(0.2))
                    .overlay(
                        Rectangle()
                            .stroke(Color.blue, lineWidth: 1)
                    )
                    .frame(width: minimapWidth, height: visibleRegionHeight)
                    .offset(y: visibleRegionOffset)
            }
            .frame(width: minimapWidth, height: minimapHeight)
            .clipShape(Rectangle())
            .gesture(
                DragGesture(minimumDistance: 0)
                    .onChanged { value in
                        handleDrag(value: value)
                    }
                    .onEnded { _ in
                        isDragging = false
                    }
            )
        }
        .frame(width: minimapWidth, height: minimapHeight)
    }
    
    private var visibleRegionHeight: CGFloat {
        guard totalContentHeight > 0 else { return 0 }
        let ratio = scrollViewHeight / totalContentHeight
        return minimapHeight * min(ratio, 1.0)
    }
    
    private var visibleRegionOffset: CGFloat {
        guard totalContentHeight > 0 else { return 0 }
        let scrollRatio = scrollOffset / (totalContentHeight - scrollViewHeight)
        return scrollRatio * (minimapHeight - visibleRegionHeight)
    }
    
    private func handleDrag(value: DragGesture.Value) {
        isDragging = true
        updateScroll(for: value.location.y)
    }
    
    private func updateScroll(for yPosition: CGFloat) {
        let clampedY = max(0, min(yPosition, minimapHeight))
        let ratio = clampedY / minimapHeight
        scrollOffset = ratio * (totalContentHeight - scrollViewHeight)
    }
    
    private func lineWidth(for line: String) -> CGFloat {
        let trimmed = line.trimmingCharacters(in: .whitespaces)
        if trimmed.isEmpty { return 5 }
        
        let maxWidth = minimapWidth - 8 // Padding
        let ratio = min(1.0, CGFloat(trimmed.count) / 80.0)
        return maxWidth * ratio
    }
    
    private func lineOpacity(for line: String) -> Double {
        let trimmed = line.trimmingCharacters(in: .whitespaces)
        if trimmed.isEmpty { return 0.1 }
        if trimmed.hasPrefix("//") || trimmed.hasPrefix("#") { return 0.4 }
        if trimmed.hasPrefix("import") || trimmed.hasPrefix("struct") || trimmed.hasPrefix("class") { return 0.8 }
        return 0.6
    }
}
>>>REPLACE
import SwiftUI

/// VS Code–style minimap with:
/// - syntax-colored tiny preview
/// - visible region overlay
/// - tap/drag to scroll
/// - optional git diff indicators (added/modified/deleted)
struct MinimapView: View {
    // MARK: - External inputs

    let content: String
    @Binding var scrollOffset: CGFloat
    @Binding var scrollViewHeight: CGFloat
    let totalContentHeight: CGFloat

    /// Optional indicators to render as thin bars on the left side of the minimap.
    /// Note: call sites can ignore this (default empty) without breaking compilation.
    var diffIndicators: [MinimapDiffIndicator] = []

    /// Fixed width; height expands to the container.
    var minimapWidth: CGFloat = 60

    // MARK: - Internal state

    @State private var isInteracting: Bool = false

    // MARK: - Types

    struct MinimapDiffIndicator: Identifiable, Hashable {
        enum Kind: Hashable {
            case added
            case modified
            case deleted
        }

        var id = UUID()
        /// 0-based line range in the current `content`.
        var lineRange: Range<Int>
        var kind: Kind

        init(lineRange: Range<Int>, kind: Kind) {
            self.lineRange = lineRange
            self.kind = kind
        }
    }

    // MARK: - View

    var body: some View {
        GeometryReader { geometry in
            let size = geometry.size
            let minimapHeight = max(1, size.height)
            let lines = content.split(separator: "\n", omittingEmptySubsequences: false)
            let lineCount = max(lines.count, 1)

            ZStack(alignment: .topLeading) {
                // Background
                Rectangle()
                    .fill(Color(white: 0.13))

                // Syntax-colored code preview
                Canvas { context, canvasSize in
                    drawMinimapPreview(
                        in: &context,
                        size: canvasSize,
                        lines: lines
                    )
                }
                .allowsHitTesting(false)

                // Git diff indicators (thin left bars)
                diffIndicatorsLayer(
                    minimapHeight: minimapHeight,
                    lineCount: lineCount
                )
                .allowsHitTesting(false)

                // Visible region highlight
                visibleRegionLayer(minimapHeight: minimapHeight)
                    .allowsHitTesting(false)
            }
            .frame(width: minimapWidth, height: minimapHeight)
            .clipShape(Rectangle())
            .contentShape(Rectangle())
            // Click-to-scroll + drag scrolling (DragGesture(minDistance: 0) captures taps too)
            .gesture(
                DragGesture(minimumDistance: 0, coordinateSpace: .local)
                    .onChanged { value in
                        isInteracting = true
                        updateScroll(forMinimapY: value.location.y, minimapHeight: minimapHeight)
                    }
                    .onEnded { _ in
                        isInteracting = false
                    }
            )
        }
        .frame(width: minimapWidth)
    }

    // MARK: - Layers

    @ViewBuilder
    private func visibleRegionLayer(minimapHeight: CGFloat) -> some View {
        let height = visibleRegionHeight(minimapHeight: minimapHeight)
        let offset = visibleRegionOffset(minimapHeight: minimapHeight, visibleHeight: height)

        Rectangle()
            .fill(Color.accentColor.opacity(isInteracting ? 0.22 : 0.16))
            .overlay(
                Rectangle()
                    .stroke(Color.accentColor.opacity(0.65), lineWidth: 1)
            )
            .frame(width: minimapWidth, height: height)
            .offset(y: offset)
    }

    @ViewBuilder
    private func diffIndicatorsLayer(minimapHeight: CGFloat, lineCount: Int) -> some View {
        // VS Code minimap diff markers are thin and pinned to the left.
        let barWidth: CGFloat = 2

        ForEach(diffIndicators) { indicator in
            let startLine = max(0, min(indicator.lineRange.lowerBound, lineCount - 1))
            let endLineExclusive = max(startLine + 1, min(indicator.lineRange.upperBound, lineCount))

            let startY = (CGFloat(startLine) / CGFloat(lineCount)) * minimapHeight
            let endY = (CGFloat(endLineExclusive) / CGFloat(lineCount)) * minimapHeight
            let height = max(2, endY - startY)

            Rectangle()
                .fill(diffColor(for: indicator.kind).opacity(0.95))
                .frame(width: barWidth, height: height)
                .offset(x: 0, y: startY)
        }
    }

    // MARK: - Visible region math

    private func visibleRegionHeight(minimapHeight: CGFloat) -> CGFloat {
        guard totalContentHeight > 0 else { return 0 }
        let ratio = scrollViewHeight / totalContentHeight
        return minimapHeight * min(max(ratio, 0), 1.0)
    }

    private func visibleRegionOffset(minimapHeight: CGFloat, visibleHeight: CGFloat) -> CGFloat {
        let scrollable = max(0, totalContentHeight - scrollViewHeight)
        guard scrollable > 0 else { return 0 }

        let scrollRatio = min(max(scrollOffset / scrollable, 0), 1.0)
        return scrollRatio * max(0, minimapHeight - visibleHeight)
    }

    // MARK: - Interaction

    /// Sets `scrollOffset` so that the main editor's visible region is centered around the minimap Y position.
    private func updateScroll(forMinimapY yPosition: CGFloat, minimapHeight: CGFloat) {
        guard totalContentHeight > 0 else { return }

        let clampedY = max(0, min(yPosition, minimapHeight))
        let ratio = (minimapHeight > 0) ? (clampedY / minimapHeight) : 0

        // Target a center position (VS Code behavior).
        let targetCenter = ratio * totalContentHeight
        let desiredOffset = targetCenter - (scrollViewHeight / 2)

        let maxOffset = max(0, totalContentHeight - scrollViewHeight)
        scrollOffset = min(max(desiredOffset, 0), maxOffset)
    }

    // MARK: - Rendering (Canvas)

    private func drawMinimapPreview(
        in context: inout GraphicsContext,
        size: CGSize,
        lines: [Substring]
    ) {
        let paddingX: CGFloat = 4
        let paddingY: CGFloat = 2

        let contentWidth = max(0, size.width - (paddingX * 2))
        let contentHeight = max(0, size.height - (paddingY * 2))

        guard contentWidth > 0, contentHeight > 0 else { return }

        let lineCount = max(lines.count, 1)
        let pixelsPerLine = contentHeight / CGFloat(lineCount)

        // If we're dense (lots of lines), switch to token-block rendering.
        // Otherwise, render actual tiny syntax-colored text.
        let useTextMode = pixelsPerLine >= 3.0

        if useTextMode {
            // Font is tiny; keep it stable rather than tied too tightly to pixelsPerLine.
            let fontSize: CGFloat = min(6, max(3.5, pixelsPerLine * 0.9))

            for i in 0..<lineCount {
                let y = paddingY + (CGFloat(i) * pixelsPerLine)
                if y > size.height { break }

                let line = lines.indices.contains(i) ? lines[i] : Substring("")
                let attributed = makeAttributedLine(from: line, fontSize: fontSize)

                // Slightly dim to match minimap look.
                let text = Text(attributed).opacity(0.92)

                context.draw(
                    text,
                    at: CGPoint(x: paddingX, y: y),
                    anchor: .topLeading
                )
            }
        } else {
            // Token-block mode (colored rectangles), closer to VS Code minimap blocks for long files.
            let minBarHeight: CGFloat = 1
            let barHeight = max(minBarHeight, pixelsPerLine)

            // Approximate "characters" across minimap width.
            let maxChars: CGFloat = 120
            let charWidth = contentWidth / maxChars

            for i in 0..<lineCount {
                let y = paddingY + (CGFloat(i) * pixelsPerLine)
                if y > size.height { break }

                let line = lines.indices.contains(i) ? lines[i] : Substring("")
                let tokens = tokenize(line)

                var x = paddingX
                let yAligned = y.rounded(.down)

                if tokens.isEmpty {
                    // Render faint whitespace line.
                    let rect = CGRect(x: x, y: yAligned, width: max(4, contentWidth * 0.15), height: barHeight)
                    context.fill(Path(rect), with: .color(Color(white: 0.45).opacity(0.10)))
                    continue
                }

                for token in tokens {
                    guard x < (paddingX + contentWidth) else { break }
                    let w = max(1, CGFloat(token.text.count) * charWidth)
                    let rect = CGRect(x: x, y: yAligned, width: min(w, paddingX + contentWidth - x), height: barHeight)
                    context.fill(Path(rect), with: .color(token.color.opacity(0.80)))
                    x += w
                }
            }
        }
    }

    // MARK: - Syntax highlighting (lightweight)

    private struct Token {
        enum Kind {
            case plain
            case keyword
            case string
            case comment
            case number
            case typeName
        }

        var text: Substring
        var kind: Kind

        var color: Color {
            switch kind {
            case .plain:
                return Color(white: 0.70)
            case .keyword:
                return Color(red: 0.78, green: 0.53, blue: 0.95) // purple-ish
            case .string:
                return Color(red: 0.80, green: 0.72, blue: 0.43) // yellow-ish
            case .comment:
                return Color(red: 0.46, green: 0.60, blue: 0.50) // green-ish
            case .number:
                return Color(red: 0.40, green: 0.73, blue: 0.92) // blue-ish
            case .typeName:
                return Color(red: 0.45, green: 0.83, blue: 0.70) // teal-ish
            }
        }
    }

    private func makeAttributedLine(from line: Substring, fontSize: CGFloat) -> AttributedString {
        let tokens = tokenize(line)

        var out = AttributedString()
        for token in tokens {
            var chunk = AttributedString(String(token.text))
            chunk.font = .system(size: fontSize, weight: .regular, design: .monospaced)
            chunk.foregroundColor = token.color
            out.append(chunk)
        }

        if out.characters.isEmpty {
            // Preserve a tiny amount of "whitespace presence" so empty lines still show.
            var chunk = AttributedString(" ")
            chunk.font = .system(size: fontSize, weight: .regular, design: .monospaced)
            chunk.foregroundColor = Color(white: 0.7).opacity(0.25)
            out.append(chunk)
        }

        return out
    }

    private func tokenize(_ line: Substring) -> [Token] {
        // Extremely lightweight tokenizer:
        // - full-line comment if first non-space is # (python-like)
        // - inline comment starting at //
        // - strings in "..." or '...'
        // - numbers
        // - keywords
        // - PascalCase tokens treated as type names
        var tokens: [Token] = []
        var i = line.startIndex

        func peek(_ offset: Int = 0) -> Character? {
            var idx = i
            for _ in 0..<offset {
                guard idx < line.endIndex else { return nil }
                idx = line.index(after: idx)
            }
            return idx < line.endIndex ? line[idx] : nil
        }

        func advance(_ n: Int = 1) {
            for _ in 0..<n {
                guard i < line.endIndex else { return }
                i = line.index(after: i)
            }
        }

        // Detect python/shebang-like comment lines: first non-whitespace is '#'
        if let firstNonSpace = line.firstIndex(where: { !$0.isWhitespace }),
           line[firstNonSpace] == "#" {
            tokens.append(Token(text: line[line.startIndex..<line.endIndex], kind: .comment))
            return tokens
        }

        while i < line.endIndex {
            let ch = line[i]

            // Inline comment: //
            if ch == "/", peek(1) == "/" {
                let range = i..<line.endIndex
                tokens.append(Token(text: line[range], kind: .comment))
                return tokens
            }

            // Whitespace
            if ch.isWhitespace {
                let start = i
                while i < line.endIndex, line[i].isWhitespace { advance() }
                tokens.append(Token(text: line[start..<i], kind: .plain))
                continue
            }

            // String literals
            if ch == "\"" || ch == "'" {
                let quote = ch
                let start = i
                advance()
                var escaped = false
                while i < line.endIndex {
                    let c = line[i]
                    if escaped {
                        escaped = false
                        advance()
                        continue
                    }
                    if c == "\\" {
                        escaped = true
                        advance()
                        continue
                    }
                    if c == quote {
                        advance()
                        break
                    }
                    advance()
                }
                tokens.append(Token(text: line[start..<i], kind: .string))
                continue
            }

            // Numbers
            if ch.isNumber {
                let start = i
                while i < line.endIndex, line[i].isNumber || line[i] == "." { advance() }
                tokens.append(Token(text: line[start..<i], kind: .number))
                continue
            }

            // Identifiers / keywords
            if ch.isLetter || ch == "_" {
                let start = i
                advance()
                while i < line.endIndex {
                    let c = line[i]
                    if c.isLetter || c.isNumber || c == "_" { advance() } else { break }
                }
                let word = line[start..<i]
                let kind: Token.Kind

                if isKeyword(word) {
                    kind = .keyword
                } else if looksLikeTypeName(word) {
                    kind = .typeName
                } else {
                    kind = .plain
                }

                tokens.append(Token(text: word, kind: kind))
                continue
            }

            // Operators / punctuation
            let start = i
            advance()
            tokens.append(Token(text: line[start..<i], kind: .plain))
        }

        return tokens
    }

    private func isKeyword(_ word: Substring) -> Bool {
        // Small superset of common Swift/JS/Python keywords.
        // (We can't depend on a full parser here.)
        let keywords: Set<String> = [
            "import", "export", "from", "as",
            "struct", "class", "enum", "protocol", "extension", "func", "var", "let",
            "if", "else", "for", "while", "repeat", "switch", "case", "default",
            "break", "continue", "return", "throw", "throws", "try", "catch",
            "do", "in", "where", "guard", "defer",
            "public", "private", "fileprivate", "internal", "open",
            "static", "final", "override", "mutating", "nonmutating",
            "async", "await",
            "true", "false", "nil",
            "self", "super",
            // JS/Python-ish
            "const", "function", "async", "await", "new", "this",
            "def", "pass", "lambda", "None"
        ]
        return keywords.contains(String(word))
    }

    private func looksLikeTypeName(_ word: Substring) -> Bool {
        // Simple heuristic: PascalCase (leading uppercase).
        guard let first = word.first else { return false }
        return first.isUppercase
    }

    // MARK: - Diff colors

    private func diffColor(for kind: MinimapDiffIndicator.Kind) -> Color {
        switch kind {
        case .added:
            return Color.green
        case .modified:
            return Color.red
        case .deleted:
            // VS Code uses red-ish for deletions too; keep distinct via slightly different tone.
            return Color(red: 1.0, green: 0.35, blue: 0.35)
        }
    }
}
>>>END

>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor/MinimapView.swift","start_line":1,"end_line":220}
>>>END

>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor/MinimapView.swift","start_line":220,"end_line":520}
>>>END

>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor/MinimapView.swift","start_line":170,"end_line":270}
>>>END

>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor/MinimapView.swift","start_line":1,"end_line":40}
>>>END

>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor/MinimapView.swift","start_line":1,"end_line":15}
>>>END

>>>REPORT
Implemented VS Code–style minimap rendering and interactions in `VSCodeiPadOS/VSCodeiPadOS/Views/Editor/MinimapView.swift`.

Key changes (with evidence):
- Actual syntax-colored code preview (tiny rendering):
  - Replaced placeholder “gray line rectangles” with `Canvas`-based rendering (lines 61-70).
  - Renders either:
    - Tiny monospaced syntax-colored text via `AttributedString` (lines 188-212, 282-302), or
    - VS Code–like colored “token blocks” when the minimap is too dense (lines 212-246).
  - Added lightweight tokenizer + token color mapping for keywords/strings/comments/numbers/type-names (lines 249-450).
- Highlight current visible region:
  - Semi-transparent overlay + stroke tied to current scroll state (lines 102-115) using `visibleRegionHeight/Offset` helpers (lines 137-151).
- Click-to-scroll and drag scrolling:
  - Implemented a `DragGesture(minimumDistance: 0)` to capture both taps and drags (lines 85-95).
  - Scroll position updates by centering the main view around the minimap Y position (lines 155-168).
- Git diff indicators (red/green bars):
  - Added optional `diffIndicators: [MinimapDiffIndicator]` input (lines 16-18) and the `MinimapDiffIndicator` type (lines 29-45).
  - Rendered thin left-side bars scaled by line ranges (lines 117-135) with colors for added/modified/deleted (lines 451-463).

Only modified file: `VSCodeiPadOS/VSCodeiPadOS/Views/Editor/MinimapView.swift`.
>>>END
