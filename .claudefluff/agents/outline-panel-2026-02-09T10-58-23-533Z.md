# Agent: outline-panel
**Status:** done
**Tokens:** 106,342
**Cost:** $0.0000
**Time:** 2026-02-09T10:58:23.533Z

## Task
Build Outline panel. Create Views/Panels/OutlineView.swift:

1. Show file symbols tree
2. Functions, classes, variables
3. Click to jump to symbol
4. Icons by symbol type
5. Filter/search symbols
6. Sort alphabetically or by position

Parse symbols from current file.

## Response
>>>TOOL list_dir
{"path":"/Users/danielswagg/PLAYGROUND/vscode-ipados"}
>>>END>>>TOOL list_dir
{"path":"/Users/danielswagg/PLAYGROUND/vscode-ipados/Views"}
>>>END>>>TOOL list_dir
{"path":"/Users/danielswagg/PLAYGROUND/vscode-ipados/Views/Panels"}
>>>END>>>TOOL read_file
{"path":"/Users/danielswagg/PLAYGROUND/vscode-ipados/Views/Panels","start_line":1,"end_line":200}
>>>END>>>TOOL list_dir
{"path":"/Users/danielswagg/PLAYGROUND/vscode-ipados/Views/Panels"}
>>>END

>>>TOOL list_dir
{}
>>>END

>>>TOOL list_dir
{"path":"/Users/danielswagg/PLAYGROUND/vscode-ipados/VSCodeiPadOS"}
>>>END

>>>TOOL list_dir
{"path":"VSCodeiPadOS"}
>>>END

>>>TOOL list_dir
{"path":"VSCodeiPadOS/Views"}
>>>END

>>>TOOL list_dir
{"path":"VSCodeiPadOS"}
>>>END

>>>TOOL list_dir
{"path":"VSCodeiPadOS/VSCodeiPadOS"}
>>>END

>>>TOOL list_dir
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views"}
>>>END

>>>TOOL list_dir
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Panels"}
>>>END

>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/ContentView.swift","start_line":1,"end_line":260}
>>>END

>>>TOOL search
{"query":"class EditorCore", "glob":"VSCodeiPadOS/VSCodeiPadOS/**/*.swift"}
>>>END>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Models/EditorCore.swift","start_line":1,"end_line":260}
>>>END>>>END
But tool calls should not be multiple? Wait user says max 1-5 tools, ok. But should format each call separate lines with >>>END. I included but also an extra >>>END at end mistakenly. I need to ensure proper format: each tool call. I did 2 tool calls and an extra >>>END line. That violates. Let's correct by sending only one tool call now. Need to wait. We'll send search only first.>>>TOOL search
{"query":"class EditorCore", "glob":"VSCodeiPadOS/VSCodeiPadOS/**/*.swift"}
>>>END

>>>TOOL search
{"query":"struct IDEEditorView", "glob":"VSCodeiPadOS/VSCodeiPadOS/**/*.swift"}
>>>END
>>>TOOL search
{"query":"onGoToLine", "glob":"VSCodeiPadOS/VSCodeiPadOS/**/*.swift"}
>>>END
>>>TOOL search
{"query":"CursorPosition", "glob":"VSCodeiPadOS/VSCodeiPadOS/**/*.swift"}
>>>END
>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Panels/GoToLineView.swift","start_line":1,"end_line":220}
>>>END

>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/ContentView.swift","start_line":300,"end_line":520}
>>>END

>>>TOOL search
{"query":"struct SyntaxHighlightingTextView", "glob":"VSCodeiPadOS/VSCodeiPadOS/**/*.swift"}
>>>END
>>>TOOL search
{"query":"scrollPosition:", "glob":"VSCodeiPadOS/VSCodeiPadOS/**/*.swift"}
>>>END
>>>TOOL search
{"query":"showGoToLine", "glob":"VSCodeiPadOS/VSCodeiPadOS/**/*.swift"}
>>>END
>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Panels/GoToLineView.swift","start_line":1,"end_line":220}
>>>END

>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift","start_line":1,"end_line":260}
>>>END

>>>TOOL search
{"query":"struct SidebarSearchView", "glob":"VSCodeiPadOS/VSCodeiPadOS/**/*.swift"}
>>>END
>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Panels/GitView.swift","start_line":1,"end_line":260}
>>>END
>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Panels/TerminalView.swift","start_line":1,"end_line":260}
>>>END
>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Panels/SettingsView.swift","start_line":1,"end_line":260}
>>>END

>>>TOOL search
{"query":"scrollTo", "glob":"VSCodeiPadOS/VSCodeiPadOS/**/*.swift"}
>>>END
>>>TOOL search
{"query":"requested", "glob":"VSCodeiPadOS/VSCodeiPadOS/**/*.swift"}
>>>END
>>>TOOL search
{"query":"jump", "glob":"VSCodeiPadOS/VSCodeiPadOS/**/*.swift"}
>>>END
>>>END

>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Models/FindViewModel.swift","start_line":1,"end_line":160}
>>>END
>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/ContentView.swift","start_line":720,"end_line":825}
>>>END
>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/CommandPalette.swift","start_line":440,"end_line":560}
>>>END
>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/TabBarView.swift","start_line":1,"end_line":140}
>>>END
>>>TOOL search
{"query":"FileItem", "glob":"VSCodeiPadOS/VSCodeiPadOS/**/*.swift"}
>>>END

>>>TOOL search
{"query":"struct CursorPosition", "glob":"VSCodeiPadOS/VSCodeiPadOS/**/*.swift"}
>>>END
>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Models/CursorPosition.swift","start_line":1,"end_line":120}
>>>END
>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Models/FileItem.swift","start_line":1,"end_line":120}
>>>END
>>>END>>>TOOL search
{"query":"struct CursorPosition", "glob":"VSCodeiPadOS/VSCodeiPadOS/**/*.swift"}
>>>END>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Models/CursorPosition.swift","start_line":1,"end_line":120}
>>>END

>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Models/EditorState.swift","start_line":1,"end_line":220}
>>>END
>>>TOOL search
{"query":"Outline", "glob":"VSCodeiPadOS/VSCodeiPadOS/**/*.swift"}
>>>END
>>>TOOL search
{"query":"symbol", "glob":"VSCodeiPadOS/VSCodeiPadOS/**/*.swift"}
>>>END
>>>TOOL search
{"query":"Sidebar", "glob":"VSCodeiPadOS/VSCodeiPadOS/Views/**/*.swift"}
>>>END
>>>TOOL list_dir
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Panels"}
>>>END

>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/SidebarView.swift","start_line":1,"end_line":260}
>>>END

>>>TOOL search
{"query":"struct Tab", "glob":"VSCodeiPadOS/VSCodeiPadOS/**/*.swift"}
>>>END
>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Models/Tab.swift","start_line":1,"end_line":220}
>>>END
>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Models/EditorState.swift","start_line":100,"end_line":180}
>>>END
>>>TOOL list_dir
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views"}
>>>END
>>>TOOL list_dir
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Panels"}
>>>END

>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Panels/GoToSymbol.swift","start_line":1,"end_line":260}
>>>END
>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor/BreadcrumbsView.swift","start_line":1,"end_line":220}
>>>END
>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/SidebarView.swift","start_line":1,"end_line":260}
>>>END
>>>TOOL search
{"query":"OutlineView", "glob":"VSCodeiPadOS/VSCodeiPadOS/**/*.swift"}
>>>END
>>>END>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Panels/GoToSymbol.swift","start_line":1,"end_line":260}
>>>END
>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor/BreadcrumbsView.swift","start_line":1,"end_line":220}
>>>END
>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/SidebarView.swift","start_line":1,"end_line":260}
>>>END
>>>END>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Panels/GoToSymbol.swift","start_line":1,"end_line":260}
>>>END
>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor/BreadcrumbsView.swift","start_line":1,"end_line":220}
>>>END
>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/SidebarView.swift","start_line":1,"end_line":260}
>>>END>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Panels/GoToSymbol.swift","start_line":1,"end_line":260}
>>>END
>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor/BreadcrumbsView.swift","start_line":1,"end_line":220}
>>>END
>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/SidebarView.swift","start_line":1,"end_line":260}
>>>END

>>>TOOL list_dir
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor"}
>>>END
>>>TOOL search
{"query":"@Published var scroll", "glob":"VSCodeiPadOS/VSCodeiPadOS/**/*.swift"}
>>>END
>>>TOOL search
{"query":"goToLine", "glob":"VSCodeiPadOS/VSCodeiPadOS/**/*.swift"}
>>>END
>>>TOOL search
{"query":"scrollPosition =", "glob":"VSCodeiPadOS/VSCodeiPadOS/**/*.swift"}
>>>END
>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor","start_line":1,"end_line":40}
>>>END

>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/FileTreeView.swift","start_line":1,"end_line":260}
>>>END
>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/FileIconView.swift","start_line":1,"end_line":220}
>>>END
>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/SidebarView.swift","start_line":260,"end_line":323}
>>>END
>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/ContentView.swift","start_line":1,"end_line":160}
>>>END
>>>END

>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/GoToSymbol.swift","start_line":260,"end_line":520}
>>>END
>>>TOOL list_dir
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor"}
>>>END
>>>TOOL search
{"query":"@Published var scrollPosition", "glob":"VSCodeiPadOS/VSCodeiPadOS/**/*.swift"}
>>>END
>>>TOOL search
{"query":"scrollPosition", "glob":"VSCodeiPadOS/VSCodeiPadOS/Models/**/*.swift"}
>>>END
>>>TOOL search
{"query":"setScroll", "glob":"VSCodeiPadOS/VSCodeiPadOS/**/*.swift"}
>>>END

>>>TOOL search
{"query":"showGoToSymbol", "glob":"VSCodeiPadOS/VSCodeiPadOS/**/*.swift"}
>>>END
>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/GoToSymbol.swift","start_line":520,"end_line":680}
>>>END
>>>TOOL search
{"query":"jumpToLine", "glob":"VSCodeiPadOS/VSCodeiPadOS/**/*.swift"}
>>>END
>>>TOOL search
{"query":"goToLine", "glob":"VSCodeiPadOS/VSCodeiPadOS/**/*.swift"}
>>>END
>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/StatusBarView.swift","start_line":1,"end_line":220}
>>>END

>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Services/EditorCore.swift","start_line":1,"end_line":320}
>>>END
>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Commands/AppCommands.swift","start_line":1,"end_line":260}
>>>END
>>>TOOL search
{"query":"requestedScroll", "glob":"VSCodeiPadOS/VSCodeiPadOS/**/*.swift"}
>>>END
>>>TOOL search
{"query":"NotificationCenter", "glob":"VSCodeiPadOS/VSCodeiPadOS/**/*.swift"}
>>>END
>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/ContentView.swift","start_line":260,"end_line":420}
>>>END

>>>TOOL search
{"query":"SidebarView(", "glob":"VSCodeiPadOS/VSCodeiPadOS/**/*.swift"}
>>>END
>>>TOOL search
{"query":"ContentView()", "glob":"VSCodeiPadOS/VSCodeiPadOS/**/*.swift"}
>>>END
>>>TOOL search
{"query":"struct ContentView", "glob":"VSCodeiPadOS/VSCodeiPadOS/**/*.swift"}
>>>END
>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/App/VSCodeiPadOSApp.swift","start_line":1,"end_line":120}
>>>END
>>>TOOL list_dir
{"path":"VSCodeiPadOS/VSCodeiPadOS/App"}
>>>END

>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/ContentView.swift","start_line":120,"end_line":190}
>>>END
>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/ContentView.swift","start_line":108,"end_line":140}
>>>END
>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/ContentView.swift","start_line":112,"end_line":135}
>>>END
>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/ContentView.swift","start_line":336,"end_line":440}
>>>END
>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Services/EditorCore.swift","start_line":120,"end_line":170}
>>>END
>>>END

>>>TOOL search
{"query":"showGoToSymbol", "glob":"VSCodeiPadOS/VSCodeiPadOS/**/*.swift"}
>>>END
>>>TOOL search
{"query":"GoToSymbolView", "glob":"VSCodeiPadOS/VSCodeiPadOS/**/*.swift"}
>>>END
>>>END

>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/GoToSymbol.swift","start_line":560,"end_line":640}
>>>END
>>>TOOL search
{"query":"showGoToSymbol", "glob":"VSCodeiPadOS/VSCodeiPadOS/ContentView.swift"}
>>>END
>>>TOOL search
{"query":"GoToSymbolView(", "glob":"VSCodeiPadOS/VSCodeiPadOS/ContentView.swift"}
>>>END
>>>END

>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/App/VSCodeiPadOSApp.swift","start_line":1,"end_line":160}
>>>END

>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/GoToSymbol.swift","start_line":600,"end_line":640}
>>>END
>>>TOOL search
{"query":"showGoToSymbol", "glob":"VSCodeiPadOS/VSCodeiPadOS/ContentView.swift"}
>>>END
>>>TOOL search
{"query":"GoToSymbolView", "glob":"VSCodeiPadOS/VSCodeiPadOS/ContentView.swift"}
>>>END

>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/ContentView.swift","start_line":170,"end_line":280}
>>>END
>>>TOOL search
{"query":"struct IDESidebarFiles", "glob":"VSCodeiPadOS/VSCodeiPadOS/ContentView.swift"}
>>>END
>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Services/EditorCore.swift","start_line":1,"end_line":70}
>>>END
>>>END

>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/ContentView.swift","start_line":1,"end_line":170}
>>>END
>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/ContentView.swift","start_line":136,"end_line":170}
>>>END
>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/ContentView.swift","start_line":140,"end_line":160}
>>>END
>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Services/EditorCore.swift","start_line":1,"end_line":40}
>>>END
>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/ContentView.swift","start_line":330,"end_line":460}
>>>END
>>>END

>>>TOOL search
{"query":"requestedScroll", "glob":"VSCodeiPadOS/VSCodeiPadOS/**/*.swift"}
>>>END
>>>TOOL search
{"query":"requested", "glob":"VSCodeiPadOS/VSCodeiPadOS/**/*.swift"}
>>>END
>>>TOOL search
{"query":"scrollToLine(", "glob":"VSCodeiPadOS/VSCodeiPadOS/**/*.swift"}
>>>END
>>>TOOL search
{"query":"showGoToLine", "glob":"VSCodeiPadOS/VSCodeiPadOS/**/*.swift"}
>>>END
>>>END

>>>TOOL create_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Panels/OutlineView.swift","content":"import SwiftUI\n\n// MARK: - Outline Panel\n\n/// Shows a tree of symbols (classes/structs/enums + their members, functions, vars/lets) for the current file.\nstruct OutlineView: View {\n    @ObservedObject var editorCore: EditorCore\n\n    enum SortMode: String, CaseIterable, Identifiable {\n        case position = \"Position\"\n        case alphabetical = \"A–Z\"\n        var id: String { rawValue }\n    }\n\n    @State private var filterText: String = \"\"\n    @State private var sortMode: SortMode = .position\n    @State private var rootItems: [OutlineItem] = []\n\n    private var activeTab: Tab? { editorCore.activeTab }\n\n    var body: some View {\n        VStack(alignment: .leading, spacing: 8) {\n            header\n\n            filterField\n\n            Picker(\"\", selection: $sortMode) {\n                ForEach(SortMode.allCases) { mode in\n                    Text(mode.rawValue).tag(mode)\n                }\n            }\n            .pickerStyle(.segmented)\n\n            if activeTab == nil {\n                emptyState(title: \"No file selected\")\n            } else if rootItems.isEmpty {\n                emptyState(title: \"No symbols\")\n            } else if displayItems.isEmpty {\n                emptyState(title: \"No matches\")\n            } else {\n                OutlineGroup(displayItems, children: \\ .children) { item in\n                    OutlineRow(item: item) {\n                        editorCore.requestScroll(toLine: item.symbol.line)\n                    }\n                }\n            }\n        }\n        .padding(.horizontal, 12)\n        .padding(.vertical, 10)\n        .background(Color(UIColor.secondarySystemBackground))\n        .onAppear { refresh() }\n        .onChange(of: editorCore.activeTabId) { _ in refresh() }\n        .onChange(of: editorCore.tabs) { _ in refresh() }\n    }\n\n    private var header: some View {\n        HStack(spacing: 8) {\n            Text(\"OUTLINE\")\n                .font(.caption)\n                .fontWeight(.semibold)\n                .foregroundColor(.secondary)\n\n            Spacer()\n\n            Button {\n                refresh()\n            } label: {\n                Image(systemName: \"arrow.clockwise\")\n                    .font(.caption)\n                    .foregroundColor(.secondary)\n            }\n            .buttonStyle(.plain)\n            .accessibilityLabel(\"Refresh Outline\")\n        }\n    }\n\n    private var filterField: some View {\n        HStack(spacing: 6) {\n            Image(systemName: \"magnifyingglass\")\n                .font(.caption)\n                .foregroundColor(.secondary)\n\n            TextField(\"Filter symbols\", text: $filterText)\n                .textFieldStyle(.plain)\n                .font(.system(size: 13))\n\n            if !filterText.isEmpty {\n                Button {\n                    filterText = \"\"\n                } label: {\n                    Image(systemName: \"xmark.circle.fill\")\n                        .font(.caption)\n                        .foregroundColor(.secondary)\n                }\n                .buttonStyle(.plain)\n            }\n        }\n        .padding(8)\n        .background(Color(UIColor.tertiarySystemFill))\n        .cornerRadius(6)\n    }\n\n    private func emptyState(title: String) -> some View {\n        HStack(spacing: 8) {\n            Image(systemName: \"list.bullet.indent\")\n                .foregroundColor(.secondary.opacity(0.6))\n            Text(title)\n                .font(.caption)\n                .foregroundColor(.secondary)\n            Spacer()\n        }\n        .padding(.vertical, 6)\n    }\n\n    private var displayItems: [OutlineItem] {\n        let filtered = OutlineItemFilter.filter(items: rootItems, query: filterText)\n        return OutlineItemSorter.sort(items: filtered, mode: sortMode)\n    }\n\n    private func refresh() {\n        guard let tab = editorCore.activeTab else {\n            rootItems = []\n            return\n        }\n\n        rootItems = OutlineTreeParser.parse(content: tab.content, language: tab.language)\n    }\n}\n\n// MARK: - Row\n\nprivate struct OutlineRow: View {\n    let item: OutlineItem\n    let onSelect: () -> Void\n\n    var body: some View {\n        HStack(spacing: 8) {\n            Image(systemName: item.symbol.type.icon)\n                .font(.system(size: 12))\n                .foregroundColor(item.symbol.type.color)\n                .frame(width: 16)\n\n            Text(item.symbol.name)\n                .font(.system(size: 12, design: .monospaced))\n                .lineLimit(1)\n\n            Spacer()\n\n            Text(\"\u202f\(item.symbol.line)\")\n                .font(.system(size: 11, design: .monospaced))\n                .foregroundColor(.secondary)\n        }\n        .contentShape(Rectangle())\n        .onTapGesture(perform: onSelect)\n        .padding(.vertical, 4)\n    }\n}\n\n// MARK: - Outline Tree Model\n\nfinal class OutlineItem: Identifiable {\n    let id: UUID\n    let symbol: CodeSymbol\n    var children: [OutlineItem]\n\n    init(id: UUID = UUID(), symbol: CodeSymbol, children: [OutlineItem] = []) {\n        self.id = id\n        self.symbol = symbol\n        self.children = children\n    }\n\n    func copying(children: [OutlineItem]) -> OutlineItem {\n        OutlineItem(id: id, symbol: symbol, children: children)\n    }\n}\n\n// MARK: - Filter + Sort\n\nprivate enum OutlineItemFilter {\n    static func filter(items: [OutlineItem], query: String) -> [OutlineItem] {\n        let q = query.trimmingCharacters(in: .whitespacesAndNewlines).lowercased()\n        guard !q.isEmpty else { return items }\n\n        return items.compactMap { item in\n            let filteredChildren = filter(items: item.children, query: q)\n            let matchesSelf = item.symbol.name.lowercased().contains(q)\n\n            guard matchesSelf || !filteredChildren.isEmpty else { return nil }\n            return item.copying(children: filteredChildren)\n        }\n    }\n}\n\nprivate enum OutlineItemSorter {\n    static func sort(items: [OutlineItem], mode: OutlineView.SortMode) -> [OutlineItem] {\n        switch mode {\n        case .position:\n            // Already position-ordered by parser; sort children recursively.\n            return items.map { $0.copying(children: sort(items: $0.children, mode: mode)) }\n        case .alphabetical:\n            let sorted = items\n                .sorted { $0.symbol.name.localizedCaseInsensitiveCompare($1.symbol.name) == .orderedAscending }\n                .map { $0.copying(children: sort(items: $0.children, mode: mode)) }\n            return sorted\n        }\n    }\n}\n\n// MARK: - Tree Parser\n\nprivate enum OutlineTreeParser {\n    static func parse(content: String, language: CodeLanguage) -> [OutlineItem] {\n        switch language {\n        case .python:\n            return parsePython(content: content)\n        case .javascript, .typescript:\n            return parseBraceScoped(content: content, language: language)\n        case .swift:\n            return parseBraceScoped(content: content, language: language)\n        default:\n            // Fallback to flat symbols grouped at root.\n            return SymbolParser.parseSymbols(from: content, language: language)\n                .map { OutlineItem(symbol: $0, children: []) }\n        }\n    }\n\n    // MARK: Brace-scoped languages (Swift, JS/TS)\n\n    private struct ContainerFrame {\n        let node: OutlineItem\n        var activeDepth: Int\n        var pending: Bool\n    }\n\n    private static func parseBraceScoped(content: String, language: CodeLanguage) -> [OutlineItem] {\n        let lines = content.components(separatedBy: .newlines)\n        var roots: [OutlineItem] = []\n\n        var braceDepth = 0\n        var stack: [ContainerFrame] = []\n\n        for (idx, rawLine) in lines.enumerated() {\n            let lineNumber = idx + 1\n            let trimmed = rawLine.trimmingCharacters(in: .whitespaces)\n\n            // Pop containers whose scope ended (after previous line updated braceDepth).\n            while let last = stack.last, !last.pending, braceDepth < last.activeDepth {\n                stack.removeLast()\n            }\n\n            let openCount = rawLine.filter { $0 == \"{\" }.count\n            let closeCount = rawLine.filter { $0 == \"}\" }.count\n\n            // Activate a pending container when we hit its opening brace.\n            if openCount > 0, let last = stack.last, last.pending {\n                var updated = last\n                updated.pending = false\n                // After this line is processed, depth increases by openCount-closeCount.\n                // For a standalone \"{\", this makes the container active at braceDepth + openCount.\n                updated.activeDepth = braceDepth + openCount\n                stack[stack.count - 1] = updated\n            }\n\n            // Skip obvious comment-only lines.\n            if trimmed.hasPrefix(\"//\") || trimmed.hasPrefix(\"/*\") || trimmed.hasPrefix(\"*\") {\n                braceDepth += (openCount - closeCount)\n                continue\n            }\n\n            if let symbol = matchSymbol(in: rawLine, language: language, lineNumber: lineNumber, braceDepth: braceDepth, inContainer: stack.last?.node.symbol.type.isContainerType == true) {\n                let node = OutlineItem(symbol: symbol)\n\n                // Attach\n                if let parent = stack.last, !parent.pending {\n                    parent.node.children.append(node)\n                } else {\n                    roots.append(node)\n                }\n\n                // If container, push\n                if symbol.type.isContainerType {\n                    let depthAfterLine = braceDepth + openCount - closeCount\n                    if openCount > 0 {\n                        stack.append(ContainerFrame(node: node, activeDepth: depthAfterLine, pending: false))\n                    } else {\n                        // Brace on next line.\n                        stack.append(ContainerFrame(node: node, activeDepth: Int.max, pending: true))\n                    }\n                }\n            }\n\n            braceDepth += (openCount - closeCount)\n        }\n\n        return roots\n    }\n\n    // MARK: Python (indent-scoped)\n\n    private struct PythonFrame {\n        let node: OutlineItem\n        let indent: Int\n        let isClass: Bool\n    }\n\n    private static func parsePython(content: String) -> [OutlineItem] {\n        let lines = content.components(separatedBy: .newlines)\n        var roots: [OutlineItem] = []\n        var stack: [PythonFrame] = []\n\n        func indentLevel(of line: String) -> Int {\n            var count = 0\n            for ch in line {\n                if ch == \" \" { count += 1 }\n                else if ch == \"\\t\" { count += 4 }\n                else { break }\n            }\n            return count\n        }\n\n        let classRegex = try? NSRegularExpression(pattern: #\"^\\s*class\\s+(\\w+)\"#, options: [])\n        let defRegex = try? NSRegularExpression(pattern: #\"^\\s*(async\\s+)?def\\s+(\\w+)\"#, options: [])\n\n        for (idx, rawLine) in lines.enumerated() {\n            let lineNumber = idx + 1\n            let trimmed = rawLine.trimmingCharacters(in: .whitespacesAndNewlines)\n            if trimmed.isEmpty || trimmed.hasPrefix(\"#\") {\n                continue\n            }\n\n            let indent = indentLevel(of: rawLine)\n            while let last = stack.last, indent <= last.indent {\n                stack.removeLast()\n            }\n\n            if let classRegex,\n               let match = classRegex.firstMatch(in: rawLine, options: [], range: NSRange(rawLine.startIndex..., in: rawLine)),\n               let range = Range(match.range(at: 1), in: rawLine) {\n                let name = String(rawLine[range])\n                let sym = CodeSymbol(name: name, type: .class, line: lineNumber, column: 1, detail: nil, containerName: nil)\n                let node = OutlineItem(symbol: sym)\n\n                if let parent = stack.last {\n                    parent.node.children.append(node)\n                } else {\n                    roots.append(node)\n                }\n\n                stack.append(PythonFrame(node: node, indent: indent, isClass: true))\n                continue\n            }\n\n            if let defRegex,\n               let match = defRegex.firstMatch(in: rawLine, options: [], range: NSRange(rawLine.startIndex..., in: rawLine)),\n               let range = Range(match.range(at: 2), in: rawLine) {\n                let name = String(rawLine[range])\n                let isMethod = stack.last?.isClass == true\n                let sym = CodeSymbol(name: name, type: isMethod ? .method : .function, line: lineNumber, column: 1, detail: nil, containerName: nil)\n                let node = OutlineItem(symbol: sym)\n\n                if let parent = stack.last {\n                    parent.node.children.append(node)\n                } else {\n                    roots.append(node)\n                }\n\n                stack.append(PythonFrame(node: node, indent: indent, isClass: false))\n                continue\n            }\n        }\n\n        return roots\n    }\n\n    // MARK: Regex matchers\n\n    private static func matchSymbol(in line: String, language: CodeLanguage, lineNumber: Int, braceDepth: Int, inContainer: Bool) -> CodeSymbol? {\n        switch language {\n        case .swift:\n            return matchSwift(in: line, lineNumber: lineNumber, inContainer: inContainer)\n        case .javascript, .typescript:\n            return matchJS(in: line, lineNumber: lineNumber, inContainer: inContainer, language: language)\n        default:\n            return nil\n        }\n    }\n\n    private static func matchSwift(in line: String, lineNumber: Int, inContainer: Bool) -> CodeSymbol? {\n        // Containers\n        if let name = firstCapture(in: line, pattern: #\"^\\s*(public |private |internal |fileprivate |open )?(final )?class\\s+(\\w+)\"#, group: 3) {\n            return CodeSymbol(name: name, type: .class, line: lineNumber, column: 1, detail: nil, containerName: nil)\n        }\n        if let name = firstCapture(in: line, pattern: #\"^\\s*(public |private |internal |fileprivate |open )?struct\\s+(\\w+)\"#, group: 2) {\n            return CodeSymbol(name: name, type: .struct, line: lineNumber, column: 1, detail: nil, containerName: nil)\n        }\n        if let name = firstCapture(in: line, pattern: #\"^\\s*(public |private |internal |fileprivate |open )?enum\\s+(\\w+)\"#, group: 2) {\n            return CodeSymbol(name: name, type: .enum, line: lineNumber, column: 1, detail: nil, containerName: nil)\n        }\n        if let name = firstCapture(in: line, pattern: #\"^\\s*(public |private |internal |fileprivate |open )?protocol\\s+(\\w+)\"#, group: 2) {\n            return CodeSymbol(name: name, type: .protocol, line: lineNumber, column: 1, detail: nil, containerName: nil)\n        }\n\n        // init\n        if firstMatch(in: line, pattern: #\"^\\s*(public |private |internal |fileprivate |open )?(required |convenience )?init\\b\"#) {\n            return CodeSymbol(name: \"init\", type: .constructor, line: lineNumber, column: 1, detail: nil, containerName: nil)\n        }\n\n        // funcs\n        if let name = firstCapture(in: line, pattern: #\"^\\s*(public |private |internal |fileprivate |open )?func\\s+(\\w+)\"#, group: 2) {\n            return CodeSymbol(name: name, type: inContainer ? .method : .function, line: lineNumber, column: 1, detail: nil, containerName: nil)\n        }\n\n        // vars/lets\n        if let name = firstCapture(in: line, pattern: #\"^\\s*(public |private |internal |fileprivate |open )?(static |class )?(var|let)\\s+(\\w+)\"#, group: 4) {\n            // Use variable for locals, property if in container.\n            return CodeSymbol(name: name, type: inContainer ? .property : .variable, line: lineNumber, column: 1, detail: nil, containerName: nil)\n        }\n\n        return nil\n    }\n\n    private static func matchJS(in line: String, lineNumber: Int, inContainer: Bool, language: CodeLanguage) -> CodeSymbol? {\n        // class\n        if let name = firstCapture(in: line, pattern: #\"^\\s*(export )?(default )?class\\s+(\\w+)\"#, group: 3) {\n            return CodeSymbol(name: name, type: .class, line: lineNumber, column: 1, detail: nil, containerName: nil)\n        }\n\n        // interface/type/enum (TS)\n        if language == .typescript {\n            if let name = firstCapture(in: line, pattern: #\"^\\s*(export )?interface\\s+(\\w+)\"#, group: 2) {\n                return CodeSymbol(name: name, type: .interface, line: lineNumber, column: 1, detail: nil, containerName: nil)\n            }\n            if let name = firstCapture(in: line, pattern: #\"^\\s*(export )?type\\s+(\\w+)\"#, group: 2) {\n                return CodeSymbol(name: name, type: .type, line: lineNumber, column: 1, detail: nil, containerName: nil)\n            }\n            if let name = firstCapture(in: line, pattern: #\"^\\s*(export )?enum\\s+(\\w+)\"#, group: 2) {\n                return CodeSymbol(name: name, type: .enum, line: lineNumber, column: 1, detail: nil, containerName: nil)\n            }\n        }\n\n        // function\n        if let name = firstCapture(in: line, pattern: #\"^\\s*(export )?(async )?function\\s+(\\w+)\"#, group: 3) {\n            return CodeSymbol(name: name, type: .function, line: lineNumber, column: 1, detail: nil, containerName: nil)\n        }\n\n        // variable assignments\n        if let name = firstCapture(in: line, pattern: #\"^\\s*(export )?(const|let|var)\\s+(\\w+)\\s*=\"#, group: 3) {\n            return CodeSymbol(name: name, type: .variable, line: lineNumber, column: 1, detail: nil, containerName: nil)\n        }\n\n        // method-ish\n        if let name = firstCapture(in: line, pattern: #\"^\\s*(static )?(async )?(\\w+)\\s*\\(.*\\)\\s*\\{\"#, group: 3) {\n            // Skip common keywords\n            if [\"if\", \"else\", \"for\", \"while\", \"switch\", \"catch\"].contains(name) {\n                return nil\n            }\n            return CodeSymbol(name: name, type: inContainer ? .method : .function, line: lineNumber, column: 1, detail: nil, containerName: nil)\n        }\n\n        return nil\n    }\n\n    private static func firstMatch(in line: String, pattern: String) -> Bool {\n        (try? NSRegularExpression(pattern: pattern, options: []))?\n            .firstMatch(in: line, options: [], range: NSRange(line.startIndex..., in: line)) != nil\n    }\n\n    private static func firstCapture(in line: String, pattern: String, group: Int) -> String? {\n        guard let regex = try? NSRegularExpression(pattern: pattern, options: []) else { return nil }\n        guard let match = regex.firstMatch(in: line, options: [], range: NSRange(line.startIndex..., in: line)) else { return nil }\n        guard match.numberOfRanges > group, let range = Range(match.range(at: group), in: line) else { return nil }\n        return String(line[range])\n    }\n}\n\nprivate extension SymbolType {\n    var isContainerType: Bool {\n        switch self {\n        case .class, .struct, .enum, .protocol, .interface, .namespace, .module:\n            return true\n        default:\n            return false\n        }\n    }\n}\n"}>>>END
>>>END

>>>TOOL search
{"query":"SidebarView(", "glob":"VSCodeiPadOS/VSCodeiPadOS/**/*.swift"}
>>>END
>>>TOOL search
{"query":"IDESidebarFiles(", "glob":"VSCodeiPadOS/VSCodeiPadOS/**/*.swift"}
>>>END
>>>TOOL search
{"query":"IDEActivityBar(", "glob":"VSCodeiPadOS/VSCodeiPadOS/**/*.swift"}
>>>END
>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Panels/OutlineView.swift","start_line":1,"end_line":200}
>>>END
>>>END>>>TOOL search
{"query":"SidebarView(", "glob":"VSCodeiPadOS/VSCodeiPadOS/**/*.swift"}
>>>END
>>>TOOL search
{"query":"IDEActivityBar(", "glob":"VSCodeiPadOS/VSCodeiPadOS/**/*.swift"}
>>>END
>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Panels/OutlineView.swift","start_line":1,"end_line":260}
>>>END

>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Panels/OutlineView.swift","start_line":1,"end_line":200}
>>>END

>>>TOOL search
{"query":"OutlineItem", "glob":"VSCodeiPadOS/VSCodeiPadOS/**/*.swift"}
>>>END
>>>TOOL search
{"query":"requestedScroll", "glob":"VSCodeiPadOS/VSCodeiPadOS/**/*.swift"}
>>>END
>>>TOOL search
{"query":"navigate", "glob":"VSCodeiPadOS/VSCodeiPadOS/Services/EditorCore.swift"}
>>>END
>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Panels/OutlineView.swift","start_line":1,"end_line":60}
>>>END

>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/ContentView.swift","start_line":88,"end_line":135}
>>>END
>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/ContentView.swift","start_line":186,"end_line":230}
>>>END
>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/ContentView.swift","start_line":405,"end_line":455}
>>>END
>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Services/EditorCore.swift","start_line":1,"end_line":120}
>>>END

>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Services/EditorCore.swift","start_line":1,"end_line":90}
>>>END
>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/ContentView.swift","start_line":40,"end_line":140}
>>>END
>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/ContentView.swift","start_line":330,"end_line":430}
>>>END
>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Panels/OutlineView.swift","start_line":1,"end_line":80}
>>>END

>>>TOOL create_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Panels/OutlineView.swift","content":"import SwiftUI\n\n// MARK: - Outline Panel\n\n/// Shows a tree of symbols (classes/structs/enums + their members, functions, vars/lets) for the current file.\n///\n/// Note: This view parses symbols from the *current editor tab content* (no LSP).\nstruct OutlineView: View {\n    @ObservedObject var editorCore: EditorCore\n\n    /// Called when the user selects a symbol.\n    /// Expected behavior: scroll editor to `line` (1-indexed).\n    var onJumpToLine: (Int) -> Void = { _ in }\n\n    enum SortMode: String, CaseIterable, Identifiable {\n        case position = \"Position\"\n        case alphabetical = \"A–Z\"\n        var id: String { rawValue }\n    }\n\n    @State private var filterText: String = \"\"\n    @State private var sortMode: SortMode = .position\n\n    // Persist expansion by stable key (not UUID) so it survives reparses.\n    @State private var expandedKeys: Set<String> = []\n\n    @State private var parsedRootItems: [OutlineItem] = []\n    @State private var parseWorkItem: DispatchWorkItem?\n\n    private var activeTab: Tab? { editorCore.activeTab }\n    private var activeContent: String { activeTab?.content ?? \"\" }\n    private var activeLanguage: CodeLanguage { activeTab?.language ?? .plainText }\n\n    var body: some View {\n        VStack(alignment: .leading, spacing: 8) {\n            header\n            filterField\n            sortPicker\n\n            Divider()\n\n            if activeTab == nil {\n                emptyState(title: \"No file open\", systemImage: \"doc\")\n            } else if parsedRootItems.isEmpty {\n                emptyState(title: \"No symbols\", systemImage: \"list.bullet.rectangle\")\n            } else {\n                ScrollView {\n                    LazyVStack(alignment: .leading, spacing: 2) {\n                        ForEach(displayItems) { item in\n                            OutlineRow(\n                                item: item,\n                                level: 0,\n                                expandedKeys: $expandedKeys,\n                                onSelect: { selected in\n                                    onJumpToLine(selected.line)\n                                }\n                            )\n                        }\n                    }\n                    .padding(.horizontal, 8)\n                    .padding(.vertical, 6)\n                }\n            }\n        }\n        .background(Color(UIColor.secondarySystemBackground))\n        .onAppear { scheduleParse() }\n        .onChange(of: editorCore.activeTabId) { _ in scheduleParse() }\n        .onChange(of: activeContent) { _ in scheduleParse() }\n    }\n\n    // MARK: - UI\n\n    private var header: some View {\n        HStack {\n            Text(\"OUTLINE\")\n                .font(.caption)\n                .fontWeight(.semibold)\n                .foregroundColor(.secondary)\n\n            Spacer()\n\n            Button {\n                scheduleParse(immediate: true)\n            } label: {\n                Image(systemName: \"arrow.clockwise\")\n                    .font(.caption)\n                    .foregroundColor(.secondary)\n            }\n            .buttonStyle(.plain)\n            .help(\"Refresh\")\n        }\n        .padding(.horizontal, 12)\n        .padding(.top, 8)\n    }\n\n    private var filterField: some View {\n        HStack(spacing: 6) {\n            Image(systemName: \"line.3.horizontal.decrease.circle\")\n                .foregroundColor(.secondary)\n                .font(.caption)\n\n            TextField(\"Filter symbols\", text: $filterText)\n                .textFieldStyle(.plain)\n                .font(.system(size: 13))\n\n            if !filterText.isEmpty {\n                Button { filterText = \"\" } label: {\n                    Image(systemName: \"xmark.circle.fill\")\n                        .foregroundColor(.secondary)\n                        .font(.caption)\n                }\n                .buttonStyle(.plain)\n            }\n        }\n        .padding(8)\n        .background(Color(UIColor.tertiarySystemFill))\n        .cornerRadius(6)\n        .padding(.horizontal, 12)\n    }\n\n    private var sortPicker: some View {\n        Picker(\"Sort\", selection: $sortMode) {\n            ForEach(SortMode.allCases) { mode in\n                Text(mode.rawValue).tag(mode)\n            }\n        }\n        .pickerStyle(.segmented)\n        .padding(.horizontal, 12)\n        .onChange(of: sortMode) { _ in\n            // just re-renders computed sorting\n        }\n    }\n\n    private func emptyState(title: String, systemImage: String) -> some View {\n        VStack(spacing: 10) {\n            Spacer(minLength: 10)\n            Image(systemName: systemImage)\n                .font(.system(size: 28))\n                .foregroundColor(.secondary.opacity(0.6))\n            Text(title)\n                .font(.caption)\n                .foregroundColor(.secondary)\n            Spacer(minLength: 10)\n        }\n        .frame(maxWidth: .infinity)\n        .padding(.vertical, 30)\n    }\n\n    // MARK: - Display items (filter + sort)\n\n    private var displayItems: [OutlineItem] {\n        let filtered = OutlineTree.filter(items: parsedRootItems, query: filterText)\n        return OutlineTree.sort(items: filtered, mode: sortMode)\n    }\n\n    // MARK: - Parsing\n\n    private func scheduleParse(immediate: Bool = false) {\n        parseWorkItem?.cancel()\n\n        let work = DispatchWorkItem {\n            let items = OutlineParser.parseOutlineItems(from: activeContent, language: activeLanguage)\n            DispatchQueue.main.async {\n                self.parsedRootItems = items\n                // Keep expanded keys only for still-present nodes.\n                let existingKeys = Set(OutlineTree.allKeys(in: items))\n                self.expandedKeys = self.expandedKeys.intersection(existingKeys)\n            }\n        }\n\n        parseWorkItem = work\n\n        if immediate {\n            DispatchQueue.global(qos: .userInitiated).async(execute: work)\n        } else {\n            DispatchQueue.global(qos: .userInitiated).asyncAfter(deadline: .now() + 0.25, execute: work)\n        }\n    }\n}\n\n// MARK: - Outline Models\n\nstruct OutlineItem: Identifiable, Hashable {\n    /// Stable key used for list identity + expansion persistence.\n    let id: String\n\n    let name: String\n    let type: SymbolType\n    let line: Int\n    let column: Int\n\n    var children: [OutlineItem]\n\n    var isContainer: Bool {\n        switch type {\n        case .class, .struct, .enum, .protocol, .interface, .namespace, .module, .type:\n            return true\n        default:\n            return !children.isEmpty\n        }\n    }\n}\n\n// MARK: - Outline Tree helpers\n\nprivate enum OutlineTree {\n    static func filter(items: [OutlineItem], query: String) -> [OutlineItem] {\n        let q = query.trimmingCharacters(in: .whitespacesAndNewlines).lowercased()\n        guard !q.isEmpty else { return items }\n\n        func matches(_ item: OutlineItem) -> Bool {\n            item.name.lowercased().contains(q) || item.type.rawValue.lowercased().contains(q)\n        }\n\n        func filterItem(_ item: OutlineItem) -> OutlineItem? {\n            let filteredChildren = item.children.compactMap(filterItem)\n            if matches(item) || !filteredChildren.isEmpty {\n                return OutlineItem(\n                    id: item.id,\n                    name: item.name,\n                    type: item.type,\n                    line: item.line,\n                    column: item.column,\n                    children: filteredChildren\n                )\n            }\n            return nil\n        }\n\n        return items.compactMap(filterItem)\n    }\n\n    static func sort(items: [OutlineItem], mode: OutlineView.SortMode) -> [OutlineItem] {\n        func sortKey(_ a: OutlineItem, _ b: OutlineItem) -> Bool {\n            switch mode {\n            case .position:\n                if a.line != b.line { return a.line < b.line }\n                return a.name.localizedCaseInsensitiveCompare(b.name) == .orderedAscending\n            case .alphabetical:\n                let cmp = a.name.localizedCaseInsensitiveCompare(b.name)\n                if cmp != .orderedSame { return cmp == .orderedAscending }\n                return a.line < b.line\n            }\n        }\n\n        return items\n            .sorted(by: sortKey)\n            .map { item in\n                OutlineItem(\n                    id: item.id,\n                    name: item.name,\n                    type: item.type,\n                    line: item.line,\n                    column: item.column,\n                    children: sort(items: item.children, mode: mode)\n                )\n            }\n    }\n\n    static func allKeys(in items: [OutlineItem]) -> [String] {\n        var out: [String] = []\n        func walk(_ items: [OutlineItem]) {\n            for item in items {\n                out.append(item.id)\n                if !item.children.isEmpty { walk(item.children) }\n            }\n        }\n        walk(items)\n        return out\n    }\n}\n\n// MARK: - Outline Row\n\nprivate struct OutlineRow: View {\n    let item: OutlineItem\n    let level: Int\n    @Binding var expandedKeys: Set<String>\n    let onSelect: (OutlineItem) -> Void\n\n    private var isExpanded: Bool {\n        expandedKeys.contains(item.id)\n    }\n\n    var body: some View {\n        VStack(alignment: .leading, spacing: 1) {\n            row\n\n            if item.isContainer && isExpanded {\n                ForEach(item.children) { child in\n                    OutlineRow(item: child, level: level + 1, expandedKeys: $expandedKeys, onSelect: onSelect)\n                }\n            }\n        }\n    }\n\n    private var row: some View {\n        Button {\n            // Clicking container name selects it; clicking chevron expands/collapses.\n            onSelect(item)\n        } label: {\n            HStack(spacing: 6) {\n                // indent\n                Spacer().frame(width: CGFloat(level) * 14)\n\n                // disclosure chevron\n                if item.isContainer {\n                    Image(systemName: isExpanded ? \"chevron.down\" : \"chevron.right\")\n                        .font(.system(size: 10, weight: .semibold))\n                        .foregroundColor(.secondary)\n                        .frame(width: 12)\n                        .contentShape(Rectangle())\n                        .onTapGesture {\n                            toggleExpanded()\n                        }\n                } else {\n                    Spacer().frame(width: 12)\n                }\n\n                Image(systemName: item.type.icon)\n                    .font(.system(size: 12))\n                    .foregroundColor(item.type.color)\n                    .frame(width: 16)\n\n                Text(item.name)\n                    .font(.system(size: 12))\n                    .foregroundColor(.primary)\n                    .lineLimit(1)\n\n                Spacer()\n\n                Text(\"\\(item.line)\")\n                    .font(.system(size: 10, design: .monospaced))\n                    .foregroundColor(.secondary)\n            }\n            .padding(.vertical, 4)\n            .padding(.horizontal, 6)\n            .contentShape(Rectangle())\n        }\n        .buttonStyle(.plain)\n        .contextMenu {\n            Button(\"Jump to Line \\(item.line)\") { onSelect(item) }\n            if item.isContainer {\n                Button(isExpanded ? \"Collapse\" : \"Expand\") { toggleExpanded() }\n            }\n        }\n    }\n\n    private func toggleExpanded() {\n        if isExpanded {\n            expandedKeys.remove(item.id)\n        } else {\n            expandedKeys.insert(item.id)\n        }\n    }\n}\n\n// MARK: - Parsing\n\nprivate enum OutlineParser {\n    static func parseOutlineItems(from content: String, language: CodeLanguage) -> [OutlineItem] {\n        switch language {\n        case .swift:\n            return SwiftOutlineParser.parse(content)\n        case .javascript, .typescript:\n            return JSOutlineParser.parse(content)\n        case .python:\n            return PythonOutlineParser.parse(content)\n        default:\n            return GenericOutlineParser.parse(content)\n        }\n    }\n}\n\n// MARK: - Swift Outline Parser\n\nprivate enum SwiftOutlineParser {\n    private struct ContainerFrame {\n        let key: String\n        let depth: Int\n    }\n\n    static func parse(_ content: String) -> [OutlineItem] {\n        let lines = content.components(separatedBy: .newlines)\n\n        // Using reference nodes to build tree then convert to value types.\n        final class Node {\n            var id: String\n            var name: String\n            var type: SymbolType\n            var line: Int\n            var column: Int\n            var children: [Node] = []\n            init(id: String, name: String, type: SymbolType, line: Int, column: Int) {\n                self.id = id\n                self.name = name\n                self.type = type\n                self.line = line\n                self.column = column\n            }\n        }\n\n        var roots: [Node] = []\n        var stack: [(frame: ContainerFrame, node: Node)] = []\n        var braceDepth = 0\n\n        // Patterns are intentionally conservative.\n        let patterns: [(regex: NSRegularExpression, type: SymbolType, nameGroup: Int)] = {\n            let list: [(String, SymbolType, Int)] = [\n                // Containers\n                (#\"^\\s*(?:public |private |internal |fileprivate |open )?(?:final )?class\\s+(\\w+)\"#, .class, 1),\n                (#\"^\\s*(?:public |private |internal |fileprivate |open )?struct\\s+(\\w+)\"#, .struct, 1),\n                (#\"^\\s*(?:public |private |internal |fileprivate |open )?enum\\s+(\\w+)\"#, .enum, 1),\n                (#\"^\\s*(?:public |private |internal |fileprivate |open )?protocol\\s+(\\w+)\"#, .protocol, 1),\n                (#\"^\\s*(?:public |private |internal |fileprivate |open )?extension\\s+([\\w\\.]+)\"#, .type, 1),\n\n                // Members\n                (#\"^\\s*(?:@\\w+\\s+)*(?:public |private |internal |fileprivate |open )?(?:static |class )?func\\s+(\\w+)\"#, .function, 1),\n                (#\"^\\s*(?:@\\w+\\s+)*(?:public |private |internal |fileprivate |open )?(?:static |class )?(?:var|let)\\s+(\\w+)\"#, .property, 1),\n                (#\"^\\s*(?:public |private |internal |fileprivate |open )?(?:required |convenience )?init\\b\"#, .constructor, 0)\n            ]\n\n            return list.compactMap { pattern, type, group in\n                guard let re = try? NSRegularExpression(pattern: pattern, options: []) else { return nil }\n                return (re, type, group)\n            }\n        }()\n\n        func addNode(_ node: Node) {\n            if let last = stack.last {\n                last.node.children.append(node)\n            } else {\n                roots.append(node)\n            }\n        }\n\n        func stableKey(type: SymbolType, name: String, line: Int, containerKey: String?) -> String {\n            let container = containerKey ?? \"<root>\"\n            return \"\\(container)|\\(type.rawValue)|\\(name)|\\(line)\"\n        }\n\n        for (idx, rawLine) in lines.enumerated() {\n            let lineNumber = idx + 1\n\n            // naive comment skip\n            let trimmed = rawLine.trimmingCharacters(in: .whitespaces)\n            if trimmed.hasPrefix(\"//\") { // single-line comment\n                braceDepth += braceDelta(in: rawLine)\n                popContainersIfNeeded(newDepth: braceDepth, stack: &stack)\n                continue\n            }\n\n            // Detect symbol BEFORE adjusting brace depth for this line.\n            var foundContainerNode: Node?\n\n            for entry in patterns {\n                if let match = entry.regex.firstMatch(in: rawLine, options: [], range: NSRange(rawLine.startIndex..., in: rawLine)) {\n                    let name: String\n                    if entry.type == .constructor {\n                        name = \"init\"\n                    } else if entry.nameGroup > 0,\n                              let range = Range(match.range(at: entry.nameGroup), in: rawLine) {\n                        name = String(rawLine[range])\n                    } else {\n                        continue\n                    }\n\n                    // Heuristic: Swift funcs inside types are methods, not functions.\n                    var type = entry.type\n                    if type == .function, let container = stack.last?.node.type,\n                       [.class, .struct, .enum, .protocol, .type].contains(container) {\n                        type = .method\n                    }\n\n                    let containerKey = stack.last?.frame.key\n                    let key = stableKey(type: type, name: name, line: lineNumber, containerKey: containerKey)\n                    let node = Node(id: key, name: name, type: type, line: lineNumber, column: 1)\n                    addNode(node)\n\n                    if isContainerType(entry.type) {\n                        foundContainerNode = node\n                    }\n                    break\n                }\n            }\n\n            // Update brace depth and container stack\n            let delta = braceDelta(in: rawLine)\n            braceDepth += delta\n\n            if let containerNode = foundContainerNode {\n                // Only push containers that actually open a scope on this line.\n                if rawLine.contains(\"{\") {\n                    let frame = ContainerFrame(key: containerNode.id, depth: braceDepth)\n                    stack.append((frame, containerNode))\n                }\n            }\n\n            popContainersIfNeeded(newDepth: braceDepth, stack: &stack)\n        }\n\n        return roots.map { toItem($0) }\n    }\n\n    private static func toItem(_ node: AnyObject) -> OutlineItem {\n        // node is Node; keep it local to avoid exposing it.\n        let n = node as! SwiftOutlineParser.Node\n        return OutlineItem(\n            id: n.id,\n            name: n.name,\n            type: n.type,\n            line: n.line,\n            column: n.column,\n            children: n.children.map { toItem($0) }\n        )\n    }\n\n    private static func isContainerType(_ type: SymbolType) -> Bool {\n        switch type {\n        case .class, .struct, .enum, .protocol, .interface, .namespace, .module, .type:\n            return true\n        default:\n            return false\n        }\n    }\n\n    private static func popContainersIfNeeded(newDepth: Int, stack: inout [(frame: ContainerFrame, node: SwiftOutlineParser.Node)]) {\n        // Pop containers whose depth is now below their body depth.\n        while let last = stack.last, newDepth < last.frame.depth {\n            stack.removeLast()\n        }\n    }\n\n    /// Approximate brace change on a line.\n    private static func braceDelta(in line: String) -> Int {\n        // Strip string literals crudely to reduce false positives.\n        let withoutStrings = stripQuotedStrings(line)\n        let opens = withoutStrings.filter { $0 == \"{\" }.count\n        let closes = withoutStrings.filter { $0 == \"}\" }.count\n        return opens - closes\n    }\n\n    private static func stripQuotedStrings(_ line: String) -> String {\n        var result = \"\"\n        var inString = false\n        var escape = false\n        for ch in line {\n            if escape {\n                escape = false\n                continue\n            }\n            if ch == \"\\\\\" {\n                escape = true\n                continue\n            }\n            if ch == \"\\\"\" {\n                inString.toggle()\n                continue\n            }\n            if !inString {\n                result.append(ch)\n            }\n        }\n        return result\n    }\n\n    // Local Node class is defined inside parse(); add a typealias for helper access.\n    private typealias Node = SwiftOutlineParserInternalNode\n\n    private final class SwiftOutlineParserInternalNode: NSObject {\n        var id: String\n        var name: String\n        var type: SymbolType\n        var line: Int\n        var column: Int\n        var children: [SwiftOutlineParserInternalNode] = []\n        init(id: String, name: String, type: SymbolType, line: Int, column: Int) {\n            self.id = id\n            self.name = name\n            self.type = type\n            self.line = line\n            self.column = column\n        }\n    }\n}\n\n// MARK: - JS/TS Outline Parser\n\nprivate enum JSOutlineParser {\n    private struct ContainerFrame {\n        let key: String\n        let depth: Int\n        let kind: SymbolType\n    }\n\n    static func parse(_ content: String) -> [OutlineItem] {\n        let lines = content.components(separatedBy: .newlines)\n\n        final class Node {\n            var id: String\n            var name: String\n            var type: SymbolType\n            var line: Int\n            var column: Int\n            var children: [Node] = []\n            init(id: String, name: String, type: SymbolType, line: Int, column: Int) {\n                self.id = id\n                self.name = name\n                self.type = type\n                self.line = line\n                self.column = column\n            }\n        }\n\n        var roots: [Node] = []\n        var stack: [(frame: ContainerFrame, node: Node)] = []\n        var braceDepth = 0\n\n        let patterns: [(NSRegularExpression, SymbolType, Int)] = {\n            let list: [(String, SymbolType, Int)] = [\n                (#\"^\\s*(?:export\\s+)?(?:default\\s+)?class\\s+(\\w+)\"#, .class, 1),\n                (#\"^\\s*(?:export\\s+)?interface\\s+(\\w+)\"#, .interface, 1),\n                (#\"^\\s*(?:export\\s+)?type\\s+(\\w+)\"#, .type, 1),\n                (#\"^\\s*(?:export\\s+)?enum\\s+(\\w+)\"#, .enum, 1),\n                (#\"^\\s*(?:export\\s+)?(?:async\\s+)?function\\s+(\\w+)\"#, .function, 1),\n                (#\"^\\s*(?:export\\s+)?(?:const|let|var)\\s+(\\w+)\\s*=\"#, .variable, 1),\n                // method (best-effort)\n                (#\"^\\s*(?:public|private|protected)?\\s*(?:static\\s+)?(?:async\\s+)?(\\w+)\\s*\\(\"#, .method, 1)\n            ]\n            return list.compactMap { p, t, g in\n                guard let re = try? NSRegularExpression(pattern: p, options: []) else { return nil }\n                return (re, t, g)\n            }\n        }()\n\n        func stableKey(type: SymbolType, name: String, line: Int, containerKey: String?) -> String {\n            let container = containerKey ?? \"<root>\"\n            return \"\\(container)|\\(type.rawValue)|\\(name)|\\(line)\"\n        }\n\n        func addNode(_ node: Node) {\n            if let last = stack.last {\n                last.node.children.append(node)\n            } else {\n                roots.append(node)\n            }\n        }\n\n        func isInClassScope() -> Bool {\n            stack.last?.frame.kind == .class\n        }\n\n        for (idx, rawLine) in lines.enumerated() {\n            let lineNumber = idx + 1\n            let trimmed = rawLine.trimmingCharacters(in: .whitespaces)\n            if trimmed.hasPrefix(\"//\") {\n                braceDepth += braceDelta(in: rawLine)\n                popContainersIfNeeded(newDepth: braceDepth, stack: &stack)\n                continue\n            }\n\n            var foundContainerNode: Node?\n            var foundContainerKind: SymbolType?\n\n            for (re, type, group) in patterns {\n                guard let match = re.firstMatch(in: rawLine, options: [], range: NSRange(rawLine.startIndex..., in: rawLine)) else { continue }\n                guard let range = Range(match.range(at: group), in: rawLine) else { continue }\n                let name = String(rawLine[range])\n\n                // Avoid treating keywords as methods.\n                if type == .method, [\"if\", \"for\", \"while\", \"switch\", \"catch\", \"function\", \"constructor\"].contains(name) {\n                    continue\n                }\n\n                var finalType = type\n                if type == .method, !isInClassScope() {\n                    // If not in class, treat as function-like.\n                    finalType = .function\n                }\n\n                let containerKey = stack.last?.frame.key\n                let key = stableKey(type: finalType, name: name, line: lineNumber, containerKey: containerKey)\n                let node = Node(id: key, name: name, type: finalType, line: lineNumber, column: 1)\n                addNode(node)\n\n                if [.class, .interface, .namespace, .module].contains(type) {\n                    foundContainerNode = node\n                    foundContainerKind = type\n                }\n                break\n            }\n\n            braceDepth += braceDelta(in: rawLine)\n\n            if let containerNode = foundContainerNode, let kind = foundContainerKind, rawLine.contains(\"{\") {\n                stack.append((ContainerFrame(key: containerNode.id, depth: braceDepth, kind: kind), containerNode))\n            }\n\n            popContainersIfNeeded(newDepth: braceDepth, stack: &stack)\n        }\n\n        return roots.map(toItem)\n    }\n\n    private static func toItem(_ node: Node) -> OutlineItem {\n        OutlineItem(\n            id: node.id,\n            name: node.name,\n            type: node.type,\n            line: node.line,\n            column: node.column,\n            children: node.children.map(toItem)\n        )\n    }\n\n    private static func popContainersIfNeeded(newDepth: Int, stack: inout [(frame: ContainerFrame, node: Node)]) {\n        while let last = stack.last, newDepth < last.frame.depth {\n            stack.removeLast()\n        }\n    }\n\n    private static func braceDelta(in line: String) -> Int {\n        let withoutStrings = stripQuotedStrings(line)\n        let opens = withoutStrings.filter { $0 == \"{\" }.count\n        let closes = withoutStrings.filter { $0 == \"}\" }.count\n        return opens - closes\n    }\n\n    private static func stripQuotedStrings(_ line: String) -> String {\n        var result = \"\"\n        var inSingle = false\n        var inDouble = false\n        var escape = false\n        for ch in line {\n            if escape {\n                escape = false\n                continue\n            }\n            if ch == \"\\\\\" {\n                escape = true\n                continue\n            }\n            if ch == \"'\" && !inDouble {\n                inSingle.toggle(); continue\n            }\n            if ch == \"\\\"\" && !inSingle {\n                inDouble.toggle(); continue\n            }\n            if !inSingle && !inDouble { result.append(ch) }\n        }\n        return result\n    }\n\n    // Local Node type\n    private final class Node {\n        var id: String\n        var name: String\n        var type: SymbolType\n        var line: Int\n        var column: Int\n        var children: [Node] = []\n        init(id: String, name: String, type: SymbolType, line: Int, column: Int) {\n            self.id = id\n            self.name = name\n            self.type = type\n            self.line = line\n            self.column = column\n        }\n    }\n}\n\n// MARK: - Python Outline Parser (indent-based)\n\nprivate enum PythonOutlineParser {\n    private struct Frame {\n        let key: String\n        let indent: Int\n        let kind: SymbolType\n    }\n\n    static func parse(_ content: String) -> [OutlineItem] {\n        let lines = content.components(separatedBy: .newlines)\n\n        final class Node {\n            var id: String\n            var name: String\n            var type: SymbolType\n            var line: Int\n            var column: Int\n            var children: [Node] = []\n            init(id: String, name: String, type: SymbolType, line: Int, column: Int) {\n                self.id = id\n                self.name = name\n                self.type = type\n                self.line = line\n                self.column = column\n            }\n        }\n\n        var roots: [Node] = []\n        var stack: [(frame: Frame, node: Node)] = []\n\n        let classRe = try? NSRegularExpression(pattern: #\"^\\s*class\\s+(\\w+)\"#, options: [])\n        let defRe = try? NSRegularExpression(pattern: #\"^\\s*(?:async\\s+)?def\\s+(\\w+)\"#, options: [])\n\n        func stableKey(type: SymbolType, name: String, line: Int, containerKey: String?) -> String {\n            let container = containerKey ?? \"<root>\"\n            return \"\\(container)|\\(type.rawValue)|\\(name)|\\(line)\"\n        }\n\n        func addNode(_ node: Node) {\n            if let last = stack.last {\n                last.node.children.append(node)\n            } else {\n                roots.append(node)\n            }\n        }\n\n        for (idx, rawLine) in lines.enumerated() {\n            let lineNumber = idx + 1\n            let trimmed = rawLine.trimmingCharacters(in: .whitespaces)\n            if trimmed.isEmpty || trimmed.hasPrefix(\"#\") { continue }\n\n            let indent = leadingIndent(rawLine)\n\n            // Pop stack when indent decreases.\n            while let last = stack.last, indent <= last.frame.indent {\n                stack.removeLast()\n            }\n\n            if let classRe,\n               let match = classRe.firstMatch(in: rawLine, options: [], range: NSRange(rawLine.startIndex..., in: rawLine)),\n               let range = Range(match.range(at: 1), in: rawLine) {\n\n                let name = String(rawLine[range])\n                let containerKey = stack.last?.frame.key\n                let key = stableKey(type: .class, name: name, line: lineNumber, containerKey: containerKey)\n                let node = Node(id: key, name: name, type: .class, line: lineNumber, column: 1)\n                addNode(node)\n\n                stack.append((Frame(key: node.id, indent: indent, kind: .class), node))\n                continue\n            }\n\n            if let defRe,\n               let match = defRe.firstMatch(in: rawLine, options: [], range: NSRange(rawLine.startIndex..., in: rawLine)),\n               let range = Range(match.range(at: 1), in: rawLine) {\n\n                let name = String(rawLine[range])\n                let containerKey = stack.last?.frame.key\n                var type: SymbolType = .function\n                if stack.last?.frame.kind == .class { type = .method }\n\n                let key = stableKey(type: type, name: name, line: lineNumber, containerKey: containerKey)\n                let node = Node(id: key, name: name, type: type, line: lineNumber, column: 1)\n                addNode(node)\n\n                // def opens new indentation scope\n                stack.append((Frame(key: node.id, indent: indent, kind: type), node))\n                continue\n            }\n\n            // Top-level variables (best-effort): name = ...\n            if stack.isEmpty {\n                if let varName = parsePythonAssignmentName(rawLine) {\n                    let key = stableKey(type: .variable, name: varName, line: lineNumber, containerKey: nil)\n                    let node = Node(id: key, name: varName, type: .variable, line: lineNumber, column: 1)\n                    addNode(node)\n                }\n            }\n        }\n\n        return roots.map(toItem)\n    }\n\n    private static func toItem(_ node: Node) -> OutlineItem {\n        OutlineItem(\n            id: node.id,\n            name: node.name,\n            type: node.type,\n            line: node.line,\n            column: node.column,\n            children: node.children.map(toItem)\n        )\n    }\n\n    private static func leadingIndent(_ line: String) -> Int {\n        var count = 0\n        for ch in line {\n            if ch == \" \" { count += 1 }\n            else if ch == \"\\t\" { count += 4 }\n            else { break }\n        }\n        return count\n    }\n\n    private static func parsePythonAssignmentName(_ line: String) -> String? {\n        // simplistic: <name> =\n        let trimmed = line.trimmingCharacters(in: .whitespaces)\n        guard let eq = trimmed.firstIndex(of: \"=\") else { return nil }\n        let lhs = trimmed[..<eq].trimmingCharacters(in: .whitespaces)\n        guard !lhs.isEmpty else { return nil }\n        // reject `==` and `:=`\n        let afterEq = trimmed.index(after: eq)\n        if afterEq < trimmed.endIndex, trimmed[afterEq] == \"=\" { return nil }\n        if lhs.contains(\" \") { return nil }\n        // identifier check\n        let allowed = CharacterSet.alphanumerics.union(CharacterSet(charactersIn: \"_\"))\n        guard lhs.unicodeScalars.allSatisfy({ allowed.contains($0) }) else { return nil }\n        return String(lhs)\n    }\n\n    // Local Node type\n    private final class Node {\n        var id: String\n        var name: String\n        var type: SymbolType\n        var line: Int\n        var column: Int\n        var children: [Node] = []\n        init(id: String, name: String, type: SymbolType, line: Int, column: Int) {\n            self.id = id\n            self.name = name\n            self.type = type\n            self.line = line\n            self.column = column\n        }\n    }\n}\n\n// MARK: - Generic Outline Parser\n\nprivate enum GenericOutlineParser {\n    static func parse(_ content: String) -> [OutlineItem] {\n        // Fallback: use the existing SymbolParser (flat list).\n        let symbols = SymbolParser.parseSymbols(from: content, language: .plainText)\n        return symbols\n            .map { sym in\n                let key = \"<root>|\\(sym.type.rawValue)|\\(sym.name)|\\(sym.line)\"\n                return OutlineItem(id: key, name: sym.name, type: sym.type, line: sym.line, column: sym.column, children: [])\n            }\n    }\n}\n"} 
>>>END


>>>TOOL create_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Panels/OutlineView.swift","overwrite":true,"content":"import SwiftUI\n\n// MARK: - Outline Panel\n\n/// Shows a tree of symbols (classes/structs/enums + their members, functions, vars/lets) for the current file.\n///\n/// Note: This view parses symbols from the *current editor tab content* (no LSP).\nstruct OutlineView: View {\n    @ObservedObject var editorCore: EditorCore\n\n    /// Called when the user selects a symbol.\n    /// Expected behavior: scroll editor to `line` (1-indexed).\n    var onJumpToLine: (Int) -> Void = { _ in }\n\n    enum SortMode: String, CaseIterable, Identifiable {\n        case position = \"Position\"\n        case alphabetical = \"A–Z\"\n        var id: String { rawValue }\n    }\n\n    @State private var filterText: String = \"\"\n    @State private var sortMode: SortMode = .position\n\n    // Persist expansion by stable key (not UUID) so it survives reparses.\n    @State private var expandedKeys: Set<String> = []\n\n    @State private var parsedRootItems: [OutlineItem] = []\n    @State private var parseWorkItem: DispatchWorkItem?\n\n    private var activeTab: Tab? { editorCore.activeTab }\n    private var activeContent: String { activeTab?.content ?? \"\" }\n    private var activeLanguage: CodeLanguage { activeTab?.language ?? .plainText }\n\n    var body: some View {\n        VStack(alignment: .leading, spacing: 8) {\n            header\n            filterField\n            sortPicker\n\n            Divider()\n\n            if activeTab == nil {\n                emptyState(title: \"No file open\", systemImage: \"doc\")\n            } else if parsedRootItems.isEmpty {\n                emptyState(title: \"No symbols\", systemImage: \"list.bullet.rectangle\")\n            } else {\n                ScrollView {\n                    LazyVStack(alignment: .leading, spacing: 2) {\n                        ForEach(displayItems) { item in\n                            OutlineRow(\n                                item: item,\n                                level: 0,\n                                expandedKeys: $expandedKeys,\n                                onSelect: { selected in\n                                    onJumpToLine(selected.line)\n                                }\n                            )\n                        }\n                    }\n                    .padding(.horizontal, 8)\n                    .padding(.vertical, 6)\n                }\n            }\n        }\n        .background(Color(UIColor.secondarySystemBackground))\n        .onAppear { scheduleParse() }\n        .onChange(of: editorCore.activeTabId) { _ in scheduleParse() }\n        .onChange(of: activeContent) { _ in scheduleParse() }\n    }\n\n    // MARK: - UI\n\n    private var header: some View {\n        HStack {\n            Text(\"OUTLINE\")\n                .font(.caption)\n                .fontWeight(.semibold)\n                .foregroundColor(.secondary)\n\n            Spacer()\n\n            Button {\n                scheduleParse(immediate: true)\n            } label: {\n                Image(systemName: \"arrow.clockwise\")\n                    .font(.caption)\n                    .foregroundColor(.secondary)\n            }\n            .buttonStyle(.plain)\n            .help(\"Refresh\")\n        }\n        .padding(.horizontal, 12)\n        .padding(.top, 8)\n    }\n\n    private var filterField: some View {\n        HStack(spacing: 6) {\n            Image(systemName: \"line.3.horizontal.decrease.circle\")\n                .foregroundColor(.secondary)\n                .font(.caption)\n\n            TextField(\"Filter symbols\", text: $filterText)\n                .textFieldStyle(.plain)\n                .font(.system(size: 13))\n\n            if !filterText.isEmpty {\n                Button { filterText = \"\" } label: {\n                    Image(systemName: \"xmark.circle.fill\")\n                        .foregroundColor(.secondary)\n                        .font(.caption)\n                }\n                .buttonStyle(.plain)\n            }\n        }\n        .padding(8)\n        .background(Color(UIColor.tertiarySystemFill))\n        .cornerRadius(6)\n        .padding(.horizontal, 12)\n    }\n\n    private var sortPicker: some View {\n        Picker(\"Sort\", selection: $sortMode) {\n            ForEach(SortMode.allCases) { mode in\n                Text(mode.rawValue).tag(mode)\n            }\n        }\n        .pickerStyle(.segmented)\n        .padding(.horizontal, 12)\n    }\n\n    private func emptyState(title: String, systemImage: String) -> some View {\n        VStack(spacing: 10) {\n            Spacer(minLength: 10)\n            Image(systemName: systemImage)\n                .font(.system(size: 28))\n                .foregroundColor(.secondary.opacity(0.6))\n            Text(title)\n                .font(.caption)\n                .foregroundColor(.secondary)\n            Spacer(minLength: 10)\n        }\n        .frame(maxWidth: .infinity)\n        .padding(.vertical, 30)\n    }\n\n    // MARK: - Display items (filter + sort)\n\n    private var displayItems: [OutlineItem] {\n        let filtered = OutlineTree.filter(items: parsedRootItems, query: filterText)\n        return OutlineTree.sort(items: filtered, mode: sortMode)\n    }\n\n    // MARK: - Parsing\n\n    private func scheduleParse(immediate: Bool = false) {\n        parseWorkItem?.cancel()\n\n        let work = DispatchWorkItem {\n            let items = OutlineParser.parseOutlineItems(from: activeContent, language: activeLanguage)\n            DispatchQueue.main.async {\n                self.parsedRootItems = items\n                // Keep expanded keys only for still-present nodes.\n                let existingKeys = Set(OutlineTree.allKeys(in: items))\n                self.expandedKeys = self.expandedKeys.intersection(existingKeys)\n            }\n        }\n\n        parseWorkItem = work\n\n        if immediate {\n            DispatchQueue.global(qos: .userInitiated).async(execute: work)\n        } else {\n            DispatchQueue.global(qos: .userInitiated).asyncAfter(deadline: .now() + 0.25, execute: work)\n        }\n    }\n}\n\n// MARK: - Outline Models\n\nstruct OutlineItem: Identifiable, Hashable {\n    /// Stable key used for list identity + expansion persistence.\n    let id: String\n\n    let name: String\n    let type: SymbolType\n    let line: Int\n    let column: Int\n\n    var children: [OutlineItem]\n\n    var isContainer: Bool {\n        switch type {\n        case .class, .struct, .enum, .protocol, .interface, .namespace, .module, .type:\n            return true\n        default:\n            return !children.isEmpty\n        }\n    }\n}\n\n// MARK: - Outline Tree helpers\n\nprivate enum OutlineTree {\n    static func filter(items: [OutlineItem], query: String) -> [OutlineItem] {\n        let q = query.trimmingCharacters(in: .whitespacesAndNewlines).lowercased()\n        guard !q.isEmpty else { return items }\n\n        func matches(_ item: OutlineItem) -> Bool {\n            item.name.lowercased().contains(q) || item.type.rawValue.lowercased().contains(q)\n        }\n\n        func filterItem(_ item: OutlineItem) -> OutlineItem? {\n            let filteredChildren = item.children.compactMap(filterItem)\n            if matches(item) || !filteredChildren.isEmpty {\n                return OutlineItem(\n                    id: item.id,\n                    name: item.name,\n                    type: item.type,\n                    line: item.line,\n                    column: item.column,\n                    children: filteredChildren\n                )\n            }\n            return nil\n        }\n\n        return items.compactMap(filterItem)\n    }\n\n    static func sort(items: [OutlineItem], mode: OutlineView.SortMode) -> [OutlineItem] {\n        func sortKey(_ a: OutlineItem, _ b: OutlineItem) -> Bool {\n            switch mode {\n            case .position:\n                if a.line != b.line { return a.line < b.line }\n                return a.name.localizedCaseInsensitiveCompare(b.name) == .orderedAscending\n            case .alphabetical:\n                let cmp = a.name.localizedCaseInsensitiveCompare(b.name)\n                if cmp != .orderedSame { return cmp == .orderedAscending }\n                return a.line < b.line\n            }\n        }\n\n        return items\n            .sorted(by: sortKey)\n            .map { item in\n                OutlineItem(\n                    id: item.id,\n                    name: item.name,\n                    type: item.type,\n                    line: item.line,\n                    column: item.column,\n                    children: sort(items: item.children, mode: mode)\n                )\n            }\n    }\n\n    static func allKeys(in items: [OutlineItem]) -> [String] {\n        var out: [String] = []\n        func walk(_ items: [OutlineItem]) {\n            for item in items {\n                out.append(item.id)\n                if !item.children.isEmpty { walk(item.children) }\n            }\n        }\n        walk(items)\n        return out\n    }\n}\n\n// MARK: - Outline Row\n\nprivate struct OutlineRow: View {\n    let item: OutlineItem\n    let level: Int\n    @Binding var expandedKeys: Set<String>\n    let onSelect: (OutlineItem) -> Void\n\n    private var isExpanded: Bool {\n        expandedKeys.contains(item.id)\n    }\n\n    var body: some View {\n        VStack(alignment: .leading, spacing: 1) {\n            row\n\n            if item.isContainer && isExpanded {\n                ForEach(item.children) { child in\n                    OutlineRow(item: child, level: level + 1, expandedKeys: $expandedKeys, onSelect: onSelect)\n                }\n            }\n        }\n    }\n\n    private var row: some View {\n        Button {\n            // Clicking container name selects it; clicking chevron expands/collapses.\n            onSelect(item)\n        } label: {\n            HStack(spacing: 6) {\n                Spacer().frame(width: CGFloat(level) * 14)\n\n                if item.isContainer {\n                    Image(systemName: isExpanded ? \"chevron.down\" : \"chevron.right\")\n                        .font(.system(size: 10, weight: .semibold))\n                        .foregroundColor(.secondary)\n                        .frame(width: 12)\n                        .contentShape(Rectangle())\n                        .onTapGesture { toggleExpanded() }\n                } else {\n                    Spacer().frame(width: 12)\n                }\n\n                Image(systemName: item.type.icon)\n                    .font(.system(size: 12))\n                    .foregroundColor(item.type.color)\n                    .frame(width: 16)\n\n                Text(item.name)\n                    .font(.system(size: 12))\n                    .foregroundColor(.primary)\n                    .lineLimit(1)\n\n                Spacer()\n\n                Text(\"\\(item.line)\")\n                    .font(.system(size: 10, design: .monospaced))\n                    .foregroundColor(.secondary)\n            }\n            .padding(.vertical, 4)\n            .padding(.horizontal, 6)\n            .contentShape(Rectangle())\n        }\n        .buttonStyle(.plain)\n        .contextMenu {\n            Button(\"Jump to Line \\(item.line)\") { onSelect(item) }\n            if item.isContainer {\n                Button(isExpanded ? \"Collapse\" : \"Expand\") { toggleExpanded() }\n            }\n        }\n    }\n\n    private func toggleExpanded() {\n        if isExpanded {\n            expandedKeys.remove(item.id)\n        } else {\n            expandedKeys.insert(item.id)\n        }\n    }\n}\n\n// MARK: - Parsing\n\nprivate enum OutlineParser {\n    static func parseOutlineItems(from content: String, language: CodeLanguage) -> [OutlineItem] {\n        switch language {\n        case .swift:\n            return SwiftOutlineParser.parse(content)\n        case .javascript, .typescript:\n            return JSOutlineParser.parse(content)\n        case .python:\n            return PythonOutlineParser.parse(content)\n        default:\n            return GenericOutlineParser.parse(content)\n        }\n    }\n}\n\n// MARK: - Swift Outline Parser\n\nprivate enum SwiftOutlineParser {\n    private struct ContainerFrame {\n        let key: String\n        let depth: Int\n        let kind: SymbolType\n    }\n\n    final class Node {\n        var id: String\n        var name: String\n        var type: SymbolType\n        var line: Int\n        var column: Int\n        var children: [Node] = []\n        init(id: String, name: String, type: SymbolType, line: Int, column: Int) {\n            self.id = id\n            self.name = name\n            self.type = type\n            self.line = line\n            self.column = column\n        }\n    }\n\n    static func parse(_ content: String) -> [OutlineItem] {\n        let lines = content.components(separatedBy: .newlines)\n\n        var roots: [Node] = []\n        var stack: [(frame: ContainerFrame, node: Node)] = []\n        var braceDepth = 0\n\n        // Patterns are intentionally conservative.\n        let patterns: [(regex: NSRegularExpression, type: SymbolType, nameGroup: Int)] = {\n            let list: [(String, SymbolType, Int)] = [\n                // Containers\n                (#\"^\\s*(?:public |private |internal |fileprivate |open )?(?:final )?class\\s+(\\w+)\"#, .class, 1),\n                (#\"^\\s*(?:public |private |internal |fileprivate |open )?struct\\s+(\\w+)\"#, .struct, 1),\n                (#\"^\\s*(?:public |private |internal |fileprivate |open )?enum\\s+(\\w+)\"#, .enum, 1),\n                (#\"^\\s*(?:public |private |internal |fileprivate |open )?protocol\\s+(\\w+)\"#, .protocol, 1),\n                (#\"^\\s*(?:public |private |internal |fileprivate |open )?extension\\s+([\\w\\.]+)\"#, .type, 1),\n\n                // Members\n                (#\"^\\s*(?:@\\w+\\s+)*(?:public |private |internal |fileprivate |open )?(?:static |class )?func\\s+(\\w+)\"#, .function, 1),\n                (#\"^\\s*(?:@\\w+\\s+)*(?:public |private |internal |fileprivate |open )?(?:static |class )?(?:var|let)\\s+(\\w+)\"#, .property, 1),\n                (#\"^\\s*(?:public |private |internal |fileprivate |open )?(?:required |convenience )?init\\b\"#, .constructor, 0)\n            ]\n\n            return list.compactMap { pattern, type, group in\n                guard let re = try? NSRegularExpression(pattern: pattern, options: []) else { return nil }\n                return (re, type, group)\n            }\n        }()\n\n        func isContainerType(_ type: SymbolType) -> Bool {\n            switch type {\n            case .class, .struct, .enum, .protocol, .interface, .namespace, .module, .type:\n                return true\n            default:\n                return false\n            }\n        }\n\n        func stableKey(type: SymbolType, name: String, line: Int, containerKey: String?) -> String {\n            let container = containerKey ?? \"<root>\"\n            return \"\\(container)|\\(type.rawValue)|\\(name)|\\(line)\"\n        }\n\n        func addNode(_ node: Node) {\n            if let last = stack.last {\n                last.node.children.append(node)\n            } else {\n                roots.append(node)\n            }\n        }\n\n        for (idx, rawLine) in lines.enumerated() {\n            let lineNumber = idx + 1\n\n            let trimmed = rawLine.trimmingCharacters(in: .whitespaces)\n            if trimmed.hasPrefix(\"//\") {\n                braceDepth += braceDelta(in: rawLine)\n                popContainersIfNeeded(newDepth: braceDepth, stack: &stack)\n                continue\n            }\n\n            var foundContainerNode: Node?\n            var foundContainerKind: SymbolType?\n\n            for entry in patterns {\n                if let match = entry.regex.firstMatch(in: rawLine, options: [], range: NSRange(rawLine.startIndex..., in: rawLine)) {\n                    let name: String\n                    if entry.type == .constructor {\n                        name = \"init\"\n                    } else if entry.nameGroup > 0,\n                              let range = Range(match.range(at: entry.nameGroup), in: rawLine) {\n                        name = String(rawLine[range])\n                    } else {\n                        continue\n                    }\n\n                    var finalType = entry.type\n                    if finalType == .function, let containerKind = stack.last?.frame.kind, isContainerType(containerKind) {\n                        finalType = .method\n                    }\n\n                    let containerKey = stack.last?.frame.key\n                    let key = stableKey(type: finalType, name: name, line: lineNumber, containerKey: containerKey)\n                    let node = Node(id: key, name: name, type: finalType, line: lineNumber, column: 1)\n                    addNode(node)\n\n                    if isContainerType(entry.type) {\n                        foundContainerNode = node\n                        foundContainerKind = entry.type\n                    }\n                    break\n                }\n            }\n\n            braceDepth += braceDelta(in: rawLine)\n\n            if let containerNode = foundContainerNode,\n               let kind = foundContainerKind,\n               rawLine.contains(\"{\") {\n                stack.append((ContainerFrame(key: containerNode.id, depth: braceDepth, kind: kind), containerNode))\n            }\n\n            popContainersIfNeeded(newDepth: braceDepth, stack: &stack)\n        }\n\n        return roots.map(toItem)\n    }\n\n    private static func toItem(_ node: Node) -> OutlineItem {\n        OutlineItem(\n            id: node.id,\n            name: node.name,\n            type: node.type,\n            line: node.line,\n            column: node.column,\n            children: node.children.map(toItem)\n        )\n    }\n\n    private static func popContainersIfNeeded(newDepth: Int, stack: inout [(frame: ContainerFrame, node: Node)]) {\n        while let last = stack.last, newDepth < last.frame.depth {\n            stack.removeLast()\n        }\n    }\n\n    private static func braceDelta(in line: String) -> Int {\n        let withoutStrings = stripQuotedStrings(line)\n        let opens = withoutStrings.filter { $0 == \"{\" }.count\n        let closes = withoutStrings.filter { $0 == \"}\" }.count\n        return opens - closes\n    }\n\n    private static func stripQuotedStrings(_ line: String) -> String {\n        var result = \"\"\n        var inString = false\n        var escape = false\n        for ch in line {\n            if escape {\n                escape = false\n                continue\n            }\n            if ch == \"\\\\\" {\n                escape = true\n                continue\n            }\n            if ch == \"\\\"\" {\n                inString.toggle()\n                continue\n            }\n            if !inString {\n                result.append(ch)\n            }\n        }\n        return result\n    }\n}\n\n// MARK: - JS/TS Outline Parser\n\nprivate enum JSOutlineParser {\n    private struct ContainerFrame {\n        let key: String\n        let depth: Int\n        let kind: SymbolType\n    }\n\n    final class Node {\n        var id: String\n        var name: String\n        var type: SymbolType\n        var line: Int\n        var column: Int\n        var children: [Node] = []\n        init(id: String, name: String, type: SymbolType, line: Int, column: Int) {\n            self.id = id\n            self.name = name\n            self.type = type\n            self.line = line\n            self.column = column\n        }\n    }\n\n    static func parse(_ content: String) -> [OutlineItem] {\n        let lines = content.components(separatedBy: .newlines)\n\n        var roots: [Node] = []\n        var stack: [(frame: ContainerFrame, node: Node)] = []\n        var braceDepth = 0\n\n        let patterns: [(NSRegularExpression, SymbolType, Int)] = {\n            let list: [(String, SymbolType, Int)] = [\n                (#\"^\\s*(?:export\\s+)?(?:default\\s+)?class\\s+(\\w+)\"#, .class, 1),\n                (#\"^\\s*(?:export\\s+)?interface\\s+(\\w+)\"#, .interface, 1),\n                (#\"^\\s*(?:export\\s+)?type\\s+(\\w+)\"#, .type, 1),\n                (#\"^\\s*(?:export\\s+)?enum\\s+(\\w+)\"#, .enum, 1),\n                (#\"^\\s*(?:export\\s+)?(?:async\\s+)?function\\s+(\\w+)\"#, .function, 1),\n                (#\"^\\s*(?:export\\s+)?(?:const|let|var)\\s+(\\w+)\\s*=\"#, .variable, 1),\n                // method (best-effort)\n                (#\"^\\s*(?:public|private|protected)?\\s*(?:static\\s+)?(?:async\\s+)?(\\w+)\\s*\\(\"#, .method, 1)\n            ]\n            return list.compactMap { p, t, g in\n                guard let re = try? NSRegularExpression(pattern: p, options: []) else { return nil }\n                return (re, t, g)\n            }\n        }()\n\n        func stableKey(type: SymbolType, name: String, line: Int, containerKey: String?) -> String {\n            let container = containerKey ?? \"<root>\"\n            return \"\\(container)|\\(type.rawValue)|\\(name)|\\(line)\"\n        }\n\n        func addNode(_ node: Node) {\n            if let last = stack.last {\n                last.node.children.append(node)\n            } else {\n                roots.append(node)\n            }\n        }\n\n        func isInClassScope() -> Bool {\n            stack.last?.frame.kind == .class\n        }\n\n        for (idx, rawLine) in lines.enumerated() {\n            let lineNumber = idx + 1\n            let trimmed = rawLine.trimmingCharacters(in: .whitespaces)\n            if trimmed.hasPrefix(\"//\") {\n                braceDepth += braceDelta(in: rawLine)\n                popContainersIfNeeded(newDepth: braceDepth, stack: &stack)\n                continue\n            }\n\n            var foundContainerNode: Node?\n            var foundContainerKind: SymbolType?\n\n            for (re, type, group) in patterns {\n                guard let match = re.firstMatch(in: rawLine, options: [], range: NSRange(rawLine.startIndex..., in: rawLine)) else { continue }\n                guard let range = Range(match.range(at: group), in: rawLine) else { continue }\n                let name = String(rawLine[range])\n\n                if type == .method, [\"if\", \"for\", \"while\", \"switch\", \"catch\", \"function\", \"constructor\"].contains(name) {\n                    continue\n                }\n\n                var finalType = type\n                if type == .method, !isInClassScope() {\n                    finalType = .function\n                }\n\n                let containerKey = stack.last?.frame.key\n                let key = stableKey(type: finalType, name: name, line: lineNumber, containerKey: containerKey)\n                let node = Node(id: key, name: name, type: finalType, line: lineNumber, column: 1)\n                addNode(node)\n\n                if [.class, .interface, .namespace, .module, .type].contains(type) {\n                    foundContainerNode = node\n                    foundContainerKind = type\n                }\n                break\n            }\n\n            braceDepth += braceDelta(in: rawLine)\n\n            if let containerNode = foundContainerNode, let kind = foundContainerKind, rawLine.contains(\"{\") {\n                stack.append((ContainerFrame(key: containerNode.id, depth: braceDepth, kind: kind), containerNode))\n            }\n\n            popContainersIfNeeded(newDepth: braceDepth, stack: &stack)\n        }\n\n        return roots.map(toItem)\n    }\n\n    private static func toItem(_ node: Node) -> OutlineItem {\n        OutlineItem(\n            id: node.id,\n            name: node.name,\n            type: node.type,\n            line: node.line,\n            column: node.column,\n            children: node.children.map(toItem)\n        )\n    }\n\n    private static func popContainersIfNeeded(newDepth: Int, stack: inout [(frame: ContainerFrame, node: Node)]) {\n        while let last = stack.last, newDepth < last.frame.depth {\n            stack.removeLast()\n        }\n    }\n\n    private static func braceDelta(in line: String) -> Int {\n        let withoutStrings = stripQuotedStrings(line)\n        let opens = withoutStrings.filter { $0 == \"{\" }.count\n        let closes = withoutStrings.filter { $0 == \"}\" }.count\n        return opens - closes\n    }\n\n    private static func stripQuotedStrings(_ line: String) -> String {\n        var result = \"\"\n        var inSingle = false\n        var inDouble = false\n        var escape = false\n        for ch in line {\n            if escape {\n                escape = false\n                continue\n            }\n            if ch == \"\\\\\" {\n                escape = true\n                continue\n            }\n            if ch == \"'\" && !inDouble {\n                inSingle.toggle(); continue\n            }\n            if ch == \"\\\"\" && !inSingle {\n                inDouble.toggle(); continue\n            }\n            if !inSingle && !inDouble { result.append(ch) }\n        }\n        return result\n    }\n}\n\n// MARK: - Python Outline Parser (indent-based)\n\nprivate enum PythonOutlineParser {\n    private struct Frame {\n        let key: String\n        let indent: Int\n        let kind: SymbolType\n    }\n\n    final class Node {\n        var id: String\n        var name: String\n        var type: SymbolType\n        var line: Int\n        var column: Int\n        var children: [Node] = []\n        init(id: String, name: String, type: SymbolType, line: Int, column: Int) {\n            self.id = id\n            self.name = name\n            self.type = type\n            self.line = line\n            self.column = column\n        }\n    }\n\n    static func parse(_ content: String) -> [OutlineItem] {\n        let lines = content.components(separatedBy: .newlines)\n\n        var roots: [Node] = []\n        var stack: [(frame: Frame, node: Node)] = []\n\n        let classRe = try? NSRegularExpression(pattern: #\"^\\s*class\\s+(\\w+)\"#, options: [])\n        let defRe = try? NSRegularExpression(pattern: #\"^\\s*(?:async\\s+)?def\\s+(\\w+)\"#, options: [])\n\n        func stableKey(type: SymbolType, name: String, line: Int, containerKey: String?) -> String {\n            let container = containerKey ?? \"<root>\"\n            return \"\\(container)|\\(type.rawValue)|\\(name)|\\(line)\"\n        }\n\n        func addNode(_ node: Node) {\n            if let last = stack.last {\n                last.node.children.append(node)\n            } else {\n                roots.append(node)\n            }\n        }\n\n        for (idx, rawLine) in lines.enumerated() {\n            let lineNumber = idx + 1\n            let trimmed = rawLine.trimmingCharacters(in: .whitespaces)\n            if trimmed.isEmpty || trimmed.hasPrefix(\"#\") { continue }\n\n            let indent = leadingIndent(rawLine)\n\n            while let last = stack.last, indent <= last.frame.indent {\n                stack.removeLast()\n            }\n\n            if let classRe,\n               let match = classRe.firstMatch(in: rawLine, options: [], range: NSRange(rawLine.startIndex..., in: rawLine)),\n               let range = Range(match.range(at: 1), in: rawLine) {\n\n                let name = String(rawLine[range])\n                let containerKey = stack.last?.frame.key\n                let key = stableKey(type: .class, name: name, line: lineNumber, containerKey: containerKey)\n                let node = Node(id: key, name: name, type: .class, line: lineNumber, column: 1)\n                addNode(node)\n\n                stack.append((Frame(key: node.id, indent: indent, kind: .class), node))\n                continue\n            }\n\n            if let defRe,\n               let match = defRe.firstMatch(in: rawLine, options: [], range: NSRange(rawLine.startIndex..., in: rawLine)),\n               let range = Range(match.range(at: 1), in: rawLine) {\n\n                let name = String(rawLine[range])\n                let containerKey = stack.last?.frame.key\n                let type: SymbolType = (stack.last?.frame.kind == .class) ? .method : .function\n\n                let key = stableKey(type: type, name: name, line: lineNumber, containerKey: containerKey)\n                let node = Node(id: key, name: name, type: type, line: lineNumber, column: 1)\n                addNode(node)\n\n                stack.append((Frame(key: node.id, indent: indent, kind: type), node))\n                continue\n            }\n\n            if stack.isEmpty {\n                if let varName = parsePythonAssignmentName(rawLine) {\n                    let key = stableKey(type: .variable, name: varName, line: lineNumber, containerKey: nil)\n                    let node = Node(id: key, name: varName, type: .variable, line: lineNumber, column: 1)\n                    addNode(node)\n                }\n            }\n        }\n\n        return roots.map(toItem)\n    }\n\n    private static func toItem(_ node: Node) -> OutlineItem {\n        OutlineItem(\n            id: node.id,\n            name: node.name,\n            type: node.type,\n            line: node.line,\n            column: node.column,\n            children: node.children.map(toItem)\n        )\n    }\n\n    private static func leadingIndent(_ line: String) -> Int {\n        var count = 0\n        for ch in line {\n            if ch == \" \" { count += 1 }\n            else if ch == \"\\t\" { count += 4 }\n            else { break }\n        }\n        return count\n    }\n\n    private static func parsePythonAssignmentName(_ line: String) -> String? {\n        // simplistic: <name> =\n        let trimmed = line.trimmingCharacters(in: .whitespaces)\n        guard let eq = trimmed.firstIndex(of: \"=\") else { return nil }\n        let lhs = trimmed[..<eq].trimmingCharacters(in: .whitespaces)\n        guard !lhs.isEmpty else { return nil }\n        // reject `==`\n        let afterEq = trimmed.index(after: eq)\n        if afterEq < trimmed.endIndex, trimmed[afterEq] == \"=\" { return nil }\n        if lhs.contains(\" \") { return nil }\n        // identifier check\n        let allowed = CharacterSet.alphanumerics.union(CharacterSet(charactersIn: \"_\"))\n        guard lhs.unicodeScalars.allSatisfy({ allowed.contains($0) }) else { return nil }\n        return String(lhs)\n    }\n}\n\n// MARK: - Generic Outline Parser\n\nprivate enum GenericOutlineParser {\n    static func parse(_ content: String) -> [OutlineItem] {\n        // Fallback: use the existing SymbolParser (flat list).\n        let symbols = SymbolParser.parseSymbols(from: content, language: .plainText)\n        return symbols\n            .map { sym in\n                let key = \"<root>|\\(sym.type.rawValue)|\\(sym.name)|\\(sym.line)\"\n                return OutlineItem(id: key, name: sym.name, type: sym.type, line: sym.line, column: sym.column, children: [])\n            }\n    }\n}\n"} 
>>>END

>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Panels/OutlineView.swift","start_line":1,"end_line":260}
>>>END

>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/ContentView.swift","start_line":30,"end_line":120}
>>>END
>>>TOOL search
{"query":"@State private var selectedSidebarTab", "glob":"VSCodeiPadOS/VSCodeiPadOS/ContentView.swift"}
>>>END
>>>TOOL search
{"query":"@State private var showPanel", "glob":"VSCodeiPadOS/VSCodeiPadOS/ContentView.swift"}
>>>END
>>>END>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/ContentView.swift","start_line":30,"end_line":120}
>>>END
>>>TOOL search
{"query":"@State private var selectedSidebarTab", "glob":"VSCodeiPadOS/VSCodeiPadOS/ContentView.swift"}
>>>END
>>>TOOL search
{"query":"@State private var showPanel", "glob":"VSCodeiPadOS/VSCodeiPadOS/ContentView.swift"}
>>>END

>>>TOOL search
{"query":"SwiftOutlineParser", "glob":"VSCodeiPadOS/VSCodeiPadOS/Views/Panels/OutlineView.swift"}
>>>END
>>>TOOL search
{"query":"typealias Node", "glob":"VSCodeiPadOS/VSCodeiPadOS/Views/Panels/OutlineView.swift"}
>>>END
>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Panels/OutlineView.swift","start_line":260,"end_line":520}
>>>END
>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Panels/OutlineView.swift","start_line":520,"end_line":720}
>>>END
>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Panels/OutlineView.swift","start_line":720,"end_line":900}
>>>END

>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Panels/OutlineView.swift","start_line":1,"end_line":40}
>>>END

>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Models/EditorState.swift","start_line":1,"end_line":120}
>>>END

>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Panels/OutlineView.swift","start_line":1,"end_line":15}
>>>END

>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Models/EditorState.swift","start_line":1,"end_line":160}
>>>END

>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Panels/OutlineView.swift","start_line":1,"end_line":12}
>>>END

>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Panels/OutlineView.swift","start_line":1,"end_line":3}
>>>END

>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Panels/OutlineView.swift","start_line":1,"end_line":8}
>>>END

>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Panels/OutlineView.swift","start_line":1,"end_line":1}
>>>END

>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Panels/OutlineView.swift","start_line":1,"end_line":25}
>>>END

>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Panels/OutlineView.swift","start_line":1,"end_line":6}
>>>END

>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Panels/OutlineView.swift","start_line":1,"end_line":2}
>>>END

>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Services/EditorCore.swift","start_line":1,"end_line":60}
>>>END

>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Panels/OutlineView.swift","start_line":1,"end_line":10}
>>>END

>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Panels/OutlineView.swift","start_line":1,"end_line":1}
>>>END

>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/ContentView.swift","start_line":300,"end_line":430}
>>>END
>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Services/EditorCore.swift","start_line":10,"end_line":60}
>>>END
>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Panels/OutlineView.swift","start_line":1,"end_line":15}
>>>END
>>>END

>>>REPORT
Implemented Outline panel in new file:

- Created/overwrote `VSCodeiPadOS/VSCodeiPadOS/Views/Panels/OutlineView.swift` (867 lines).
  - Parses symbols from the current editor tab content via `editorCore.activeTab?.content` / `editorCore.activeTab?.language` and debounced background parsing (lines 30-33, 155-175).
  - Displays a hierarchical/tree outline with expandable containers and nested members using `OutlineItem` + recursive `OutlineRow` (lines 47-63, 180-199, 272-349).
  - Covers functions/methods, classes/structs/enums/protocols/extensions, properties/vars/lets, constructors; plus JS/TS and Python equivalents via language-specific parsers:
    - Swift parser `SwiftOutlineParser` (lines 370-548)
    - JS/TS parser `JSOutlineParser` (lines 552-714)
    - Python parser `PythonOutlineParser` (lines 718-852)
    - Generic fallback uses existing `SymbolParser` (lines 856-866)
  - Click-to-jump support: selecting a row calls `onJumpToLine(selected.line)` (lines 11-13, 49-57, 295-333). (Caller wires this closure to actual editor scrolling.)
  - Icons by symbol type: uses `SymbolType.icon` and `SymbolType.color` in rows (lines 313-316). (`SymbolType` icon/color mapping is defined in `VSCodeiPadOS/VSCodeiPadOS/Views/GoToSymbol.swift` lines 12-63.)
  - Filter/search: “Filter symbols” text field filters by name or type and keeps parents if children match (lines 96-119, 203-228).
  - Sort: segmented picker “Position” vs “A–Z” with recursive sort implementation (lines 15-19, 121-129, 230-255).

Files examined for integration context/evidence:
- `VSCodeiPadOS/VSCodeiPadOS/Views/GoToSymbol.swift` (SymbolType/icon/color + SymbolParser).
- `VSCodeiPadOS/VSCodeiPadOS/ContentView.swift` (activeTab usage + editor line jump plumbing exists via `requestedLineSelection` binding to `SyntaxHighlightingTextView`, e.g. lines 358-430 in latest read).
>>>END
