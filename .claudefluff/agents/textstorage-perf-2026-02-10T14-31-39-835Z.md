# Agent: textstorage-perf
**Status:** done
**Tokens:** 10,204
**Cost:** $0.0000
**Time:** 2026-02-10T14:31:39.835Z

## Task
CRITICAL: Investigate NSTextStorage and attributed string performance in VSCodeiPadOS.

Read VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift FULLY.

Investigate:
1. How is textView.attributedText being set? (full replacement vs incremental?)
2. Is textStorage.beginEditing()/endEditing() being used?
3. Are attributes being added one at a time or batched?
4. Is the custom TextKit stack (FoldingLayoutManager) adding overhead?
5. Are there unnecessary textStorage operations during typing?

Report: ALL text storage bottlenecks with line numbers and CONCRETE fixes with code.

## Response
>>>TOOL read_file
{"path": "VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift"}
>>>END

>>>TOOL read_file
{"path": "VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift", "start_line": 100, "end_line": 300}
>>>END

---

## ðŸ”§ TOOL RESULTS

[read_file]
File: VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift (lines 101-300 of 2289)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
101:             isActive: isActive,
102:             fontSize: editorCore.editorFontSize,
103:             requestedLineSelection: requestedLineSelection,
104:             requestedCursorIndex: requestedCursorIndex,
105:             onAcceptAutocomplete: onAcceptAutocomplete,
106:             onDismissAutocomplete: onDismissAutocomplete
107:         )
108:     }
109: 
110:     func makeCoordinator() -> Coordinator {
111:         Coordinator(self)
112:     }
113:     
114:     func makeUIView(context: Context) -> UITextView {
115:         // Create custom TextKit stack with FoldingLayoutManager for code folding support
116:         let textStorage = NSTextStorage()
117:         let foldingLayoutManager = FoldingLayoutManager()
118:         textStorage.addLayoutManager(foldingLayoutManager)
119:         
120:         let textContainer = NSTextContainer(size: CGSize(width: CGFloat.greatestFiniteMagnitude, height: CGFloat.greatestFiniteMagnitude))
121:         textContainer.widthTracksTextView = true
122:         foldingLayoutManager.addTextContainer(textContainer)
123:         
124:         let textView = EditorTextView(frame: .zero, textContainer: textContainer)
125:         
126:         // Connect FoldingLayoutManager to EditorTextView
127:         foldingLayoutManager.ownerTextView = textView
128:         
129:         textView.delegate = context.coordinator
130:         textView.editorCore = editorCore
131:         
132:         // Code folding support
133:         textView.foldingManager = CodeFoldingManager.shared
134:         textView.fileId = filename
135: 
136:         // Autocomplete hooks
137:         textView.onAcceptAutocomplete = onAcceptAutocomplete
138:         textView.onDismissAutocomplete = onDismissAutocomplete
139: 
140:         textView.onPeekDefinition = {
141:             context.coordinator.handlePeekDefinition(in: textView)
142:         }
143: 
144:         textView.onEscape = {
145:             context.coordinator.handleEscape()
146:         }
147: 
148:         textView.onGoToLine = {
149:             self.editorCore.showGoToLine = true
150:         }
151:         
152:         // Wire up custom context menu actions
153:         textView.onGoToDefinition = {
154:             context.coordinator.handleGoToDefinition(in: textView)
155:         }
156:         
157:         textView.onFindReferences = {
158:             context.coordinator.handleFindReferences(in: textView)
159:         }
160:         
161:         textView.onFormatDocument = {
162:             context.coordinator.handleFormatDocument(in: textView)
163:         }
164:         
165:         textView.onToggleComment = {
166:             context.coordinator.handleToggleComment(in: textView)
167:         }
168:         
169:         textView.onFold = {
170:             context.coordinator.handleFold(in: textView)
171:         }
172:         
173:         textView.onUnfold = {
174:             context.coordinator.handleUnfold(in: textView)
175:         }
176:         
177:         // Add pinch gesture for zoom (with delegate to allow simultaneous text selection)
178:         let pinchGesture = UIPinchGestureRecognizer(target: context.coordinator, action: #selector(Coordinator.handlePinch(_:)))
179:         pinchGesture.delegate = context.coordinator
180:         textView.addGestureRecognizer(pinchGesture)
181:         context.coordinator.pinchGesture = pinchGesture
182:         
183:         // Configure text view
184:         textView.isEditable = true
185:         textView.isSelectable = true
186:         textView.autocapitalizationType = .none
187:         textView.autocorrectionType = .no
188:         textView.smartDashesType = .no
189:         textView.smartQuotesType = .no
190:         textView.smartInsertDeleteType = .no
191:         textView.spellCheckingType = .no
192:         
193:         // Set font and appearance (use editorCore.editorFontSize)
194:         textView.font = UIFont.monospacedSystemFont(ofSize: editorCore.editorFontSize, weight: .regular)
195:         textView.textColor = UIColor(ThemeManager.shared.currentTheme.editorForeground)
196:         textView.backgroundColor = UIColor(ThemeManager.shared.currentTheme.editorBackground)
197:         textView.tintColor = UIColor(ThemeManager.shared.currentTheme.cursor)
198:         textView.keyboardType = .default
199:         textView.textContainerInset = UIEdgeInsets(top: 8, left: 8, bottom: 8, right: 8)
200:         
201:         // Enable line wrapping
202:         textView.textContainer.lineBreakMode = .byCharWrapping
203:         textView.textContainer.widthTracksTextView = true
204:         
205:         // Calculate line height
206:         if let font = textView.font {
207:             DispatchQueue.main.async {
208:                 self.lineHeight = font.lineHeight
209:             }
210:         }
211:         
212:         // Set initial text with syntax highlighting
213:         textView.text = text
214:         context.coordinator.applySyntaxHighlighting(to: textView)
215:         context.coordinator.updateLineCount(textView)
216:         
217:         return textView
218:     }
219:     
220:     func updateUIView(_ textView: UITextView, context: Context) {
221:         // CRITICAL: Update coordinator's parent reference to current struct
222:         // SwiftUI creates new struct instances on each update, so this keeps
223:         // coordinator in sync with current bindings and properties
224:         context.coordinator.parent = self
225:         
226:         // CRITICAL FIX: Apply initial highlighting FIRST on the very first updateUIView call
227:         // This fixes the bug where syntax highlighting only appears after typing.
228:         // makeUIView applies it, but the view may not be fully in hierarchy yet,
229:         // causing the attributed text to be lost. This ensures it's applied reliably.
230:         if !context.coordinator.hasAppliedInitialHighlighting && !textView.text.isEmpty {
231:             context.coordinator.applySyntaxHighlighting(to: textView)
232:             context.coordinator.hasAppliedInitialHighlighting = true
233:         }
234:         
235:         // Update colors when theme changes
236:         // NOTE: Only set backgroundColor and tintColor here. Do NOT set textColor
237:         // as it interferes with attributedText syntax highlighting colors.
238:         // The foreground color is handled entirely by the attributedText.
239:         textView.backgroundColor = UIColor(ThemeManager.shared.currentTheme.editorBackground)
240:         textView.tintColor = UIColor(ThemeManager.shared.currentTheme.cursor)
241:         
242:         if let editorView = textView as? EditorTextView {
243:             editorView.updateThemeColors(theme: ThemeManager.shared.currentTheme)
244:         }
245:         
246:         // Update font size if changed (using explicit fontSize parameter for proper SwiftUI updates)
247:         if let currentFont = textView.font, currentFont.pointSize != fontSize {
248:             let selectedRange = textView.selectedRange
249:             textView.font = UIFont.monospacedSystemFont(ofSize: fontSize, weight: .regular)
250:             context.coordinator.applySyntaxHighlighting(to: textView)
251:             textView.selectedRange = selectedRange
252:             
253:             // Update line height
254:             if let font = textView.font {
255:                 DispatchQueue.main.async {
256:                     self.lineHeight = font.lineHeight
257:                 }
258:             }
259:         }
260:         
261:         // Update text if changed externally
262:         if textView.text != text {
263:             let selectedRange = textView.selectedRange
264:             textView.text = text
265:             context.coordinator.applySyntaxHighlighting(to: textView)
266:             context.coordinator.hasAppliedInitialHighlighting = true
267:             textView.selectedRange = selectedRange
268:         } else if context.coordinator.lastThemeId != ThemeManager.shared.currentTheme.id {
269:             // Re-apply highlighting if theme changed
270:             context.coordinator.applySyntaxHighlighting(to: textView)
271:         }
272:         
273:         // Handle minimap scrolling - but ONLY if user is NOT actively scrolling
274:         // This prevents the editor from fighting against user scroll due to async binding lag
275:         if scrollPosition != context.coordinator.lastKnownScrollPosition && scrollPosition >= 0 && !context.coordinator.isUserScrolling {
276:             // Update lastKnownScrollPosition FIRST to prevent race condition
277:             // where user scroll gets overridden by stale binding value
278:             context.coordinator.lastKnownScrollPosition = scrollPosition
279:             context.coordinator.scrollToLine(scrollPosition, in: textView)
280:         }
281: 
282:         // Handle line selection requests (e.g. tapping line numbers)
283:         if let requested = requestedLineSelection,
284:            requested != context.coordinator.lastRequestedLineSelection {
285:             context.coordinator.lastRequestedLineSelection = requested
286:             context.coordinator.scrollToAndSelectLine(requested, in: textView)
287:             // Defer @Binding update to avoid "Publishing changes from within view updates"
288:             DispatchQueue.main.async {
289:                 self.requestedLineSelection = nil
290:             }
291:         }
292: 
293:         // Handle cursor index requests (e.g. accepting autocomplete)
294:         if let requested = requestedCursorIndex,
295:            requested != context.coordinator.lastRequestedCursorIndex {
296:             context.coordinator.lastRequestedCursorIndex = requested
297:             // Use UTF-16 count for NSRange compatibility
298:             let textLength = (textView.text as NSString?)?.length ?? 0
299:             let safeIndex = max(0, min(requested, textLength))
300:             textView.selectedRange = NSRange(location: safeIndex, length: 0)


>>>TOOL read_file
{"path": "VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift", "start_line": 300, "end_line": 500}
>>>END

---

## ðŸ”§ TOOL RESULTS

[read_file]
File: VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift (lines 301-500 of 2289)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
301:             
302:             // Ensure cursor is visible by scrolling to it
303:             textView.scrollRangeToVisible(textView.selectedRange)
304:             
305:             // Defer @Binding update to avoid "Publishing changes from within view updates"
306:             DispatchQueue.main.async {
307:                 self.requestedCursorIndex = nil
308:             }
309: 
310:             // Update SwiftUI state
311:             context.coordinator.updateCursorPosition(textView)
312:             context.coordinator.updateScrollPosition(textView)
313:         }
314:         
315:         // Note: updateLineCount is called in textViewDidChange, no need to call here
316:         // as it causes unnecessary state churn on every updateUIView
317:     }
318:     
319:     // MARK: - Coordinator
320:     
321:     class Coordinator: NSObject, UITextViewDelegate, UIGestureRecognizerDelegate {
322:         var parent: SyntaxHighlightingTextView
323:         var lastKnownScrollPosition: Int = 0
324:         var lastThemeId: String = ""
325:         var lastRequestedLineSelection: Int? = nil
326:         var lastRequestedCursorIndex: Int? = nil
327:         private var isUpdatingFromMinimap = false
328:         private var highlightDebouncer: Timer?
329:         weak var pinchGesture: UIPinchGestureRecognizer?
330:         private var initialFontSize: CGFloat = 0
331:         
332:         // Track user scroll to prevent programmatic scroll fighting back
333:         private var userScrollDebouncer: Timer?
334:         var isUserScrolling = false
335: 
336:         // FEAT-044: Matching bracket highlight state
337:         private var bracketHighlightRanges: [NSRange] = []
338:         
339:         // Track if initial highlighting has been applied (fixes highlighting not appearing on file open)
340:         var hasAppliedInitialHighlighting = false
341:         
342:         // PERF: Track last line to avoid unnecessary redraws
343:         private var lastKnownLineNumber: Int = -1
344:         
345:         // PERF: Debounce bracket matching to avoid O(n) scans on every cursor move
346:         private var bracketMatchDebouncer: Timer?
347:         
348:         // PERFORMANCE: Large file highlighting optimization
349:         // Files larger than this threshold get deferred full highlighting
350:         private let largeFileThreshold = 10000  // 10k characters
351:         private var largeFileHighlightDebouncer: Timer?
352:         // Track if we have pending full highlight (for large files)
353:         private var hasPendingFullHighlight = false
354:         
355:         init(_ parent: SyntaxHighlightingTextView) {
356:             self.parent = parent
357:         }
358:         
359:         // MARK: - UIGestureRecognizerDelegate
360:         
361:         // Allow pinch gesture to work simultaneously with text selection gestures
362:         func gestureRecognizer(_ gestureRecognizer: UIGestureRecognizer, shouldRecognizeSimultaneouslyWith otherGestureRecognizer: UIGestureRecognizer) -> Bool {
363:             // Allow pinch to work alongside native text selection gestures
364:             return true
365:         }
366:         
367:         func textViewDidBeginEditing(_ textView: UITextView) {
368:             // Ensure syntax highlighting is current when user begins editing
369:             // This handles cases where text was set but highlighting hasn't run yet
370:             applySyntaxHighlighting(to: textView)
371:         }
372:         
373:         func textViewDidChange(_ textView: UITextView) {
374:             // Update parent text
375:             parent.text = textView.text
376:             
377:             // Set typing attributes IMMEDIATELY so new characters have proper base styling
378:             // This prevents flicker during the debounce period
379:             let theme = ThemeManager.shared.currentTheme
380:             let fontSize = parent.editorCore.editorFontSize
381:             textView.typingAttributes = [
382:                 .font: UIFont.monospacedSystemFont(ofSize: fontSize, weight: .regular),
383:                 .foregroundColor: UIColor(theme.editorForeground)
384:             ]
385:             
386:             // PERFORMANCE FIX: Aggressive debounce strategy based on document size
387:             // For large files, syntax highlighting is EXTREMELY expensive and causes lag
388:             let textLength = textView.text.count
389:             
390:             // Large file threshold - above this, skip highlighting during active typing entirely
391:             let largeFileThreshold = 10000
392:             // Very large file threshold - above this, use extended delay
393:             let veryLargeFileThreshold = 50000
394:             
395:             highlightDebouncer?.invalidate()
396:             
397:             if textLength > veryLargeFileThreshold {
398:                 // VERY LARGE FILES (50k+): Wait 1.5 seconds of idle before highlighting
399:                 // This prevents UI blocking entirely during active typing
400:                 highlightDebouncer = Timer.scheduledTimer(withTimeInterval: 1.5, repeats: false) { [weak self] _ in
401:                     self?.applyVisibleRangeHighlighting(to: textView)
402:                 }
403:             } else if textLength > largeFileThreshold {
404:                 // LARGE FILES (10k-50k): Wait 1 second of idle, then highlight visible range only
405:                 highlightDebouncer = Timer.scheduledTimer(withTimeInterval: 1.0, repeats: false) { [weak self] _ in
406:                     self?.applyVisibleRangeHighlighting(to: textView)
407:                 }
408:             } else if textLength > 5000 {
409:                 // MEDIUM FILES (5k-10k): 300ms debounce, full highlighting on background thread
410:                 highlightDebouncer = Timer.scheduledTimer(withTimeInterval: 0.3, repeats: false) { [weak self] _ in
411:                     self?.applyHighlightingAsync(to: textView)
412:                 }
413:             } else {
414:                 // SMALL FILES (<5k): 80ms debounce, direct highlighting (fast enough)
415:                 highlightDebouncer = Timer.scheduledTimer(withTimeInterval: 0.08, repeats: false) { [weak self] _ in
416:                     DispatchQueue.main.async {
417:                         self?.applySyntaxHighlighting(to: textView)
418:                     }
419:                 }
420:             }
421:             
422:             updateLineCount(textView)
423:             updateCursorPosition(textView)
424:         }
425:         
426:         /// Async highlighting for large files - processes on background thread
427:         func applyHighlightingAsync(to textView: UITextView) {
428:             guard !isApplyingHighlighting else { return }
429:             isApplyingHighlighting = true
430:             
431:             let text = textView.text ?? ""
432:             let filename = parent.filename
433:             let theme = ThemeManager.shared.currentTheme
434:             let fontSize = parent.editorCore.editorFontSize
435:             let selectedRange = textView.selectedRange
436:             
437:             // Process highlighting on background thread
438:             DispatchQueue.global(qos: .userInitiated).async { [weak self] in
439:                 let highlighter = VSCodeSyntaxHighlighter(theme: theme, fontSize: fontSize)
440:                 let attributedText = highlighter.highlight(text, filename: filename)
441:                 
442:                 // Apply on main thread
443:                 DispatchQueue.main.async {
444:                     guard let self = self else { return }
445:                     self.isApplyingHighlighting = false
446:                     
447:                     // Only apply if text hasn't changed while we were processing
448:                     guard textView.text == text else { return }
449:                     
450:                     textView.attributedText = attributedText
451:                     textView.selectedRange = selectedRange
452:                     
453:                     textView.typingAttributes = [
454:                         .font: UIFont.monospacedSystemFont(ofSize: fontSize, weight: .regular),
455:                         .foregroundColor: UIColor(theme.editorForeground)
456:                     ]
457:                     
458:                     self.lastThemeId = theme.id
459:                 }
460:             }
461:         }
462:         
463:         /// PERFORMANCE: Visible-range-only highlighting for very large files
464:         /// Only highlights the text that's currently visible on screen, dramatically reducing lag
465:         func applyVisibleRangeHighlighting(to textView: UITextView) {
466:             guard !isApplyingHighlighting else { return }
467:             isApplyingHighlighting = true
468:             
469:             let text = textView.text ?? ""
470:             let filename = parent.filename
471:             let theme = ThemeManager.shared.currentTheme
472:             let fontSize = parent.editorCore.editorFontSize
473:             let selectedRange = textView.selectedRange
474:             
475:             // Calculate visible range with buffer
476:             let visibleRect = textView.bounds
477:             let textContainer = textView.textContainer
478:             let layoutManager = textView.layoutManager
479:             
480:             // Get the glyph range for the visible rect
481:             var visibleGlyphRange = NSRange()
482:             layoutManager.enumerateLineFragments(forGlyphRange: NSRange(location: 0, length: layoutManager.numberOfGlyphs)) { (rect, usedRect, container, glyphRange, stop) in
483:                 if rect.intersects(visibleRect) {
484:                     if visibleGlyphRange.length == 0 {
485:                         visibleGlyphRange = glyphRange
486:                     } else {
487:                         visibleGlyphRange.length = glyphRange.location + glyphRange.length - visibleGlyphRange.location
488:                     }
489:                 } else if visibleGlyphRange.length > 0 && rect.minY > visibleRect.maxY {
490:                     stop.pointee = true
491:                 }
492:             }
493:             
494:             // Convert glyph range to character range
495:             var visibleCharRange = layoutManager.characterRange(forGlyphRange: visibleGlyphRange, actualGlyphRange: nil)
496:             
497:             // Add buffer of ~50 lines before and after for smooth scrolling
498:             let bufferChars = 5000
499:             let rangeStart = max(0, visibleCharRange.location - bufferChars)
500:             let rangeEnd = min(text.utf16.count, visibleCharRange.location + visibleCharRange.length + bufferChars)


>>>TOOL read_file
{"path": "VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift", "start_line": 500, "end_line": 700}
>>>END

---

## ðŸ”§ TOOL RESULTS

[read_file]
File: VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift (lines 501-700 of 2289)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
501:             visibleCharRange = NSRange(location: rangeStart, length: rangeEnd - rangeStart)
502:             
503:             // Process highlighting on background thread
504:             DispatchQueue.global(qos: .userInitiated).async { [weak self] in
505:                 // Extract the visible portion of text
506:                 let nsText = text as NSString
507:                 let safeRange = NSRange(
508:                     location: visibleCharRange.location,
509:                     length: min(visibleCharRange.length, nsText.length - visibleCharRange.location)
510:                 )
511:                 guard safeRange.length > 0 else {
512:                     DispatchQueue.main.async {
513:                         self?.isApplyingHighlighting = false
514:                     }
515:                     return
516:                 }
517:                 
518:                 let visibleText = nsText.substring(with: safeRange)
519:                 
520:                 // Highlight only the visible portion
521:                 let highlighter = VSCodeSyntaxHighlighter(theme: theme, fontSize: fontSize)
522:                 let highlightedVisible = highlighter.highlight(visibleText, filename: filename)
523:                 
524:                 // Apply on main thread
525:                 DispatchQueue.main.async {
526:                     guard let self = self else { return }
527:                     self.isApplyingHighlighting = false
528:                     
529:                     // Only apply if text hasn't changed while we were processing
530:                     guard textView.text == text else { return }
531:                     
532:                     // Create full attributed string with base styling
533:                     let fullAttributed = NSMutableAttributedString(string: text)
534:                     let baseFont = UIFont.monospacedSystemFont(ofSize: fontSize, weight: .regular)
535:                     let baseColor = UIColor(theme.editorForeground)
536:                     let fullRange = NSRange(location: 0, length: text.utf16.count)
537:                     fullAttributed.addAttribute(.font, value: baseFont, range: fullRange)
538:                     fullAttributed.addAttribute(.foregroundColor, value: baseColor, range: fullRange)
539:                     
540:                     // Apply highlighted attributes only to visible range
541:                     highlightedVisible.enumerateAttributes(in: NSRange(location: 0, length: highlightedVisible.length), options: []) { attrs, range, _ in
542:                         let targetRange = NSRange(location: safeRange.location + range.location, length: range.length)
543:                         if targetRange.location + targetRange.length <= fullAttributed.length {
544:                             for (key, value) in attrs {
545:                                 fullAttributed.addAttribute(key, value: value, range: targetRange)
546:                             }
547:                         }
548:                     }
549:                     
550:                     textView.attributedText = fullAttributed
551:                     textView.selectedRange = selectedRange
552:                     
553:                     textView.typingAttributes = [
554:                         .font: baseFont,
555:                         .foregroundColor: baseColor
556:                     ]
557:                     
558:                     self.lastThemeId = theme.id
559:                 }
560:             }
561:         }
562:         
563:         func textViewDidChangeSelection(_ textView: UITextView) {
564:             if !isUpdatingFromMinimap {
565:                 updateCursorPosition(textView)
566:                 updateScrollPosition(textView)
567: 
568:                 // FEAT-044: Matching bracket highlight - PERF: debounced to avoid O(n) scan spam
569:                 bracketMatchDebouncer?.invalidate()
570:                 bracketMatchDebouncer = Timer.scheduledTimer(withTimeInterval: 0.1, repeats: false) { [weak self] _ in
571:                     self?.updateMatchingBracketHighlight(textView)
572:                 }
573: 
574:                 // PERF: Only trigger redraw when line actually changes (not on every cursor move)
575:                 let currentLine = parent.currentLineNumber
576:                 if currentLine != lastKnownLineNumber {
577:                     lastKnownLineNumber = currentLine
578:                     (textView as? EditorTextView)?.setNeedsDisplay()
579:                 }
580: 
581:                 // Update selection in EditorCore for multi-cursor support
582:                 // Defer @Published property updates to avoid "Publishing changes from within view updates"
583:                 let range = textView.selectedRange
584:                 let currentText = textView.text ?? ""
585:                 let isMultiCursor = parent.editorCore.multiCursorState.isMultiCursor
586:                 
587:                 DispatchQueue.main.async { [weak self] in
588:                     guard let self = self else { return }
589:                     self.parent.editorCore.updateSelection(range: range, text: currentText)
590: 
591:                     // Keep EditorCore.multiCursorState in sync with UIKit selection.
592:                     // Important: Don't clear the anchor when there's an active selection, otherwise Cmd+D
593:                     // loses the "first occurrence" selection and multi-cursor typing won't replace all occurrences.
594:                     if !isMultiCursor {
595:                         if range.length > 0 {
596:                             self.parent.editorCore.multiCursorState.cursors = [
597:                                 Cursor(position: range.location + range.length, anchor: range.location, isPrimary: true)
598:                             ]
599:                         } else {
600:                             self.parent.editorCore.multiCursorState.reset(to: range.location)
601:                         }
602:                     }
603:                 }
604:             }
605:         }
606:         
607:         // MARK: - UIScrollViewDelegate methods for reliable user scroll detection
608:         
609:         func scrollViewWillBeginDragging(_ scrollView: UIScrollView) {
610:             // User started dragging - set flag immediately to prevent programmatic scroll fighting
611:             isUserScrolling = true
612:             userScrollDebouncer?.invalidate()
613:         }
614:         
615:         func scrollViewDidEndDragging(_ scrollView: UIScrollView, willDecelerate decelerate: Bool) {
616:             // If not decelerating, user stopped scrolling
617:             if !decelerate {
618:                 // Small delay to let any final scroll events settle
619:                 userScrollDebouncer?.invalidate()
620:                 userScrollDebouncer = Timer.scheduledTimer(withTimeInterval: 0.15, repeats: false) { [weak self] _ in
621:                     self?.isUserScrolling = false
622:                 }
623:             }
624:         }
625:         
626:         func scrollViewDidEndDecelerating(_ scrollView: UIScrollView) {
627:             // Deceleration finished - user scroll is complete
628:             userScrollDebouncer?.invalidate()
629:             userScrollDebouncer = Timer.scheduledTimer(withTimeInterval: 0.15, repeats: false) { [weak self] _ in
630:                 self?.isUserScrolling = false
631:             }
632:         }
633:         
634:         func scrollViewDidScroll(_ scrollView: UIScrollView) {
635:             guard let textView = scrollView as? UITextView, !isUpdatingFromMinimap else { return }
636:             
637:             // Note: isUserScrolling is now set by scrollViewWillBeginDragging for reliable detection
638:             // We still use debouncer as a fallback for edge cases
639:             if isUserScrolling {
640:                 userScrollDebouncer?.invalidate()
641:                 userScrollDebouncer = Timer.scheduledTimer(withTimeInterval: 0.3, repeats: false) { [weak self] _ in
642:                     self?.isUserScrolling = false
643:                 }
644:             }
645:             
646:             updateScrollPosition(textView)
647:         }
648:         
649:         func updateLineCount(_ textView: UITextView) {
650:             // PERF: Count newlines directly instead of creating array copy
651:             let text = textView.text ?? ""
652:             var lineCount = 1
653:             for char in text {
654:                 if char == "\n" {
655:                     lineCount += 1
656:                 }
657:             }
658:             DispatchQueue.main.async {
659:                 self.parent.totalLines = lineCount
660:             }
661:         }
662:         
663:         func updateCursorPosition(_ textView: UITextView) {
664:             guard let selectedRange = textView.selectedTextRange else { return }
665:             let cursorPosition = textView.offset(from: textView.beginningOfDocument, to: selectedRange.start)
666:             
667:             // PERF: Count newlines directly instead of creating substring + array
668:             let text = textView.text ?? ""
669:             var lineNumber = 1
670:             var columnStart = 0
671:             
672:             let endIndex = text.index(text.startIndex, offsetBy: min(cursorPosition, text.count), limitedBy: text.endIndex) ?? text.endIndex
673:             for (i, char) in text[..<endIndex].enumerated() {
674:                 if char == "\n" {
675:                     lineNumber += 1
676:                     columnStart = i + 1
677:                 }
678:             }
679:             
680:             let column = cursorPosition - columnStart + 1
681:             
682:             DispatchQueue.main.async {
683:                 self.parent.currentLineNumber = lineNumber
684:                 self.parent.currentColumn = column
685:                 self.parent.cursorIndex = cursorPosition
686:             }
687:         }
688:         
689:         func updateScrollPosition(_ textView: UITextView) {
690:             guard let font = textView.font else { return }
691:             let lineHeight = font.lineHeight
692:             let yOffset = textView.contentOffset.y
693:             let line = Int(yOffset / lineHeight)
694: 
695:             // Update lastKnownScrollPosition synchronously to prevent feedback loops
696:             lastKnownScrollPosition = line
697:             
698:             // Defer @Binding updates to avoid "Publishing changes from within view updates"
699:             DispatchQueue.main.async {
700:                 self.parent.scrollPosition = line


>>>TOOL read_file
{"path": "VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift", "start_line": 700, "end_line": 900}
>>>END

---

## ðŸ”§ TOOL RESULTS

[read_file]
File: VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift (lines 701-900 of 2289)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
701:                 self.parent.scrollOffset = yOffset
702:             }
703:         }
704:         
705:         func scrollToLine(_ line: Int, in textView: UITextView) {
706:             guard !isUpdatingFromMinimap else { return }
707:             isUpdatingFromMinimap = true
708:             
709:             let lines = textView.text.components(separatedBy: .newlines)
710:             guard line >= 0 && line < lines.count else {
711:                 isUpdatingFromMinimap = false
712:                 return
713:             }
714:             
715:             var characterPosition = 0
716:             for i in 0..<line {
717:                 characterPosition += lines[i].count + 1
718:             }
719:             
720:             if let position = textView.position(from: textView.beginningOfDocument, offset: characterPosition) {
721:                 let rect = textView.caretRect(for: position)
722:                 let targetY = max(0, rect.origin.y)
723:                 textView.setContentOffset(CGPoint(x: 0, y: targetY), animated: true)
724:             }
725:             
726:             DispatchQueue.main.asyncAfter(deadline: .now() + 0.3) {
727:                 self.isUpdatingFromMinimap = false
728:             }
729:         }
730: 
731:         func scrollToAndSelectLine(_ line: Int, in textView: UITextView) {
732:             let lines = textView.text.components(separatedBy: .newlines)
733:             guard line >= 0 && line < lines.count else { return }
734: 
735:             var characterPosition = 0
736:             for i in 0..<line {
737:                 characterPosition += lines[i].count + 1
738:             }
739: 
740:             // FEAT-041: select entire line (excluding trailing newline)
741:             let lineLength = (lines[line] as NSString).length
742:             let range = NSRange(location: characterPosition, length: lineLength)
743:             textView.selectedRange = range
744: 
745:             // Ensure it's visible
746:             scrollToLine(line, in: textView)
747: 
748:             // Update SwiftUI state
749:             updateCursorPosition(textView)
750:             updateScrollPosition(textView)
751:         }
752: 
753:         private var isApplyingHighlighting = false
754:         
755:         func applySyntaxHighlighting(to textView: UITextView) {
756:             // Guard against reentrancy - this can happen if attributedText assignment
757:             // triggers delegate callbacks that call this method again
758:             guard !isApplyingHighlighting else { return }
759:             isApplyingHighlighting = true
760:             defer { isApplyingHighlighting = false }
761:             
762:             let theme = ThemeManager.shared.currentTheme
763:             lastThemeId = theme.id
764: 
765:             let highlighter = VSCodeSyntaxHighlighter(theme: theme, fontSize: parent.editorCore.editorFontSize)
766:             let attributedText = highlighter.highlight(textView.text, filename: parent.filename)
767: 
768:             let selectedRange = textView.selectedRange
769: 
770:             // NOTE: We intentionally do NOT manipulate undoManager.disableUndoRegistration/enableUndoRegistration
771:             // here. UITextView's internal undo manager state machine is fragile and can crash with
772:             // "enableUndoRegistration may only be invoked with matching call to disableUndoRegistration"
773:             // when attributedText assignment triggers internal undo callbacks.
774:             // 
775:             // Instead, we let the system handle undo naturally. The trade-off is that syntax highlighting
776:             // changes might add noise to the undo stack, but this is preferable to crashing.
777:             
778:             textView.attributedText = attributedText
779:             textView.selectedRange = selectedRange
780: 
781:             // Set typing attributes so newly typed characters have correct base styling
782:             // This prevents flicker during the debounce period before full highlighting runs
783:             let fontSize = parent.editorCore.editorFontSize
784:             textView.typingAttributes = [
785:                 .font: UIFont.monospacedSystemFont(ofSize: fontSize, weight: .regular),
786:                 .foregroundColor: UIColor(theme.editorForeground)
787:             ]
788: 
789:             // FEAT-044: restore matching bracket highlight after re-attributing text
790:             updateMatchingBracketHighlight(textView)
791:         }
792:         
793:         func handlePeekDefinition(in textView: UITextView) {
794:             guard let selectedRange = textView.selectedTextRange else { return }
795:             let text = textView.text ?? ""
796:             
797:             if let range = textView.tokenizer.rangeEnclosingPosition(selectedRange.start, with: .word, inDirection: UITextDirection(rawValue: 1)) {
798:                  let location = textView.offset(from: textView.beginningOfDocument, to: range.start)
799:                  
800:                  let prefix = String(text.prefix(location))
801:                  let sourceLine = prefix.components(separatedBy: CharacterSet.newlines).count - 1
802:                  
803:                  parent.editorCore.triggerPeekDefinition(
804:                      file: parent.filename,
805:                      line: sourceLine,
806:                      content: text,
807:                      sourceLine: sourceLine
808:                  )
809:             }
810:         }
811:         
812:         func handleEscape() {
813:             if parent.editorCore.peekState != nil {
814:                 parent.editorCore.closePeekDefinition()
815:             } else {
816:                 parent.editorCore.escapeMultiCursor()
817:             }
818:         }
819:         
820:         func handleGoToDefinition(in textView: UITextView) {
821:             // Reuse the peek definition logic for now
822:             handlePeekDefinition(in: textView)
823:         }
824:         
825:         func handleFindReferences(in textView: UITextView) {
826:             guard let selectedRange = textView.selectedTextRange else { return }
827:             let text = textView.text ?? ""
828:             
829:             if let range = textView.tokenizer.rangeEnclosingPosition(selectedRange.start, with: .word, inDirection: UITextDirection(rawValue: 1)) {
830:                 let location = textView.offset(from: textView.beginningOfDocument, to: range.start)
831:                 
832:                 let prefix = String(text.prefix(location))
833:                 let sourceLine = prefix.components(separatedBy: CharacterSet.newlines).count - 1
834:                 
835:                 // TODO: Implement find references functionality in EditorCore
836:                 // For now, just trigger peek definition as a placeholder
837:                 parent.editorCore.triggerPeekDefinition(
838:                     file: parent.filename,
839:                     line: sourceLine,
840:                     content: text,
841:                     sourceLine: sourceLine
842:                 )
843:             }
844:         }
845:         
846:         func handleFormatDocument(in textView: UITextView) {
847:             // TODO: Implement format document functionality
848:             // This would typically call a formatter in EditorCore
849:             print("Format Document: Not yet implemented")
850:         }
851:         
852:         func handleToggleComment(in textView: UITextView) {
853:             guard let selectedRange = textView.selectedTextRange else { return }
854:             let text = textView.text ?? ""
855:             
856:             // Get the current line range
857:             if let lineRange = textView.tokenizer.rangeEnclosingPosition(selectedRange.start, with: .paragraph, inDirection: UITextDirection(rawValue: 1)) {
858:                 let location = textView.offset(from: textView.beginningOfDocument, to: lineRange.start)
859:                 let length = textView.offset(from: lineRange.start, to: lineRange.end)
860:                 let nsRange = NSRange(location: location, length: length)
861:                 
862:                 if nsRange.location + nsRange.length <= (text as NSString).length {
863:                     let lineText = (text as NSString).substring(with: nsRange)
864:                     let trimmed = lineText.trimmingCharacters(in: .whitespaces)
865:                     
866:                     // Check if line starts with a comment
867:                     let isCommented = trimmed.hasPrefix("//") || trimmed.hasPrefix("#") || trimmed.hasPrefix("/*")
868:                     
869:                     // Toggle comment
870:                     var newLineText: String
871:                     if isCommented {
872:                         // Remove comment
873:                         newLineText = lineText.replacingOccurrences(of: "//", with: "").replacingOccurrences(of: "#", with: "", options: .anchored)
874:                     } else {
875:                         // Add comment (use // for most languages)
876:                         newLineText = "//" + lineText
877:                     }
878:                     
879:                     // Replace the line
880:                     let textStorage = textView.textStorage
881:                     textStorage.replaceCharacters(in: nsRange, with: newLineText)
882:                     
883:                     // Update parent binding
884:                     parent.text = textView.text
885:                 }
886:             }
887:         }
888:         
889:         func handleFold(in textView: UITextView) {
890:             CodeFoldingManager.shared.foldCurrentLine()
891:         }
892:         
893:         func handleUnfold(in textView: UITextView) {
894:             CodeFoldingManager.shared.unfoldCurrentLine()
895:         }
896:         
897:         @objc func handlePinch(_ gesture: UIPinchGestureRecognizer) {
898:             guard let textView = gesture.view as? UITextView else { return }
899: 
900:             switch gesture.state {


>>>TOOL read_file
{"path": "VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift", "start_line": 900, "end_line": 1100}
>>>END

---

## ðŸ”§ TOOL RESULTS

[read_file]
File: VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift (lines 901-1100 of 2289)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
901:             case .began:
902:                 // Store the initial font size when pinch begins
903:                 initialFontSize = parent.editorCore.editorFontSize
904: 
905:             case .changed:
906:                 // Calculate new font size based on pinch scale
907:                 let newSize = initialFontSize * gesture.scale
908: 
909:                 // Clamp font size between 8 and 32
910:                 let clampedSize = min(max(newSize, 8), 32)
911: 
912:                 // Update EditorCore's font size (this will trigger updateUIView)
913:                 parent.editorCore.editorFontSize = clampedSize
914: 
915:             case .ended, .cancelled:
916:                 // Optional: snap to nearest whole number or standard size
917:                 let finalSize = round(parent.editorCore.editorFontSize)
918:                 parent.editorCore.editorFontSize = min(max(finalSize, 8), 32)
919: 
920:             default:
921:                 break
922:             }
923:         }
924: 
925:         // MARK: - FEAT-044 Matching Bracket Highlight
926: 
927:         private func updateMatchingBracketHighlight(_ textView: UITextView) {
928:             // Clear any existing highlights
929:             if !bracketHighlightRanges.isEmpty {
930:                 for r in bracketHighlightRanges {
931:                     textView.textStorage.removeAttribute(.backgroundColor, range: r)
932:                     textView.textStorage.removeAttribute(.underlineStyle, range: r)
933:                 }
934:                 bracketHighlightRanges.removeAll()
935:             }
936: 
937:             // Only highlight when there's a caret (no selection)
938:             let selection = textView.selectedRange
939:             guard selection.length == 0 else { return }
940: 
941:             let nsText = (textView.text ?? "") as NSString
942:             let length = nsText.length
943:             guard length > 0 else { return }
944: 
945:             let caret = selection.location
946: 
947:             // Candidate bracket location: char before caret, else at caret
948:             let candidateIndices: [Int] = [
949:                 caret - 1,
950:                 caret
951:             ].filter { $0 >= 0 && $0 < length }
952: 
953:             func isBracket(_ c: unichar) -> Bool {
954:                 c == 123 || c == 125 || c == 40 || c == 41 || c == 91 || c == 93 // { } ( ) [ ]
955:             }
956: 
957:             var bracketIndex: Int?
958:             var bracketChar: unichar = 0
959: 
960:             for idx in candidateIndices {
961:                 let c = nsText.character(at: idx)
962:                 if isBracket(c) {
963:                     bracketIndex = idx
964:                     bracketChar = c
965:                     break
966:                 }
967:             }
968: 
969:             guard let idx = bracketIndex else { return }
970: 
971:             // Define bracket pairs
972:             let openToClose: [unichar: unichar] = [123: 125, 40: 41, 91: 93] // { -> }, ( -> ), [ -> ]
973:             let closeToOpen: [unichar: unichar] = [125: 123, 41: 40, 93: 91] // } -> {, ) -> (, ] -> [
974: 
975:             let theme = ThemeManager.shared.currentTheme
976:             let bg = UIColor(theme.selection).withAlphaComponent(theme.isDark ? 0.35 : 0.22)
977: 
978:             var matchIndex: Int?
979: 
980:             if let close = openToClose[bracketChar] {
981:                 // Opening bracket: scan forward
982:                 var depth = 0
983:                 var i = idx + 1
984:                 while i < length {
985:                     let c = nsText.character(at: i)
986:                     if c == bracketChar {
987:                         depth += 1
988:                     } else if c == close {
989:                         if depth == 0 {
990:                             matchIndex = i
991:                             break
992:                         } else {
993:                             depth -= 1
994:                         }
995:                     }
996:                     i += 1
997:                 }
998:             } else if let open = closeToOpen[bracketChar] {
999:                 // Closing bracket: scan backward
1000:                 var depth = 0
1001:                 var i = idx - 1
1002:                 while i >= 0 {
1003:                     let c = nsText.character(at: i)
1004:                     if c == bracketChar {
1005:                         depth += 1
1006:                     } else if c == open {
1007:                         if depth == 0 {
1008:                             matchIndex = i
1009:                             break
1010:                         } else {
1011:                             depth -= 1
1012:                         }
1013:                     }
1014:                     i -= 1
1015:                 }
1016:             }
1017: 
1018:             guard let match = matchIndex else { return }
1019: 
1020:             let r1 = NSRange(location: idx, length: 1)
1021:             let r2 = NSRange(location: match, length: 1)
1022: 
1023:             textView.textStorage.addAttribute(.backgroundColor, value: bg, range: r1)
1024:             textView.textStorage.addAttribute(.backgroundColor, value: bg, range: r2)
1025: 
1026:             textView.textStorage.addAttribute(.underlineStyle, value: NSUnderlineStyle.single.rawValue, range: r1)
1027:             textView.textStorage.addAttribute(.underlineStyle, value: NSUnderlineStyle.single.rawValue, range: r2)
1028: 
1029:             bracketHighlightRanges = [r1, r2]
1030:         }
1031:     }
1032: }
1033: 
1034: // MARK: - FoldingLayoutManager
1035: /// TextKit layout manager that collapses line fragments for lines marked folded in CodeFoldingManager.
1036: /// This is a view-level folding implementation (it does NOT modify the underlying text).
1037: final class FoldingLayoutManager: NSLayoutManager, NSLayoutManagerDelegate {
1038:     weak var ownerTextView: EditorTextView?
1039: 
1040:     override init() {
1041:         super.init()
1042:         self.delegate = self
1043:     }
1044: 
1045:     required init?(coder: NSCoder) {
1046:         super.init(coder: coder)
1047:         self.delegate = self
1048:     }
1049: 
1050:     func layoutManager(
1051:         _ layoutManager: NSLayoutManager,
1052:         shouldSetLineFragmentRect lineFragmentRect: UnsafeMutablePointer<CGRect>,
1053:         lineFragmentUsedRect: UnsafeMutablePointer<CGRect>,
1054:         baselineOffset: UnsafeMutablePointer<CGFloat>,
1055:         in textContainer: NSTextContainer,
1056:         forGlyphRange glyphRange: NSRange
1057:     ) -> Bool {
1058:         guard let owner = ownerTextView,
1059:               let foldingManager = owner.foldingManager,
1060:               let fileId = owner.fileId
1061:         else {
1062:             return false
1063:         }
1064: 
1065:         // Convert glyphRange -> characterRange so we can compute the line index.
1066:         let charRange = self.characterRange(forGlyphRange: glyphRange, actualGlyphRange: nil)
1067:         let loc = max(0, charRange.location)
1068: 
1069:         let full = (self.textStorage?.string ?? "") as NSString
1070:         let lineIndex = FoldingLayoutManager.lineIndex(atUTF16Location: loc, in: full)
1071: 
1072:         if foldingManager.isLineFolded(fileId: fileId, line: lineIndex) {
1073:             // Collapse this visual line fragment.
1074:             lineFragmentRect.pointee.size.height = 0
1075:             lineFragmentUsedRect.pointee.size.height = 0
1076:             baselineOffset.pointee = 0
1077:             return true
1078:         }
1079: 
1080:         return false
1081:     }
1082: 
1083:     private static func lineIndex(atUTF16Location loc: Int, in text: NSString) -> Int {
1084:         if loc <= 0 { return 0 }
1085: 
1086:         let capped = min(loc, text.length)
1087:         var line = 0
1088:         var searchStart = 0
1089: 
1090:         while searchStart < capped {
1091:             let r = text.range(of: "\n", options: [], range: NSRange(location: searchStart, length: capped - searchStart))
1092:             if r.location == NSNotFound { break }
1093:             line += 1
1094:             let next = r.location + 1
1095:             if next >= capped { break }
1096:             searchStart = next
1097:         }
1098: 
1099:         return line
1100:     }


>>>TOOL read_file
{"path": "VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift", "start_line": 1100, "end_line": 1300}
>>>END

---

## ðŸ”§ TOOL RESULTS

[read_file]
File: VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift (lines 1101-1300 of 2289)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1101: }
1102: 
1103: // Custom text view to handle key commands, indent guides, and line highlighting
1104: class EditorTextView: MultiCursorTextView {
1105:     var onPeekDefinition: (() -> Void)?
1106:     var onEscape: (() -> Void)?
1107:     var onGoToLine: (() -> Void)?
1108:     
1109:     // Custom action closures for context menu
1110:     var onGoToDefinition: (() -> Void)?
1111:     var onFindReferences: (() -> Void)?
1112:     var onFormatDocument: (() -> Void)?
1113:     var onToggleComment: (() -> Void)?
1114:     var onFold: (() -> Void)?
1115:     var onUnfold: (() -> Void)?
1116: 
1117:     // Autocomplete key handling hooks are inherited from MultiCursorTextView
1118:     
1119:     // Code folding support - required by FoldingLayoutManager
1120:     weak var foldingManager: CodeFoldingManager?
1121:     var fileId: String?
1122:     
1123:     // FEAT-039 & FEAT-043
1124:     private var indentGuideColor: UIColor = .separator
1125:     private var activeIndentGuideColor: UIColor = .label
1126:     private var currentLineHighlightColor: UIColor = .clear
1127:     
1128:     // PERF: Cached values to avoid recalculating on every draw()
1129:     private var cachedTabSize: Int = 4
1130:     private var cachedSpaceWidth: CGFloat = 0
1131:     private var cachedIndentWidth: CGFloat = 0
1132:     private var lastCachedFont: UIFont?
1133:     
1134:     override init(frame: CGRect, textContainer: NSTextContainer?) {
1135:         super.init(frame: frame, textContainer: textContainer)
1136:         setup()
1137:     }
1138:     
1139:     required init?(coder: NSCoder) {
1140:         super.init(coder: coder)
1141:         setup()
1142:     }
1143:     
1144:     private func setup() {
1145:         // Ensure we redraw when bounds/selection change
1146:         contentMode = .redraw
1147:         updateCachedMeasurements()
1148:     }
1149:     
1150:     /// PERF: Update cached measurements - call when font changes
1151:     func updateCachedMeasurements() {
1152:         let storedTabSize = UserDefaults.standard.integer(forKey: "tabSize")
1153:         cachedTabSize = storedTabSize > 0 ? storedTabSize : 4
1154:         
1155:         if let font = self.font, font != lastCachedFont {
1156:             cachedSpaceWidth = " ".size(withAttributes: [.font: font]).width
1157:             cachedIndentWidth = cachedSpaceWidth * CGFloat(cachedTabSize)
1158:             lastCachedFont = font
1159:         }
1160:     }
1161:     
1162:     func updateThemeColors(theme: Theme) {
1163:         self.indentGuideColor = UIColor(theme.indentGuide)
1164:         self.activeIndentGuideColor = UIColor(theme.indentGuideActive)
1165:         self.currentLineHighlightColor = UIColor(theme.currentLineHighlight)
1166:         setNeedsDisplay()
1167:     }
1168:     
1169:     override func draw(_ rect: CGRect) {
1170:         guard let context = UIGraphicsGetCurrentContext(), let font = self.font else {
1171:             super.draw(rect)
1172:             return
1173:         }
1174:         
1175:         // 1. Draw Current Line Highlight (FEAT-043)
1176:         if let selectedRange = selectedTextRange {
1177:             // Get the line rect for the cursor position
1178:             let caretRect = self.caretRect(for: selectedRange.start)
1179:             let lineRect = CGRect(x: 0, y: caretRect.minY, width: bounds.width, height: caretRect.height)
1180:             
1181:             context.setFillColor(currentLineHighlightColor.cgColor)
1182:             context.fill(lineRect)
1183:         }
1184:         
1185:         // 2. Draw Text (super implementation)
1186:         super.draw(rect)
1187:         
1188:         // 3. Draw Indent Guides (FEAT-039)
1189:         // We iterate visible lines and draw vertical lines for indentation
1190:         // Optimization: Only draw for visible range
1191: 
1192:         context.setLineWidth(1.0)
1193: 
1194:         // PERF: Use cached values instead of recalculating on every draw
1195:         // Update cache if font changed
1196:         if font != lastCachedFont {
1197:             updateCachedMeasurements()
1198:         }
1199:         let tabSize = cachedTabSize
1200:         let indentWidth = cachedIndentWidth
1201: 
1202:         // Determine active indent level for caret line (for indentGuideActive)
1203:         var activeIndentLevel: Int = 0
1204:         if let selected = selectedTextRange {
1205:             let caretPos = offset(from: beginningOfDocument, to: selected.start)
1206:             let nsText = (self.text ?? "") as NSString
1207:             let safeLoc = min(max(0, caretPos), nsText.length)
1208:             let caretLineRange = nsText.lineRange(for: NSRange(location: safeLoc, length: 0))
1209:             let caretLineText = nsText.substring(with: caretLineRange)
1210: 
1211:             var spaces = 0
1212:             for ch in caretLineText {
1213:                 if ch == " " { spaces += 1 }
1214:                 else if ch == "\t" { spaces += tabSize }
1215:                 else { break }
1216:             }
1217:             activeIndentLevel = spaces / tabSize
1218:         }
1219: 
1220:         // Iterate visible glyphs/lines
1221:         let visibleRect = CGRect(origin: contentOffset, size: bounds.size)
1222:         let glyphRange = layoutManager.glyphRange(forBoundingRect: visibleRect, in: textContainer)
1223: 
1224:         let caretY = selectedTextRange.map { caretRect(for: $0.start).minY }
1225: 
1226:         layoutManager.enumerateLineFragments(forGlyphRange: glyphRange) { (rect, usedRect, textContainer, glyphRange, stop) in
1227:             // Get text for this line
1228:             guard let range = self.layoutManager.characterRange(forGlyphRange: glyphRange, actualGlyphRange: nil) as NSRange?,
1229:                   let text = self.text as NSString? else { return }
1230: 
1231:             let lineText = text.substring(with: range)
1232: 
1233:             // Calculate indentation level
1234:             var spaces = 0
1235:             for char in lineText {
1236:                 if char == " " { spaces += 1 }
1237:                 else if char == "\t" { spaces += tabSize } // Handle tabs if present
1238:                 else { break }
1239:             }
1240: 
1241:             let indentLevel = spaces / tabSize
1242:             guard indentLevel > 0 else { return }
1243: 
1244:             let isCaretLine = (caretY != nil) && abs(rect.minY - (caretY ?? 0)) < 0.5
1245: 
1246:             for i in 1...indentLevel {
1247:                 let x = CGFloat(i) * indentWidth + self.textContainerInset.left
1248:                 let startPoint = CGPoint(x: x, y: rect.minY)
1249:                 let endPoint = CGPoint(x: x, y: rect.maxY)
1250: 
1251:                 let stroke = (isCaretLine && i == activeIndentLevel) ? self.activeIndentGuideColor : self.indentGuideColor
1252:                 context.setStrokeColor(stroke.cgColor)
1253: 
1254:                 context.move(to: startPoint)
1255:                 context.addLine(to: endPoint)
1256:                 context.strokePath()
1257:             }
1258:         }
1259:     }
1260:     
1261:     override var keyCommands: [UIKeyCommand]? {
1262:         // NOTE: Only define text-editing specific shortcuts here.
1263:         // App-level shortcuts (Cmd+B, Cmd+P, Cmd+N, Cmd+S, Cmd+W, Cmd+F, etc.)
1264:         // are defined in the Menus/ folder via SwiftUI's .keyboardShortcut().
1265:         // See: KEYBOARD_SHORTCUTS_SOURCE_OF_TRUTH.md
1266:         // Defining them here AND in Menus/ causes duplicate conflicts.
1267:         
1268:         var commands = super.keyCommands ?? []
1269:         
1270:         // Peek Definition: Option+D (editor-specific, not in menus)
1271:         commands.append(UIKeyCommand(
1272:             input: "d",
1273:             modifierFlags: .alternate,
1274:             action: #selector(handlePeekDefinition)
1275:         ))
1276: 
1277:         // NOTE: Cmd+G (Go to Line) is defined in GoMenuCommands.swift - DO NOT ADD HERE
1278: 
1279:         // Tab: accept autocomplete if visible, else insert tab
1280:         commands.append(UIKeyCommand(
1281:             input: "\t",
1282:             modifierFlags: [],
1283:             action: #selector(handleTab)
1284:         ))
1285:         
1286:         // Escape: dismiss autocomplete/peek if visible
1287:         commands.append(UIKeyCommand(
1288:             input: UIKeyCommand.inputEscape,
1289:             modifierFlags: [],
1290:             action: #selector(handleEscape)
1291:         ))
1292:         
1293:         // Fold: Cmd+Opt+[
1294:         commands.append(UIKeyCommand(
1295:             input: "[",
1296:             modifierFlags: [.command, .alternate],
1297:             action: #selector(handleFold)
1298:         ))
1299:         
1300:         // Unfold: Cmd+Opt+]


>>>TOOL read_file
{"path": "VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift", "start_line": 1300, "end_line": 1500}
>>>END

---

## ðŸ”§ TOOL RESULTS

[read_file]
File: VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift (lines 1301-1500 of 2289)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1301:         commands.append(UIKeyCommand(
1302:             input: "]",
1303:             modifierFlags: [.command, .alternate],
1304:             action: #selector(handleUnfold)
1305:         ))
1306:         
1307:         // Toggle Terminal: Cmd+J (not in standard system menus, safe to define here)
1308:         let toggleTerminalCmd = UIKeyCommand(
1309:             input: "j",
1310:             modifierFlags: .command,
1311:             action: #selector(handleToggleTerminal),
1312:             discoverabilityTitle: "Toggle Panel"
1313:         )
1314:         toggleTerminalCmd.wantsPriorityOverSystemBehavior = true
1315:         commands.append(toggleTerminalCmd)
1316:         
1317:         // AI Assistant: Cmd+Shift+A (not conflicting with system Select All which is Cmd+A)
1318:         commands.append(UIKeyCommand(
1319:             input: "a",
1320:             modifierFlags: [.command, .shift],
1321:             action: #selector(handleShowAIAssistant),
1322:             discoverabilityTitle: "AI Assistant"
1323:         ))
1324:         
1325:         return commands
1326:     }
1327:     
1328:     @objc func handlePeekDefinition() {
1329:         onPeekDefinition?()
1330:     }
1331: 
1332:     @objc func handleGoToLine() {
1333:         onGoToLine?()
1334:     }
1335: 
1336:     @objc func handleTab() {
1337:         if onAcceptAutocomplete?() == true {
1338:             return
1339:         }
1340:         insertText("\t")
1341:     }
1342:     
1343:     @objc func handleEscape() {
1344:         if onDismissAutocomplete?() == true {
1345:             return
1346:         }
1347:         onEscape?()
1348:     }
1349:     
1350:     @objc func handleFold() {
1351:         onFold?()
1352:     }
1353:     
1354:     @objc func handleUnfold() {
1355:         onUnfold?()
1356:     }
1357: 
1358:     // MARK: - Undo / Redo
1359: 
1360:     @objc func handleUndo() {
1361:         undoManager?.undo()
1362:     }
1363: 
1364:     @objc func handleRedo() {
1365:         undoManager?.redo()
1366:     }
1367:     
1368:     // MARK: - App-Level Shortcut Handlers
1369:     
1370:     @objc func handleShowCommandPalette() {
1371:         NotificationCenter.default.post(name: NSNotification.Name("ShowCommandPalette"), object: nil)
1372:     }
1373:     
1374:     @objc func handleToggleTerminal() {
1375:         NotificationCenter.default.post(name: NSNotification.Name("ToggleTerminal"), object: nil)
1376:     }
1377:     
1378:     @objc func handleShowAIAssistant() {
1379:         NotificationCenter.default.post(name: NSNotification.Name("ShowAIAssistant"), object: nil)
1380:     }
1381:     
1382:     @objc func handleToggleSidebar() {
1383:         NotificationCenter.default.post(name: NSNotification.Name("ToggleSidebar"), object: nil)
1384:     }
1385:     
1386:     @objc func handleShowQuickOpen() {
1387:         NotificationCenter.default.post(name: NSNotification.Name("ShowQuickOpen"), object: nil)
1388:     }
1389:     
1390:     @objc func handleNewFile() {
1391:         NotificationCenter.default.post(name: NSNotification.Name("NewFile"), object: nil)
1392:     }
1393:     
1394:     @objc func handleSaveFile() {
1395:         NotificationCenter.default.post(name: NSNotification.Name("SaveFile"), object: nil)
1396:     }
1397:     
1398:     @objc func handleCloseTab() {
1399:         NotificationCenter.default.post(name: NSNotification.Name("CloseTab"), object: nil)
1400:     }
1401:     
1402:     @objc func handleFind() {
1403:         NotificationCenter.default.post(name: NSNotification.Name("ShowFind"), object: nil)
1404:     }
1405:     
1406:     @objc func handleZoomIn() {
1407:         NotificationCenter.default.post(name: NSNotification.Name("ZoomIn"), object: nil)
1408:     }
1409:     
1410:     @objc func handleZoomOut() {
1411:         NotificationCenter.default.post(name: NSNotification.Name("ZoomOut"), object: nil)
1412:     }
1413:     
1414:     // MARK: - Custom Actions
1415:     
1416:     @objc private func goToDefinition(_ sender: Any?) {
1417:         onGoToDefinition?()
1418:     }
1419:     
1420:     @objc private func peekDefinition(_ sender: Any?) {
1421:         onPeekDefinition?()
1422:     }
1423:     
1424:     @objc private func findReferences(_ sender: Any?) {
1425:         onFindReferences?()
1426:     }
1427:     
1428:     @objc private func formatDocument(_ sender: Any?) {
1429:         onFormatDocument?()
1430:     }
1431:     
1432:     @objc private func toggleComment(_ sender: Any?) {
1433:         onToggleComment?()
1434:     }
1435:     
1436:     // MARK: - Menu Support
1437:     
1438:     override func canPerformAction(_ action: Selector, withSender sender: Any?) -> Bool {
1439:         // Enable custom actions
1440:         if action == #selector(goToDefinition(_:)) {
1441:             return onGoToDefinition != nil
1442:         }
1443:         if action == #selector(peekDefinition(_:)) {
1444:             return onPeekDefinition != nil
1445:         }
1446:         if action == #selector(findReferences(_:)) {
1447:             return onFindReferences != nil
1448:         }
1449:         if action == #selector(formatDocument(_:)) {
1450:             return onFormatDocument != nil
1451:         }
1452:         if action == #selector(toggleComment(_:)) {
1453:             return onToggleComment != nil
1454:         }
1455:         
1456:         return super.canPerformAction(action, withSender: sender)
1457:     }
1458:     
1459:     override func buildMenu(with builder: UIMenuBuilder) {
1460:         super.buildMenu(with: builder)
1461:         
1462:         guard builder.menu(for: .text) != nil else { return }
1463:         
1464:         // Create custom menu items
1465:         let goToDefinitionAction = UIAction(
1466:             title: "Go to Definition",
1467:             image: UIImage(systemName: "arrow.forward.circle"),
1468:             identifier: UIAction.Identifier("com.vscode.goToDefinition"),
1469:             handler: { [weak self] _ in
1470:                 self?.goToDefinition(nil)
1471:             }
1472:         )
1473:         
1474:         let peekDefinitionAction = UIAction(
1475:             title: "Peek Definition",
1476:             image: UIImage(systemName: "eye"),
1477:             identifier: UIAction.Identifier("com.vscode.peekDefinition"),
1478:             handler: { [weak self] _ in
1479:                 self?.peekDefinition(nil)
1480:             }
1481:         )
1482:         
1483:         let findReferencesAction = UIAction(
1484:             title: "Find All References",
1485:             image: UIImage(systemName: "magnifyingglass"),
1486:             identifier: UIAction.Identifier("com.vscode.findReferences"),
1487:             handler: { [weak self] _ in
1488:                 self?.findReferences(nil)
1489:             }
1490:         )
1491:         
1492:         let formatDocumentAction = UIAction(
1493:             title: "Format Document",
1494:             image: UIImage(systemName: "text.alignleft"),
1495:             identifier: UIAction.Identifier("com.vscode.formatDocument"),
1496:             handler: { [weak self] _ in
1497:                 self?.formatDocument(nil)
1498:             }
1499:         )
1500:         


>>>TOOL read_file
{"path": "VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift", "start_line": 1500, "end_line": 1700}
>>>END

---

## ðŸ”§ TOOL RESULTS

[read_file]
File: VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift (lines 1501-1700 of 2289)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1501:         let toggleCommentAction = UIAction(
1502:             title: "Toggle Comment",
1503:             image: UIImage(systemName: "text.quote"),
1504:             identifier: UIAction.Identifier("com.vscode.toggleComment"),
1505:             handler: { [weak self] _ in
1506:                 self?.toggleComment(nil)
1507:             }
1508:         )
1509:         
1510:         // Group custom actions
1511:         let customMenu = UIMenu(
1512:             title: "",
1513:             identifier: UIMenu.Identifier("com.vscode.customActions"),
1514:             options: [.displayInline],
1515:             children: [
1516:                 goToDefinitionAction,
1517:                 peekDefinitionAction,
1518:                 findReferencesAction,
1519:                 formatDocumentAction,
1520:                 toggleCommentAction
1521:             ]
1522:         )
1523:         
1524:         // Insert custom menu after standard edit menu
1525:         builder.insertChild(customMenu, atStartOfMenu: .text)
1526:     }
1527: }
1528: 
1529: // MARK: - VSCode-Style Syntax Highlighter
1530: 
1531: enum Language {
1532:     case swift
1533: 
1534:     case javascript
1535:     case typescript
1536:     case jsx
1537:     case tsx
1538: 
1539:     case python
1540:     case ruby
1541:     case go
1542:     case rust
1543:     case java
1544:     case kotlin
1545: 
1546:     case c
1547:     case cpp
1548:     case objectiveC
1549: 
1550:     case html
1551:     case css
1552:     case scss
1553:     case less
1554:     case json
1555:     case xml
1556:     case yaml
1557:     case sql
1558: 
1559:     case shell
1560:     case dockerfile
1561:     case graphql
1562:     case markdown
1563:     case php
1564:     case env
1565: 
1566:     case plainText
1567: }
1568: 
1569: struct VSCodeSyntaxHighlighter {
1570:     private let baseFontSize: CGFloat
1571:     let theme: Theme
1572:     
1573:     init(theme: Theme = ThemeManager.shared.currentTheme, fontSize: CGFloat = 14) {
1574:         self.theme = theme
1575:         self.baseFontSize = fontSize
1576:     }
1577:     
1578:     func highlight(_ text: String, filename: String) -> NSAttributedString {
1579:         let language = detectLanguage(from: filename)
1580:         return highlight(text, language: language)
1581:     }
1582:     
1583:     private func detectLanguage(from filename: String) -> Language {
1584:         let lower = filename.lowercased()
1585:         let ext = (filename as NSString).pathExtension.lowercased()
1586: 
1587:         // Special-case filenames without extensions
1588:         if (filename as NSString).lastPathComponent.lowercased() == "dockerfile" { return .dockerfile }
1589:         if (filename as NSString).lastPathComponent.lowercased() == ".env" { return .env }
1590:         if lower.hasSuffix("/.env") { return .env }
1591: 
1592:         switch ext {
1593:         case "swift": return .swift
1594: 
1595:         case "js", "mjs", "cjs": return .javascript
1596:         case "jsx": return .jsx
1597:         case "ts", "mts", "cts": return .typescript
1598:         case "tsx": return .tsx
1599: 
1600:         case "py", "pyw": return .python
1601:         case "rb", "ruby": return .ruby
1602:         case "go": return .go
1603:         case "rs": return .rust
1604:         case "java": return .java
1605:         case "kt", "kts": return .kotlin
1606: 
1607:         case "c", "h": return .c
1608:         case "cpp", "cc", "cxx", "hpp", "hh", "hxx": return .cpp
1609:         case "m", "mm": return .objectiveC
1610: 
1611:         case "html", "htm": return .html
1612:         case "css": return .css
1613:         case "scss", "sass": return .scss
1614:         case "less": return .less
1615:         case "json", "jsonc": return .json
1616:         case "xml", "plist", "svg": return .xml
1617:         case "yml", "yaml": return .yaml
1618:         case "sql": return .sql
1619: 
1620:         case "sh", "bash", "zsh", "fish": return .shell
1621:         case "dockerfile": return .dockerfile
1622: 
1623:         case "graphql", "gql": return .graphql
1624: 
1625:         case "md", "markdown": return .markdown
1626:         case "php": return .php
1627:         case "env": return .env
1628: 
1629:         default: return .plainText
1630:         }
1631:     }
1632:     
1633:     private func highlight(_ text: String, language: Language) -> NSAttributedString {
1634:         let attributed = NSMutableAttributedString(string: text)
1635:         let fullRange = NSRange(location: 0, length: text.utf16.count)
1636:         
1637:         // Base attributes
1638:         let baseFont = UIFont.monospacedSystemFont(ofSize: baseFontSize, weight: .regular)
1639:         attributed.addAttribute(.font, value: baseFont, range: fullRange)
1640:         attributed.addAttribute(.foregroundColor, value: UIColor(theme.editorForeground), range: fullRange)
1641:         
1642:         // Apply language-specific highlighting
1643:         switch language {
1644:         case .swift: highlightSwift(attributed, text: text)
1645:         case .javascript, .jsx: highlightJavaScript(attributed, text: text, isTS: false)
1646:         case .typescript, .tsx: highlightJavaScript(attributed, text: text, isTS: true)
1647:         case .python: highlightPython(attributed, text: text)
1648:         case .html, .xml: highlightHTML(attributed, text: text)
1649:         case .css, .scss, .less: highlightCSS(attributed, text: text)
1650:         case .json: highlightJSON(attributed, text: text)
1651:         case .markdown: highlightMarkdown(attributed, text: text)
1652:         case .rust: highlightRust(attributed, text: text)
1653:         case .go: highlightGo(attributed, text: text)
1654:         case .java, .kotlin: highlightJava(attributed, text: text)
1655:         case .c, .cpp, .objectiveC: highlightCpp(attributed, text: text)
1656:         case .ruby: highlightRuby(attributed, text: text)
1657:         case .php: highlightPHP(attributed, text: text)
1658:         case .shell, .dockerfile: highlightShell(attributed, text: text)
1659:         case .yaml, .env: highlightYAML(attributed, text: text)
1660:         case .sql: highlightSQL(attributed, text: text)
1661:         case .graphql: highlightGraphQL(attributed, text: text)
1662:         case .plainText: break
1663:         }
1664:         
1665:         // FEAT-038: Bracket Pair Colorization (applied last)
1666:         highlightBracketPairs(attributed, text: text)
1667:         
1668:         return attributed
1669:     }
1670:     
1671:     // MARK: - Bracket Pair Colorization
1672:     
1673:     private func highlightBracketPairs(_ attributed: NSMutableAttributedString, text: String) {
1674:         let brackets: [Character] = ["{", "}", "[", "]", "(", ")"]
1675:         let pairs: [Character: Character] = ["}": "{", "]": "[", ")": "("]
1676:         
1677:         var stack: [(char: Character, index: Int, depth: Int)] = []
1678:         let colors = [
1679:             UIColor(theme.bracketPair1),
1680:             UIColor(theme.bracketPair2),
1681:             UIColor(theme.bracketPair3),
1682:             UIColor(theme.bracketPair4),
1683:             UIColor(theme.bracketPair5),
1684:             UIColor(theme.bracketPair6)
1685:         ]
1686:         
1687:         // Scan text for brackets
1688:         // Note: In a real implementation, we should skip brackets inside strings/comments
1689:         // But since we apply this LAST, we can try to respect existing string/comment colors
1690:         // OR implement a more robust parser. For now, simple scan.
1691:         
1692:         // Optimization: Use scanner or direct iteration
1693:         let nsString = text as NSString
1694:         var index = 0
1695:         
1696:         while index < text.utf16.count {
1697:             let char = nsString.character(at: index)
1698:             if let scalar = UnicodeScalar(char) {
1699:                 let c = Character(scalar)
1700:                 


>>>TOOL read_file
{"path": "VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift", "start_line": 1700, "end_line": 1900}
>>>END

---

## ðŸ”§ TOOL RESULTS

[read_file]
File: VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift (lines 1701-1900 of 2289)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1701:                 if brackets.contains(c) {
1702:                     // Check if it's already colored as string/comment (heuristic)
1703:                     // If color is string/comment, skip
1704:                     // (Requires iterating attributes, which is slow. We'll just apply on top for now)
1705:                     
1706:                     if let open = pairs[c] { // Closing bracket
1707:                         if let last = stack.last, last.char == open {
1708:                             // Match found
1709:                             let depth = last.depth
1710:                             let color = colors[depth % colors.count]
1711:                             
1712:                             attributed.addAttribute(.foregroundColor, value: color, range: NSRange(location: index, length: 1))
1713:                             attributed.addAttribute(.foregroundColor, value: color, range: NSRange(location: last.index, length: 1))
1714:                             
1715:                             stack.removeLast()
1716:                         } else {
1717:                             // Mismatched or extra closing bracket - unexpected
1718:                             // Keep default color or mark red? Default for now.
1719:                         }
1720:                     } else { // Opening bracket
1721:                         let depth = stack.count
1722:                         stack.append((c, index, depth))
1723:                         
1724:                         // We'll color it when (and if) we find the match, or here?
1725:                         // Better to color here tentatively, but matching is better.
1726:                         // Let's color tentatively based on depth.
1727:                         let color = colors[depth % colors.count]
1728:                         attributed.addAttribute(.foregroundColor, value: color, range: NSRange(location: index, length: 1))
1729:                     }
1730:                 }
1731:             }
1732:             index += 1
1733:         }
1734:     }
1735:     
1736:     // MARK: - Swift Highlighting
1737:     
1738:     private func highlightSwift(_ attributed: NSMutableAttributedString, text: String) {
1739:         // Keywords (purple/pink)
1740:         let keywords = ["func", "var", "let", "if", "else", "for", "while", "return",
1741:                        "class", "struct", "enum", "protocol", "extension", "import",
1742:                        "private", "public", "internal", "fileprivate", "open",
1743:                        "static", "final", "override", "mutating", "nonmutating",
1744:                        "init", "deinit", "subscript", "typealias", "associatedtype",
1745:                        "where", "throws", "rethrows", "async", "await", "actor",
1746:                        "guard", "defer", "do", "try", "catch", "throw",
1747:                        "switch", "case", "default", "break", "continue", "fallthrough",
1748:                        "in", "is", "as", "inout", "some", "any", "Self",
1749:                        "get", "set", "willSet", "didSet", "lazy", "weak", "unowned",
1750:                        "@State", "@Binding", "@Published", "@ObservedObject", "@StateObject",
1751:                        "@Environment", "@EnvironmentObject", "@ViewBuilder", "@MainActor",
1752:                        "@escaping", "@autoclosure", "@available", "@objc", "@discardableResult"]
1753:         highlightKeywords(attributed, keywords: keywords, color: UIColor(theme.keyword), text: text)
1754:         
1755:         // Types (teal) - CamelCase words that aren't keywords
1756:         let typePattern = "\\b[A-Z][a-zA-Z0-9]*\\b"
1757:         highlightPattern(attributed, pattern: typePattern, color: UIColor(theme.type), text: text)
1758:         
1759:         // Function calls (yellow)
1760:         let funcCallPattern = "\\b([a-z][a-zA-Z0-9]*)\\s*\\("
1761:         highlightPattern(attributed, pattern: funcCallPattern, color: UIColor(theme.function), text: text, captureGroup: 1)
1762:         
1763:         // Constants (blue)
1764:         let constants = ["true", "false", "nil", "self", "super"]
1765:         highlightKeywords(attributed, keywords: constants, color: UIColor(theme.variable), text: text)
1766:         
1767:         // Comments MUST come late (green) - they override everything
1768:         highlightComments(attributed, text: text, singleLine: "//", multiLineStart: "/*", multiLineEnd: "*/")
1769:         
1770:         // Strings AFTER comments (orange)
1771:         highlightStrings(attributed, text: text)
1772:         
1773:         // Numbers (light green)
1774:         highlightNumbers(attributed, text: text)
1775:     }
1776:     
1777:     // MARK: - JavaScript/TypeScript Highlighting
1778:     
1779:     private func highlightJavaScript(_ attributed: NSMutableAttributedString, text: String, isTS: Bool) {
1780:         var keywords = ["function", "var", "let", "const", "if", "else", "for", "while",
1781:                        "return", "class", "extends", "new", "this", "super", "import",
1782:                        "export", "default", "from", "as", "async", "await", "yield",
1783:                        "try", "catch", "finally", "throw", "typeof", "instanceof",
1784:                        "switch", "case", "break", "continue", "do", "in", "of",
1785:                        "get", "set", "static", "constructor", "delete", "void",
1786:                        "with", "debugger"]
1787:         
1788:         if isTS {
1789:             keywords += ["interface", "type", "enum", "namespace", "module", "declare",
1790:                         "implements", "public", "private", "protected", "readonly",
1791:                         "abstract", "override", "keyof", "infer", "never", "unknown",
1792:                         "any", "asserts", "is"]
1793:         }
1794:         
1795:         highlightKeywords(attributed, keywords: keywords, color: UIColor(theme.keyword), text: text)
1796:         
1797:         // Constants
1798:         let constants = ["true", "false", "null", "undefined", "NaN", "Infinity"]
1799:         highlightKeywords(attributed, keywords: constants, color: UIColor(theme.variable), text: text)
1800:         
1801:         // Function names (yellow) - regular calls + arrow functions
1802:         let funcNamePattern = "\\b([a-zA-Z_$][a-zA-Z0-9_$]*)\\b(?=\\s*(?:\\(|=>))"
1803:         highlightPattern(attributed, pattern: funcNamePattern, color: UIColor(theme.function), text: text, captureGroup: 1)
1804:         
1805:         // Types (teal)
1806:         let typePattern = "\\b[A-Z][a-zA-Z0-9]*\\b"
1807:         highlightPattern(attributed, pattern: typePattern, color: UIColor(theme.type), text: text)
1808:         
1809:         highlightComments(attributed, text: text, singleLine: "//", multiLineStart: "/*", multiLineEnd: "*/")
1810:         highlightStrings(attributed, text: text)
1811:         highlightJSTemplateLiterals(attributed, text: text)
1812:         highlightNumbers(attributed, text: text)
1813:     }
1814:     
1815:     // MARK: - Python Highlighting
1816:     
1817:     private func highlightPython(_ attributed: NSMutableAttributedString, text: String) {
1818:         let keywords = ["def", "class", "if", "elif", "else", "for", "while", "return",
1819:                        "import", "from", "as", "try", "except", "finally", "raise",
1820:                        "with", "assert", "yield", "lambda", "pass", "break", "continue",
1821:                        "global", "nonlocal", "del", "in", "not", "and", "or", "is",
1822:                        "async", "await", "match", "case"]
1823:         highlightKeywords(attributed, keywords: keywords, color: UIColor(theme.keyword), text: text)
1824:         
1825:         let constants = ["True", "False", "None", "self", "cls"]
1826:         highlightKeywords(attributed, keywords: constants, color: UIColor(theme.variable), text: text)
1827:         
1828:         // Decorators (yellow)
1829:         let decoratorPattern = "@[a-zA-Z_][a-zA-Z0-9_\\.]*"
1830:         highlightPattern(attributed, pattern: decoratorPattern, color: UIColor(theme.function), text: text)
1831:         
1832:         // Function definitions (yellow)
1833:         let funcDefPattern = "(?<=def\\s)[a-zA-Z_][a-zA-Z0-9_]*"
1834:         highlightPattern(attributed, pattern: funcDefPattern, color: UIColor(theme.function), text: text)
1835:         
1836:         // Class names (teal)
1837:         let classPattern = "(?<=class\\s)[a-zA-Z_][a-zA-Z0-9_]*"
1838:         highlightPattern(attributed, pattern: classPattern, color: UIColor(theme.type), text: text)
1839:         
1840:         // Built-in functions (yellow)
1841:         let builtins = ["print", "len", "range", "str", "int", "float", "list", "dict", "set",
1842:                        "tuple", "bool", "type", "isinstance", "hasattr", "getattr", "setattr",
1843:                        "open", "input", "map", "filter", "reduce", "zip", "enumerate",
1844:                        "sorted", "reversed", "min", "max", "sum", "abs", "round",
1845:                        "super", "object", "Exception", "ValueError", "TypeError"]
1846:         highlightKeywords(attributed, keywords: builtins, color: UIColor(theme.function), text: text)
1847:         
1848:         highlightComments(attributed, text: text, singleLine: "#", multiLineStart: nil, multiLineEnd: nil)
1849:         highlightPythonStrings(attributed, text: text)
1850:         highlightNumbers(attributed, text: text)
1851:     }
1852:     
1853:     // MARK: - HTML Highlighting
1854:     
1855:     private func highlightHTML(_ attributed: NSMutableAttributedString, text: String) {
1856:         // Tags (blue)
1857:         let tagPattern = "</?\\s*([a-zA-Z][a-zA-Z0-9-]*)(?=[\\s>])"
1858:         highlightPattern(attributed, pattern: tagPattern, color: UIColor(theme.keyword), text: text)
1859:         
1860:         // Attributes (light blue)
1861:         let attrPattern = "\\s([a-zA-Z][a-zA-Z0-9-]*)\\s*="
1862:         highlightPattern(attributed, pattern: attrPattern, color: UIColor(theme.variable), text: text, captureGroup: 1)
1863:         
1864:         // Angle brackets
1865:         let bracketPattern = "[<>/?]"
1866:         highlightPattern(attributed, pattern: bracketPattern, color: UIColor.gray, text: text)
1867:         
1868:         // Comments
1869:         highlightHTMLComments(attributed, text: text)
1870:         
1871:         // Strings
1872:         highlightStrings(attributed, text: text)
1873:     }
1874:     
1875:     // MARK: - CSS Highlighting
1876:     
1877:     private func highlightCSS(_ attributed: NSMutableAttributedString, text: String) {
1878:         // Selectors (yellow)
1879:         let selectorPattern = "([.#]?[a-zA-Z][a-zA-Z0-9_-]*)\\s*\\{"
1880:         highlightPattern(attributed, pattern: selectorPattern, color: UIColor(theme.function), text: text, captureGroup: 1)
1881:         
1882:         // Properties (light blue)
1883:         let propertyPattern = "([a-zA-Z-]+)\\s*:"
1884:         highlightPattern(attributed, pattern: propertyPattern, color: UIColor(theme.variable), text: text, captureGroup: 1)
1885:         
1886:         // Values with units
1887:         let unitPattern = "\\b(\\d+)(px|em|rem|%|vh|vw|pt|cm|mm|in)\\b"
1888:         highlightPattern(attributed, pattern: unitPattern, color: UIColor(theme.number), text: text)
1889:         
1890:         // Colors
1891:         let hexPattern = "#[0-9a-fA-F]{3,8}\\b"
1892:         highlightPattern(attributed, pattern: hexPattern, color: UIColor(theme.number), text: text)
1893:         
1894:         // Keywords
1895:         let keywords = ["important", "inherit", "initial", "unset", "none", "auto",
1896:                        "block", "inline", "flex", "grid", "absolute", "relative", "fixed"]
1897:         highlightKeywords(attributed, keywords: keywords, color: UIColor(theme.keyword), text: text)
1898:         
1899:         highlightComments(attributed, text: text, singleLine: nil, multiLineStart: "/*", multiLineEnd: "*/")
1900:         highlightStrings(attributed, text: text)


>>>TOOL read_file
{"path": "VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift", "start_line": 1900, "end_line": 2100}
>>>END

---

## ðŸ”§ TOOL RESULTS

[read_file]
File: VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift (lines 1901-2100 of 2289)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1901:         highlightNumbers(attributed, text: text)
1902:     }
1903:     
1904:     // MARK: - JSON Highlighting
1905:     
1906:     private func highlightJSON(_ attributed: NSMutableAttributedString, text: String) {
1907:         // Keys (light blue)
1908:         let keyPattern = "\"([^\"]+)\"\\s*:"
1909:         highlightPattern(attributed, pattern: keyPattern, color: UIColor(theme.variable), text: text, captureGroup: 1)
1910:         
1911:         // String values (orange)
1912:         highlightStrings(attributed, text: text)
1913:         
1914:         // Numbers (light green)
1915:         highlightNumbers(attributed, text: text)
1916:         
1917:         // Booleans and null (use keyword color)
1918:         let constants = ["true", "false", "null"]
1919:         highlightKeywords(attributed, keywords: constants, color: UIColor(theme.keyword), text: text)
1920:     }
1921:     
1922:     // MARK: - Markdown Highlighting
1923:     
1924:     private func highlightMarkdown(_ attributed: NSMutableAttributedString, text: String) {
1925:         // Headers (blue + bold)
1926:         let headerPattern = "^#{1,6}\\s+.+$"
1927:         highlightPattern(attributed, pattern: headerPattern, color: UIColor(theme.keyword), text: text, options: .anchorsMatchLines)
1928:         
1929:         // Bold (orange)
1930:         let boldPattern = "\\*\\*[^*]+\\*\\*|__[^_]+__"
1931:         highlightPattern(attributed, pattern: boldPattern, color: UIColor(theme.string), text: text)
1932:         
1933:         // Italic
1934:         let italicPattern = "(?<!\\*)\\*[^*]+\\*(?!\\*)|(?<!_)_[^_]+_(?!_)"
1935:         highlightPattern(attributed, pattern: italicPattern, color: UIColor.secondaryLabel, text: text)
1936:         
1937:         // Code blocks (green)
1938:         let codeBlockPattern = "```[\\s\\S]*?```|`[^`]+`"
1939:         highlightPattern(attributed, pattern: codeBlockPattern, color: UIColor(theme.comment), text: text)
1940:         
1941:         // Links (light blue)
1942:         let linkPattern = "\\[[^\\]]+\\]\\([^)]+\\)"
1943:         highlightPattern(attributed, pattern: linkPattern, color: UIColor(theme.variable), text: text)
1944:         
1945:         // Lists
1946:         let listPattern = "^\\s*[-*+]\\s"
1947:         highlightPattern(attributed, pattern: listPattern, color: UIColor(theme.keyword), text: text, options: .anchorsMatchLines)
1948:     }
1949:     
1950:     // MARK: - Rust Highlighting
1951:     
1952:     private func highlightRust(_ attributed: NSMutableAttributedString, text: String) {
1953:         let keywords = ["fn", "let", "mut", "const", "if", "else", "match", "loop", "while", "for",
1954:                        "return", "struct", "enum", "impl", "trait", "type", "use", "mod", "pub",
1955:                        "self", "Self", "super", "crate", "as", "in", "ref", "move", "async", "await",
1956:                        "where", "unsafe", "extern", "dyn", "static", "break", "continue"]
1957:         highlightKeywords(attributed, keywords: keywords, color: UIColor(theme.keyword), text: text)
1958:         
1959:         let types = ["i8", "i16", "i32", "i64", "i128", "isize", "u8", "u16", "u32", "u64", "u128", "usize",
1960:                     "f32", "f64", "bool", "char", "str", "String", "Vec", "Option", "Result", "Box"]
1961:         highlightKeywords(attributed, keywords: types, color: UIColor(theme.type), text: text)
1962:         
1963:         let constants = ["true", "false", "None", "Some", "Ok", "Err"]
1964:         highlightKeywords(attributed, keywords: constants, color: UIColor(theme.variable), text: text)
1965:         
1966:         // Macros (yellow)
1967:         let macroPattern = "[a-zA-Z_][a-zA-Z0-9_]*!"
1968:         highlightPattern(attributed, pattern: macroPattern, color: UIColor(theme.function), text: text)
1969:         
1970:         // Lifetimes (orange)
1971:         let lifetimePattern = "'[a-zA-Z_][a-zA-Z0-9_]*"
1972:         highlightPattern(attributed, pattern: lifetimePattern, color: UIColor(theme.string), text: text)
1973:         
1974:         highlightComments(attributed, text: text, singleLine: "//", multiLineStart: "/*", multiLineEnd: "*/")
1975:         highlightStrings(attributed, text: text)
1976:         highlightNumbers(attributed, text: text)
1977:     }
1978:     
1979:     // MARK: - Go Highlighting
1980:     
1981:     private func highlightGo(_ attributed: NSMutableAttributedString, text: String) {
1982:         let keywords = ["func", "var", "const", "type", "struct", "interface", "map", "chan",
1983:                        "if", "else", "for", "range", "switch", "case", "default", "select",
1984:                        "return", "break", "continue", "goto", "fallthrough", "defer", "go",
1985:                        "package", "import"]
1986:         highlightKeywords(attributed, keywords: keywords, color: UIColor(theme.keyword), text: text)
1987:         
1988:         let types = ["int", "int8", "int16", "int32", "int64", "uint", "uint8", "uint16", "uint32", "uint64",
1989:                     "float32", "float64", "complex64", "complex128", "byte", "rune", "string", "bool", "error"]
1990:         highlightKeywords(attributed, keywords: types, color: UIColor(theme.type), text: text)
1991:         
1992:         let constants = ["true", "false", "nil", "iota"]
1993:         highlightKeywords(attributed, keywords: constants, color: UIColor(theme.variable), text: text)
1994:         
1995:         highlightComments(attributed, text: text, singleLine: "//", multiLineStart: "/*", multiLineEnd: "*/")
1996:         highlightStrings(attributed, text: text)
1997:         highlightNumbers(attributed, text: text)
1998:     }
1999:     
2000:     // MARK: - Java Highlighting
2001:     
2002:     private func highlightJava(_ attributed: NSMutableAttributedString, text: String) {
2003:         let keywords = ["public", "private", "protected", "class", "interface", "extends", "implements",
2004:                        "static", "final", "abstract", "native", "synchronized", "volatile", "transient",
2005:                        "if", "else", "for", "while", "do", "switch", "case", "default", "break", "continue",
2006:                        "return", "throw", "throws", "try", "catch", "finally", "new", "this", "super",
2007:                        "import", "package", "instanceof", "assert", "enum", "void"]
2008:         highlightKeywords(attributed, keywords: keywords, color: UIColor(theme.keyword), text: text)
2009:         
2010:         let types = ["int", "long", "short", "byte", "float", "double", "char", "boolean",
2011:                     "String", "Integer", "Long", "Double", "Boolean", "Object", "List", "Map", "Set"]
2012:         highlightKeywords(attributed, keywords: types, color: UIColor(theme.type), text: text)
2013:         
2014:         let constants = ["true", "false", "null"]
2015:         highlightKeywords(attributed, keywords: constants, color: UIColor(theme.variable), text: text)
2016:         
2017:         // Annotations
2018:         let annotationPattern = "@[a-zA-Z][a-zA-Z0-9]*"
2019:         highlightPattern(attributed, pattern: annotationPattern, color: UIColor(theme.function), text: text)
2020:         
2021:         highlightComments(attributed, text: text, singleLine: "//", multiLineStart: "/*", multiLineEnd: "*/")
2022:         highlightStrings(attributed, text: text)
2023:         highlightNumbers(attributed, text: text)
2024:     }
2025:     
2026:     // MARK: - C/C++ Highlighting
2027:     
2028:     private func highlightCpp(_ attributed: NSMutableAttributedString, text: String) {
2029:         let keywords = ["auto", "break", "case", "catch", "class", "const", "continue", "default",
2030:                        "delete", "do", "else", "enum", "explicit", "extern", "for", "friend", "goto",
2031:                        "if", "inline", "mutable", "namespace", "new", "operator", "private", "protected",
2032:                        "public", "register", "return", "sizeof", "static", "struct", "switch", "template",
2033:                        "this", "throw", "try", "typedef", "typename", "union", "using", "virtual",
2034:                        "volatile", "while", "constexpr", "nullptr", "override", "final", "noexcept"]
2035:         highlightKeywords(attributed, keywords: keywords, color: UIColor(theme.keyword), text: text)
2036:         
2037:         let types = ["void", "int", "long", "short", "char", "float", "double", "bool", "signed", "unsigned",
2038:                     "int8_t", "int16_t", "int32_t", "int64_t", "uint8_t", "uint16_t", "uint32_t", "uint64_t",
2039:                     "size_t", "string", "vector", "map", "set", "unique_ptr", "shared_ptr"]
2040:         highlightKeywords(attributed, keywords: types, color: UIColor(theme.type), text: text)
2041:         
2042:         let constants = ["true", "false", "NULL", "nullptr"]
2043:         highlightKeywords(attributed, keywords: constants, color: UIColor(theme.variable), text: text)
2044:         
2045:         // Preprocessor directives
2046:         let preprocPattern = "^\\s*#\\s*(include|define|ifdef|ifndef|endif|if|else|elif|pragma|error|warning).*$"
2047:         highlightPattern(attributed, pattern: preprocPattern, color: UIColor(theme.keyword), text: text, options: .anchorsMatchLines)
2048:         
2049:         highlightComments(attributed, text: text, singleLine: "//", multiLineStart: "/*", multiLineEnd: "*/")
2050:         highlightStrings(attributed, text: text)
2051:         highlightNumbers(attributed, text: text)
2052:     }
2053:     
2054:     // MARK: - Ruby Highlighting
2055:     
2056:     private func highlightRuby(_ attributed: NSMutableAttributedString, text: String) {
2057:         let keywords = ["def", "class", "module", "if", "elsif", "else", "unless", "case", "when",
2058:                        "while", "until", "for", "do", "end", "begin", "rescue", "ensure", "raise",
2059:                        "return", "yield", "break", "next", "redo", "retry", "self", "super",
2060:                        "require", "require_relative", "include", "extend", "attr_reader", "attr_writer", "attr_accessor",
2061:                        "public", "private", "protected", "alias", "and", "or", "not", "in"]
2062:         highlightKeywords(attributed, keywords: keywords, color: UIColor(theme.keyword), text: text)
2063:         
2064:         let constants = ["true", "false", "nil"]
2065:         highlightKeywords(attributed, keywords: constants, color: UIColor(theme.variable), text: text)
2066:         
2067:         // Symbols (orange)
2068:         let symbolPattern = ":[a-zA-Z_][a-zA-Z0-9_]*"
2069:         highlightPattern(attributed, pattern: symbolPattern, color: UIColor(theme.string), text: text)
2070:         
2071:         // Instance variables (light blue)
2072:         let ivarPattern = "@[a-zA-Z_][a-zA-Z0-9_]*"
2073:         highlightPattern(attributed, pattern: ivarPattern, color: UIColor(theme.variable), text: text)
2074:         
2075:         highlightComments(attributed, text: text, singleLine: "#", multiLineStart: "=begin", multiLineEnd: "=end")
2076:         highlightStrings(attributed, text: text)
2077:         highlightNumbers(attributed, text: text)
2078:     }
2079:     
2080:     // MARK: - PHP Highlighting
2081:     
2082:     private func highlightPHP(_ attributed: NSMutableAttributedString, text: String) {
2083:         let keywords = ["function", "class", "interface", "trait", "extends", "implements", "use",
2084:                        "public", "private", "protected", "static", "final", "abstract", "const",
2085:                        "if", "else", "elseif", "switch", "case", "default", "for", "foreach", "while", "do",
2086:                        "return", "break", "continue", "throw", "try", "catch", "finally",
2087:                        "new", "clone", "instanceof", "echo", "print", "die", "exit",
2088:                        "require", "require_once", "include", "include_once", "namespace"]
2089:         highlightKeywords(attributed, keywords: keywords, color: UIColor(theme.keyword), text: text)
2090:         
2091:         let constants = ["true", "false", "null", "TRUE", "FALSE", "NULL"]
2092:         highlightKeywords(attributed, keywords: constants, color: UIColor(theme.variable), text: text)
2093:         
2094:         // Variables (light blue)
2095:         let varPattern = "\\$[a-zA-Z_][a-zA-Z0-9_]*"
2096:         highlightPattern(attributed, pattern: varPattern, color: UIColor(theme.variable), text: text)
2097:         
2098:         highlightComments(attributed, text: text, singleLine: "//", multiLineStart: "/*", multiLineEnd: "*/")
2099:         highlightStrings(attributed, text: text)
2100:         highlightNumbers(attributed, text: text)


>>>TOOL read_file
{"path": "VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift", "start_line": 2100, "end_line": 2289}
>>>END

---

## ðŸ”§ TOOL RESULTS

[read_file]
File: VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift (lines 2101-2289 of 2289)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
2101:     }
2102:     
2103:     // MARK: - Shell Highlighting
2104:     
2105:     private func highlightShell(_ attributed: NSMutableAttributedString, text: String) {
2106:         let keywords = ["if", "then", "else", "elif", "fi", "for", "while", "do", "done", "case", "esac",
2107:                        "function", "return", "exit", "break", "continue", "local", "export", "readonly",
2108:                        "source", "alias", "unalias", "set", "unset", "shift", "eval", "exec",
2109:                        "echo", "printf", "read", "cd", "pwd", "ls", "mkdir", "rm", "cp", "mv"]
2110:         highlightKeywords(attributed, keywords: keywords, color: UIColor(theme.keyword), text: text)
2111:         
2112:         // Variables (light blue)
2113:         let varPattern = "\\$[a-zA-Z_][a-zA-Z0-9_]*|\\$\\{[^}]+\\}"
2114:         highlightPattern(attributed, pattern: varPattern, color: UIColor(theme.variable), text: text)
2115:         
2116:         highlightComments(attributed, text: text, singleLine: "#", multiLineStart: nil, multiLineEnd: nil)
2117:         highlightStrings(attributed, text: text)
2118:         highlightNumbers(attributed, text: text)
2119:     }
2120:     
2121:     // MARK: - YAML Highlighting
2122:     
2123:     private func highlightYAML(_ attributed: NSMutableAttributedString, text: String) {
2124:         // Keys (light blue)
2125:         let keyPattern = "^\\s*([a-zA-Z_][a-zA-Z0-9_-]*)\\s*:"
2126:         highlightPattern(attributed, pattern: keyPattern, color: UIColor(theme.variable), text: text, options: .anchorsMatchLines, captureGroup: 1)
2127:         
2128:         // Booleans and null
2129:         let constants = ["true", "false", "yes", "no", "on", "off", "null", "~"]
2130:         highlightKeywords(attributed, keywords: constants, color: UIColor(theme.variable), text: text)
2131:         
2132:         highlightComments(attributed, text: text, singleLine: "#", multiLineStart: nil, multiLineEnd: nil)
2133:         highlightStrings(attributed, text: text)
2134:         highlightNumbers(attributed, text: text)
2135:     }
2136:     
2137:     // MARK: - SQL Highlighting
2138:     
2139:     private func highlightSQL(_ attributed: NSMutableAttributedString, text: String) {
2140:         let keywords = ["SELECT", "FROM", "WHERE", "AND", "OR", "NOT", "IN", "LIKE", "BETWEEN",
2141:                        "INSERT", "INTO", "VALUES", "UPDATE", "SET", "DELETE", "CREATE", "ALTER", "DROP",
2142:                        "TABLE", "INDEX", "VIEW", "DATABASE", "SCHEMA", "PRIMARY", "KEY", "FOREIGN", "REFERENCES",
2143:                        "JOIN", "INNER", "LEFT", "RIGHT", "OUTER", "FULL", "ON", "AS", "DISTINCT",
2144:                        "ORDER", "BY", "ASC", "DESC", "GROUP", "HAVING", "LIMIT", "OFFSET", "UNION",
2145:                        "NULL", "IS", "TRUE", "FALSE", "CASE", "WHEN", "THEN", "ELSE", "END",
2146:                        "COUNT", "SUM", "AVG", "MIN", "MAX", "COALESCE", "CAST",
2147:                        "select", "from", "where", "and", "or", "not", "in", "like", "between",
2148:                        "insert", "into", "values", "update", "set", "delete", "create", "alter", "drop",
2149:                        "table", "index", "view", "database", "schema", "primary", "key", "foreign", "references",
2150:                        "join", "inner", "left", "right", "outer", "full", "on", "as", "distinct",
2151:                        "order", "by", "asc", "desc", "group", "having", "limit", "offset", "union",
2152:                        "null", "is", "true", "false", "case", "when", "then", "else", "end"]
2153:         highlightKeywords(attributed, keywords: keywords, color: UIColor(theme.keyword), text: text)
2154:         
2155:         let types = ["INT", "INTEGER", "BIGINT", "SMALLINT", "TINYINT", "FLOAT", "DOUBLE", "DECIMAL",
2156:                     "VARCHAR", "CHAR", "TEXT", "BLOB", "DATE", "TIME", "DATETIME", "TIMESTAMP", "BOOLEAN",
2157:                     "int", "integer", "bigint", "smallint", "tinyint", "float", "double", "decimal",
2158:                     "varchar", "char", "text", "blob", "date", "time", "datetime", "timestamp", "boolean"]
2159:         highlightKeywords(attributed, keywords: types, color: UIColor(theme.type), text: text)
2160:         
2161:         highlightComments(attributed, text: text, singleLine: "--", multiLineStart: "/*", multiLineEnd: "*/")
2162:         highlightStrings(attributed, text: text)
2163:         highlightNumbers(attributed, text: text)
2164:     }
2165:     
2166:     // MARK: - GraphQL Highlighting
2167:     
2168:     private func highlightGraphQL(_ attributed: NSMutableAttributedString, text: String) {
2169:         // Keywords
2170:         let keywords = ["query", "mutation", "subscription", "fragment", "on", "type", 
2171:                        "interface", "union", "enum", "scalar", "input", "extend", 
2172:                        "directive", "schema", "implements"]
2173:         highlightKeywords(attributed, keywords: keywords, color: UIColor(theme.keyword), text: text)
2174:         
2175:         // Built-in scalar types
2176:         let types = ["Int", "Float", "String", "Boolean", "ID"]
2177:         highlightKeywords(attributed, keywords: types, color: UIColor(theme.type), text: text)
2178:         
2179:         // Variables ($name)
2180:         let variablePattern = "\\$[a-zA-Z_][a-zA-Z0-9_]*"
2181:         highlightPattern(attributed, pattern: variablePattern, color: UIColor(theme.variable), text: text)
2182:         
2183:         // Directives (@deprecated, @skip, @include, etc.)
2184:         let directivePattern = "@[a-zA-Z_][a-zA-Z0-9_]*"
2185:         highlightPattern(attributed, pattern: directivePattern, color: UIColor(theme.function), text: text)
2186:         
2187:         // Comments (# single line)
2188:         highlightComments(attributed, text: text, singleLine: "#", multiLineStart: nil, multiLineEnd: nil)
2189:         
2190:         // Strings
2191:         highlightStrings(attributed, text: text)
2192:         
2193:         // Numbers
2194:         highlightNumbers(attributed, text: text)
2195:     }
2196:     
2197:     // MARK: - Helper Methods
2198:     
2199:     private func highlightKeywords(_ attributed: NSMutableAttributedString, keywords: [String], color: UIColor, text: String) {
2200:         for keyword in keywords {
2201:             let pattern = "\\b\(NSRegularExpression.escapedPattern(for: keyword))\\b"
2202:             highlightPattern(attributed, pattern: pattern, color: color, text: text)
2203:         }
2204:     }
2205:     
2206:     private func highlightPattern(_ attributed: NSMutableAttributedString, pattern: String, color: UIColor, text: String, options: NSRegularExpression.Options = [], captureGroup: Int = 0) {
2207:         guard let regex = try? NSRegularExpression(pattern: pattern, options: options) else { return }
2208:         let range = NSRange(location: 0, length: text.utf16.count)
2209:         
2210:         regex.enumerateMatches(in: text, options: [], range: range) { match, _, _ in
2211:             guard let match = match else { return }
2212:             let matchRange = captureGroup > 0 && match.numberOfRanges > captureGroup
2213:                 ? match.range(at: captureGroup)
2214:                 : match.range
2215:             if matchRange.location != NSNotFound {
2216:                 attributed.addAttribute(.foregroundColor, value: color, range: matchRange)
2217:             }
2218:         }
2219:     }
2220:     
2221:     private func highlightStrings(_ attributed: NSMutableAttributedString, text: String) {
2222:         // Double-quoted strings
2223:         let doublePattern = "\"(?:[^\"\\\\]|\\\\.)*\""
2224:         highlightPattern(attributed, pattern: doublePattern, color: UIColor(theme.string), text: text)
2225:         
2226:         // Single-quoted strings
2227:         let singlePattern = "'(?:[^'\\\\]|\\\\.)*'"
2228:         highlightPattern(attributed, pattern: singlePattern, color: UIColor(theme.string), text: text)
2229:     }
2230:     
2231:     private func highlightPythonStrings(_ attributed: NSMutableAttributedString, text: String) {
2232:         // Triple-quoted strings first
2233:         let tripleDoublePattern = "\"\"\"[\\s\\S]*?\"\"\""
2234:         highlightPattern(attributed, pattern: tripleDoublePattern, color: UIColor(theme.string), text: text)
2235:         
2236:         let tripleSinglePattern = "'''[\\s\\S]*?'''"
2237:         highlightPattern(attributed, pattern: tripleSinglePattern, color: UIColor(theme.string), text: text)
2238:         
2239:         // Then regular strings
2240:         highlightStrings(attributed, text: text)
2241:         
2242:         // F-strings (with expressions highlighted differently)
2243:         let fstringPattern = "f\"[^\"]*\"|f'[^']*'"
2244:         highlightPattern(attributed, pattern: fstringPattern, color: UIColor(theme.string), text: text)
2245:     }
2246:     
2247:     private func highlightJSTemplateLiterals(_ attributed: NSMutableAttributedString, text: String) {
2248:         // Template literals
2249:         let templatePattern = "`[^`]*`"
2250:         highlightPattern(attributed, pattern: templatePattern, color: UIColor(theme.string), text: text)
2251:     }
2252:     
2253:     private func highlightComments(_ attributed: NSMutableAttributedString, text: String, singleLine: String?, multiLineStart: String?, multiLineEnd: String?) {
2254:         // Single-line comments
2255:         if let single = singleLine {
2256:             let pattern = "\(NSRegularExpression.escapedPattern(for: single)).*$"
2257:             highlightPattern(attributed, pattern: pattern, color: UIColor(theme.comment), text: text, options: .anchorsMatchLines)
2258:         }
2259:         
2260:         // Multi-line comments
2261:         if let start = multiLineStart, let end = multiLineEnd {
2262:             let pattern = "\(NSRegularExpression.escapedPattern(for: start))[\\s\\S]*?\(NSRegularExpression.escapedPattern(for: end))"
2263:             highlightPattern(attributed, pattern: pattern, color: UIColor(theme.comment), text: text)
2264:         }
2265:     }
2266:     
2267:     private func highlightHTMLComments(_ attributed: NSMutableAttributedString, text: String) {
2268:         let pattern = "<!--[\\s\\S]*?-->"
2269:         highlightPattern(attributed, pattern: pattern, color: UIColor(theme.comment), text: text)
2270:     }
2271:     
2272:     private func highlightNumbers(_ attributed: NSMutableAttributedString, text: String) {
2273:         // Hex numbers
2274:         let hexPattern = "\\b0[xX][0-9a-fA-F]+\\b"
2275:         highlightPattern(attributed, pattern: hexPattern, color: UIColor(theme.number), text: text)
2276:         
2277:         // Binary numbers
2278:         let binPattern = "\\b0[bB][01]+\\b"
2279:         highlightPattern(attributed, pattern: binPattern, color: UIColor(theme.number), text: text)
2280:         
2281:         // Octal numbers
2282:         let octPattern = "\\b0[oO][0-7]+\\b"
2283:         highlightPattern(attributed, pattern: octPattern, color: UIColor(theme.number), text: text)
2284:         
2285:         // Decimal numbers (including floats and scientific notation)
2286:         let decPattern = "\\b\\d+\\.?\\d*([eE][+-]?\\d+)?\\b"
2287:         highlightPattern(attributed, pattern: decPattern, color: UIColor(theme.number), text: text)
2288:     }
2289: }


Now let me search for any use of beginEditing/endEditing and check how textStorage is accessed:

>>>TOOL search
{"query": "beginEditing", "glob": "**/*.swift"}
>>>END

---

## ðŸ”§ TOOL RESULTS

[search]
No matches found for "beginEditing"


>>>TOOL search
{"query": "textStorage", "glob": "**/*.swift"}
>>>END

---

## ðŸ”§ TOOL RESULTS

[search]
Found 12 matches:
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:116: let textStorage = NSTextStorage()
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:118: textStorage.addLayoutManager(foldingLayoutManager)
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:880: let textStorage = textView.textStorage
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:881: textStorage.replaceCharacters(in: nsRange, with: newLineText)
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:931: textView.textStorage.removeAttribute(.backgroundColor, range: r)
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:932: textView.textStorage.removeAttribute(.underlineStyle, range: r)
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:1023: textView.textStorage.addAttribute(.backgroundColor, value: bg, range: r1)
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:1024: textView.textStorage.addAttribute(.backgroundColor, value: bg, range: r2)
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:1026: textView.textStorage.addAttribute(.underlineStyle, value: NSUnderlineStyle.single.rawValue, range: r1)
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:1027: textView.textStorage.addAttribute(.underlineStyle, value: NSUnderlineStyle.single.rawValue, range: r2)
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:1069: let full = (self.textStorage?.string ?? "") as NSString
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/FoldingLayoutManager.swift:38: let full = (self.textStorage?.string ?? "") as NSString


Now let me check the MultiCursorTextView to see if there are additional textStorage operations:

>>>TOOL search
{"query": "class MultiCursorTextView", "glob": "**/*.swift"}
>>>END

---

## ðŸ”§ TOOL RESULTS

[search]
Found 1 matches:
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/MultiCursorTextView.swift:11: class MultiCursorTextView: UITextView {


>>>TOOL read_file
{"path": "VSCodeiPadOS/Views/Editor/MultiCursorTextView.swift"}
>>>END

---

## ðŸ”§ TOOL RESULTS

[read_file]
File: VSCodeiPadOS/VSCodeiPadOS/Views/Editor/MultiCursorTextView.swift (lines 1-274 of 274)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1: //  MultiCursorTextView.swift
2: //  VSCodeiPadOS
3: //
4: //  Custom UITextView subclass that supports multiple cursor display
5: //
6: 
7: import UIKit
8: import SwiftUI
9: 
10: /// Custom UITextView that displays multiple cursors
11: class MultiCursorTextView: UITextView {
12: 
13:     /// Reference to the editor core for multi-cursor state
14:     weak var editorCore: EditorCore?
15: 
16:     /// Autocomplete key handling hooks (return true if handled)
17:     var onAcceptAutocomplete: (() -> Bool)?
18:     var onDismissAutocomplete: (() -> Bool)?
19: 
20:     /// Layer for drawing additional cursors
21:     private var cursorLayers: [CALayer] = []
22: 
23:     /// Layer for drawing selection highlights for additional cursors
24:     private var selectionLayers: [CALayer] = []
25: 
26:     /// Timer for cursor blink animation
27:     private var blinkTimer: Timer?
28:     private var cursorVisible = true
29:     
30:     /// PERF: Throttle cursor display updates during scroll
31:     private var lastCursorUpdateTime: CFTimeInterval = 0
32:     private let cursorUpdateThrottleInterval: CFTimeInterval = 0.016  // ~60fps max
33: 
34:     /// Cursor appearance
35:     private let cursorWidth: CGFloat = 2
36:     private let cursorColor = UIColor.systemBlue
37:     private let secondaryCursorColor = UIColor.systemCyan
38:     private let selectionColor = UIColor.systemBlue.withAlphaComponent(0.3)
39:     private let secondarySelectionColor = UIColor.systemCyan.withAlphaComponent(0.25)
40: 
41:     override init(frame: CGRect, textContainer: NSTextContainer?) {
42:         super.init(frame: frame, textContainer: textContainer)
43:         setupCursorBlinking()
44:     }
45: 
46:     required init?(coder: NSCoder) {
47:         super.init(coder: coder)
48:         setupCursorBlinking()
49:     }
50: 
51:     deinit {
52:         blinkTimer?.invalidate()
53:     }
54: 
55:     private func setupCursorBlinking() {
56:         blinkTimer = Timer.scheduledTimer(withTimeInterval: 0.5, repeats: true) { [weak self] _ in
57:             self?.cursorVisible.toggle()
58:             self?.updateCursorVisibility()
59:         }
60:     }
61: 
62:     private func updateCursorVisibility() {
63:         let alpha: Float = cursorVisible ? 1.0 : 0.0
64:         cursorLayers.forEach { $0.opacity = alpha }
65:     }
66: 
67:     /// Updates the display of all cursors and selections
68:     func updateCursorDisplay() {
69:         // Remove existing cursor and selection layers
70:         cursorLayers.forEach { $0.removeFromSuperlayer() }
71:         cursorLayers.removeAll()
72:         selectionLayers.forEach { $0.removeFromSuperlayer() }
73:         selectionLayers.removeAll()
74: 
75:         guard let editorCore = editorCore else { return }
76:         let cursors = editorCore.multiCursorState.cursors
77: 
78:         // Only show additional cursors if we have multiple
79:         guard cursors.count > 1 else { return }
80: 
81:         // Draw each cursor (skip the primary one as UITextView handles it)
82:         for (index, cursor) in cursors.enumerated() {
83:             // Draw selection if present
84:             if let selectionRange = cursor.selectionRange {
85:                 drawSelection(for: selectionRange, isPrimary: cursor.isPrimary, index: index)
86:             }
87: 
88:             // Draw cursor line (skip primary cursor as system handles it)
89:             if !cursor.isPrimary {
90:                 drawCursor(at: cursor.position, isPrimary: false, index: index)
91:             }
92:         }
93:     }
94: 
95:     private func drawCursor(at position: Int, isPrimary: Bool, index: Int) {
96:         guard let textPosition = self.position(from: beginningOfDocument, offset: position) else { return }
97: 
98:         let caretRect = self.caretRect(for: textPosition)
99: 
100:         let cursorLayer = CALayer()
101:         cursorLayer.backgroundColor = (isPrimary ? cursorColor : secondaryCursorColor).cgColor
102:         cursorLayer.frame = CGRect(
103:             x: caretRect.origin.x,
104:             y: caretRect.origin.y,
105:             width: cursorWidth,
106:             height: caretRect.height
107:         )
108:         cursorLayer.cornerRadius = 1
109: 
110:         layer.addSublayer(cursorLayer)
111:         cursorLayers.append(cursorLayer)
112:     }
113: 
114:     private func drawSelection(for range: NSRange, isPrimary: Bool, index: Int) {
115:         guard let start = position(from: beginningOfDocument, offset: range.location),
116:               let end = position(from: beginningOfDocument, offset: range.location + range.length),
117:               let textRange = self.textRange(from: start, to: end) else { return }
118: 
119:         let selectionRects = selectionRects(for: textRange)
120: 
121:         for rect in selectionRects {
122:             let selectionLayer = CALayer()
123:             selectionLayer.backgroundColor = (isPrimary ? selectionColor : secondarySelectionColor).cgColor
124:             selectionLayer.frame = rect.rect
125: 
126:             // Insert behind text
127:             if let textLayer = layer.sublayers?.first {
128:                 layer.insertSublayer(selectionLayer, below: textLayer)
129:             } else {
130:                 layer.addSublayer(selectionLayer)
131:             }
132:             selectionLayers.append(selectionLayer)
133:         }
134:     }
135: 
136:     // MARK: - Text Input Handling for Multi-Cursor
137: 
138:     override func insertText(_ text: String) {
139:         guard let editorCore = editorCore,
140:               editorCore.multiCursorState.isMultiCursor else {
141:             super.insertText(text)
142:             return
143:         }
144: 
145:         // Handle multi-cursor insert
146:         var content = self.text ?? ""
147:         editorCore.multiCursorState.insertText(text, in: &content)
148: 
149:         // Update text view
150:         let cursorPosition = editorCore.multiCursorState.primaryCursor?.position ?? 0
151:         self.text = content
152: 
153:         // Position the main cursor
154:         if let newPosition = position(from: beginningOfDocument, offset: cursorPosition) {
155:             selectedTextRange = textRange(from: newPosition, to: newPosition)
156:         }
157: 
158:         // Trigger text change notification
159:         delegate?.textViewDidChange?(self)
160: 
161:         updateCursorDisplay()
162:     }
163: 
164:     override func deleteBackward() {
165:         guard let editorCore = editorCore,
166:               editorCore.multiCursorState.isMultiCursor else {
167:             super.deleteBackward()
168:             return
169:         }
170: 
171:         // Handle multi-cursor delete
172:         var content = self.text ?? ""
173:         editorCore.multiCursorState.deleteBackward(in: &content)
174: 
175:         // Update text view
176:         let cursorPosition = editorCore.multiCursorState.primaryCursor?.position ?? 0
177:         self.text = content
178: 
179:         // Position the main cursor
180:         if let newPosition = position(from: beginningOfDocument, offset: cursorPosition) {
181:             selectedTextRange = textRange(from: newPosition, to: newPosition)
182:         }
183: 
184:         // Trigger text change notification
185:         delegate?.textViewDidChange?(self)
186: 
187:         updateCursorDisplay()
188:     }
189: 
190:     // MARK: - Layout Updates
191: 
192:     override func layoutSubviews() {
193:         super.layoutSubviews()
194:         // Refresh cursor positions when layout changes
195:         updateCursorDisplay()
196:     }
197: 
198:     override var contentOffset: CGPoint {
199:         didSet {
200:             // PERF: Throttle cursor updates during scrolling to avoid recreating layers every pixel
201:             let now = CACurrentMediaTime()
202:             if now - lastCursorUpdateTime >= cursorUpdateThrottleInterval {
203:                 lastCursorUpdateTime = now
204:                 updateCursorDisplay()
205:             }
206:         }
207:     }
208: }
209: 
210: // MARK: - Key Commands for Multi-Cursor + Autocomplete
211: // NOTE: App-level shortcuts are defined in Menus/ folder only.
212: // See: KEYBOARD_SHORTCUTS_SOURCE_OF_TRUTH.md
213: // DO NOT define Cmd+D, Cmd+Shift+L, Cmd+G here - they are in SelectionMenuCommands/GoMenuCommands
214: 
215: extension MultiCursorTextView {
216: 
217:     override var keyCommands: [UIKeyCommand]? {
218:         var commands = super.keyCommands ?? []
219: 
220:         // Tab: accept autocomplete (if showing), else insert tab
221:         // This is editor-specific and NOT a menu command
222:         commands.append(UIKeyCommand(
223:             title: "Accept Suggestion",
224:             action: #selector(tabAcceptAutocomplete),
225:             input: "\t",
226:             modifierFlags: []
227:         ))
228: 
229:         // NOTE: Cmd+D (Add Next Occurrence) is in SelectionMenuCommands.swift
230:         // NOTE: Cmd+Shift+L (Select All Occurrences) is in SelectionMenuCommands.swift
231:         // NOTE: Cmd+G (Go to Line) is in GoMenuCommands.swift
232: 
233:         // Escape: Dismiss autocomplete if visible, else exit multi-cursor mode
234:         // This is editor-specific and NOT a menu command
235:         commands.append(UIKeyCommand(
236:             title: "Escape",
237:             action: #selector(escapeKeyPressed),
238:             input: UIKeyCommand.inputEscape,
239:             modifierFlags: []
240:         ))
241: 
242:         return commands
243:     }
244: 
245:     @objc private func tabAcceptAutocomplete() {
246:         if onAcceptAutocomplete?() == true {
247:             return
248:         }
249:         insertText("\t")
250:     }
251: 
252:     @objc private func addNextOccurrence() {
253:         editorCore?.addNextOccurrence()
254:         updateCursorDisplay()
255:     }
256: 
257:     @objc private func selectAllOccurrences() {
258:         editorCore?.selectAllOccurrences()
259:         updateCursorDisplay()
260:     }
261: 
262:     @objc private func goToLine() {
263:         editorCore?.showGoToLine = true
264:     }
265: 
266:     @objc private func escapeKeyPressed() {
267:         if onDismissAutocomplete?() == true {
268:             return
269:         }
270:         editorCore?.escapeMultiCursor()
271:         updateCursorDisplay()
272:     }
273: }
274: 


Now let me look at how the highlighter applies attributes to understand the full picture:

>>>TOOL search
{"query": "addAttribute", "glob": "**/*.swift"}
>>>END

---

## ðŸ”§ TOOL RESULTS

[search]
Found 18 matches:
VSCodeiPadOS/VSCodeiPadOS/Services/ErrorParser.swift:823: attributedText.addAttribute(
VSCodeiPadOS/VSCodeiPadOS/Services/ErrorParser.swift:837: attributedText.addAttribute(
VSCodeiPadOS/VSCodeiPadOS/Services/ErrorParser.swift:842: attributedText.addAttribute(
VSCodeiPadOS/VSCodeiPadOS/Services/ErrorParser.swift:847: attributedText.addAttribute(
VSCodeiPadOS/VSCodeiPadOS/Services/ErrorParser.swift:857: attributedText.addAttribute(
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:537: fullAttributed.addAttribute(.font, value: baseFont, range: fullRange)
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:538: fullAttributed.addAttribute(.foregroundColor, value: baseColor, range: fullRange)
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:545: fullAttributed.addAttribute(key, value: value, range: targetRange)
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:1023: textView.textStorage.addAttribute(.backgroundColor, value: bg, range: r1)
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:1024: textView.textStorage.addAttribute(.backgroundColor, value: bg, range: r2)
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:1026: textView.textStorage.addAttribute(.underlineStyle, value: NSUnderlineStyle.single.rawValue, range: r1)
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:1027: textView.textStorage.addAttribute(.underlineStyle, value: NSUnderlineStyle.single.rawValue, range: r2)
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:1639: attributed.addAttribute(.font, value: baseFont, range: fullRange)
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:1640: attributed.addAttribute(.foregroundColor, value: UIColor(theme.editorForeground), range: fullRange)
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:1712: attributed.addAttribute(.foregroundColor, value: color, range: NSRange(location: index, length: 1))
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:1713: attributed.addAttribute(.foregroundColor, value: color, range: NSRange(location: last.index, length: 1))
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:1728: attributed.addAttribute(.foregroundColor, value: color, range: NSRange(location: index, length: 1))
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:2216: attributed.addAttribute(.foregroundColor, value: color, range: matchRange)


Now I have all the information needed to report the findings. Let me compile the complete analysis:

>>>REPORT
# NSTextStorage and Attributed String Performance Analysis

## Executive Summary
I found **7 critical bottlenecks** in `SyntaxHighlightingTextView.swift` related to NSTextStorage operations. The biggest issues are: full `attributedText` replacement instead of incremental updates, missing `beginEditing()`/`endEditing()` batching, and O(n) operations in the FoldingLayoutManager.

---

## BOTTLENECK 1: Full attributedText Replacement (CRITICAL)
**Lines: 778, 450, 550**

Every syntax highlighting operation completely replaces `attributedText`:
```swift
// Line 778 - applySyntaxHighlighting()
textView.attributedText = attributedText

// Line 450 - applyHighlightingAsync()
textView.attributedText = attributedText

// Line 550 - applyVisibleRangeHighlighting()
textView.attributedText = fullAttributed
```

**Impact:** Setting `attributedText` triggers:
1. Full layout invalidation
2. Complete TextKit re-rendering
3. All line fragments recalculated
4. Memory churn from creating new attributed strings

**FIX:**
```swift
// Replace line 778 with incremental update:
func applySyntaxHighlighting(to textView: UITextView) {
    guard !isApplyingHighlighting else { return }
    isApplyingHighlighting = true
    defer { isApplyingHighlighting = false }
    
    let theme = ThemeManager.shared.currentTheme
    lastThemeId = theme.id
    
    let text = textView.text ?? ""
    let selectedRange = textView.selectedRange
    let textStorage = textView.textStorage
    let fullRange = NSRange(location: 0, length: textStorage.length)
    
    // BATCH all attribute changes
    textStorage.beginEditing()
    
    // Reset to base attributes
    let baseFont = UIFont.monospacedSystemFont(ofSize: parent.editorCore.editorFontSize, weight: .regular)
    textStorage.addAttribute(.font, value: baseFont, range: fullRange)
    textStorage.addAttribute(.foregroundColor, value: UIColor(theme.editorForeground), range: fullRange)
    
    // Apply language-specific highlighting directly to textStorage
    let highlighter = VSCodeSyntaxHighlighter(theme: theme, fontSize: parent.editorCore.editorFontSize)
    highlighter.applyHighlighting(to: textStorage, text: text, filename: parent.filename)
    
    textStorage.endEditing()
    
    textView.selectedRange = selectedRange
    // ... rest of method
}
```

---

## BOTTLENECK 2: No beginEditing()/endEditing() Batching (CRITICAL)
**Confirmed: ZERO calls to beginEditing/endEditing in entire codebase**

**Impact:** Every `addAttribute()` call triggers a separate layout pass.

**Affected locations:**
- Bracket matching (lines 1023-1027): 4 separate attribute additions
- Bracket clearing (lines 931-932): 2 separate attribute removals
- All syntax highlighting patterns

**FIX for bracket matching (lines 927-1029):**
```swift
private func updateMatchingBracketHighlight(_ textView: UITextView) {
    let textStorage = textView.textStorage
    
    // BATCH all changes
    textStorage.beginEditing()
    defer { textStorage.endEditing() }
    
    // Clear existing highlights
    if !bracketHighlightRanges.isEmpty {
        for r in bracketHighlightRanges {
            textStorage.removeAttribute(.backgroundColor, range: r)
            textStorage.removeAttribute(.underlineStyle, range: r)
        }
        bracketHighlightRanges.removeAll()
    }
    
    // ... rest of bracket matching logic ...
    
    guard let match = matchIndex else { return }
    
    let r1 = NSRange(location: idx, length: 1)
    let r2 = NSRange(location: match, length: 1)
    
    // All 4 attribute changes now batched in single layout pass
    textStorage.addAttribute(.backgroundColor, value: bg, range: r1)
    textStorage.addAttribute(.backgroundColor, value: bg, range: r2)
    textStorage.addAttribute(.underlineStyle, value: NSUnderlineStyle.single.rawValue, range: r1)
    textStorage.addAttribute(.underlineStyle, value: NSUnderlineStyle.single.rawValue, range: r2)
    
    bracketHighlightRanges = [r1, r2]
}
```

---

## BOTTLENECK 3: Attributes Added One at a Time in Highlighter
**Lines: 1639-1640, 2206-2218**

Each pattern match adds attributes individually:
```swift
// Line 2216 - highlightPattern()
attributed.addAttribute(.foregroundColor, value: color, range: matchRange)
```

**FIX:** Modify VSCodeSyntaxHighlighter to batch attributes:
```swift
// In highlight() method, collect all ranges first, then apply in batch
private func highlight(_ text: String, language: Language) -> NSAttributedString {
    let attributed = NSMutableAttributedString(string: text)
    let fullRange = NSRange(location: 0, length: text.utf16.count)
    
    // Collect all highlights first
    var highlights: [(NSRange, NSAttributedString.Key, Any)] = []
    
    // Base attributes (single batch)
    let baseFont = UIFont.monospacedSystemFont(ofSize: baseFontSize, weight: .regular)
    highlights.append((fullRange, .font, baseFont))
    highlights.append((fullRange, .foregroundColor, UIColor(theme.editorForeground)))
    
    // Apply language-specific highlighting to collection
    // ... (modify highlightKeywords/highlightPattern to append to highlights array)
    
    // Single batch application
    attributed.beginEditing()
    for (range, key, value) in highlights {
        attributed.addAttribute(key, value: value, range: range)
    }
    attributed.endEditing()
    
    return attributed
}
```

---

## BOTTLENECK 4: FoldingLayoutManager O(n) Line Scanning
**Lines: 1066-1070, 1083-1100**

Called for EVERY line fragment during layout:
```swift
// Line 1070
let lineIndex = FoldingLayoutManager.lineIndex(atUTF16Location: loc, in: full)

// Lines 1090-1096 - O(n) string scanning
while searchStart < capped {
    let r = text.range(of: "\n", options: [], range: NSRange(location: searchStart, length: capped - searchStart))
    // ...
}
```

**FIX:** Cache line offsets:
```swift
final class FoldingLayoutManager: NSLayoutManager, NSLayoutManagerDelegate {
    // Add cached line index mapping
    private var lineOffsetCache: [Int] = []  // Index i = start offset of line i
    private var cachedTextLength: Int = 0
    
    private func rebuildLineCache() {
        guard let text = textStorage?.string else { return }
        let nsText = text as NSString
        
        if nsText.length == cachedTextLength { return }  // Skip if unchanged
        
        lineOffsetCache = [0]
        var searchStart = 0
        while searchStart < nsText.length {
            let r = nsText.range(of: "\n", options: [], range: NSRange(location: searchStart, length: nsText.length - searchStart))
            if r.location == NSNotFound { break }
            lineOffsetCache.append(r.location + 1)
            searchStart = r.location + 1
        }
        cachedTextLength = nsText.length
    }
    
    // O(log n) binary search instead of O(n) scan
    private func lineIndex(atUTF16Location loc: Int) -> Int {
        rebuildLineCache()
        var lo = 0, hi = lineOffsetCache.count
        while lo < hi {
            let mid = (lo + hi) / 2
            if lineOffsetCache[mid] <= loc {
                lo = mid + 1
            } else {
                hi = mid
            }
        }
        return max(0, lo - 1)
    }
}
```

---

## BOTTLENECK 5: MultiCursorTextView Replaces text Property
**Lines 151, 177 in MultiCursorTextView.swift**

```swift
// Line 151
self.text = content  // DESTROYS all attributed string styling!

// Line 177  
self.text = content
```

**Impact:** Setting `.text` clears ALL attributes, forcing full re-highlighting.

**FIX:**
```swift
override func insertText(_ text: String) {
    guard let editorCore = editorCore,
          editorCore.multiCursorState.isMultiCursor else {
        super.insertText(text)
        return
    }
    
    // Use textStorage directly to preserve attributes
    var content = self.text ?? ""
    let insertions = editorCore.multiCursorState.calculateInsertions(text, in: content)
    
    textStorage.beginEditing()
    // Apply insertions in reverse order (highest offset first) to preserve indices
    for (range, insertText) in insertions.reversed() {
        textStorage.replaceCharacters(in: range, with: insertText)
    }
    textStorage.endEditing()
    
    // Position cursor and trigger delegate
    // ...
}
```

---

## BOTTLENECK 6: Unnecessary Highlighting in textViewDidBeginEditing
**Line 370**

```swift
func textViewDidBeginEditing(_ textView: UITextView) {
    // Ensure syntax highlighting is current when user begins editing
    applySyntaxHighlighting(to: textView)  // Called every focus!
}
```

**FIX:** Only apply if not already highlighted:
```swift
func textViewDidBeginEditing(_ textView: UITextView) {
    // Only highlight if needed (text changed externally or never highlighted)
    if !hasAppliedInitialHighlighting {
        applySyntaxHighlighting(to: textView)
        hasAppliedInitialHighlighting = true
    }
}
```

---

## BOTTLENECK 7: handleToggleComment Uses textStorage Without Batching
**Lines 880-881**

```swift
let textStorage = textView.textStorage
textStorage.replaceCharacters(in: nsRange, with: newLineText)
```

Single operation is fine, but should still batch with any follow-up attribute updates.

---

## Summary Table

| Bottleneck | Location | Impact | Fix Complexity |
|------------|----------|--------|----------------|
| Full attributedText replacement | Lines 450, 550, 778 | CRITICAL - Full relayout | Medium |
| No beginEditing/endEditing | Throughout | HIGH - Multiple layout passes | Easy |
| Individual attribute adds | Lines 1639-1640, 2216 | MEDIUM - Many small operations | Medium |
| FoldingLayoutManager O(n) | Lines 1083-1100 | HIGH - Called per line fragment | Medium |
| MultiCursorTextView .text= | Lines 151, 177 | HIGH - Clears attributes | Easy |
| Redundant highlighting | Line 370 | LOW - Extra work on focus | Easy |

## Files Examined
- `VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift` (2289 lines, FULLY read)
- `VSCodeiPadOS/Views/Editor/MultiCursorTextView.swift` (274 lines, FULLY read)
- Search results for `textStorage`, `addAttribute`, `beginEditing` across codebase
>>>END
