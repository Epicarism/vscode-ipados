# Agent: scout-sticky
**Status:** done
**Tokens:** 2,957
**Cost:** $0.0000
**Time:** 2026-02-09T21:59:21.018Z

## Task
Search for 'StickyHeaderView' in all files. Report: what methods/properties are expected, what files import it.

## Response
>>>TOOL search
{"query": "StickyHeaderView"}
>>>END

>>>TOOL search
{"query": "StickyHeader"}
>>>END

---

## ðŸ”§ TOOL RESULTS

[search]
No matches found for "StickyHeader"


>>>TOOL search
{"query": "sticky"}
>>>END

---

## ðŸ”§ TOOL RESULTS

[search]
No matches found for "sticky"


>>>TOOL list_dir
{}
>>>END

---

## ðŸ”§ TOOL RESULTS

[list_dir]
ðŸ“ ./
ðŸ“ .claude/
ðŸ“ .claudefluff/
ðŸ“ .garbage/
ðŸ“ .patch-backups/
ðŸ“ .vscode/
ðŸ“ Docs/
ðŸ“ Extensions/
ðŸ“ logs/
ðŸ“ Models/
ðŸ“ Services/
ðŸ“ test-results/
ðŸ“ Tests/
ðŸ“ Views/
ðŸ“ VSCodeiPadOS/
ðŸ“ VSCodeiPadOSUITests/
   .gitignore
   build.log
   compiler fix.md
   FULL_FEATURE_TEST_PLAN.md
   LICENSE
   MASTER_AGENT_PLAN.md
   phase1-agents.json
   README.md
(cached)


>>>TOOL list_dir
{"path": "Views"}
>>>END

---

## ðŸ”§ TOOL RESULTS

[list_dir]
ðŸ“ Views/
ðŸ“ Editor/
ðŸ“ Panels/
(cached)


>>>TOOL list_dir
{"path": "Views/Editor"}
>>>END

---

## ðŸ”§ TOOL RESULTS

[list_dir]
ðŸ“ Views/Editor/
   (empty directory)
(cached)


>>>TOOL list_dir
{"path": "Views/Panels"}
>>>END

---

## ðŸ”§ TOOL RESULTS

[list_dir]
ðŸ“ Views/Panels/
   RunnerWarningView.swift
   TerminalView.swift_patch1
   TerminalView.swift_patch2
(cached)


>>>TOOL read_file
{"path": "Views/Panels/RunnerWarningView.swift"}
>>>END

---

## ðŸ”§ TOOL RESULTS

[read_file]
File: Views/Panels/RunnerWarningView.swift (lines 1-353 of 353)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1: import SwiftUI
2: 
3: // MARK: - Warning Types
4: 
5: enum RunnerWarningType: Equatable {
6:     case remoteRequired(reason: String, limitations: [String])
7:     case limitedFunctionality(reason: String, unavailableFeatures: [String])
8:     case securityRisk(reason: String, detectedIssues: [String])
9:     
10:     var iconName: String {
11:         switch self {
12:         case .remoteRequired:
13:             return "exclamationmark.triangle.fill"
14:         case .limitedFunctionality:
15:             return "exclamationmark.circle.fill"
16:         case .securityRisk:
17:             return "exclamationmark.shield.fill"
18:         }
19:     }
20:     
21:     var iconColor: Color {
22:         switch self {
23:         case .remoteRequired:
24:             return .orange
25:         case .limitedFunctionality:
26:             return .yellow
27:         case .securityRisk:
28:             return .red
29:         }
30:     }
31:     
32:     var title: String {
33:         switch self {
34:         case .remoteRequired:
35:             return "Remote Execution Required"
36:         case .limitedFunctionality:
37:             return "Limited Functionality"
38:         case .securityRisk:
39:             return "Security Warning"
40:         }
41:     }
42:     
43:     var primaryReason: String {
44:         switch self {
45:         case .remoteRequired(let reason, _),
46:              .limitedFunctionality(let reason, _),
47:              .securityRisk(let reason, _):
48:             return reason
49:         }
50:     }
51:     
52:     var listItems: [String] {
53:         switch self {
54:         case .remoteRequired(_, let limitations):
55:             return limitations
56:         case .limitedFunctionality(_, let features):
57:             return features
58:         case .securityRisk(_, let issues):
59:             return issues
60:         }
61:     }
62:     
63:     var listTitle: String {
64:         switch self {
65:         case .remoteRequired:
66:             return "Missing Dependencies"
67:         case .limitedFunctionality:
68:             return "Unavailable Features"
69:         case .securityRisk:
70:             return "Detected Issues"
71:         }
72:     }
73: }
74: 
75: // MARK: - View Model
76: 
77: class RunnerWarningViewModel: ObservableObject {
78:     @Published var isPresented: Bool = false
79:     @Published var warningType: RunnerWarningType = .remoteRequired(reason: "", limitations: [])
80:     @Published var alwaysAllowRemote: Bool = false
81:     
82:     var onRunRemotely: (() -> Void)?
83:     var onCancel: (() -> Void)?
84:     var onEditCode: (() -> Void)?
85:     
86:     func showWarning(type: RunnerWarningType) {
87:         self.warningType = type
88:         withAnimation(.spring(response: 0.35, dampingFraction: 0.8)) {
89:             self.isPresented = true
90:         }
91:     }
92:     
93:     func dismiss() {
94:         withAnimation(.spring(response: 0.35, dampingFraction: 0.8)) {
95:             self.isPresented = false
96:         }
97:     }
98:     
99:     func runRemotely() {
100:         onRunRemotely?()
101:         dismiss()
102:     }
103:     
104:     func cancel() {
105:         onCancel?()
106:         dismiss()
107:     }
108:     
109:     func editCode() {
110:         onEditCode?()
111:         dismiss()
112:     }
113: }
114: 
115: // MARK: - Main View
116: 
117: struct RunnerWarningView: View {
118:     @ObservedObject var viewModel: RunnerWarningViewModel
119:     
120:     var body: some View {
121:         ZStack {
122:             if viewModel.isPresented {
123:                 // Background overlay
124:                 Color.black.opacity(0.4)
125:                     .ignoresSafeArea()
126:                     .transition(.opacity)
127:                     .onTapGesture {
128:                         viewModel.cancel()
129:                     }
130:                 
131:                 // Alert card
132:                 warningCard
133:                     .transition(.scale(scale: 0.9).combined(with: .opacity))
134:             }
135:         }
136:     }
137:     
138:     private var warningCard: some View {
139:         VStack(spacing: 0) {
140:             // Icon
141:             Image(systemName: viewModel.warningType.iconName)
142:                 .font(.system(size: 44, weight: .semibold))
143:                 .foregroundColor(viewModel.warningType.iconColor)
144:                 .padding(.top, 24)
145:                 .padding(.bottom, 16)
146:             
147:             // Title
148:             Text(viewModel.warningType.title)
149:                 .font(.system(size: 17, weight: .semibold))
150:                 .foregroundColor(.primary)
151:                 .multilineTextAlignment(.center)
152:                 .padding(.horizontal, 24)
153:             
154:             // Explanation
155:             Text(viewModel.warningType.primaryReason)
156:                 .font(.system(size: 13))
157:                 .foregroundColor(.secondary)
158:                 .multilineTextAlignment(.center)
159:                 .padding(.horizontal, 24)
160:                 .padding(.top, 8)
161:             
162:             // List of items
163:             VStack(alignment: .leading, spacing: 8) {
164:                 Text(viewModel.warningType.listTitle)
165:                     .font(.system(size: 13, weight: .semibold))
166:                     .foregroundColor(.primary)
167:                 
168:                 ForEach(viewModel.warningType.listItems, id: \.self) { item in
169:                     HStack(alignment: .top, spacing: 8) {
170:                         Image(systemName: "circle.fill")
171:                             .font(.system(size: 4))
172:                             .foregroundColor(.secondary)
173:                             .padding(.top, 6)
174:                         
175:                         Text(item)
176:                             .font(.system(size: 13))
177:                             .foregroundColor(.secondary)
178:                             .fixedSize(horizontal: false, vertical: true)
179:                     }
180:                 }
181:             }
182:             .frame(maxWidth: .infinity, alignment: .leading)
183:             .padding(.horizontal, 24)
184:             .padding(.top, 16)
185:             
186:             // Toggle
187:             Toggle("Always allow remote execution for this project", isOn: $viewModel.alwaysAllowRemote)
188:                 .font(.system(size: 13))
189:                 .padding(.horizontal, 20)
190:                 .padding(.top, 20)
191:             
192:             // Divider before buttons
193:             Divider()
194:                 .padding(.top, 20)
195:             
196:             // Buttons
197:             HStack(spacing: 0) {
198:                 Button(action: { viewModel.cancel() }) {
199:                     Text("Cancel")
200:                         .font(.system(size: 17, weight: .regular))
201:                         .foregroundColor(.accentColor)
202:                         .frame(maxWidth: .infinity)
203:                         .frame(height: 44)
204:                 }
205:                 
206:                 Divider()
207:                     .frame(height: 44)
208:                 
209:                 Button(action: { viewModel.editCode() }) {
210:                     Text("Edit Code")
211:                         .font(.system(size: 17, weight: .regular))
212:                         .foregroundColor(.accentColor)
213:                         .frame(maxWidth: .infinity)
214:                         .frame(height: 44)
215:                 }
216:                 
217:                 Divider()
218:                     .frame(height: 44)
219:                 
220:                 Button(action: { viewModel.runRemotely() }) {
221:                     Text("Run Remotely")
222:                         .font(.system(size: 17, weight: .semibold))
223:                         .foregroundColor(viewModel.warningType.iconColor)
224:                         .frame(maxWidth: .infinity)
225:                         .frame(height: 44)
226:                 }
227:             }
228:         }
229:         .background(
230:             RoundedRectangle(cornerRadius: 14)
231:                 .fill(Color(UIColor.systemBackground))
232:                 .shadow(color: Color.black.opacity(0.2), radius: 40, x: 0, y: 20)
233:         )
234:         .frame(maxWidth: 320)
235:     }
236: }
237: 
238: // MARK: - Preview Provider
239: 
240: #Preview("Remote Required") {
241:     let viewModel = RunnerWarningViewModel()
242:     viewModel.warningType = .remoteRequired(
243:         reason: "This project requires dependencies that are not available on iOS.",
244:         limitations: [
245:             "numpy - Scientific computing library",
246:             "pandas - Data analysis library",
247:             "matplotlib - Plotting library"
248:         ]
249:     )
250:     viewModel.isPresented = true
251:     
252:     return ZStack {
253:         Color.gray.opacity(0.3).ignoresSafeArea()
254:         RunnerWarningView(viewModel: viewModel)
255:     }
256: }
257: 
258: #Preview("Limited Functionality") {
259:     let viewModel = RunnerWarningViewModel()
260:     viewModel.warningType = .limitedFunctionality(
261:         reason: "Some features will be unavailable when running locally.",
262:         unavailableFeatures: [
263:             "File system access",
264:             "Network requests to external APIs",
265:             "System process execution"
266:         ]
267:     )
268:     viewModel.isPresented = true
269:     
270:     return ZStack {
271:         Color.gray.opacity(0.3).ignoresSafeArea()
272:         RunnerWarningView(viewModel: viewModel)
273:     }
274: }
275: 
276: #Preview("Security Risk") {
277:     let viewModel = RunnerWarningViewModel()
278:     viewModel.warningType = .securityRisk(
279:         reason: "Potentially dangerous operations detected in your code.",
280:         detectedIssues: [
281:             "Use of eval() function",
282:             "Dynamic code execution",
283:             "Import of restricted modules"
284:         ]
285:     )
286:     viewModel.isPresented = true
287:     
288:     return ZStack {
289:         Color.gray.opacity(0.3).ignoresSafeArea()
290:         RunnerWarningView(viewModel: viewModel)
291:     }
292: }
293: 
294: #Preview("Dark Mode - Remote Required") {
295:     let viewModel = RunnerWarningViewModel()
296:     viewModel.warningType = .remoteRequired(
297:         reason: "This project requires dependencies that are not available on iOS.",
298:         limitations: [
299:             "numpy - Scientific computing library",
300:             "pandas - Data analysis library"
301:         ]
302:     )
303:     viewModel.isPresented = true
304:     
305:     return ZStack {
306:         Color.black.ignoresSafeArea()
307:         RunnerWarningView(viewModel: viewModel)
308:     }
309:     .preferredColorScheme(.dark)
310: }
311: 
312: #Preview("Animation Demo") {
313:     struct AnimationDemo: View {
314:         @StateObject private var viewModel = RunnerWarningViewModel()
315:         
316:         var body: some View {
317:             ZStack {
318:                 Color(UIColor.systemGroupedBackground).ignoresSafeArea()
319:                 
320:                 VStack {
321:                     Button("Show Remote Required Warning") {
322:                         viewModel.showWarning(type: .remoteRequired(
323:                             reason: "Dependencies not available on iOS.",
324:                             limitations: ["numpy", "scipy", "matplotlib"]
325:                         ))
326:                     }
327:                     .padding()
328:                     
329:                     Button("Show Limited Functionality Warning") {
330:                         viewModel.showWarning(type: .limitedFunctionality(
331:                             reason: "Some features unavailable locally.",
332:                             unavailableFeatures: ["File I/O", "Network requests"]
333:                         ))
334:                     }
335:                     .padding()
336:                     
337:                     Button("Show Security Risk Warning") {
338:                         viewModel.showWarning(type: .securityRisk(
339:                             reason: "Dangerous operations detected.",
340:                             detectedIssues: ["eval() usage", "exec() call"]
341:                         ))
342:                     }
343:                     .padding()
344:                 }
345:                 
346:                 RunnerWarningView(viewModel: viewModel)
347:             }
348:         }
349:     }
350:     
351:     return AnimationDemo()
352: }
353: 


>>>TOOL list_dir
{"path": "VSCodeiPadOS"}
>>>END

---

## ðŸ”§ TOOL RESULTS

[list_dir]
ðŸ“ VSCodeiPadOS/
ðŸ“ .garbage/
ðŸ“ Docs/
ðŸ“ Views/
ðŸ“ VSCodeiPadOS/
ðŸ“ VSCodeiPadOS.xcodeproj/
ðŸ“ VSCodeiPadOSTests/
   build_output.log
   build_output2.log
   build.log
   Info.plist
   Package.swift
(cached)


>>>TOOL list_dir
{"path": "VSCodeiPadOS/VSCodeiPadOS"}
>>>END

---

## ðŸ”§ TOOL RESULTS

[list_dir]
ðŸ“ VSCodeiPadOS/VSCodeiPadOS/
ðŸ“ App/
ðŸ“ Assets.xcassets/
ðŸ“ Commands/
ðŸ“ Docs/
ðŸ“ Extensions/
ðŸ“ Menus/
ðŸ“ Models/
ðŸ“ Resources/
ðŸ“ Services/
ðŸ“ Tests/
ðŸ“ UITests/
ðŸ“ Utils/
ðŸ“ Views/
   .tooling_note.txt
   ContentView_shift_arrow.patch
   ContentView.swift
   ContentView.swift.bak
   FIX_SUMMARY.md
   IMPLEMENTATION_SUMMARY.md
   Info.plist
   KeyboardShortcuts.md
   MULTI_WINDOW_IMPLEMENTATION.md
   MultiWindowSupport.md
   SceneDelegate.swift
   SyntaxHighlighter_Optimizations.md
(cached)


>>>TOOL list_dir
{"path": "VSCodeiPadOS/VSCodeiPadOS/Views"}
>>>END

---

## ðŸ”§ TOOL RESULTS

[list_dir]
ðŸ“ VSCodeiPadOS/VSCodeiPadOS/Views/
ðŸ“ Editor/
ðŸ“ Panels/
   _tmp.txt
   BranchMenu.swift
   CommandPalette.swift
   CommandPaletteView.swift
   DiffComponents.swift
   FileIconView.swift
   FileTreeView.swift
   GoToSymbol.swift
   LaunchConfigView.swift
   QuickOpen.swift
   RunConfigView.swift
   SidebarView.swift
   SnippetPickerView.swift
   StatusBarView.swift
   TabBarView.swift
   TasksView.swift
   WorkspaceSettingsView.swift
   WorkspaceTrustDialog.swift
(cached)


>>>TOOL search
{"query": "StickyHeaderView", "glob": "*.swift"}
>>>END

---

## ðŸ”§ TOOL RESULTS

[search]
No matches found for "StickyHeaderView"


>>>TOOL search
{"query": "HeaderView", "glob": "*.swift"}
>>>END

---

## ðŸ”§ TOOL RESULTS

[search]
No matches found for "HeaderView"


>>>TOOL search
{"query": "header", "glob": "*.swift"}
>>>END

---

## ðŸ”§ TOOL RESULTS

[search]
No matches found for "header"


>>>TOOL search
{"glob": "*.swift", "query": "Header"}
>>>END

---

## ðŸ”§ TOOL RESULTS

[search]
No matches found for "Header"


>>>TOOL read_file
{"path": "Views/Panels/TerminalView.swift_patch1"}
>>>END

---

## ðŸ”§ TOOL RESULTS

[read_file]
File: Views/Panels/TerminalView.swift_patch1 (lines 1-1 of 1)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1: 


>>>TOOL read_file
{"path": "Views/Panels/TerminalView.swift_patch2"}
>>>END

---

## ðŸ”§ TOOL RESULTS

[read_file]
File: Views/Panels/TerminalView.swift_patch2 (lines 1-1 of 1)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1: 


>>>TOOL list_dir
{"path": "VSCodeiPadOS/VSCodeiPadOS/Views/Editor"}
>>>END

---

## ðŸ”§ TOOL RESULTS

[list_dir]
ðŸ“ VSCodeiPadOS/VSCodeiPadOS/Views/Editor/
   BreadcrumbsView.swift
   ColorPickerView.swift
   EditorSplitView.swift
   GitGutterView.swift
   HoverInfoView.swift
   InlayHintsOverlay.swift
   InlineSuggestionView.swift
   JSONTreeView.swift
   MergeConflictView.swift
   MinimapView.swift
   MultiCursorTextView.swift
   PeekDefinitionView.swift
   SplitEditorView.swift
   StickyHeaderView.swift
   SyntaxHighlightingTextView_Update.swift
   SyntaxHighlightingTextView.swift
(cached)


>>>TOOL read_file
{"path": "VSCodeiPadOS/VSCodeiPadOS/Views/Editor/StickyHeaderView.swift"}
>>>END

---

## ðŸ”§ TOOL RESULTS

[read_file]
File: VSCodeiPadOS/VSCodeiPadOS/Views/Editor/StickyHeaderView.swift (lines 1-79 of 79)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1: import SwiftUI
2: 
3: struct StickyHeaderView: View {
4:     let text: String
5:     let currentLine: Int
6:     let theme: Theme
7:     let lineHeight: CGFloat
8:     let onSelect: (Int) -> Void
9:     
10:     @State private var stickyLines: [(line: Int, content: String, depth: Int)] = []
11:     
12:     var body: some View {
13:         VStack(alignment: .leading, spacing: 0) {
14:             ForEach(stickyLines, id: \.line) { item in
15:                 HStack {
16:                     Text(item.content.trimmingCharacters(in: .whitespaces))
17:                         .font(.system(size: 14, weight: .regular, design: .monospaced))
18:                         .foregroundColor(theme.editorForeground)
19:                         .padding(.leading, CGFloat(item.depth) * 16 + 4)
20:                         .padding(.vertical, 2)
21:                     Spacer()
22:                 }
23:                 .frame(height: lineHeight)
24:                 .background(theme.editorBackground.opacity(0.95))
25:                 .overlay(Rectangle().frame(height: 1).foregroundColor(theme.sidebarBackground), alignment: .bottom)
26:                 .onTapGesture {
27:                     onSelect(item.line)
28:                 }
29:             }
30:         }
31:         .onChange(of: currentLine) { _ in updateStickyLines() }
32:         .onAppear { updateStickyLines() }
33:     }
34:     
35:     private func updateStickyLines() {
36:         // Simplified logic: scan upwards from currentLine for class/func definitions
37:         // In a real app, use AST or Symbol Table
38:         
39:         let lines = text.components(separatedBy: .newlines)
40:         guard currentLine < lines.count else { return }
41:         
42:         var found: [(line: Int, content: String, depth: Int)] = []
43:         var minIndent = Int.max
44:         
45:         // Scan upwards
46:         for i in stride(from: currentLine, through: 0, by: -1) {
47:             let line = lines[i]
48:             let trimmed = line.trimmingCharacters(in: .whitespaces)
49:             
50:             if trimmed.isEmpty || trimmed.hasPrefix("//") { continue }
51:             
52:             let indent = line.prefix(while: { $0 == " " }).count / 4
53:             
54:             // Heuristic: declarations usually have less indentation than current scope
55:             // and contain keywords
56:             if indent < minIndent {
57:                 if trimmed.hasPrefix("class ") || 
58:                    trimmed.hasPrefix("struct ") || 
59:                    trimmed.hasPrefix("enum ") || 
60:                    trimmed.hasPrefix("func ") || 
61:                    trimmed.hasPrefix("extension ") ||
62:                    trimmed.contains(" body: some View") {
63:                     
64:                     found.insert((i, line, indent), at: 0)
65:                     minIndent = indent
66:                 }
67:             }
68:             
69:             if minIndent == 0 { break }
70:         }
71:         
72:         // Limit to 3 levels to avoid clutter
73:         if found.count > 3 {
74:             found = Array(found.suffix(3))
75:         }
76:         
77:         self.stickyLines = found
78:     }
79: }


>>>TOOL search
{"glob": "*.swift", "query": "StickyHeaderView"}
>>>END

---

## ðŸ”§ TOOL RESULTS

[search]
No matches found for "StickyHeaderView"


>>>TOOL search
{"query": "StickyHeaderView"}
>>>END

---

## ðŸ”§ TOOL RESULTS

[search]
No matches found for "StickyHeaderView"


>>>TOOL read_file
{"path": "VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SplitEditorView.swift"}
>>>END

---

## ðŸ”§ TOOL RESULTS

[read_file]
File: VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SplitEditorView.swift (lines 1-774 of 774)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1: //
2: //  SplitEditorView.swift
3: //  VSCodeiPadOS
4: //
5: //  Split editor panes implementation
6: //  - Split right/down
7: //  - Drag tabs to create splits
8: //  - Independent panes with own tabs
9: //  - Resizable with drag handles
10: //  - Close split buttons
11: //  - Sync scroll option
12: //
13: 
14: import SwiftUI
15: 
16: // MARK: - Split Direction
17: 
18: enum SplitDirection: String, CaseIterable {
19:     case horizontal // side by side
20:     case vertical   // top and bottom
21: }
22: 
23: // MARK: - Editor Pane Model
24: 
25: class EditorPane: ObservableObject, Identifiable {
26:     let id: UUID
27:     @Published var tabs: [Tab]
28:     @Published var activeTabId: UUID?
29:     @Published var scrollOffset: CGFloat = 0
30:     
31:     var activeTab: Tab? {
32:         tabs.first { $0.id == activeTabId }
33:     }
34:     
35:     init(id: UUID = UUID(), tabs: [Tab] = [], activeTabId: UUID? = nil) {
36:         self.id = id
37:         self.tabs = tabs
38:         self.activeTabId = activeTabId ?? tabs.first?.id
39:     }
40:     
41:     func addTab(_ tab: Tab) {
42:         // Check if already exists
43:         if let existing = tabs.first(where: { $0.url == tab.url && tab.url != nil }) {
44:             activeTabId = existing.id
45:             return
46:         }
47:         tabs.append(tab)
48:         activeTabId = tab.id
49:     }
50:     
51:     func closeTab(id: UUID) {
52:         guard let index = tabs.firstIndex(where: { $0.id == id }) else { return }
53:         tabs.remove(at: index)
54:         
55:         if activeTabId == id {
56:             if tabs.isEmpty {
57:                 activeTabId = nil
58:             } else if index >= tabs.count {
59:                 activeTabId = tabs[tabs.count - 1].id
60:             } else {
61:                 activeTabId = tabs[index].id
62:             }
63:         }
64:     }
65:     
66:     func selectTab(id: UUID) {
67:         activeTabId = id
68:     }
69:     
70:     func updateTabContent(_ content: String) {
71:         guard let index = tabs.firstIndex(where: { $0.id == activeTabId }) else { return }
72:         tabs[index].content = content
73:         if tabs[index].url != nil {
74:             tabs[index].isUnsaved = true
75:         }
76:     }
77: }
78: 
79: // MARK: - Split Editor Manager
80: 
81: class SplitEditorManager: ObservableObject {
82:     @Published var panes: [EditorPane] = []
83:     @Published var splitDirection: SplitDirection = .horizontal
84:     @Published var splitRatios: [CGFloat] = [1.0]
85:     @Published var activePaneId: UUID?
86:     @Published var syncScroll: Bool = false
87:     
88:     var activePane: EditorPane? {
89:         panes.first { $0.id == activePaneId }
90:     }
91:     
92:     init() {
93:         let initialPane = EditorPane()
94:         panes = [initialPane]
95:         activePaneId = initialPane.id
96:         splitRatios = [1.0]
97:     }
98:     
99:     // Initialize with EditorCore's tabs
100:     func initializeWithTabs(_ tabs: [Tab], activeTabId: UUID?) {
101:         if panes.isEmpty {
102:             let pane = EditorPane(tabs: tabs, activeTabId: activeTabId)
103:             panes = [pane]
104:             activePaneId = pane.id
105:             splitRatios = [1.0]
106:         } else if let firstPane = panes.first, firstPane.tabs.isEmpty {
107:             firstPane.tabs = tabs
108:             firstPane.activeTabId = activeTabId
109:         }
110:     }
111:     
112:     // MARK: - Split Operations
113:     
114:     func splitPane(direction: SplitDirection, fromPaneId: UUID? = nil) {
115:         let sourcePane = fromPaneId.flatMap { id in panes.first { $0.id == id } } ?? activePane
116:         guard let source = sourcePane else { return }
117:         
118:         // Create new pane with duplicate of active tab (or empty)
119:         var newTabs: [Tab] = []
120:         if let activeTab = source.activeTab {
121:             let duplicateTab = Tab(
122:                 fileName: activeTab.fileName,
123:                 content: activeTab.content,
124:                 language: activeTab.language,
125:                 url: activeTab.url,
126:                 isUnsaved: activeTab.isUnsaved
127:             )
128:             newTabs = [duplicateTab]
129:         }
130:         
131:         let newPane = EditorPane(tabs: newTabs, activeTabId: newTabs.first?.id)
132:         
133:         self.splitDirection = direction
134:         panes.append(newPane)
135:         
136:         // Recalculate ratios equally
137:         let ratio = 1.0 / CGFloat(panes.count)
138:         splitRatios = Array(repeating: ratio, count: panes.count)
139:         
140:         activePaneId = newPane.id
141:     }
142:     
143:     func closePane(id: UUID) {
144:         guard panes.count > 1 else { return } // Keep at least one pane
145:         guard let index = panes.firstIndex(where: { $0.id == id }) else { return }
146:         
147:         panes.remove(at: index)
148:         splitRatios.remove(at: index)
149:         
150:         // Normalize ratios
151:         let total = splitRatios.reduce(0, +)
152:         if total > 0 {
153:             splitRatios = splitRatios.map { $0 / total }
154:         } else {
155:             splitRatios = Array(repeating: 1.0 / CGFloat(panes.count), count: panes.count)
156:         }
157:         
158:         // Update active pane
159:         if activePaneId == id {
160:             activePaneId = panes.first?.id
161:         }
162:     }
163:     
164:     func moveTabToPane(tab: Tab, fromPaneId: UUID, toPaneId: UUID) {
165:         guard let fromPane = panes.first(where: { $0.id == fromPaneId }),
166:               let toPane = panes.first(where: { $0.id == toPaneId }) else { return }
167:         
168:         fromPane.closeTab(id: tab.id)
169:         
170:         // Create new tab (since Tab is a struct)
171:         let newTab = Tab(
172:             fileName: tab.fileName,
173:             content: tab.content,
174:             language: tab.language,
175:             url: tab.url,
176:             isUnsaved: tab.isUnsaved
177:         )
178:         toPane.addTab(newTab)
179:     }
180:     
181:     func moveTabToNewSplit(tab: Tab, fromPaneId: UUID, direction: SplitDirection) {
182:         guard let fromPane = panes.first(where: { $0.id == fromPaneId }) else { return }
183:         
184:         fromPane.closeTab(id: tab.id)
185:         
186:         let newTab = Tab(
187:             fileName: tab.fileName,
188:             content: tab.content,
189:             language: tab.language,
190:             url: tab.url,
191:             isUnsaved: tab.isUnsaved
192:         )
193:         
194:         let newPane = EditorPane(tabs: [newTab], activeTabId: newTab.id)
195:         self.splitDirection = direction
196:         panes.append(newPane)
197:         
198:         let ratio = 1.0 / CGFloat(panes.count)
199:         splitRatios = Array(repeating: ratio, count: panes.count)
200:         activePaneId = newPane.id
201:     }
202:     
203:     func updateRatio(at index: Int, delta: CGFloat, totalSize: CGFloat) {
204:         guard index < splitRatios.count - 1 else { return }
205:         
206:         let deltaRatio = delta / totalSize
207:         let minRatio: CGFloat = 0.15
208:         
209:         let newRatio1 = splitRatios[index] + deltaRatio
210:         let newRatio2 = splitRatios[index + 1] - deltaRatio
211:         
212:         if newRatio1 >= minRatio && newRatio2 >= minRatio {
213:             splitRatios[index] = newRatio1
214:             splitRatios[index + 1] = newRatio2
215:         }
216:     }
217:     
218:     // Sync scroll across panes
219:     func syncScrollOffset(_ offset: CGFloat, fromPaneId: UUID) {
220:         guard syncScroll else { return }
221:         for pane in panes where pane.id != fromPaneId {
222:             pane.scrollOffset = offset
223:         }
224:     }
225: }
226: 
227: // MARK: - Split Editor View
228: 
229: struct SplitEditorView: View {
230:     @ObservedObject var splitManager: SplitEditorManager
231:     @ObservedObject var editorCore: EditorCore
232:     
233:     var body: some View {
234:         GeometryReader { geometry in
235:             if splitManager.panes.count == 1 {
236:                 // Single pane - no split
237:                 if let pane = splitManager.panes.first {
238:                     SinglePaneView(pane: pane, splitManager: splitManager, editorCore: editorCore)
239:                 }
240:             } else {
241:                 // Multiple panes with split
242:                 splitContent(geometry: geometry)
243:             }
244:         }
245:     }
246:     
247:     @ViewBuilder
248:     private func splitContent(geometry: GeometryProxy) -> some View {
249:         let totalSize = splitManager.splitDirection == .horizontal ? geometry.size.width : geometry.size.height
250:         
251:         if splitManager.splitDirection == .horizontal {
252:             HStack(spacing: 0) {
253:                 ForEach(Array(splitManager.panes.enumerated()), id: \.element.id) { index, pane in
254:                     SinglePaneView(pane: pane, splitManager: splitManager, editorCore: editorCore)
255:                         .frame(width: totalSize * splitManager.splitRatios[index])
256:                     
257:                     if index < splitManager.panes.count - 1 {
258:                         SplitDragHandle(direction: .horizontal) { delta in
259:                             splitManager.updateRatio(at: index, delta: delta, totalSize: totalSize)
260:                         }
261:                     }
262:                 }
263:             }
264:         } else {
265:             VStack(spacing: 0) {
266:                 ForEach(Array(splitManager.panes.enumerated()), id: \.element.id) { index, pane in
267:                     SinglePaneView(pane: pane, splitManager: splitManager, editorCore: editorCore)
268:                         .frame(height: totalSize * splitManager.splitRatios[index])
269:                     
270:                     if index < splitManager.panes.count - 1 {
271:                         SplitDragHandle(direction: .vertical) { delta in
272:                             splitManager.updateRatio(at: index, delta: delta, totalSize: totalSize)
273:                         }
274:                     }
275:                 }
276:             }
277:         }
278:     }
279: }
280: 
281: // MARK: - Single Pane View
282: 
283: struct SinglePaneView: View {
284:     @ObservedObject var pane: EditorPane
285:     @ObservedObject var splitManager: SplitEditorManager
286:     @ObservedObject var editorCore: EditorCore
287:     @State private var dragOverPane = false
288:     
289:     var isActive: Bool {
290:         splitManager.activePaneId == pane.id
291:     }
292:     
293:     var body: some View {
294:         VStack(spacing: 0) {
295:             // Pane header with tabs and controls
296:             paneHeader
297:             
298:             // Editor content
299:             if let tab = pane.activeTab {
300:                 PaneEditorView(
301:                     pane: pane,
302:                     tab: tab,
303:                     splitManager: splitManager,
304:                     editorCore: editorCore
305:                 )
306:             } else {
307:                 emptyPaneView
308:             }
309:         }
310:         .background(isActive ? Color(UIColor.systemBackground) : Color(UIColor.secondarySystemBackground).opacity(0.3))
311:         .overlay(
312:             RoundedRectangle(cornerRadius: 0)
313:                 .stroke(isActive ? Color.accentColor : Color.clear, lineWidth: 2)
314:         )
315:         .overlay(
316:             // Drop zone indicator
317:             Group {
318:                 if dragOverPane {
319:                     RoundedRectangle(cornerRadius: 4)
320:                         .fill(Color.accentColor.opacity(0.2))
321:                         .overlay(
322:                             RoundedRectangle(cornerRadius: 4)
323:                                 .stroke(Color.accentColor, style: StrokeStyle(lineWidth: 2, dash: [5]))
324:                         )
325:                 }
326:             }
327:         )
328:         .onTapGesture {
329:             splitManager.activePaneId = pane.id
330:         }
331:         .onDrop(of: [.text], isTargeted: $dragOverPane) { providers in
332:             // Handle tab drop
333:             return true
334:         }
335:     }
336:     
337:     private var paneHeader: some View {
338:         HStack(spacing: 0) {
339:             // Tab bar
340:             ScrollView(.horizontal, showsIndicators: false) {
341:                 HStack(spacing: 0) {
342:                     ForEach(pane.tabs) { tab in
343:                         PaneTabItem(
344:                             tab: tab,
345:                             isSelected: pane.activeTabId == tab.id,
346:                             pane: pane,
347:                             splitManager: splitManager
348:                         )
349:                     }
350:                 }
351:             }
352:             
353:             Spacer()
354:             
355:             // Pane controls
356:             HStack(spacing: 4) {
357:                 // Split buttons
358:                 Menu {
359:                     Button(action: { splitManager.splitPane(direction: .horizontal, fromPaneId: pane.id) }) {
360:                         Label("Split Right", systemImage: "rectangle.split.2x1")
361:                     }
362:                     Button(action: { splitManager.splitPane(direction: .vertical, fromPaneId: pane.id) }) {
363:                         Label("Split Down", systemImage: "rectangle.split.1x2")
364:                     }
365:                     Divider()
366:                     Toggle(isOn: $splitManager.syncScroll) {
367:                         Label("Sync Scroll", systemImage: "arrow.up.arrow.down")
368:                     }
369:                 } label: {
370:                     Image(systemName: "rectangle.split.3x1")
371:                         .font(.caption)
372:                         .foregroundColor(.secondary)
373:                         .frame(width: 24, height: 24)
374:                 }
375:                 
376:                 // Close pane button (only if more than one pane)
377:                 if splitManager.panes.count > 1 {
378:                     Button(action: { splitManager.closePane(id: pane.id) }) {
379:                         Image(systemName: "xmark")
380:                             .font(.caption)
381:                             .foregroundColor(.secondary)
382:                     }
383:                     .frame(width: 24, height: 24)
384:                 }
385:             }
386:             .padding(.horizontal, 8)
387:         }
388:         .frame(height: 36)
389:         .background(Color(UIColor.secondarySystemBackground))
390:     }
391:     
392:     private var emptyPaneView: some View {
393:         VStack(spacing: 12) {
394:             Image(systemName: "doc.text")
395:                 .font(.system(size: 40))
396:                 .foregroundColor(.secondary.opacity(0.5))
397:             Text("No file open")
398:                 .font(.caption)
399:                 .foregroundColor(.secondary)
400:             
401:             HStack(spacing: 8) {
402:                 Button(action: { editorCore.showFilePicker = true }) {
403:                     Text("Open File")
404:                         .font(.caption)
405:                         .padding(.horizontal, 12)
406:                         .padding(.vertical, 6)
407:                         .background(Color.accentColor)
408:                         .foregroundColor(.white)
409:                         .cornerRadius(4)
410:                 }
411:             }
412:         }
413:         .frame(maxWidth: .infinity, maxHeight: .infinity)
414:     }
415: }
416: 
417: // MARK: - Pane Tab Item
418: 
419: struct PaneTabItem: View {
420:     let tab: Tab
421:     let isSelected: Bool
422:     @ObservedObject var pane: EditorPane
423:     @ObservedObject var splitManager: SplitEditorManager
424:     @State private var isDragging = false
425:     
426:     var body: some View {
427:         HStack(spacing: 6) {
428:             Image(systemName: tab.language.iconName)
429:                 .font(.caption)
430:                 .foregroundColor(tab.language.color)
431:             
432:             Text(tab.fileName)
433:                 .font(.system(size: 12))
434:                 .lineLimit(1)
435:             
436:             if tab.isUnsaved {
437:                 Circle()
438:                     .fill(Color.orange)
439:                     .frame(width: 6, height: 6)
440:             }
441:             
442:             Button(action: { pane.closeTab(id: tab.id) }) {
443:                 Image(systemName: "xmark")
444:                     .font(.system(size: 9, weight: .medium))
445:                     .foregroundColor(.secondary)
446:             }
447:         }
448:         .padding(.horizontal, 12)
449:         .padding(.vertical, 6)
450:         .background(
451:             RoundedRectangle(cornerRadius: 4)
452:                 .fill(isSelected ? Color(UIColor.systemBackground) : Color.clear)
453:         )
454:         .opacity(isDragging ? 0.5 : 1.0)
455:         .onTapGesture {
456:             pane.selectTab(id: tab.id)
457:             splitManager.activePaneId = pane.id
458:         }
459:         .onDrag {
460:             isDragging = true
461:             return NSItemProvider(object: tab.id.uuidString as NSString)
462:         }
463:         .contextMenu {
464:             Button(action: { pane.closeTab(id: tab.id) }) {
465:                 Label("Close", systemImage: "xmark")
466:             }
467:             
468:             Divider()
469:             
470:             Button(action: { splitManager.moveTabToNewSplit(tab: tab, fromPaneId: pane.id, direction: .horizontal) }) {
471:                 Label("Move to Split Right", systemImage: "rectangle.split.2x1")
472:             }
473:             
474:             Button(action: { splitManager.moveTabToNewSplit(tab: tab, fromPaneId: pane.id, direction: .vertical) }) {
475:                 Label("Move to Split Down", systemImage: "rectangle.split.1x2")
476:             }
477:         }
478:     }
479: }
480: 
481: // MARK: - Pane Editor View
482: 
483: struct PaneEditorView: View {
484:     @ObservedObject var pane: EditorPane
485:     let tab: Tab
486:     @ObservedObject var splitManager: SplitEditorManager
487:     @ObservedObject var editorCore: EditorCore
488:     @ObservedObject private var debugManager = DebugManager.shared
489:     @ObservedObject private var foldingManager = CodeFoldingManager.shared
490:     @State private var text: String = ""
491:     @State private var scrollPosition: Int = 0
492:     @State private var totalLines: Int = 1
493:     @State private var visibleLines: Int = 20
494:     @State private var currentLineNumber: Int = 1
495:     @State private var currentColumn: Int = 1
496:     @State private var lineHeight: CGFloat = 17
497:     @State private var requestedLineSelection: Int? = nil
498: 
499:     @AppStorage("lineNumbersStyle") private var lineNumbersStyle: String = "on"
500:     
501:     private var fileId: String { tab.url?.path ?? tab.fileName }
502:     
503:     var body: some View {
504:         GeometryReader { geometry in
505:             HStack(spacing: 0) {
506:                 // Line numbers + breakpoints + code folding (gutter)
507:                 //
508:                 // IMPORTANT: keep gutter in sync with the editor scroll position. The gutter ScrollView
509:                 // is scroll-disabled, and we offset the content to match the editor's scroll.
510:                 if lineNumbersStyle != "off" {
511:                     ScrollView(showsIndicators: false) {
512:                         VStack(alignment: .trailing, spacing: 0) {
513:                             ForEach(0..<totalLines, id: \ .self) { lineIndex in
514:                                 HStack(spacing: 2) {
515:                                     // Fold chevron icon
516:                                     if foldingManager.isFoldable(fileId: fileId, line: lineIndex) {
517:                                         Button(action: { 
518:                                             foldingManager.toggleFold(fileId: fileId, line: lineIndex)
519:                                         }) {
520:                                             Image(systemName: foldingManager.isFolded(fileId: fileId, line: lineIndex) ? "chevron.right" : "chevron.down")
521:                                                 .font(.system(size: 10, weight: .regular))
522:                                                 .foregroundColor(.secondary.opacity(0.8))
523:                                                 .frame(width: 12, height: lineHeight)
524:                                         }
525:                                         .buttonStyle(.plain)
526:                                     } else {
527:                                         // Spacer for alignment
528:                                         Spacer()
529:                                             .frame(width: 12)
530:                                     }
531:                                     
532:                                     // Breakpoint indicator
533:                                     Button(action: { debugManager.toggleBreakpoint(file: fileId, line: lineIndex) }) {
534:                                         Circle()
535:                                             .fill(debugManager.hasBreakpoint(file: fileId, line: lineIndex) ? Color.red : Color.clear)
536:                                             .overlay(
537:                                                 Circle()
538:                                                     .stroke(Color.red.opacity(0.6), lineWidth: 1)
539:                                                     .opacity(debugManager.hasBreakpoint(file: fileId, line: lineIndex) ? 0 : 0.25)
540:                                             )
541:                                             .frame(width: 10, height: 10)
542:                                     }
543:                                     .buttonStyle(.plain)
544:                                     .frame(width: 14, height: lineHeight)
545: 
546:                                     Text(displayText(for: lineIndex))
547:                                         .font(.system(size: 12, design: .monospaced))
548:                                         .foregroundColor(lineIndex + 1 == currentLineNumber ? .primary : .secondary.opacity(0.6))
549:                                         .frame(height: lineHeight)
550:                                         .contentShape(Rectangle())
551:                                         .onTapGesture {
552:                                             requestedLineSelection = lineIndex
553:                                         }
554:                                 }
555:                                 .frame(maxWidth: .infinity, alignment: .trailing)
556:                             }
557:                         }
558:                         .padding(.trailing, 4)
559:                         .offset(y: -CGFloat(scrollPosition) * lineHeight)
560:                     }
561:                     .frame(width: 70)
562:                     .background(Color(UIColor.secondarySystemBackground).opacity(0.5))
563:                 }
564: 
565:                 // Editor
566:                 SyntaxHighlightingTextView(
567:                     text: $text,
568:                     filename: tab.fileName,
569:                     scrollPosition: $scrollPosition,
570:                     totalLines: $totalLines,
571:                     visibleLines: $visibleLines,
572:                     currentLineNumber: $currentLineNumber,
573:                     currentColumn: $currentColumn,
574:                     lineHeight: $lineHeight,
575:                     isActive: splitManager.activePaneId == pane.id,
576:                     editorCore: editorCore,
577:                     requestedLineSelection: $requestedLineSelection
578:                 )
579:                 .onChange(of: text) { newValue in
580:                     pane.updateTabContent(newValue)
581:                     
582:                     // Sync scroll if enabled
583:                     if splitManager.syncScroll {
584:                         splitManager.syncScrollOffset(CGFloat(scrollPosition) * lineHeight, fromPaneId: pane.id)
585:                     }
586:                 }
587:                 
588:                 // Mini minimap
589:                 MinimapView(
590:                     content: text,
591:                     scrollOffset: .constant(CGFloat(scrollPosition) * lineHeight),
592:                     scrollViewHeight: .constant(geometry.size.height),
593:                     totalContentHeight: CGFloat(totalLines) * lineHeight
594:                 )
595:                 .frame(width: 60)
596:             }
597:             // Sticky Header Overlay (FEAT-040)
598:             StickyHeaderView(
599:                 text: text,
600:                 currentLine: scrollPosition, // Using scrollPosition as approximate top line
601:                 theme: ThemeManager.shared.currentTheme,
602:                 lineHeight: lineHeight,
603:                 onSelect: { line in
604:                     requestedLineSelection = line
605:                 }
606:             )
607:             .padding(.leading, 70) // Offset for line numbers + folding icons
608:             .padding(.trailing, 60) // Offset for minimap
609:             
610:             // Peek Definition Overlay
611:             if let peekState = editorCore.peekState, editorCore.activeTabId == tab.id {
612:                  // Calculate simplified position: center of screen for now, but conceptually "inline"
613:                  // To make it truly inline, we'd need more complex geometry, but overlay is a good start.
614:                  VStack {
615:                      Spacer()
616:                          .frame(height: max(0, CGFloat(peekState.sourceLine - scrollPosition) * lineHeight + lineHeight + 20))
617:                      
618:                      PeekDefinitionView(
619:                          editorCore: editorCore,
620:                          targetFile: peekState.file,
621:                          targetLine: peekState.line,
622:                          content: peekState.content,
623:                          onClose: { editorCore.closePeekDefinition() },
624:                          onOpen: {
625:                              editorCore.openFile(FileItem(name: URL(fileURLWithPath: peekState.file).lastPathComponent, path: peekState.file, isDirectory: false))
626:                              editorCore.closePeekDefinition()
627:                          }
628:                      )
629:                      .padding(.horizontal)
630:                      .padding(.bottom, 20)
631:                      
632:                      Spacer()
633:                  }
634:                  .frame(maxWidth: .infinity, maxHeight: .infinity, alignment: .top)
635:                  .background(Color.black.opacity(0.01)) // Capture taps outside if needed, or let them pass
636:                  .transition(.opacity)
637:                  .zIndex(100)
638:             }
639:         }
640:         .onAppear {
641:             text = tab.content
642:         }
643:         .onChange(of: tab.id) { _ in
644:             text = tab.content
645:         }
646:         .onChange(of: pane.scrollOffset) { newOffset in
647:             if splitManager.syncScroll {
648:                 scrollPosition = Int(newOffset / lineHeight)
649:             }
650:         }
651:     }
652:     
653:     private func displayText(for lineIndex: Int) -> String {
654:         switch lineNumbersStyle {
655:         case "relative":
656:             let lineNumber = lineIndex + 1
657:             if lineNumber == currentLineNumber { return "\(lineNumber)" }
658:             return "\(abs(lineNumber - currentLineNumber))"
659:         case "interval":
660:             let lineNumber = lineIndex + 1
661:             return (lineNumber == 1 || lineNumber % 5 == 0) ? "\(lineNumber)" : ""
662:         default:
663:             return "\(lineIndex + 1)"
664:         }
665:     }
666: }
667: 
668: // MARK: - Split Drag Handle
669: 
670: struct SplitDragHandle: View {
671:     let direction: SplitDirection
672:     let onDrag: (CGFloat) -> Void
673:     
674:     @State private var isDragging = false
675:     @GestureState private var dragOffset: CGFloat = 0
676:     
677:     var body: some View {
678:         ZStack {
679:             // Background
680:             Rectangle()
681:                 .fill(Color(UIColor.separator))
682:             
683:             // Handle indicator
684:             if direction == .horizontal {
685:                 VStack(spacing: 2) {
686:                     ForEach(0..<3, id: \.self) { _ in
687:                         Circle()
688:                             .fill(isDragging ? Color.accentColor : Color.secondary)
689:                             .frame(width: 3, height: 3)
690:                     }
691:                 }
692:             } else {
693:                 HStack(spacing: 2) {
694:                     ForEach(0..<3, id: \.self) { _ in
695:                         Circle()
696:                             .fill(isDragging ? Color.accentColor : Color.secondary)
697:                             .frame(width: 3, height: 3)
698:                     }
699:                 }
700:             }
701:         }
702:         .frame(
703:             width: direction == .horizontal ? 6 : nil,
704:             height: direction == .vertical ? 6 : nil
705:         )
706:         .contentShape(Rectangle())
707:         .gesture(
708:             DragGesture()
709:                 .updating($dragOffset) { value, state, _ in
710:                     let delta = direction == .horizontal ? value.translation.width : value.translation.height
711:                     state = delta
712:                 }
713:                 .onChanged { value in
714:                     isDragging = true
715:                     let delta = direction == .horizontal ? value.translation.width : value.translation.height
716:                     onDrag(delta)
717:                 }
718:                 .onEnded { _ in
719:                     isDragging = false
720:                 }
721:         )
722:         .onHover { hovering in
723:             if hovering {
724:                 #if targetEnvironment(macCatalyst)
725:                 NSCursor.resizeLeftRight.push()
726:                 #endif
727:             } else {
728:                 #if targetEnvironment(macCatalyst)
729:                 NSCursor.pop()
730:                 #endif
731:             }
732:         }
733:     }
734: }
735: 
736: // MARK: - Split Action Buttons (for toolbar/menu)
737: 
738: struct SplitEditorButtons: View {
739:     @ObservedObject var splitManager: SplitEditorManager
740:     
741:     var body: some View {
742:         HStack(spacing: 4) {
743:             Button(action: { splitManager.splitPane(direction: .horizontal) }) {
744:                 Image(systemName: "rectangle.split.2x1")
745:                     .font(.caption)
746:             }
747:             .help("Split Editor Right")
748:             
749:             Button(action: { splitManager.splitPane(direction: .vertical) }) {
750:                 Image(systemName: "rectangle.split.1x2")
751:                     .font(.caption)
752:             }
753:             .help("Split Editor Down")
754:             
755:             Toggle(isOn: $splitManager.syncScroll) {
756:                 Image(systemName: "arrow.up.arrow.down")
757:                     .font(.caption)
758:             }
759:             .toggleStyle(.button)
760:             .help("Sync Scroll")
761:         }
762:     }
763: }
764: 
765: // MARK: - Preview
766: 
767: #Preview {
768:     let manager = SplitEditorManager()
769:     let core = EditorCore()
770:     manager.initializeWithTabs(core.tabs, activeTabId: core.activeTabId)
771:     
772:     return SplitEditorView(splitManager: manager, editorCore: core)
773: }
774: 


>>>TOOL search
{"glob": "*.swift", "query": "import.*StickyHeaderView|StickyHeaderView\\("}
>>>END

---

## ðŸ”§ TOOL RESULTS

[search]
No matches found for "import.*StickyHeaderView|StickyHeaderView\("


>>>TOOL search
{"glob": "*.swift", "query": "Sticky"}
>>>END

---

## ðŸ”§ TOOL RESULTS

[search]
No matches found for "Sticky"


>>>TOOL search
{"glob": "*.swift", "query": "StickyHeaderView"}
>>>END

---

## ðŸ”§ TOOL RESULTS

[search]
No matches found for "StickyHeaderView"


>>>TOOL search
{"glob": "*.swift", "query": "struct Theme|class Theme"}
>>>END

---

## ðŸ”§ TOOL RESULTS

[search]
No matches found for "struct Theme|class Theme"


>>>TOOL read_file
{"path": "VSCodeiPadOS/VSCodeiPadOS/ContentView.swift"}
>>>END

---

## ðŸ”§ TOOL RESULTS

[read_file]
File: VSCodeiPadOS/VSCodeiPadOS/ContentView.swift (lines 1-1016 of 1016)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1: import SwiftUI
2: import UIKit
3: import UniformTypeIdentifiers
4: 
5: // MARK: - Helper Functions
6: // Moved to Extensions/FileHelpers.swift
7: 
8: // MARK: - Main Content View
9: 
10: struct ContentView: View {
11:     @EnvironmentObject var editorCore: EditorCore
12:     @StateObject private var fileNavigator = FileSystemNavigator()
13:     @StateObject private var themeManager = ThemeManager.shared
14:     
15:     @State private var showingDocumentPicker = false
16:     @State private var showingFolderPicker = false
17:     @State private var showSettings = false
18:     @State private var showTerminal = false
19:     @State private var terminalHeight: CGFloat = 200
20:     @State private var selectedSidebarTab = 0
21:     @State private var pendingTrustURL: URL?
22:     @State private var windowTitle: String = "VS Code"
23:     
24:     @StateObject private var trustManager = WorkspaceTrustManager.shared
25:     
26:     private var theme: Theme { themeManager.currentTheme }
27:     
28:     var body: some View {
29:         ZStack {
30:             VStack(spacing: 0) {
31:                 HStack(spacing: 0) {
32:                     IDEActivityBar(editorCore: editorCore, selectedTab: $selectedSidebarTab, showSettings: $showSettings, showTerminal: $showTerminal)
33:                     
34:                     if editorCore.showSidebar {
35:                         sidebarContent.frame(width: editorCore.sidebarWidth)
36:                     }
37:                     
38:                     VStack(spacing: 0) {
39:                         IDETabBar(editorCore: editorCore, theme: theme)
40:                         
41:                         if let tab = editorCore.activeTab {
42:                             IDEEditorView(editorCore: editorCore, tab: tab, theme: theme)
43:                         } else {
44:                             IDEWelcomeView(editorCore: editorCore, showFolderPicker: $showingFolderPicker, theme: theme)
45:                         }
46:                         
47:                         StatusBarView(editorCore: editorCore)
48:                     }
49:                 }
50:                 
51:                 if showTerminal {
52:                     PanelView(isVisible: $showTerminal, height: $terminalHeight)
53:                 }
54:             }
55:             .background(theme.editorBackground)
56:             
57:             // Overlays - Command Palette (Cmd+Shift+P)
58:             if editorCore.showCommandPalette {
59:                 Color.black.opacity(0.4).ignoresSafeArea().onTapGesture { editorCore.showCommandPalette = false }
60:                 CommandPaletteView(editorCore: editorCore, showSettings: $showSettings, showTerminal: $showTerminal)
61:             }
62:             
63:             // Quick Open (Cmd+P)
64:             if editorCore.showQuickOpen {
65:                 Color.black.opacity(0.4).ignoresSafeArea().onTapGesture { editorCore.showQuickOpen = false }
66:                 QuickOpenView(editorCore: editorCore, fileNavigator: fileNavigator)
67:             }
68:             
69:             // Go To Symbol (Cmd+Shift+O)
70:             if editorCore.showGoToSymbol {
71:                 Color.black.opacity(0.4).ignoresSafeArea().onTapGesture { editorCore.showGoToSymbol = false }
72:                 GoToSymbolView(editorCore: editorCore, onGoToLine: { _ in })
73:             }
74:             
75:             // AI Assistant
76:             if editorCore.showAIAssistant {
77:                 HStack { Spacer(); IDEAIAssistant(editorCore: editorCore, theme: theme).frame(width: 400, height: 500).padding() }
78:             }
79:             
80:             // Go To Line (Ctrl+G)
81:             if editorCore.showGoToLine {
82:                 Color.black.opacity(0.4).ignoresSafeArea().onTapGesture { editorCore.showGoToLine = false }
83:                 GoToLineView(isPresented: $editorCore.showGoToLine, onGoToLine: { _ in })
84:             }
85:             
86:             // Workspace Trust Dialog
87:             if let trustURL = pendingTrustURL {
88:                 Color.black.opacity(0.4).ignoresSafeArea()
89:                 WorkspaceTrustDialog(workspaceURL: trustURL, onTrust: {
90:                     trustManager.trust(url: trustURL)
91:                     finishOpeningWorkspace(trustURL)
92:                     pendingTrustURL = nil
93:                 }, onCancel: {
94:                     pendingTrustURL = nil
95:                 })
96:             }
97:         }
98:         .sheet(isPresented: $showingDocumentPicker) { IDEDocumentPicker(editorCore: editorCore) }
99:         .sheet(isPresented: $showingFolderPicker) {
100:             IDEFolderPicker(fileNavigator: fileNavigator) { url in
101:                 if trustManager.isTrusted(url: url) {
102:                     finishOpeningWorkspace(url)
103:                 } else {
104:                     pendingTrustURL = url
105:                 }
106:             }
107:         }
108:         .sheet(isPresented: $showSettings) { SettingsView(themeManager: themeManager) }
109:         .onChange(of: editorCore.showFilePicker) { show in showingDocumentPicker = show }
110:         .onChange(of: editorCore.activeTab?.fileName) { newFileName in
111:             updateWindowTitle()
112:         }
113:         .onChange(of: editorCore.tabs.count) { _ in
114:             updateWindowTitle()
115:         }
116:         .onAppear {
117:             updateWindowTitle()
118:         }
119:         .environmentObject(themeManager)
120:         .environmentObject(editorCore)
121:     }
122:     
123:     private func finishOpeningWorkspace(_ url: URL) {
124:         fileNavigator.loadFileTree(at: url)
125:         Task { @MainActor in
126:             LaunchManager.shared.setWorkspaceRoot(url)
127:             GitManager.shared.setWorkingDirectory(url)
128:         }
129:     }
130:     
131:     private func updateWindowTitle() {
132:         if let activeTab = editorCore.activeTab {
133:             let fileName = activeTab.fileName
134:             let unsavedIndicator = activeTab.isUnsaved ? "â— " : ""
135:             windowTitle = "\(unsavedIndicator)\(fileName) - VS Code"
136:         } else if !editorCore.tabs.isEmpty {
137:             windowTitle = "VS Code"
138:         } else {
139:             windowTitle = "Welcome - VS Code"
140:         }
141:         
142:         // Notify the app of the title change
143:         NotificationCenter.default.post(
144:             name: NSNotification.Name("WindowTitleDidChange"),
145:             object: nil,
146:             userInfo: ["title": windowTitle]
147:         )
148:     }
149:     
150:     @ViewBuilder
151:     private var sidebarContent: some View {
152:         switch selectedSidebarTab {
153:         case 0:
154:             IDESidebarFiles(editorCore: editorCore, fileNavigator: fileNavigator, showFolderPicker: $showingFolderPicker, theme: theme)
155:         case 1:
156:             SidebarSearchView(theme: theme)
157:         case 2:
158:             GitView()
159:         case 3:
160:             DebugView()
161:         default:
162:             IDESidebarFiles(editorCore: editorCore, fileNavigator: fileNavigator, showFolderPicker: $showingFolderPicker, theme: theme)
163:         }
164:     }
165: }
166: 
167: // MARK: - Activity Bar
168: 
169: 
170: 
171: struct BarButton: View {
172:     let icon: String
173:     let isSelected: Bool
174:     let theme: Theme
175:     let action: () -> Void
176:     
177:     var body: some View {
178:         Button(action: action) {
179:             Image(systemName: icon)
180:                 .font(.system(size: 22))
181:                 .foregroundColor(isSelected ? theme.activityBarSelection : theme.activityBarForeground.opacity(0.6))
182:                 .frame(width: 48, height: 48)
183:         }
184:     }
185: }
186: 
187: // MARK: - Sidebar with Real File System
188: 
189: struct IDESidebarFiles: View {
190:     @ObservedObject var editorCore: EditorCore
191:     @ObservedObject var fileNavigator: FileSystemNavigator
192:     @Binding var showFolderPicker: Bool
193:     let theme: Theme
194:     
195:     var body: some View {
196:         VStack(alignment: .leading, spacing: 0) {
197:             HStack {
198:                 Text("EXPLORER").font(.caption).fontWeight(.semibold).foregroundColor(theme.sidebarForeground.opacity(0.7))
199:                 Spacer()
200:                 Button(action: { showFolderPicker = true }) {
201:                     Image(systemName: "folder.badge.plus").font(.caption)
202:                 }.foregroundColor(theme.sidebarForeground.opacity(0.7))
203:                 Button(action: { editorCore.showFilePicker = true }) {
204:                     Image(systemName: "doc.badge.plus").font(.caption)
205:                 }.foregroundColor(theme.sidebarForeground.opacity(0.7))
206:                 if fileNavigator.fileTree != nil {
207:                     Button(action: { fileNavigator.refreshFileTree() }) {
208:                         Image(systemName: "arrow.clockwise").font(.caption)
209:                     }.foregroundColor(theme.sidebarForeground.opacity(0.7))
210:                 }
211:             }.padding(.horizontal, 12).padding(.vertical, 8)
212:             
213:             ScrollView {
214:                 VStack(alignment: .leading, spacing: 2) {
215:                     if let tree = fileNavigator.fileTree {
216:                         FileTreeView(root: tree, fileNavigator: fileNavigator, editorCore: editorCore)
217:                     } else {
218:                         DemoFileTree(editorCore: editorCore, theme: theme)
219:                     }
220:                 }.padding(.horizontal, 8)
221:             }
222:         }.background(theme.sidebarBackground)
223:     }
224: }
225: 
226: struct RealFileTreeView: View {
227:     let node: FileTreeNode
228:     let level: Int
229:     @ObservedObject var fileNavigator: FileSystemNavigator
230:     @ObservedObject var editorCore: EditorCore
231:     let theme: Theme
232:     
233:     var isExpanded: Bool { fileNavigator.expandedPaths.contains(node.url.path) }
234:     
235:     var body: some View {
236:         VStack(alignment: .leading, spacing: 2) {
237:             HStack(spacing: 4) {
238:                 if node.isDirectory {
239:                     Image(systemName: isExpanded ? "chevron.down" : "chevron.right")
240:                         .font(.caption2).frame(width: 12)
241:                         .foregroundColor(theme.sidebarForeground.opacity(0.6))
242:                         .onTapGesture { fileNavigator.toggleExpanded(path: node.url.path) }
243:                 } else {
244:                     Spacer().frame(width: 12)
245:                 }
246:                 Image(systemName: node.isDirectory ? "folder.fill" : fileIcon(for: node.name))
247:                     .font(.caption)
248:                     .foregroundColor(node.isDirectory ? .yellow : fileColor(for: node.name))
249:                 Text(node.name).font(.system(.caption)).lineLimit(1)
250:                     .foregroundColor(theme.sidebarForeground)
251:                 Spacer()
252:             }
253:             .padding(.leading, CGFloat(level * 16)).padding(.vertical, 4)
254:             .contentShape(Rectangle())
255:             .onTapGesture {
256:                 if node.isDirectory {
257:                     fileNavigator.toggleExpanded(path: node.url.path)
258:                 } else {
259:                     editorCore.openFile(from: node.url)
260:                 }
261:             }
262:             
263:             if isExpanded && node.isDirectory {
264:                 ForEach(node.children) { child in
265:                     RealFileTreeView(node: child, level: level + 1, fileNavigator: fileNavigator, editorCore: editorCore, theme: theme)
266:                 }
267:             }
268:         }
269:     }
270: }
271: 
272: struct DemoFileTree: View {
273:     @ObservedObject var editorCore: EditorCore
274:     let theme: Theme
275:     
276:     var body: some View {
277:         VStack(alignment: .leading, spacing: 4) {
278:             Text("Open a folder to browse files")
279:                 .font(.caption)
280:                 .foregroundColor(theme.sidebarForeground.opacity(0.6))
281:                 .padding(.vertical, 8)
282:             
283:             DemoFileRow(name: "main.swift", editorCore: editorCore, theme: theme)
284:             DemoFileRow(name: "ContentView.swift", editorCore: editorCore, theme: theme)
285:             DemoFileRow(name: "README.md", editorCore: editorCore, theme: theme)
286:         }
287:     }
288: }
289: 
290: struct DemoFileRow: View {
291:     let name: String
292:     @ObservedObject var editorCore: EditorCore
293:     let theme: Theme
294:     
295:     var body: some View {
296:         HStack(spacing: 4) {
297:             Spacer().frame(width: 12)
298:             Image(systemName: fileIcon(for: name)).font(.caption).foregroundColor(fileColor(for: name))
299:             Text(name).font(.system(.caption)).lineLimit(1).foregroundColor(theme.sidebarForeground)
300:             Spacer()
301:         }
302:         .padding(.vertical, 4)
303:         .contentShape(Rectangle())
304:         .onTapGesture {
305:             editorCore.addTab(fileName: name, content: "// \(name)\n\n")
306:         }
307:     }
308: }
309: 
310: // MARK: - Tab Bar
311: 
312: struct IDETabBar: View {
313:     @ObservedObject var editorCore: EditorCore
314:     let theme: Theme
315:     
316:     var body: some View {
317:         ScrollView(.horizontal, showsIndicators: false) {
318:             HStack(spacing: 0) {
319:                 ForEach(editorCore.tabs) { tab in
320:                     IDETabItem(tab: tab, isSelected: editorCore.activeTabId == tab.id, editorCore: editorCore, theme: theme)
321:                 }
322:                 Button(action: { editorCore.addTab() }) {
323:                     Image(systemName: "plus").font(.caption).foregroundColor(theme.tabInactiveForeground).padding(8)
324:                 }
325:             }.padding(.horizontal, 4)
326:         }.frame(height: 36).background(theme.tabBarBackground)
327:     }
328: }
329: 
330: struct IDETabItem: View {
331:     let tab: Tab
332:     let isSelected: Bool
333:     @ObservedObject var editorCore: EditorCore
334:     let theme: Theme
335:     
336:     var body: some View {
337:         HStack(spacing: 6) {
338:             Image(systemName: fileIcon(for: tab.fileName)).font(.caption).foregroundColor(fileColor(for: tab.fileName))
339:             Text(tab.fileName).font(.system(size: 12)).lineLimit(1)
340:                 .foregroundColor(isSelected ? theme.tabActiveForeground : theme.tabInactiveForeground)
341:             if tab.isUnsaved { Circle().fill(Color.orange).frame(width: 6, height: 6) }
342:             Button(action: { editorCore.closeTab(id: tab.id) }) {
343:                 Image(systemName: "xmark").font(.system(size: 9, weight: .medium))
344:                     .foregroundColor(isSelected ? theme.tabActiveForeground.opacity(0.6) : theme.tabInactiveForeground)
345:             }
346:         }
347:         .padding(.horizontal, 12).padding(.vertical, 6)
348:         .background(RoundedRectangle(cornerRadius: 4).fill(isSelected ? theme.tabActiveBackground : theme.tabInactiveBackground))
349:         .onTapGesture { editorCore.selectTab(id: tab.id) }
350:     }
351: }
352: 
353: // MARK: - Editor with Syntax Highlighting + Autocomplete + Folding
354: 
355: struct IDEEditorView: View {
356:     @ObservedObject var editorCore: EditorCore
357:     let tab: Tab
358:     let theme: Theme
359: 
360:     @AppStorage("lineNumbersStyle") private var lineNumbersStyle: String = "on"
361:     @State private var text: String = ""
362:     @State private var scrollPosition: Int = 0
363:     @State private var totalLines: Int = 1
364:     @State private var visibleLines: Int = 20
365:     @State private var currentLineNumber: Int = 1
366:     @State private var currentColumn: Int = 1
367:     @State private var cursorIndex: Int = 0
368:     @State private var lineHeight: CGFloat = 17
369:     @State private var requestedCursorIndex: Int? = nil
370:     @State private var requestedLineSelection: Int? = nil
371: 
372:     @StateObject private var autocomplete = AutocompleteManager()
373:     @State private var showAutocomplete = false
374:     @StateObject private var foldingManager = CodeFoldingManager()
375:     @StateObject private var findViewModel = FindViewModel()
376:     
377:     var body: some View {
378:         VStack(spacing: 0) {
379:             // Find/Replace bar
380:             if editorCore.showSearch {
381:                 FindReplaceView(viewModel: findViewModel)
382:                     .background(theme.tabBarBackground)
383:             }
384:             
385:             BreadcrumbsView(editorCore: editorCore, tab: tab)
386:             
387:             GeometryReader { geometry in
388:                 ZStack(alignment: .topLeading) {
389:                 HStack(spacing: 0) {
390:                     if lineNumbersStyle != "off" {
391:                         LineNumbersWithFolding(
392:                             fileId: tab.url?.path ?? tab.fileName,
393:                             totalLines: totalLines,
394:                             currentLine: currentLineNumber,
395:                             scrollOffset: CGFloat(scrollPosition) * lineHeight,
396:                             lineHeight: lineHeight,
397:                             requestedLineSelection: $requestedLineSelection,
398:                             foldingManager: foldingManager,
399:                             theme: theme
400:                         )
401:                         .frame(width: 60)
402:                         .background(theme.sidebarBackground.opacity(0.5))
403:                     }
404:                     
405:                     if tab.fileName.hasSuffix(".json") {
406:                         // JSON Tree View for .json files
407:                         JSONTreeView(data: text.data(using: .utf8) ?? Data())
408:                             .frame(maxWidth: .infinity, maxHeight: .infinity)
409:                             .background(theme.editorBackground)
410:                     } else {
411:                         SyntaxHighlightingTextView(
412:                             text: $text,
413:                             filename: tab.fileName,
414:                             scrollPosition: $scrollPosition,
415:                             totalLines: $totalLines,
416:                             visibleLines: $visibleLines,
417:                             currentLineNumber: $currentLineNumber,
418:                             currentColumn: $currentColumn,
419:                             cursorIndex: $cursorIndex,
420:                             lineHeight: $lineHeight,
421:                             isActive: true,
422:                             requestedLineSelection: $requestedLineSelection,
423:                             requestedCursorIndex: $requestedCursorIndex,
424:                             onAcceptAutocomplete: {
425:                                 guard showAutocomplete else { return false }
426:                                 var tempText = text
427:                                 var tempCursor = cursorIndex
428:                                 autocomplete.commitCurrentSuggestion(into: &tempText, cursorPosition: &tempCursor)
429:                                 if tempText != text {
430:                                     text = tempText
431:                                     cursorIndex = tempCursor
432:                                     requestedCursorIndex = tempCursor
433:                                     showAutocomplete = false
434:                                     return true
435:                                 }
436:                                 return false
437:                             },
438:                             onDismissAutocomplete: {
439:                                 guard showAutocomplete else { return false }
440:                                 autocomplete.hideSuggestions()
441:                                 showAutocomplete = false
442:                                 return true
443:                             }
444:                         )
445:                         .onChange(of: text) { newValue in
446:                             editorCore.updateActiveTabContent(newValue)
447:                             editorCore.cursorPosition = CursorPosition(line: currentLineNumber, column: currentColumn)
448:                             autocomplete.updateSuggestions(for: newValue, cursorPosition: cursorIndex)
449:                             showAutocomplete = autocomplete.showSuggestions
450:                             foldingManager.detectFoldableRegions(in: newValue)
451:                         }
452:                         .onChange(of: cursorIndex) { newCursor in
453:                             autocomplete.updateSuggestions(for: text, cursorPosition: newCursor)
454:                             showAutocomplete = autocomplete.showSuggestions
455:                         }
456:                     }
457:                     
458:                     if !tab.fileName.hasSuffix(".json") {
459:                         MinimapView(
460:                             content: text,
461:                             scrollOffset: .constant(CGFloat(scrollPosition) * lineHeight),
462:                             scrollViewHeight: .constant(geometry.size.height),
463:                             totalContentHeight: CGFloat(totalLines) * lineHeight
464:                         )
465:                         .frame(width: 80)
466:                     }
467:                 }
468:                 .background(theme.editorBackground)
469: 
470:                 // Sticky Header Overlay (FEAT-040)
471:                 StickyHeaderView(
472:                     text: text,
473:                     currentLine: scrollPosition,
474:                     theme: theme,
475:                     lineHeight: lineHeight,
476:                     onSelect: { line in
477:                         requestedLineSelection = line
478:                     }
479:                 )
480:                 .padding(.leading, lineNumbersStyle != "off" ? 60 : 0)
481:                 .padding(.trailing, tab.fileName.hasSuffix(".json") ? 0 : 80)
482: 
483:                 if showAutocomplete && !autocomplete.suggestionItems.isEmpty {
484:                     AutocompletePopup(
485:                         suggestions: autocomplete.suggestionItems,
486:                         selectedIndex: autocomplete.selectedIndex,
487:                         theme: theme
488:                     ) { index in
489:                         autocomplete.selectedIndex = index
490:                         var tempText = text
491:                         var tempCursor = cursorIndex
492:                         autocomplete.commitCurrentSuggestion(into: &tempText, cursorPosition: &tempCursor)
493:                         if tempText != text {
494:                             text = tempText
495:                             cursorIndex = tempCursor
496:                             requestedCursorIndex = tempCursor
497:                         }
498:                         showAutocomplete = false
499:                     }
500:                     .offset(x: 70, y: CGFloat(currentLineNumber) * lineHeight)
501:                 }
502:             }
503:         }
504:         }
505:         .onAppear {
506:             text = tab.content
507:             foldingManager.detectFoldableRegions(in: text)
508:         }
509:         .onChange(of: tab.id) { _ in
510:             text = tab.content
511:             foldingManager.detectFoldableRegions(in: text)
512:         }
513:         .onChange(of: currentLineNumber) { line in
514:             editorCore.cursorPosition = CursorPosition(line: line, column: currentColumn)
515:         }
516:         .onChange(of: currentColumn) { col in
517:             editorCore.cursorPosition = CursorPosition(line: currentLineNumber, column: col)
518:         }
519:         .onAppear {
520:             findViewModel.editorCore = editorCore
521:         }
522:     }
523:     
524:     // Autocomplete insertion is handled by AutocompleteManager.acceptSuggestion(...)
525: }
526: 
527: // MARK: - Line Numbers with Folding
528: 
529: struct LineNumbersWithFolding: View {
530:     let fileId: String
531:     let totalLines: Int
532:     let currentLine: Int
533:     let scrollOffset: CGFloat
534:     let lineHeight: CGFloat
535:     @Binding var requestedLineSelection: Int?
536:     @ObservedObject var foldingManager: CodeFoldingManager
537:     @ObservedObject private var debugManager = DebugManager.shared
538:     let theme: Theme
539: 
540:     @AppStorage("lineNumbersStyle") private var lineNumbersStyle: String = "on"
541: 
542:     var body: some View {
543:         ScrollView(showsIndicators: false) {
544:             VStack(alignment: .trailing, spacing: 0) {
545:                 ForEach(0..<totalLines, id: \.self) { lineIndex in
546:                     if !foldingManager.isLineFolded(line: lineIndex) {
547:                         HStack(spacing: 2) {
548:                             Button(action: { debugManager.toggleBreakpoint(file: fileId, line: lineIndex) }) {
549:                                 Circle()
550:                                     .fill(debugManager.hasBreakpoint(file: fileId, line: lineIndex) ? Color.red : Color.clear)
551:                                     .overlay(
552:                                         Circle()
553:                                             .stroke(Color.red.opacity(0.6), lineWidth: 1)
554:                                             .opacity(debugManager.hasBreakpoint(file: fileId, line: lineIndex) ? 0 : 0.25)
555:                                     )
556:                                     .frame(width: 10, height: 10)
557:                                     .padding(.leading, 2)
558:                             }
559:                             .buttonStyle(.plain)
560:                             .frame(width: 14, height: lineHeight)
561: 
562:                             if foldingManager.isFoldable(line: lineIndex) {
563:                                 Button(action: { foldingManager.toggleFold(at: lineIndex) }) {
564:                                     Image(systemName: foldingManager.foldRegions.first(where: { $0.startLine == lineIndex })?.isFolded == true ? "chevron.right" : "chevron.down")
565:                                         .font(.system(size: 8))
566:                                         .foregroundColor(theme.lineNumber)
567:                                 }
568:                                 .buttonStyle(.plain)
569:                                 .frame(width: 14, height: lineHeight)
570:                             } else {
571:                                 Spacer().frame(width: 14)
572:                             }
573: 
574:                             Text(displayText(for: lineIndex))
575:                                 .font(.system(size: 12, design: .monospaced))
576:                                 .foregroundColor(lineIndex + 1 == currentLine ? theme.lineNumberActive : theme.lineNumber)
577:                                 .frame(height: lineHeight)
578:                                 .contentShape(Rectangle())
579:                                 .onTapGesture {
580:                                     // FEAT-041: click line number selects entire line
581:                                     requestedLineSelection = lineIndex
582:                                 }
583:                         }
584:                         .frame(maxWidth: .infinity, alignment: .trailing)
585:                         .padding(.trailing, 4)
586:                     }
587:                 }
588:             }
589:             .offset(y: -scrollOffset)
590:         }
591:     }
592: 
593:     private func displayText(for lineIndex: Int) -> String {
594:         switch lineNumbersStyle {
595:         case "relative":
596:             // VS Code-style: current line shows absolute, others show relative distance
597:             let lineNumber = lineIndex + 1
598:             if lineNumber == currentLine { return "\(lineNumber)" }
599:             return "\(abs(lineNumber - currentLine))"
600: 
601:         case "interval":
602:             let lineNumber = lineIndex + 1
603:             return (lineNumber == 1 || lineNumber % 5 == 0) ? "\(lineNumber)" : ""
604: 
605:         default:
606:             return "\(lineIndex + 1)"
607:         }
608:     }
609: }
610: 
611: // MARK: - Autocomplete Popup
612: 
613: struct AutocompletePopup: View {
614:     let suggestions: [AutocompleteSuggestion]
615:     let selectedIndex: Int
616:     let theme: Theme
617:     let onSelectIndex: (Int) -> Void
618:     
619:     var body: some View {
620:         VStack(alignment: .leading, spacing: 0) {
621:             ForEach(suggestions.indices, id: \.self) { index in
622:                 let s = suggestions[index]
623:                 HStack(spacing: 6) {
624:                     Image(systemName: icon(for: s.kind))
625:                         .font(.caption)
626:                         .foregroundColor(color(for: s.kind))
627:                     VStack(alignment: .leading, spacing: 1) {
628:                         Text(s.displayText)
629:                             .font(.system(size: 12, design: .monospaced))
630:                             .foregroundColor(theme.editorForeground)
631:                         if s.insertText != s.displayText && !s.insertText.isEmpty {
632:                             Text(s.insertText)
633:                                 .font(.system(size: 10, design: .monospaced))
634:                                 .foregroundColor(theme.editorForeground.opacity(0.55))
635:                                 .lineLimit(1)
636:                         }
637:                     }
638:                     Spacer()
639:                 }
640:                 .padding(.horizontal, 8).padding(.vertical, 6)
641:                 .background(index == selectedIndex ? theme.selection : Color.clear)
642:                 .contentShape(Rectangle())
643:                 .onTapGesture { onSelectIndex(index) }
644:             }
645:         }
646:         .frame(width: 260)
647:         .background(theme.editorBackground)
648:         .cornerRadius(6)
649:         .shadow(radius: 8)
650:     }
651:     
652:     private func icon(for kind: AutocompleteSuggestionKind) -> String {
653:         switch kind {
654:         case .keyword: return "key.fill"
655:         case .symbol: return "cube.fill"
656:         case .stdlib: return "curlybraces"
657:         case .member: return "arrow.right.circle.fill"
658:         }
659:     }
660:     
661:     private func color(for kind: AutocompleteSuggestionKind) -> Color {
662:         switch kind {
663:         case .keyword: return .purple
664:         case .symbol: return .blue
665:         case .stdlib: return .orange
666:         case .member: return .green
667:         }
668:     }
669: }
670: 
671: // MARK: - Welcome View
672: 
673: struct IDEWelcomeView: View {
674:     @ObservedObject var editorCore: EditorCore
675:     @Binding var showFolderPicker: Bool
676:     let theme: Theme
677:     
678:     var body: some View {
679:         VStack(spacing: 24) {
680:             Image(systemName: "chevron.left.forwardslash.chevron.right").font(.system(size: 80)).foregroundColor(theme.editorForeground.opacity(0.3))
681:             Text("VS Code for iPadOS").font(.largeTitle).fontWeight(.bold).foregroundColor(theme.editorForeground)
682:             VStack(alignment: .leading, spacing: 12) {
683:                 WelcomeBtn(icon: "doc.badge.plus", title: "New File", shortcut: "âŒ˜N", theme: theme) { editorCore.addTab() }
684:                 WelcomeBtn(icon: "folder", title: "Open Folder", shortcut: "âŒ˜â‡§O", theme: theme) { showFolderPicker = true }
685:                 WelcomeBtn(icon: "doc", title: "Open File", shortcut: "âŒ˜O", theme: theme) { editorCore.showFilePicker = true }
686:                 WelcomeBtn(icon: "terminal", title: "Command Palette", shortcut: "âŒ˜â‡§P", theme: theme) { editorCore.showCommandPalette = true }
687:             }
688:         }.frame(maxWidth: .infinity, maxHeight: .infinity).background(theme.editorBackground)
689:     }
690: }
691: 
692: struct WelcomeBtn: View {
693:     let icon: String
694:     let title: String
695:     let shortcut: String
696:     let theme: Theme
697:     let action: () -> Void
698:     
699:     var body: some View {
700:         Button(action: action) {
701:             HStack {
702:                 Image(systemName: icon).frame(width: 24).foregroundColor(theme.editorForeground)
703:                 Text(title).foregroundColor(theme.editorForeground)
704:                 Spacer()
705:                 Text(shortcut).font(.caption).foregroundColor(theme.editorForeground.opacity(0.5))
706:             }
707:             .padding().frame(width: 280)
708:             .background(theme.sidebarBackground)
709:             .cornerRadius(8)
710:         }.buttonStyle(.plain)
711:     }
712: }
713: 
714: // MARK: - Command Palette
715: 
716: struct IDECommandPalette: View {
717:     @ObservedObject var editorCore: EditorCore
718:     @Binding var showSettings: Bool
719:     @Binding var showTerminal: Bool
720:     @State private var searchText = ""
721:     
722:     var body: some View {
723:         VStack(spacing: 0) {
724:             HStack {
725:                 Image(systemName: "magnifyingglass").foregroundColor(.secondary)
726:                 TextField("Type a command...", text: $searchText).textFieldStyle(.plain)
727:             }.padding().background(Color(UIColor.secondarySystemBackground))
728:             Divider()
729:             ScrollView {
730:                 VStack(spacing: 0) {
731:                     CommandRow(icon: "doc.badge.plus", name: "New File", shortcut: "âŒ˜N") { editorCore.addTab(); editorCore.showCommandPalette = false }
732:                     CommandRow(icon: "folder", name: "Open File", shortcut: "âŒ˜O") { editorCore.showFilePicker = true; editorCore.showCommandPalette = false }
733:                     CommandRow(icon: "square.and.arrow.down", name: "Save File", shortcut: "âŒ˜S") { editorCore.saveActiveTab(); editorCore.showCommandPalette = false }
734:                     CommandRow(icon: "sidebar.left", name: "Toggle Sidebar", shortcut: "âŒ˜B") { editorCore.toggleSidebar(); editorCore.showCommandPalette = false }
735:                     CommandRow(icon: "brain", name: "AI Assistant", shortcut: "âŒ˜â‡§A") { editorCore.showAIAssistant = true; editorCore.showCommandPalette = false }
736:                     CommandRow(icon: "terminal", name: "Toggle Terminal", shortcut: "âŒ˜`") { showTerminal.toggle(); editorCore.showCommandPalette = false }
737:                     CommandRow(icon: "gear", name: "Settings", shortcut: "âŒ˜,") { showSettings = true; editorCore.showCommandPalette = false }
738:                     CommandRow(icon: "number", name: "Go to Line", shortcut: "âŒ˜G") { editorCore.showGoToLine = true; editorCore.showCommandPalette = false }
739:                 }.padding(.vertical, 8)
740:             }
741:         }.frame(width: 500, height: 400).background(Color(UIColor.systemBackground)).cornerRadius(12).shadow(radius: 20)
742:     }
743: }
744: 
745: struct CommandRow: View {
746:     let icon: String; let name: String; let shortcut: String; let action: () -> Void
747:     var body: some View {
748:         Button(action: action) {
749:             HStack {
750:                 Image(systemName: icon).foregroundColor(.accentColor).frame(width: 24)
751:                 Text(name).foregroundColor(.primary)
752:                 Spacer()
753:                 Text(shortcut).font(.caption).foregroundColor(.secondary).padding(.horizontal, 8).padding(.vertical, 4).background(Color(UIColor.tertiarySystemFill)).cornerRadius(4)
754:             }.padding(.horizontal).padding(.vertical, 12).contentShape(Rectangle())
755:         }.buttonStyle(.plain)
756:     }
757: }
758: 
759: // MARK: - Quick Open
760: 
761: struct IDEQuickOpen: View {
762:     @ObservedObject var editorCore: EditorCore
763:     @State private var searchText = ""
764:     
765:     var body: some View {
766:         VStack(spacing: 0) {
767:             HStack {
768:                 Image(systemName: "magnifyingglass").foregroundColor(.gray)
769:                 TextField("Search files...", text: $searchText).textFieldStyle(.plain)
770:             }.padding().background(Color(UIColor.secondarySystemBackground))
771:             Divider()
772:             ScrollView {
773:                 VStack(alignment: .leading, spacing: 0) {
774:                     ForEach(editorCore.tabs) { tab in
775:                         QuickOpenRow(name: tab.fileName, path: "") {
776:                             editorCore.selectTab(id: tab.id)
777:                             editorCore.showQuickOpen = false
778:                         }
779:                     }
780:                 }
781:             }.frame(maxHeight: 350)
782:         }.frame(width: 500).background(Color(UIColor.systemBackground)).cornerRadius(12).shadow(radius: 20)
783:     }
784: }
785: 
786: struct QuickOpenRow: View {
787:     let name: String; let path: String; let action: () -> Void
788:     var body: some View {
789:         Button(action: action) {
790:             HStack {
791:                 Image(systemName: fileIcon(for: name)).foregroundColor(fileColor(for: name)).frame(width: 20)
792:                 VStack(alignment: .leading, spacing: 2) { Text(name).font(.system(size: 14)); Text(path + name).font(.system(size: 11)).foregroundColor(.secondary) }
793:                 Spacer()
794:             }.padding(.horizontal).padding(.vertical, 8).contentShape(Rectangle())
795:         }.buttonStyle(.plain)
796:     }
797: }
798: 
799: // MARK: - AI Assistant
800: 
801: struct IDEAIAssistant: View {
802:     @ObservedObject var editorCore: EditorCore
803:     let theme: Theme
804:     @State private var userInput = ""
805:     @State private var messages: [(id: UUID, role: String, content: String)] = [(UUID(), "assistant", "Hello! I'm your AI coding assistant. How can I help?")]
806:     
807:     var body: some View {
808:         VStack(spacing: 0) {
809:             HStack {
810:                 Image(systemName: "brain").foregroundColor(.blue)
811:                 Text("AI Assistant").font(.headline).foregroundColor(theme.editorForeground)
812:                 Spacer()
813:                 Button(action: { editorCore.showAIAssistant = false }) { Image(systemName: "xmark.circle.fill").foregroundColor(theme.editorForeground.opacity(0.5)) }
814:             }.padding().background(theme.sidebarBackground)
815:             
816:             ScrollView {
817:                 LazyVStack(alignment: .leading, spacing: 12) {
818:                     ForEach(messages, id: \.id) { msg in
819:                         HStack {
820:                             if msg.role == "user" { Spacer(minLength: 60) }
821:                             Text(msg.content).padding(12).background(RoundedRectangle(cornerRadius: 12).fill(msg.role == "user" ? Color.blue : theme.sidebarBackground)).foregroundColor(msg.role == "user" ? .white : theme.editorForeground)
822:                             if msg.role == "assistant" { Spacer(minLength: 60) }
823:                         }
824:                     }
825:                 }.padding()
826:             }.background(theme.editorBackground)
827:             
828:             HStack(spacing: 12) {
829:                 TextField("Ask about your code...", text: $userInput).textFieldStyle(.roundedBorder)
830:                 Button(action: { sendMessage() }) { Image(systemName: "paperplane.fill").foregroundColor(userInput.isEmpty ? .gray : .blue) }.disabled(userInput.isEmpty)
831:             }.padding().background(theme.sidebarBackground)
832:         }.background(theme.editorBackground).cornerRadius(12).shadow(radius: 20)
833:     }
834:     
835:     func sendMessage() {
836:         guard !userInput.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty else { return }
837:         messages.append((UUID(), "user", userInput))
838:         let input = userInput
839:         userInput = ""
840:         DispatchQueue.main.asyncAfter(deadline: .now() + 0.8) {
841:             messages.append((UUID(), "assistant", "I can help with '\(input)'! What specifically would you like to know?"))
842:         }
843:     }
844: }
845: 
846: // MARK: - Status Bar
847: 
848: 
849: 
850: // MARK: - Folder Picker
851: 
852: struct IDEFolderPicker: UIViewControllerRepresentable {
853:     @ObservedObject var fileNavigator: FileSystemNavigator
854:     var onPick: ((URL) -> Void)?
855:     
856:     init(fileNavigator: FileSystemNavigator, onPick: ((URL) -> Void)? = nil) {
857:         self.fileNavigator = fileNavigator
858:         self.onPick = onPick
859:     }
860:     
861:     func makeUIViewController(context: Context) -> UIDocumentPickerViewController {
862:         let picker = UIDocumentPickerViewController(forOpeningContentTypes: [.folder])
863:         picker.delegate = context.coordinator
864:         return picker
865:     }
866:     
867:     func updateUIViewController(_ uiViewController: UIDocumentPickerViewController, context: Context) {}
868:     
869:     func makeCoordinator() -> Coordinator { Coordinator(self) }
870:     
871:     class Coordinator: NSObject, UIDocumentPickerDelegate {
872:         let parent: IDEFolderPicker
873:         init(_ parent: IDEFolderPicker) { self.parent = parent }
874:         
875:         func documentPicker(_ controller: UIDocumentPickerViewController, didPickDocumentsAt urls: [URL]) {
876:             if let url = urls.first {
877:                 _ = url.startAccessingSecurityScopedResource()
878:                 if let onPick = parent.onPick {
879:                     onPick(url)
880:                 } else {
881:                     // Default behavior if no custom handler
882:                     parent.fileNavigator.loadFileTree(at: url)
883:                     Task { @MainActor in
884:                         LaunchManager.shared.setWorkspaceRoot(url)
885:                         GitManager.shared.setWorkingDirectory(url)
886:                     }
887:                 }
888:             }
889:         }
890:     }
891: }
892: 
893: // MARK: - Document Picker
894: 
895: struct IDEDocumentPicker: UIViewControllerRepresentable {
896:     @ObservedObject var editorCore: EditorCore
897:     
898:     func makeUIViewController(context: Context) -> UIDocumentPickerViewController {
899:         let picker = UIDocumentPickerViewController(forOpeningContentTypes: [.text, .sourceCode, .json, .plainText, .data])
900:         picker.allowsMultipleSelection = true
901:         picker.delegate = context.coordinator
902:         return picker
903:     }
904:     
905:     func updateUIViewController(_ uiViewController: UIDocumentPickerViewController, context: Context) {}
906:     
907:     func makeCoordinator() -> Coordinator { Coordinator(editorCore: editorCore) }
908:     
909:     class Coordinator: NSObject, UIDocumentPickerDelegate {
910:         let editorCore: EditorCore
911:         init(editorCore: EditorCore) { self.editorCore = editorCore }
912:         
913:         func documentPicker(_ controller: UIDocumentPickerViewController, didPickDocumentsAt urls: [URL]) {
914:             for url in urls { editorCore.openFile(from: url) }
915:             editorCore.showFilePicker = false
916:         }
917:         
918:         func documentPickerWasCancelled(_ controller: UIDocumentPickerViewController) {
919:             editorCore.showFilePicker = false
920:         }
921:     }
922: }
923: 
924: // MARK: - Sidebar Search View
925: 
926: struct SidebarSearchView: View {
927:     let theme: Theme
928:     @State private var searchText = ""
929:     @State private var replaceText = ""
930:     @State private var showReplace = false
931:     @State private var searchResults: [(fileName: String, line: Int, preview: String)] = []
932:     
933:     var body: some View {
934:         VStack(alignment: .leading, spacing: 0) {
935:             HStack {
936:                 Text("SEARCH").font(.caption).fontWeight(.semibold).foregroundColor(theme.sidebarForeground.opacity(0.7))
937:                 Spacer()
938:             }.padding(.horizontal, 12).padding(.vertical, 8)
939:             
940:             HStack(spacing: 4) {
941:                 Image(systemName: "magnifyingglass").foregroundColor(theme.sidebarForeground.opacity(0.6)).font(.caption)
942:                 TextField("Search", text: $searchText).textFieldStyle(.plain).font(.system(size: 13))
943:                     .foregroundColor(theme.sidebarForeground)
944:                 if !searchText.isEmpty {
945:                     Button(action: { searchText = "" }) {
946:                         Image(systemName: "xmark.circle.fill").foregroundColor(theme.sidebarForeground.opacity(0.6)).font(.caption)
947:                     }
948:                 }
949:             }
950:             .padding(8)
951:             .background(theme.editorBackground)
952:             .cornerRadius(6)
953:             .padding(.horizontal, 12)
954:             
955:             HStack {
956:                 Button(action: { showReplace.toggle() }) {
957:                     Image(systemName: showReplace ? "chevron.down" : "chevron.right").font(.caption2)
958:                     Text("Replace").font(.caption)
959:                 }.foregroundColor(theme.sidebarForeground.opacity(0.7))
960:                 Spacer()
961:             }.padding(.horizontal, 12).padding(.vertical, 6)
962:             
963:             if showReplace {
964:                 HStack(spacing: 4) {
965:                     Image(systemName: "arrow.right").foregroundColor(theme.sidebarForeground.opacity(0.6)).font(.caption)
966:                     TextField("Replace", text: $replaceText).textFieldStyle(.plain).font(.system(size: 13))
967:                         .foregroundColor(theme.sidebarForeground)
968:                 }
969:                 .padding(8)
970:                 .background(theme.editorBackground)
971:                 .cornerRadius(6)
972:                 .padding(.horizontal, 12)
973:             }
974:             
975:             Divider().padding(.top, 8)
976:             
977:             if searchText.isEmpty {
978:                 VStack(spacing: 8) {
979:                     Spacer()
980:                     Image(systemName: "magnifyingglass").font(.largeTitle).foregroundColor(theme.sidebarForeground.opacity(0.3))
981:                     Text("Search in files").font(.caption).foregroundColor(theme.sidebarForeground.opacity(0.6))
982:                     Spacer()
983:                 }.frame(maxWidth: .infinity)
984:             } else {
985:                 ScrollView {
986:                     LazyVStack(alignment: .leading, spacing: 0) {
987:                         ForEach(0..<searchResults.count, id: \.self) { i in
988:                             let result = searchResults[i]
989:                             VStack(alignment: .leading, spacing: 2) {
990:                                 HStack {
991:                                     Image(systemName: "doc.text").font(.caption2).foregroundColor(theme.sidebarForeground.opacity(0.6))
992:                                     Text(result.fileName).font(.system(size: 11, weight: .medium)).foregroundColor(theme.sidebarForeground)
993:                                     Spacer()
994:                                     Text(":\(result.line)").font(.system(size: 10, design: .monospaced)).foregroundColor(theme.sidebarForeground.opacity(0.6))
995:                                 }
996:                                 Text(result.preview).font(.system(size: 11, design: .monospaced)).foregroundColor(theme.sidebarForeground.opacity(0.7)).lineLimit(1)
997:                             }.padding(.horizontal, 12).padding(.vertical, 6)
998:                         }
999:                     }
1000:                 }
1001:             }
1002:         }
1003:         .background(theme.sidebarBackground)
1004:         .onChange(of: searchText) { query in
1005:             if query.isEmpty { searchResults = [] }
1006:             else { searchResults = [("ContentView.swift", 15, "Text(\"\(query)\")"), ("main.swift", 8, "// \(query)")] }
1007:         }
1008:     }
1009: }
1010: 
1011: // MARK: - Preview
1012: 
1013: #Preview {
1014:     ContentView()
1015: }
1016: 


>>>TOOL search
{"glob": "*.swift", "query": "struct Theme\\s*\\{|class Theme\\s*\\{"}
>>>END

---

## ðŸ”§ TOOL RESULTS

[search]
No matches found for "struct Theme\s*\{|class Theme\s*\{"


>>>TOOL search
{"glob": "*.swift", "query": "Theme"}
>>>END

---

## ðŸ”§ TOOL RESULTS

[search]
No matches found for "Theme"


>>>TOOL list_dir
{"path": "VSCodeiPadOS/VSCodeiPadOS/Services"}
>>>END

---

## ðŸ”§ TOOL RESULTS

[list_dir]
ðŸ“ VSCodeiPadOS/VSCodeiPadOS/Services/
ðŸ“ NativeGit/
ðŸ“ OnDevice/
ðŸ“ Runners/
   AIManager.swift
   AutocompleteManager.swift
   CodeFoldingManager.swift
   ColorPickerManager.swift
   DebugManager.swift
   EditorCore.swift
   ErrorParser.swift
   FileSystemNavigator.swift
   GitManager.swift
   GitService.swift
   HoverInfoManager.swift
   InlayHintsManager.swift
   InlineSuggestionManager.swift
   KeychainManager.swift
   LaunchManager.swift
   NavigationManager.swift
   RecentFileManager.swift
   RemoteDebugger.swift
   RemoteRunner.swift
   RunnerSelector.existing.swift
   RunnerSelector.swift
   SearchManager.swift
   SettingsManager.swift
   SFTPManager.swift
   SnippetsManager.swift
   SpotlightManager.swift
   SSHManager.swift
   SuggestionCache.swift
   TasksManager.swift
   ThemeManager.swift
   WindowStateManager.swift
   WorkspaceManager.swift
   WorkspaceTrustManager.swift


>>>TOOL read_file
{"path": "VSCodeiPadOS/VSCodeiPadOS/Services/ThemeManager.swift"}
>>>END

---

## ðŸ”§ TOOL RESULTS

[read_file]
File: VSCodeiPadOS/VSCodeiPadOS/Services/ThemeManager.swift (lines 1-186 of 186)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1: import SwiftUI
2: 
3: // MARK: - Theme Model
4: 
5: struct Theme: Identifiable, Hashable {
6:     let id: String
7:     let name: String
8:     let isDark: Bool
9:     
10:     // Editor colors
11:     let backgroundColor: Color
12:     let textColor: Color
13:     let lineNumberColor: Color
14:     let selectionColor: Color
15:     let cursorColor: Color
16:     
17:     // Syntax colors
18:     let keywordColor: Color
19:     let stringColor: Color
20:     let commentColor: Color
21:     let numberColor: Color
22:     let functionColor: Color
23:     let typeColor: Color
24:     let variableColor: Color
25:     let operatorColor: Color
26:     
27:     // UI colors
28:     let sidebarBackground: Color
29:     let tabBarBackground: Color
30:     let statusBarBackground: Color
31:     let borderColor: Color
32:     
33:     // Predefined themes
34:     static let defaultDark = Theme(
35:         id: "dark-default",
36:         name: "Dark+ (default)",
37:         isDark: true,
38:         backgroundColor: Color(hex: "1e1e1e"),
39:         textColor: Color(hex: "d4d4d4"),
40:         lineNumberColor: Color(hex: "858585"),
41:         selectionColor: Color(hex: "264f78"),
42:         cursorColor: Color(hex: "aeafad"),
43:         keywordColor: Color(hex: "569cd6"),
44:         stringColor: Color(hex: "ce9178"),
45:         commentColor: Color(hex: "6a9955"),
46:         numberColor: Color(hex: "b5cea8"),
47:         functionColor: Color(hex: "dcdcaa"),
48:         typeColor: Color(hex: "4ec9b0"),
49:         variableColor: Color(hex: "9cdcfe"),
50:         operatorColor: Color(hex: "d4d4d4"),
51:         sidebarBackground: Color(hex: "252526"),
52:         tabBarBackground: Color(hex: "252526"),
53:         statusBarBackground: Color(hex: "007acc"),
54:         borderColor: Color(hex: "3c3c3c")
55:     )
56:     
57:     static let defaultLight = Theme(
58:         id: "light-default",
59:         name: "Light+ (default)",
60:         isDark: false,
61:         backgroundColor: Color(hex: "ffffff"),
62:         textColor: Color(hex: "000000"),
63:         lineNumberColor: Color(hex: "237893"),
64:         selectionColor: Color(hex: "add6ff"),
65:         cursorColor: Color(hex: "000000"),
66:         keywordColor: Color(hex: "0000ff"),
67:         stringColor: Color(hex: "a31515"),
68:         commentColor: Color(hex: "008000"),
69:         numberColor: Color(hex: "098658"),
70:         functionColor: Color(hex: "795e26"),
71:         typeColor: Color(hex: "267f99"),
72:         variableColor: Color(hex: "001080"),
73:         operatorColor: Color(hex: "000000"),
74:         sidebarBackground: Color(hex: "f3f3f3"),
75:         tabBarBackground: Color(hex: "f3f3f3"),
76:         statusBarBackground: Color(hex: "007acc"),
77:         borderColor: Color(hex: "e7e7e7")
78:     )
79:     
80:     static let monokai = Theme(
81:         id: "monokai",
82:         name: "Monokai",
83:         isDark: true,
84:         backgroundColor: Color(hex: "272822"),
85:         textColor: Color(hex: "f8f8f2"),
86:         lineNumberColor: Color(hex: "90908a"),
87:         selectionColor: Color(hex: "49483e"),
88:         cursorColor: Color(hex: "f8f8f0"),
89:         keywordColor: Color(hex: "f92672"),
90:         stringColor: Color(hex: "e6db74"),
91:         commentColor: Color(hex: "75715e"),
92:         numberColor: Color(hex: "ae81ff"),
93:         functionColor: Color(hex: "a6e22e"),
94:         typeColor: Color(hex: "66d9ef"),
95:         variableColor: Color(hex: "f8f8f2"),
96:         operatorColor: Color(hex: "f92672"),
97:         sidebarBackground: Color(hex: "21201d"),
98:         tabBarBackground: Color(hex: "1e1f1c"),
99:         statusBarBackground: Color(hex: "75715e"),
100:         borderColor: Color(hex: "3b3a32")
101:     )
102:     
103:     static let solarizedDark = Theme(
104:         id: "solarized-dark",
105:         name: "Solarized Dark",
106:         isDark: true,
107:         backgroundColor: Color(hex: "002b36"),
108:         textColor: Color(hex: "839496"),
109:         lineNumberColor: Color(hex: "586e75"),
110:         selectionColor: Color(hex: "073642"),
111:         cursorColor: Color(hex: "839496"),
112:         keywordColor: Color(hex: "859900"),
113:         stringColor: Color(hex: "2aa198"),
114:         commentColor: Color(hex: "586e75"),
115:         numberColor: Color(hex: "d33682"),
116:         functionColor: Color(hex: "268bd2"),
117:         typeColor: Color(hex: "b58900"),
118:         variableColor: Color(hex: "839496"),
119:         operatorColor: Color(hex: "839496"),
120:         sidebarBackground: Color(hex: "00252e"),
121:         tabBarBackground: Color(hex: "003847"),
122:         statusBarBackground: Color(hex: "073642"),
123:         borderColor: Color(hex: "073642")
124:     )
125:     
126:     static let allThemes: [Theme] = [.defaultDark, .defaultLight, .monokai, .solarizedDark]
127: }
128: 
129: // MARK: - Theme Manager
130: 
131: class ThemeManager: ObservableObject {
132:     static let shared = ThemeManager()
133:     
134:     @Published var currentTheme: Theme {
135:         didSet {
136:             UserDefaults.standard.set(currentTheme.id, forKey: "selectedThemeId")
137:         }
138:     }
139:     
140:     @Published var availableThemes: [Theme] = Theme.allThemes
141:     
142:     private init() {
143:         // Load saved theme or use default
144:         let savedThemeId = UserDefaults.standard.string(forKey: "selectedThemeId") ?? Theme.defaultDark.id
145:         currentTheme = Theme.allThemes.first { $0.id == savedThemeId } ?? Theme.defaultDark
146:     }
147:     
148:     func setTheme(_ theme: Theme) {
149:         currentTheme = theme
150:     }
151:     
152:     func setTheme(id: String) {
153:         if let theme = availableThemes.first(where: { $0.id == id }) {
154:             currentTheme = theme
155:         }
156:     }
157: }
158: 
159: // MARK: - Color Hex Extension
160: 
161: extension Color {
162:     init(hex: String) {
163:         let hex = hex.trimmingCharacters(in: CharacterSet.alphanumerics.inverted)
164:         var int: UInt64 = 0
165:         Scanner(string: hex).scanHexInt64(&int)
166:         let a, r, g, b: UInt64
167:         switch hex.count {
168:         case 3: // RGB (12-bit)
169:             (a, r, g, b) = (255, (int >> 8) * 17, (int >> 4 & 0xF) * 17, (int & 0xF) * 17)
170:         case 6: // RGB (24-bit)
171:             (a, r, g, b) = (255, int >> 16, int >> 8 & 0xFF, int & 0xFF)
172:         case 8: // ARGB (32-bit)
173:             (a, r, g, b) = (int >> 24, int >> 16 & 0xFF, int >> 8 & 0xFF, int & 0xFF)
174:         default:
175:             (a, r, g, b) = (1, 1, 1, 0)
176:         }
177:         self.init(
178:             .sRGB,
179:             red: Double(r) / 255,
180:             green: Double(g) / 255,
181:             blue: Double(b) / 255,
182:             opacity: Double(a) / 255
183:         )
184:     }
185: }
186: 


>>>REPORT
## StickyHeaderView Search Results

### Location
`VSCodeiPadOS/VSCodeiPadOS/Views/Editor/StickyHeaderView.swift` (lines 1-79)

### Definition
```swift
struct StickyHeaderView: View
```

### Expected Initializer Properties
The view expects these **5 parameters**:
1. **`text: String`** - Full editor text content to scan for declarations
2. **`currentLine: Int`** - Current scroll position (used as top line indicator)
3. **`theme: Theme`** - Current theme for styling colors
4. **`lineHeight: CGFloat`** - Height of each line for frame calculation
5. **`onSelect: (Int) -> Void`** - Closure callback when user taps a sticky header line

### Internal Properties
- **`@State private var stickyLines: [(line: Int, content: String, depth: Int)]`** - Stores detected class/struct/func declarations found during scanning

### Required Theme Properties
The view accesses these `theme` properties:
- **`theme.editorBackground`** - Background color (line 24)
- **`theme.editorForeground`** - Text color (line 18)
- **`theme.sidebarBackground`** - Border/divider color (line 25)

### Files Importing/Using StickyHeaderView
1. **`VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SplitEditorView.swift`** (lines 598-606)
   - Used in `PaneEditorView` as an overlay
   - Passed: `text`, `scrollPosition` (as currentLine), `ThemeManager.shared.currentTheme`, `lineHeight`, closure setting `requestedLineSelection`

2. **`VSCodeiPadOS/VSCodeiPadOS/ContentView.swift`** (lines 471-479)
   - Used in `IDEEditorView` as an overlay with same parameters
   - Same usage pattern as SplitEditorView

### Functionality
The view implements code outline navigation by:
- Scanning upward from `currentLine` for class/struct/enum/func/extension declarations
- Showing up to 3 levels of nesting with indentation
- Making headers tappable to navigate to that line
- Updating when scroll position changes via `onChange(of: currentLine)`
>>>END
