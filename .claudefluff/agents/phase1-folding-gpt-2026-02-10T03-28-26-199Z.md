# Agent: phase1-folding-gpt
**Status:** done
**Tokens:** 119,989
**Cost:** $0.0000
**Time:** 2026-02-10T03:28:26.199Z

## Task
Verify code folding in VSCodeiPadOS. Check CodeFoldingManager.swift. Functions/classes should show fold arrows in gutter. Clicking should fold/unfold. Verify FoldRegion detection works for Swift. Fix bugs. BUILD AFTER.

## Response
>>>TOOL list_dir
{"path":"/Users/danielswagg/PLAYGROUND/vscode-ipados"}
>>>END>>>TOOL search
{"query":"CodeFoldingManager", "glob":"**/*"}
>>>END>>>TOOL read_file
{"path":"/Users/danielswagg/PLAYGROUND/vscode-ipados/CodeFoldingManager.swift"}
>>>END>>>TOOL get_symbols
{"path":"/Users/danielswagg/PLAYGROUND/vscode-ipados/CodeFoldingManager.swift"}
>>>END>>>END

>>>TOOL search
{"query":"LineNumberViewWithFolding", "glob":"VSCodeiPadOS/**/*"}
>>>END
>>>TOOL search
{"query":"FoldButton(", "glob":"VSCodeiPadOS/**/*"}
>>>END
>>>TOOL search
{"query":"toggleFoldAtLine", "glob":"VSCodeiPadOS/**/*"}
>>>END
>>>TOOL search
{"query":"detectFoldableRegions", "glob":"VSCodeiPadOS/**/*"}
>>>END
>>>TOOL search
{"query":"collapsedLines", "glob":"VSCodeiPadOS/**/*"}
>>>END
>>>END

---

## üîß TOOL RESULTS

[search]
Found 1 matches:
VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift:838: struct LineNumberViewWithFolding: View {

---

[search]
Found 1 matches:
VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift:848: FoldButton(

---

[search]
Found 1 matches:
VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift:591: func toggleFoldAtLine(_ cursorLine: Int) {

---

[search]
Found 4 matches:
VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift:83: func detectFoldableRegions(in code: String, filePath: String? = nil) {
VSCodeiPadOS/VSCodeiPadOS/ContentView.swift:492: foldingManager.detectFoldableRegions(in: newValue)
VSCodeiPadOS/VSCodeiPadOS/ContentView.swift:555: foldingManager.detectFoldableRegions(in: text)
VSCodeiPadOS/VSCodeiPadOS/ContentView.swift:559: foldingManager.detectFoldableRegions(in: text)

---

[search]
Found 5 matches:
VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift:72: @Published var collapsedLines: Set<Int> = []
VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift:673: return collapsedLines.contains(line)
VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift:756: return collapsedLines.count
VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift:779: collapsedLines.removeAll()
VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift:783: collapsedLines.insert(line)


>>>TOOL list_dir
{"path":"."}
>>>END
>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/ContentView.swift","start_line":430,"end_line":650}
>>>END
>>>TOOL search
{"query":"LineNumberViewWithFolding(", "glob":"VSCodeiPadOS/VSCodeiPadOS/**/*.swift"}
>>>END
>>>TOOL search
{"query":"onFoldTap", "glob":"VSCodeiPadOS/VSCodeiPadOS/**/*.swift"}
>>>END
>>>END>>>TOOL list_dir
{"path":"."}
>>>END
>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/ContentView.swift","start_line":430,"end_line":650}
>>>END
>>>TOOL search
{"query":"LineNumberViewWithFolding(", "glob":"VSCodeiPadOS/VSCodeiPadOS/**/*.swift"}
>>>END
>>>TOOL search
{"query":"onFoldTap", "glob":"VSCodeiPadOS/VSCodeiPadOS/**/*.swift"}
>>>END
>>>END

---

## üîß TOOL RESULTS

[list_dir]
üìÅ ./
üìÅ .claude/
üìÅ .claudefluff/
üìÅ .patch-backups/
üìÅ .vscode/
üìÅ Docs/
üìÅ Extensions/
üìÅ logs/
üìÅ Models/
üìÅ Services/
üìÅ test-results/
üìÅ Tests/
üìÅ Views/
üìÅ VSCodeiPadOS/
üìÅ VSCodeiPadOSUITests/
   .gitignore
   build.log
   FULL_FEATURE_TEST_PLAN.md
   LICENSE
   README.md
(cached)

---

[read_file]
File: VSCodeiPadOS/VSCodeiPadOS/ContentView.swift (lines 431-650 of 1064)
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
431:                     if lineNumbersStyle != "off" {
432:                         LineNumbersWithFolding(
433:                             fileId: tab.url?.path ?? tab.fileName,
434:                             totalLines: totalLines,
435:                             currentLine: currentLineNumber,
436:                             scrollOffset: CGFloat(scrollPosition) * lineHeight,
437:                             lineHeight: lineHeight,
438:                             requestedLineSelection: $requestedLineSelection,
439:                             foldingManager: foldingManager,
440:                             theme: theme
441:                         )
442:                         .frame(width: 60)
443:                         .background(theme.sidebarBackground.opacity(0.5))
444:                     }
445:                     
446:                     if tab.fileName.hasSuffix(".json") {
447:                         // JSON Tree View for .json files
448:                         JSONTreeView(data: text.data(using: .utf8) ?? Data())
449:                             .frame(maxWidth: .infinity, maxHeight: .infinity)
450:                             .background(theme.editorBackground)
451:                     } else {
452:                         SyntaxHighlightingTextView(
453:                             text: $text,
454:                             filename: tab.fileName,
455:                             scrollPosition: $scrollPosition,
456:                             totalLines: $totalLines,
457:                             visibleLines: $visibleLines,
458:                             currentLineNumber: $currentLineNumber,
459:                             currentColumn: $currentColumn,
460:                             cursorIndex: $cursorIndex,
461:                             lineHeight: $lineHeight,
462:                             isActive: true,
463:                             fontSize: editorCore.editorFontSize,
464:                             requestedLineSelection: $requestedLineSelection,
465:                             requestedCursorIndex: $requestedCursorIndex,
466:                             onAcceptAutocomplete: {
467:                                 guard showAutocomplete else { return false }
468:                                 var tempText = text
469:                                 var tempCursor = cursorIndex
470:                                 autocomplete.commitCurrentSuggestion(into: &tempText, cursorPosition: &tempCursor)
471:                                 if tempText != text {
472:                                     text = tempText
473:                                     cursorIndex = tempCursor
474:                                     requestedCursorIndex = tempCursor
475:                                     showAutocomplete = false
476:                                     return true
477:                                 }
478:                                 return false
479:                             },
480:                             onDismissAutocomplete: {
481:                                 guard showAutocomplete else { return false }
482:                                 autocomplete.hideSuggestions()
483:                                 showAutocomplete = false
484:                                 return true
485:                             }
486:                         )
487:                         .onChange(of: text) { newValue in
488:                             editorCore.updateActiveTabContent(newValue)
489:                             editorCore.cursorPosition = CursorPosition(line: currentLineNumber, column: currentColumn)
490:                             autocomplete.updateSuggestions(for: newValue, cursorPosition: cursorIndex)
491:                             showAutocomplete = autocomplete.showSuggestions
492:                             foldingManager.detectFoldableRegions(in: newValue)
493:                         }
494:                         .onChange(of: cursorIndex) { newCursor in
495:                             autocomplete.updateSuggestions(for: text, cursorPosition: newCursor)
496:                             showAutocomplete = autocomplete.showSuggestions
497:                         }
498:                     }
499:                     
500:                     if !tab.fileName.hasSuffix(".json") {
501:                         MinimapView(
502:                             content: text,
503:                             scrollOffset: CGFloat(scrollPosition) * lineHeight,
504:                             scrollViewHeight: geometry.size.height,
505:                             totalContentHeight: CGFloat(totalLines) * lineHeight,
506:                             onScrollRequested: { newOffset in
507:                                 // Minimap requested scroll - update editor position
508:                                 // Convert back from pixels to line number
509:                                 let newLine = Int(newOffset / lineHeight)
510:                                 scrollPosition = max(0, min(newLine, totalLines - 1))
511:                             }
512:                         )
513:                         .frame(width: 80)
514:                     }
515:                 }
516:                 .background(theme.editorBackground)
517: 
518:                 // Sticky Header Overlay (FEAT-040)
519:                 StickyHeaderView(
520:                     text: text,
521:                     currentLine: scrollPosition,
522:                     theme: theme,
523:                     lineHeight: lineHeight,
524:                     onSelect: { line in
525:                         requestedLineSelection = line
526:                     }
527:                 )
528:                 .padding(.leading, lineNumbersStyle != "off" ? 60 : 0)
529:                 .padding(.trailing, tab.fileName.hasSuffix(".json") ? 0 : 80)
530: 
531:                 if showAutocomplete && !autocomplete.suggestionItems.isEmpty {
532:                     AutocompletePopup(
533:                         suggestions: autocomplete.suggestionItems,
534:                         selectedIndex: autocomplete.selectedIndex,
535:                         theme: theme
536:                     ) { index in
537:                         autocomplete.selectedIndex = index
538:                         var tempText = text
539:                         var tempCursor = cursorIndex
540:                         autocomplete.commitCurrentSuggestion(into: &tempText, cursorPosition: &tempCursor)
541:                         if tempText != text {
542:                             text = tempText
543:                             cursorIndex = tempCursor
544:                             requestedCursorIndex = tempCursor
545:                         }
546:                         showAutocomplete = false
547:                     }
548:                     .offset(x: 70, y: CGFloat(currentLineNumber) * lineHeight)
549:                 }
550:             }
551:         }
552:         }
553:         .onAppear {
554:             text = tab.content
555:             foldingManager.detectFoldableRegions(in: text)
556:         }
557:         .onChange(of: tab.id) { _ in
558:             text = tab.content
559:             foldingManager.detectFoldableRegions(in: text)
560:         }
561:         .onChange(of: currentLineNumber) { line in
562:             editorCore.cursorPosition = CursorPosition(line: line, column: currentColumn)
563:         }
564:         .onChange(of: currentColumn) { col in
565:             editorCore.cursorPosition = CursorPosition(line: currentLineNumber, column: col)
566:         }
567:         .onAppear {
568:             findViewModel.editorCore = editorCore
569:         }
570:     }
571:     
572:     // Autocomplete insertion is handled by AutocompleteManager.acceptSuggestion(...)
573: }
574: 
575: // MARK: - Line Numbers with Folding
576: 
577: struct LineNumbersWithFolding: View {
578:     let fileId: String
579:     let totalLines: Int
580:     let currentLine: Int
581:     let scrollOffset: CGFloat
582:     let lineHeight: CGFloat
583:     @Binding var requestedLineSelection: Int?
584:     @ObservedObject var foldingManager: CodeFoldingManager
585:     @ObservedObject private var debugManager = DebugManager.shared
586:     let theme: Theme
587: 
588:     @AppStorage("lineNumbersStyle") private var lineNumbersStyle: String = "on"
589: 
590:     var body: some View {
591:         ScrollView(showsIndicators: false) {
592:             VStack(alignment: .trailing, spacing: 0) {
593:                 ForEach(0..<totalLines, id: \.self) { lineIndex in
594:                     if !foldingManager.isLineFolded(line: lineIndex) {
595:                         HStack(spacing: 2) {
596:                             Button(action: { debugManager.toggleBreakpoint(file: fileId, line: lineIndex) }) {
597:                                 Circle()
598:                                     .fill(debugManager.hasBreakpoint(file: fileId, line: lineIndex) ? Color.red : Color.clear)
599:                                     .overlay(
600:                                         Circle()
601:                                             .stroke(Color.red.opacity(0.6), lineWidth: 1)
602:                                             .opacity(debugManager.hasBreakpoint(file: fileId, line: lineIndex) ? 0 : 0.25)
603:                                     )
604:                                     .frame(width: 10, height: 10)
605:                                     .padding(.leading, 2)
606:                             }
607:                             .buttonStyle(.plain)
608:                             .frame(width: 14, height: lineHeight)
609: 
610:                             if foldingManager.isFoldable(line: lineIndex) {
611:                                 Button(action: { foldingManager.toggleFold(at: lineIndex) }) {
612:                                     Image(systemName: foldingManager.foldRegions.first(where: { $0.startLine == lineIndex })?.isFolded == true ? "chevron.right" : "chevron.down")
613:                                         .font(.system(size: 8))
614:                                         .foregroundColor(theme.lineNumber)
615:                                 }
616:                                 .buttonStyle(.plain)
617:                                 .frame(width: 14, height: lineHeight)
618:                             } else {
619:                                 Spacer().frame(width: 14)
620:                             }
621: 
622:                             Text(displayText(for: lineIndex))
623:                                 .font(.system(size: 12, design: .monospaced))
624:                                 .foregroundColor(lineIndex + 1 == currentLine ? theme.lineNumberActive : theme.lineNumber)
625:                                 .frame(height: lineHeight)
626:                                 .contentShape(Rectangle())
627:                                 .onTapGesture {
628:                                     // FEAT-041: click line number selects entire line
629:                                     requestedLineSelection = lineIndex
630:                                 }
631:                         }
632:                         .frame(maxWidth: .infinity, alignment: .trailing)
633:                         .padding(.trailing, 4)
634:                     }
635:                 }
636:             }
637:             .offset(y: -scrollOffset)
638:         }
639:     }
640: 
641:     private func displayText(for lineIndex: Int) -> String {
642:         switch lineNumbersStyle {
643:         case "relative":
644:             // VS Code-style: current line shows absolute, others show relative distance
645:             let lineNumber = lineIndex + 1
646:             if lineNumber == currentLine { return "\(lineNumber)" }
647:             return "\(abs(lineNumber - currentLine))"
648: 
649:         case "interval":
650:             let lineNumber = lineIndex + 1

---

[search]
No matches found for "LineNumberViewWithFolding("

---

[search]
Found 2 matches:
VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift:843: let onFoldTap: () -> Void
VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift:852: action: onFoldTap


>>>TOOL search
{"query":"getFoldedLineRanges", "glob":"VSCodeiPadOS/**/*"}
>>>END
>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift","start_line":1,"end_line":260}
>>>END
>>>TOOL search
{"query":"isLineFolded", "glob":"VSCodeiPadOS/**/*"}
>>>END
>>>END

---

## üîß TOOL RESULTS

[search]
Found 1 matches:
VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift:741: func getFoldedLineRanges() -> [ClosedRange<Int>] {

---

[read_file]
File: VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift (lines 2-260 of 1995)
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
2: //  SyntaxHighlightingTextView.swift
3: //  VSCodeiPadOS
4: //
5: //  Upgraded syntax highlighting with VSCode-like colors
6: //
7: 
8: import SwiftUI
9: import UIKit
10: 
11: /// UITextView wrapper with syntax highlighting support
12: struct SyntaxHighlightingTextView: UIViewRepresentable {
13:     @Binding var text: String
14:     let filename: String
15:     @Binding var scrollPosition: Int
16:     @Binding var totalLines: Int
17:     @Binding var visibleLines: Int
18:     @Binding var currentLineNumber: Int
19:     @Binding var currentColumn: Int
20:     @Binding var cursorIndex: Int
21:     @Binding var lineHeight: CGFloat
22:     @Binding var requestedLineSelection: Int?
23:     @Binding var requestedCursorIndex: Int?
24: 
25:     /// Autocomplete key handling hooks (return true if handled)
26:     let onAcceptAutocomplete: (() -> Bool)?
27:     let onDismissAutocomplete: (() -> Bool)?
28: 
29:     let isActive: Bool
30:     let fontSize: CGFloat  // Explicit parameter to trigger SwiftUI updates
31:     @EnvironmentObject var editorCore: EditorCore
32: 
33:     init(
34:         text: Binding<String>,
35:         filename: String,
36:         scrollPosition: Binding<Int>,
37:         totalLines: Binding<Int>,
38:         visibleLines: Binding<Int>,
39:         currentLineNumber: Binding<Int>,
40:         currentColumn: Binding<Int>,
41:         cursorIndex: Binding<Int> = .constant(0),
42:         lineHeight: Binding<CGFloat>,
43:         isActive: Bool,
44:         fontSize: CGFloat = 14.0,
45:         requestedLineSelection: Binding<Int?> = .constant(nil),
46:         requestedCursorIndex: Binding<Int?> = .constant(nil),
47:         onAcceptAutocomplete: (() -> Bool)? = nil,
48:         onDismissAutocomplete: (() -> Bool)? = nil
49:     ) {
50:         self._text = text
51:         self.filename = filename
52:         self._scrollPosition = scrollPosition
53:         self._totalLines = totalLines
54:         self._visibleLines = visibleLines
55:         self._currentLineNumber = currentLineNumber
56:         self._currentColumn = currentColumn
57:         self._cursorIndex = cursorIndex
58:         self._lineHeight = lineHeight
59:         self.isActive = isActive
60:         self.fontSize = fontSize
61:         self._requestedLineSelection = requestedLineSelection
62:         self._requestedCursorIndex = requestedCursorIndex
63:         self.onAcceptAutocomplete = onAcceptAutocomplete
64:         self.onDismissAutocomplete = onDismissAutocomplete
65:     }
66:     
67:     // Compatibility init for older call sites (e.g. SplitEditorView) that pass editorCore explicitly.
68:     init(
69:         text: Binding<String>,
70:         filename: String,
71:         scrollPosition: Binding<Int>,
72:         totalLines: Binding<Int>,
73:         visibleLines: Binding<Int>,
74:         currentLineNumber: Binding<Int>,
75:         currentColumn: Binding<Int>,
76:         cursorIndex: Binding<Int> = .constant(0),
77:         lineHeight: Binding<CGFloat>,
78:         isActive: Bool,
79:         editorCore: EditorCore,
80:         requestedLineSelection: Binding<Int?> = .constant(nil),
81:         requestedCursorIndex: Binding<Int?> = .constant(nil),
82:         onAcceptAutocomplete: (() -> Bool)? = nil,
83:         onDismissAutocomplete: (() -> Bool)? = nil
84:     ) {
85:         self.init(
86:             text: text,
87:             filename: filename,
88:             scrollPosition: scrollPosition,
89:             totalLines: totalLines,
90:             visibleLines: visibleLines,
91:             currentLineNumber: currentLineNumber,
92:             currentColumn: currentColumn,
93:             cursorIndex: cursorIndex,
94:             lineHeight: lineHeight,
95:             isActive: isActive,
96:             fontSize: editorCore.editorFontSize,
97:             requestedLineSelection: requestedLineSelection,
98:             requestedCursorIndex: requestedCursorIndex,
99:             onAcceptAutocomplete: onAcceptAutocomplete,
100:             onDismissAutocomplete: onDismissAutocomplete
101:         )
102:     }
103: 
104:     func makeCoordinator() -> Coordinator {
105:         Coordinator(self)
106:     }
107:     
108:     func makeUIView(context: Context) -> UITextView {
109:         let textView = EditorTextView()
110:         textView.delegate = context.coordinator
111: 
112:         // Autocomplete hooks
113:         textView.onAcceptAutocomplete = onAcceptAutocomplete
114:         textView.onDismissAutocomplete = onDismissAutocomplete
115: 
116:         textView.onPeekDefinition = {
117:             context.coordinator.handlePeekDefinition(in: textView)
118:         }
119: 
120:         textView.onEscape = {
121:             context.coordinator.handleEscape()
122:         }
123: 
124:         textView.onGoToLine = {
125:             self.editorCore.showGoToLine = true
126:         }
127:         
128:         // Wire up custom context menu actions
129:         textView.onGoToDefinition = {
130:             context.coordinator.handleGoToDefinition(in: textView)
131:         }
132:         
133:         textView.onFindReferences = {
134:             context.coordinator.handleFindReferences(in: textView)
135:         }
136:         
137:         textView.onFormatDocument = {
138:             context.coordinator.handleFormatDocument(in: textView)
139:         }
140:         
141:         textView.onToggleComment = {
142:             context.coordinator.handleToggleComment(in: textView)
143:         }
144:         
145:         textView.onFold = {
146:             context.coordinator.handleFold(in: textView)
147:         }
148:         
149:         textView.onUnfold = {
150:             context.coordinator.handleUnfold(in: textView)
151:         }
152:         
153:         // Add pinch gesture for zoom
154:         let pinchGesture = UIPinchGestureRecognizer(target: context.coordinator, action: #selector(Coordinator.handlePinch(_:)))
155:         textView.addGestureRecognizer(pinchGesture)
156:         context.coordinator.pinchGesture = pinchGesture
157:         
158:         // Configure text view
159:         textView.isEditable = true
160:         textView.isSelectable = true
161:         textView.autocapitalizationType = .none
162:         textView.autocorrectionType = .no
163:         textView.smartDashesType = .no
164:         textView.smartQuotesType = .no
165:         textView.smartInsertDeleteType = .no
166:         textView.spellCheckingType = .no
167:         
168:         // Set font and appearance (use editorCore.editorFontSize)
169:         textView.font = UIFont.monospacedSystemFont(ofSize: editorCore.editorFontSize, weight: .regular)
170:         textView.textColor = UIColor(ThemeManager.shared.currentTheme.editorForeground)
171:         textView.backgroundColor = UIColor(ThemeManager.shared.currentTheme.editorBackground)
172:         textView.keyboardType = .default
173:         textView.textContainerInset = UIEdgeInsets(top: 8, left: 8, bottom: 8, right: 8)
174:         
175:         // Enable line wrapping
176:         textView.textContainer.lineBreakMode = .byCharWrapping
177:         textView.textContainer.widthTracksTextView = true
178:         
179:         // Calculate line height
180:         if let font = textView.font {
181:             DispatchQueue.main.async {
182:                 self.lineHeight = font.lineHeight
183:             }
184:         }
185:         
186:         // Set initial text with syntax highlighting
187:         textView.text = text
188:         context.coordinator.applySyntaxHighlighting(to: textView)
189:         context.coordinator.updateLineCount(textView)
190:         
191:         return textView
192:     }
193:     
194:     func updateUIView(_ textView: UITextView, context: Context) {
195:         // CRITICAL: Update coordinator's parent reference to current struct
196:         // SwiftUI creates new struct instances on each update, so this keeps
197:         // coordinator in sync with current bindings and properties
198:         context.coordinator.parent = self
199:         
200:         // CRITICAL FIX: Apply initial highlighting FIRST on the very first updateUIView call
201:         // This fixes the bug where syntax highlighting only appears after typing.
202:         // makeUIView applies it, but the view may not be fully in hierarchy yet,
203:         // causing the attributed text to be lost. This ensures it's applied reliably.
204:         if !context.coordinator.hasAppliedInitialHighlighting && !textView.text.isEmpty {
205:             context.coordinator.applySyntaxHighlighting(to: textView)
206:             context.coordinator.hasAppliedInitialHighlighting = true
207:         }
208:         
209:         // Update colors when theme changes
210:         // NOTE: Only set backgroundColor and tintColor here. Do NOT set textColor
211:         // as it interferes with attributedText syntax highlighting colors.
212:         // The foreground color is handled entirely by the attributedText.
213:         textView.backgroundColor = UIColor(ThemeManager.shared.currentTheme.editorBackground)
214:         textView.tintColor = UIColor(ThemeManager.shared.currentTheme.cursor)
215:         
216:         if let editorView = textView as? EditorTextView {
217:             editorView.updateThemeColors(theme: ThemeManager.shared.currentTheme)
218:         }
219:         
220:         // Update font size if changed (using explicit fontSize parameter for proper SwiftUI updates)
221:         if let currentFont = textView.font, currentFont.pointSize != fontSize {
222:             let selectedRange = textView.selectedRange
223:             textView.font = UIFont.monospacedSystemFont(ofSize: fontSize, weight: .regular)
224:             context.coordinator.applySyntaxHighlighting(to: textView)
225:             textView.selectedRange = selectedRange
226:             
227:             // Update line height
228:             if let font = textView.font {
229:                 DispatchQueue.main.async {
230:                     self.lineHeight = font.lineHeight
231:                 }
232:             }
233:         }
234:         
235:         // Update text if changed externally
236:         if textView.text != text {
237:             let selectedRange = textView.selectedRange
238:             textView.text = text
239:             context.coordinator.applySyntaxHighlighting(to: textView)
240:             context.coordinator.hasAppliedInitialHighlighting = true
241:             textView.selectedRange = selectedRange
242:         } else if context.coordinator.lastThemeId != ThemeManager.shared.currentTheme.id {
243:             // Re-apply highlighting if theme changed
244:             context.coordinator.applySyntaxHighlighting(to: textView)
245:         }
246:         
247:         // Handle minimap scrolling - but ONLY if user is NOT actively scrolling
248:         // This prevents the editor from fighting against user scroll due to async binding lag
249:         if scrollPosition != context.coordinator.lastKnownScrollPosition && scrollPosition >= 0 && !context.coordinator.isUserScrolling {
250:             // Update lastKnownScrollPosition FIRST to prevent race condition
251:             // where user scroll gets overridden by stale binding value
252:             context.coordinator.lastKnownScrollPosition = scrollPosition
253:             context.coordinator.scrollToLine(scrollPosition, in: textView)
254:         }
255: 
256:         // Handle line selection requests (e.g. tapping line numbers)
257:         if let requested = requestedLineSelection,
258:            requested != context.coordinator.lastRequestedLineSelection {
259:             context.coordinator.lastRequestedLineSelection = requested
260:             context.coordinator.scrollToAndSelectLine(requested, in: textView)

---

[search]
Found 2 matches:
VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift:672: func isLineFolded(line: Int) -> Bool {
VSCodeiPadOS/VSCodeiPadOS/ContentView.swift:594: if !foldingManager.isLineFolded(line: lineIndex) {


>>>TOOL search
{"query":"getFoldedLineRanges()", "glob":"VSCodeiPadOS/VSCodeiPadOS/**/*"}
>>>END
>>>TOOL search
{"query":"collapsedLines", "glob":"VSCodeiPadOS/VSCodeiPadOS/**/*"}
>>>END
>>>TOOL search
{"query":"foldRegions", "glob":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor/**/*"}
>>>END
>>>TOOL search
{"query":"handleFold", "glob":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift"}
>>>END
>>>END

---

## üîß TOOL RESULTS

[search]
Found 1 matches:
VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift:741: func getFoldedLineRanges() -> [ClosedRange<Int>] {

---

[search]
Found 5 matches:
VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift:72: @Published var collapsedLines: Set<Int> = []
VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift:673: return collapsedLines.contains(line)
VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift:756: return collapsedLines.count
VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift:779: collapsedLines.removeAll()
VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift:783: collapsedLines.insert(line)

---

[search]
No matches found for "foldRegions"

---

[search]
Found 4 matches:
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:146: context.coordinator.handleFold(in: textView)
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:614: func handleFold(in textView: UITextView) {
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:932: action: #selector(handleFold)
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:1066: @objc func handleFold() {




>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift","start_line":560,"end_line":760}
>>>END
>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift","start_line":1000,"end_line":1120}
>>>END
>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift","start_line":120,"end_line":200}
>>>END
>>>END

---

## üîß TOOL RESULTS

[read_file]
File: VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift (lines 561-760 of 1995)
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
561:                 // For now, just trigger peek definition as a placeholder
562:                 parent.editorCore.triggerPeekDefinition(
563:                     file: parent.filename,
564:                     line: sourceLine,
565:                     content: text,
566:                     sourceLine: sourceLine
567:                 )
568:             }
569:         }
570:         
571:         func handleFormatDocument(in textView: UITextView) {
572:             // TODO: Implement format document functionality
573:             // This would typically call a formatter in EditorCore
574:             print("Format Document: Not yet implemented")
575:         }
576:         
577:         func handleToggleComment(in textView: UITextView) {
578:             guard let selectedRange = textView.selectedTextRange else { return }
579:             let text = textView.text ?? ""
580:             
581:             // Get the current line range
582:             if let lineRange = textView.tokenizer.rangeEnclosingPosition(selectedRange.start, with: .paragraph, inDirection: UITextDirection(rawValue: 1)) {
583:                 let location = textView.offset(from: textView.beginningOfDocument, to: lineRange.start)
584:                 let length = textView.offset(from: lineRange.start, to: lineRange.end)
585:                 let nsRange = NSRange(location: location, length: length)
586:                 
587:                 if nsRange.location + nsRange.length <= (text as NSString).length {
588:                     let lineText = (text as NSString).substring(with: nsRange)
589:                     let trimmed = lineText.trimmingCharacters(in: .whitespaces)
590:                     
591:                     // Check if line starts with a comment
592:                     let isCommented = trimmed.hasPrefix("//") || trimmed.hasPrefix("#") || trimmed.hasPrefix("/*")
593:                     
594:                     // Toggle comment
595:                     var newLineText: String
596:                     if isCommented {
597:                         // Remove comment
598:                         newLineText = lineText.replacingOccurrences(of: "//", with: "").replacingOccurrences(of: "#", with: "", options: .anchored)
599:                     } else {
600:                         // Add comment (use // for most languages)
601:                         newLineText = "//" + lineText
602:                     }
603:                     
604:                     // Replace the line
605:                     let textStorage = textView.textStorage
606:                     textStorage.replaceCharacters(in: nsRange, with: newLineText)
607:                     
608:                     // Update parent binding
609:                     parent.text = textView.text
610:                 }
611:             }
612:         }
613:         
614:         func handleFold(in textView: UITextView) {
615:             CodeFoldingManager.shared.foldCurrentLine()
616:         }
617:         
618:         func handleUnfold(in textView: UITextView) {
619:             CodeFoldingManager.shared.unfoldCurrentLine()
620:         }
621:         
622:         @objc func handlePinch(_ gesture: UIPinchGestureRecognizer) {
623:             guard let textView = gesture.view as? UITextView else { return }
624: 
625:             switch gesture.state {
626:             case .began:
627:                 // Store the initial font size when pinch begins
628:                 initialFontSize = parent.editorCore.editorFontSize
629: 
630:             case .changed:
631:                 // Calculate new font size based on pinch scale
632:                 let newSize = initialFontSize * gesture.scale
633: 
634:                 // Clamp font size between 8 and 32
635:                 let clampedSize = min(max(newSize, 8), 32)
636: 
637:                 // Update EditorCore's font size (this will trigger updateUIView)
638:                 parent.editorCore.editorFontSize = clampedSize
639: 
640:             case .ended, .cancelled:
641:                 // Optional: snap to nearest whole number or standard size
642:                 let finalSize = round(parent.editorCore.editorFontSize)
643:                 parent.editorCore.editorFontSize = min(max(finalSize, 8), 32)
644: 
645:             default:
646:                 break
647:             }
648:         }
649: 
650:         // MARK: - FEAT-044 Matching Bracket Highlight
651: 
652:         private func updateMatchingBracketHighlight(_ textView: UITextView) {
653:             // Clear any existing highlights
654:             if !bracketHighlightRanges.isEmpty {
655:                 for r in bracketHighlightRanges {
656:                     textView.textStorage.removeAttribute(.backgroundColor, range: r)
657:                     textView.textStorage.removeAttribute(.underlineStyle, range: r)
658:                 }
659:                 bracketHighlightRanges.removeAll()
660:             }
661: 
662:             // Only highlight when there's a caret (no selection)
663:             let selection = textView.selectedRange
664:             guard selection.length == 0 else { return }
665: 
666:             let nsText = (textView.text ?? "") as NSString
667:             let length = nsText.length
668:             guard length > 0 else { return }
669: 
670:             let caret = selection.location
671: 
672:             // Candidate bracket location: char before caret, else at caret
673:             let candidateIndices: [Int] = [
674:                 caret - 1,
675:                 caret
676:             ].filter { $0 >= 0 && $0 < length }
677: 
678:             func isBracket(_ c: unichar) -> Bool {
679:                 c == 123 || c == 125 || c == 40 || c == 41 || c == 91 || c == 93 // { } ( ) [ ]
680:             }
681: 
682:             var bracketIndex: Int?
683:             var bracketChar: unichar = 0
684: 
685:             for idx in candidateIndices {
686:                 let c = nsText.character(at: idx)
687:                 if isBracket(c) {
688:                     bracketIndex = idx
689:                     bracketChar = c
690:                     break
691:                 }
692:             }
693: 
694:             guard let idx = bracketIndex else { return }
695: 
696:             // Define bracket pairs
697:             let openToClose: [unichar: unichar] = [123: 125, 40: 41, 91: 93] // { -> }, ( -> ), [ -> ]
698:             let closeToOpen: [unichar: unichar] = [125: 123, 41: 40, 93: 91] // } -> {, ) -> (, ] -> [
699: 
700:             let theme = ThemeManager.shared.currentTheme
701:             let bg = UIColor(theme.selection).withAlphaComponent(theme.isDark ? 0.35 : 0.22)
702: 
703:             var matchIndex: Int?
704: 
705:             if let close = openToClose[bracketChar] {
706:                 // Opening bracket: scan forward
707:                 var depth = 0
708:                 var i = idx + 1
709:                 while i < length {
710:                     let c = nsText.character(at: i)
711:                     if c == bracketChar {
712:                         depth += 1
713:                     } else if c == close {
714:                         if depth == 0 {
715:                             matchIndex = i
716:                             break
717:                         } else {
718:                             depth -= 1
719:                         }
720:                     }
721:                     i += 1
722:                 }
723:             } else if let open = closeToOpen[bracketChar] {
724:                 // Closing bracket: scan backward
725:                 var depth = 0
726:                 var i = idx - 1
727:                 while i >= 0 {
728:                     let c = nsText.character(at: i)
729:                     if c == bracketChar {
730:                         depth += 1
731:                     } else if c == open {
732:                         if depth == 0 {
733:                             matchIndex = i
734:                             break
735:                         } else {
736:                             depth -= 1
737:                         }
738:                     }
739:                     i -= 1
740:                 }
741:             }
742: 
743:             guard let match = matchIndex else { return }
744: 
745:             let r1 = NSRange(location: idx, length: 1)
746:             let r2 = NSRange(location: match, length: 1)
747: 
748:             textView.textStorage.addAttribute(.backgroundColor, value: bg, range: r1)
749:             textView.textStorage.addAttribute(.backgroundColor, value: bg, range: r2)
750: 
751:             textView.textStorage.addAttribute(.underlineStyle, value: NSUnderlineStyle.single.rawValue, range: r1)
752:             textView.textStorage.addAttribute(.underlineStyle, value: NSUnderlineStyle.single.rawValue, range: r2)
753: 
754:             bracketHighlightRanges = [r1, r2]
755:         }
756:     }
757: }
758: 
759: // Custom text view to handle key commands, indent guides, and line highlighting
760: class EditorTextView: UITextView {

---

[read_file]
File: VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift (lines 1001-1120 of 1995)
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
1001:             action: #selector(handleSaveFile),
1002:             discoverabilityTitle: "Save"
1003:         ))
1004:         
1005:         // Close Tab: Cmd+W
1006:         let closeTabCmd = UIKeyCommand(
1007:             input: "w",
1008:             modifierFlags: .command,
1009:             action: #selector(handleCloseTab),
1010:             discoverabilityTitle: "Close Tab"
1011:         )
1012:         closeTabCmd.wantsPriorityOverSystemBehavior = true
1013:         commands.append(closeTabCmd)
1014:         
1015:         // Find: Cmd+F
1016:         let findCmd = UIKeyCommand(
1017:             input: "f",
1018:             modifierFlags: .command,
1019:             action: #selector(handleFind),
1020:             discoverabilityTitle: "Find"
1021:         )
1022:         findCmd.wantsPriorityOverSystemBehavior = true
1023:         commands.append(findCmd)
1024:         
1025:         // Zoom In: Cmd+=
1026:         commands.append(UIKeyCommand(
1027:             input: "=",
1028:             modifierFlags: .command,
1029:             action: #selector(handleZoomIn),
1030:             discoverabilityTitle: "Zoom In"
1031:         ))
1032:         
1033:         // Zoom Out: Cmd+-
1034:         commands.append(UIKeyCommand(
1035:             input: "-",
1036:             modifierFlags: .command,
1037:             action: #selector(handleZoomOut),
1038:             discoverabilityTitle: "Zoom Out"
1039:         ))
1040:         
1041:         return commands
1042:     }
1043:     
1044:     @objc func handlePeekDefinition() {
1045:         onPeekDefinition?()
1046:     }
1047: 
1048:     @objc func handleGoToLine() {
1049:         onGoToLine?()
1050:     }
1051: 
1052:     @objc func handleTab() {
1053:         if onAcceptAutocomplete?() == true {
1054:             return
1055:         }
1056:         insertText("\t")
1057:     }
1058:     
1059:     @objc func handleEscape() {
1060:         if onDismissAutocomplete?() == true {
1061:             return
1062:         }
1063:         onEscape?()
1064:     }
1065:     
1066:     @objc func handleFold() {
1067:         onFold?()
1068:     }
1069:     
1070:     @objc func handleUnfold() {
1071:         onUnfold?()
1072:     }
1073:     
1074:     // MARK: - App-Level Shortcut Handlers
1075:     
1076:     @objc func handleShowCommandPalette() {
1077:         NotificationCenter.default.post(name: NSNotification.Name("ShowCommandPalette"), object: nil)
1078:     }
1079:     
1080:     @objc func handleToggleTerminal() {
1081:         NotificationCenter.default.post(name: NSNotification.Name("ToggleTerminal"), object: nil)
1082:     }
1083:     
1084:     @objc func handleShowAIAssistant() {
1085:         NotificationCenter.default.post(name: NSNotification.Name("ShowAIAssistant"), object: nil)
1086:     }
1087:     
1088:     @objc func handleToggleSidebar() {
1089:         NotificationCenter.default.post(name: NSNotification.Name("ToggleSidebar"), object: nil)
1090:     }
1091:     
1092:     @objc func handleShowQuickOpen() {
1093:         NotificationCenter.default.post(name: NSNotification.Name("ShowQuickOpen"), object: nil)
1094:     }
1095:     
1096:     @objc func handleNewFile() {
1097:         NotificationCenter.default.post(name: NSNotification.Name("NewFile"), object: nil)
1098:     }
1099:     
1100:     @objc func handleSaveFile() {
1101:         NotificationCenter.default.post(name: NSNotification.Name("SaveFile"), object: nil)
1102:     }
1103:     
1104:     @objc func handleCloseTab() {
1105:         NotificationCenter.default.post(name: NSNotification.Name("CloseTab"), object: nil)
1106:     }
1107:     
1108:     @objc func handleFind() {
1109:         NotificationCenter.default.post(name: NSNotification.Name("ShowFind"), object: nil)
1110:     }
1111:     
1112:     @objc func handleZoomIn() {
1113:         NotificationCenter.default.post(name: NSNotification.Name("ZoomIn"), object: nil)
1114:     }
1115:     
1116:     @objc func handleZoomOut() {
1117:         NotificationCenter.default.post(name: NSNotification.Name("ZoomOut"), object: nil)
1118:     }
1119:     
1120:     // MARK: - Custom Actions

---

[read_file]
File: VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift (lines 121-200 of 1995)
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
121:             context.coordinator.handleEscape()
122:         }
123: 
124:         textView.onGoToLine = {
125:             self.editorCore.showGoToLine = true
126:         }
127:         
128:         // Wire up custom context menu actions
129:         textView.onGoToDefinition = {
130:             context.coordinator.handleGoToDefinition(in: textView)
131:         }
132:         
133:         textView.onFindReferences = {
134:             context.coordinator.handleFindReferences(in: textView)
135:         }
136:         
137:         textView.onFormatDocument = {
138:             context.coordinator.handleFormatDocument(in: textView)
139:         }
140:         
141:         textView.onToggleComment = {
142:             context.coordinator.handleToggleComment(in: textView)
143:         }
144:         
145:         textView.onFold = {
146:             context.coordinator.handleFold(in: textView)
147:         }
148:         
149:         textView.onUnfold = {
150:             context.coordinator.handleUnfold(in: textView)
151:         }
152:         
153:         // Add pinch gesture for zoom
154:         let pinchGesture = UIPinchGestureRecognizer(target: context.coordinator, action: #selector(Coordinator.handlePinch(_:)))
155:         textView.addGestureRecognizer(pinchGesture)
156:         context.coordinator.pinchGesture = pinchGesture
157:         
158:         // Configure text view
159:         textView.isEditable = true
160:         textView.isSelectable = true
161:         textView.autocapitalizationType = .none
162:         textView.autocorrectionType = .no
163:         textView.smartDashesType = .no
164:         textView.smartQuotesType = .no
165:         textView.smartInsertDeleteType = .no
166:         textView.spellCheckingType = .no
167:         
168:         // Set font and appearance (use editorCore.editorFontSize)
169:         textView.font = UIFont.monospacedSystemFont(ofSize: editorCore.editorFontSize, weight: .regular)
170:         textView.textColor = UIColor(ThemeManager.shared.currentTheme.editorForeground)
171:         textView.backgroundColor = UIColor(ThemeManager.shared.currentTheme.editorBackground)
172:         textView.keyboardType = .default
173:         textView.textContainerInset = UIEdgeInsets(top: 8, left: 8, bottom: 8, right: 8)
174:         
175:         // Enable line wrapping
176:         textView.textContainer.lineBreakMode = .byCharWrapping
177:         textView.textContainer.widthTracksTextView = true
178:         
179:         // Calculate line height
180:         if let font = textView.font {
181:             DispatchQueue.main.async {
182:                 self.lineHeight = font.lineHeight
183:             }
184:         }
185:         
186:         // Set initial text with syntax highlighting
187:         textView.text = text
188:         context.coordinator.applySyntaxHighlighting(to: textView)
189:         context.coordinator.updateLineCount(textView)
190:         
191:         return textView
192:     }
193:     
194:     func updateUIView(_ textView: UITextView, context: Context) {
195:         // CRITICAL: Update coordinator's parent reference to current struct
196:         // SwiftUI creates new struct instances on each update, so this keeps
197:         // coordinator in sync with current bindings and properties
198:         context.coordinator.parent = self
199:         
200:         // CRITICAL FIX: Apply initial highlighting FIRST on the very first updateUIView call


>>>TOOL search
{"query":"getFoldedLineRanges()", "glob":"VSCodeiPadOS/**/*"}
>>>END
>>>TOOL search
{"query":"collapsedLines", "glob":"VSCodeiPadOS/VSCodeiPadOS/**/*"}
>>>END
>>>TOOL search
{"query":"isLineFolded(line:", "glob":"VSCodeiPadOS/VSCodeiPadOS/**/*"}
>>>END
>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift","start_line":200,"end_line":420}
>>>END
>>>END

---

## üîß TOOL RESULTS

[search]
Found 1 matches:
VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift:741: func getFoldedLineRanges() -> [ClosedRange<Int>] {

---

[search]
Found 5 matches:
VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift:72: @Published var collapsedLines: Set<Int> = []
VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift:673: return collapsedLines.contains(line)
VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift:756: return collapsedLines.count
VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift:779: collapsedLines.removeAll()
VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift:783: collapsedLines.insert(line)

---

[search]
Found 2 matches:
VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift:672: func isLineFolded(line: Int) -> Bool {
VSCodeiPadOS/VSCodeiPadOS/ContentView.swift:594: if !foldingManager.isLineFolded(line: lineIndex) {

---

[read_file]
File: VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift (lines 201-420 of 1995)
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
201:         // This fixes the bug where syntax highlighting only appears after typing.
202:         // makeUIView applies it, but the view may not be fully in hierarchy yet,
203:         // causing the attributed text to be lost. This ensures it's applied reliably.
204:         if !context.coordinator.hasAppliedInitialHighlighting && !textView.text.isEmpty {
205:             context.coordinator.applySyntaxHighlighting(to: textView)
206:             context.coordinator.hasAppliedInitialHighlighting = true
207:         }
208:         
209:         // Update colors when theme changes
210:         // NOTE: Only set backgroundColor and tintColor here. Do NOT set textColor
211:         // as it interferes with attributedText syntax highlighting colors.
212:         // The foreground color is handled entirely by the attributedText.
213:         textView.backgroundColor = UIColor(ThemeManager.shared.currentTheme.editorBackground)
214:         textView.tintColor = UIColor(ThemeManager.shared.currentTheme.cursor)
215:         
216:         if let editorView = textView as? EditorTextView {
217:             editorView.updateThemeColors(theme: ThemeManager.shared.currentTheme)
218:         }
219:         
220:         // Update font size if changed (using explicit fontSize parameter for proper SwiftUI updates)
221:         if let currentFont = textView.font, currentFont.pointSize != fontSize {
222:             let selectedRange = textView.selectedRange
223:             textView.font = UIFont.monospacedSystemFont(ofSize: fontSize, weight: .regular)
224:             context.coordinator.applySyntaxHighlighting(to: textView)
225:             textView.selectedRange = selectedRange
226:             
227:             // Update line height
228:             if let font = textView.font {
229:                 DispatchQueue.main.async {
230:                     self.lineHeight = font.lineHeight
231:                 }
232:             }
233:         }
234:         
235:         // Update text if changed externally
236:         if textView.text != text {
237:             let selectedRange = textView.selectedRange
238:             textView.text = text
239:             context.coordinator.applySyntaxHighlighting(to: textView)
240:             context.coordinator.hasAppliedInitialHighlighting = true
241:             textView.selectedRange = selectedRange
242:         } else if context.coordinator.lastThemeId != ThemeManager.shared.currentTheme.id {
243:             // Re-apply highlighting if theme changed
244:             context.coordinator.applySyntaxHighlighting(to: textView)
245:         }
246:         
247:         // Handle minimap scrolling - but ONLY if user is NOT actively scrolling
248:         // This prevents the editor from fighting against user scroll due to async binding lag
249:         if scrollPosition != context.coordinator.lastKnownScrollPosition && scrollPosition >= 0 && !context.coordinator.isUserScrolling {
250:             // Update lastKnownScrollPosition FIRST to prevent race condition
251:             // where user scroll gets overridden by stale binding value
252:             context.coordinator.lastKnownScrollPosition = scrollPosition
253:             context.coordinator.scrollToLine(scrollPosition, in: textView)
254:         }
255: 
256:         // Handle line selection requests (e.g. tapping line numbers)
257:         if let requested = requestedLineSelection,
258:            requested != context.coordinator.lastRequestedLineSelection {
259:             context.coordinator.lastRequestedLineSelection = requested
260:             context.coordinator.scrollToAndSelectLine(requested, in: textView)
261:             // Defer @Binding update to avoid "Publishing changes from within view updates"
262:             DispatchQueue.main.async {
263:                 self.requestedLineSelection = nil
264:             }
265:         }
266: 
267:         // Handle cursor index requests (e.g. accepting autocomplete)
268:         if let requested = requestedCursorIndex,
269:            requested != context.coordinator.lastRequestedCursorIndex {
270:             context.coordinator.lastRequestedCursorIndex = requested
271:             textView.selectedRange = NSRange(location: max(0, requested), length: 0)
272:             // Defer @Binding update to avoid "Publishing changes from within view updates"
273:             DispatchQueue.main.async {
274:                 self.requestedCursorIndex = nil
275:             }
276: 
277:             // Update SwiftUI state
278:             context.coordinator.updateCursorPosition(textView)
279:             context.coordinator.updateScrollPosition(textView)
280:         }
281:         
282:         // Note: updateLineCount is called in textViewDidChange, no need to call here
283:         // as it causes unnecessary state churn on every updateUIView
284:     }
285:     
286:     // MARK: - Coordinator
287:     
288:     class Coordinator: NSObject, UITextViewDelegate {
289:         var parent: SyntaxHighlightingTextView
290:         var lastKnownScrollPosition: Int = 0
291:         var lastThemeId: String = ""
292:         var lastRequestedLineSelection: Int? = nil
293:         var lastRequestedCursorIndex: Int? = nil
294:         private var isUpdatingFromMinimap = false
295:         private var highlightDebouncer: Timer?
296:         weak var pinchGesture: UIPinchGestureRecognizer?
297:         private var initialFontSize: CGFloat = 0
298:         
299:         // Track user scroll to prevent programmatic scroll fighting back
300:         private var userScrollDebouncer: Timer?
301:         var isUserScrolling = false
302: 
303:         // FEAT-044: Matching bracket highlight state
304:         private var bracketHighlightRanges: [NSRange] = []
305:         
306:         // Track if initial highlighting has been applied (fixes highlighting not appearing on file open)
307:         var hasAppliedInitialHighlighting = false
308:         
309:         init(_ parent: SyntaxHighlightingTextView) {
310:             self.parent = parent
311:         }
312:         
313:         func textViewDidBeginEditing(_ textView: UITextView) {
314:             // Ensure syntax highlighting is current when user begins editing
315:             // This handles cases where text was set but highlighting hasn't run yet
316:             applySyntaxHighlighting(to: textView)
317:         }
318:         
319:         func textViewDidChange(_ textView: UITextView) {
320:             // Update parent text
321:             parent.text = textView.text
322:             
323:             // Set typing attributes IMMEDIATELY so new characters have proper base styling
324:             // This prevents flicker during the debounce period
325:             let theme = ThemeManager.shared.currentTheme
326:             let fontSize = parent.editorCore.editorFontSize
327:             textView.typingAttributes = [
328:                 .font: UIFont.monospacedSystemFont(ofSize: fontSize, weight: .regular),
329:                 .foregroundColor: UIColor(theme.editorForeground)
330:             ]
331:             
332:             // Debounced syntax highlighting for performance (reduced from 0.15s to 0.08s)
333:             highlightDebouncer?.invalidate()
334:             highlightDebouncer = Timer.scheduledTimer(withTimeInterval: 0.08, repeats: false) { [weak self] _ in
335:                 DispatchQueue.main.async {
336:                     self?.applySyntaxHighlighting(to: textView)
337:                 }
338:             }
339:             
340:             updateLineCount(textView)
341:             updateCursorPosition(textView)
342:         }
343:         
344:         func textViewDidChangeSelection(_ textView: UITextView) {
345:             if !isUpdatingFromMinimap {
346:                 updateCursorPosition(textView)
347:                 updateScrollPosition(textView)
348: 
349:                 // FEAT-044: Matching bracket highlight
350:                 updateMatchingBracketHighlight(textView)
351: 
352:                 // Trigger redraw so current-line highlight/indent guides track the caret
353:                 (textView as? EditorTextView)?.setNeedsDisplay()
354: 
355:                 // Update selection in EditorCore for multi-cursor support
356:                 let range = textView.selectedRange
357:                 parent.editorCore.updateSelection(range: range, text: textView.text ?? "")
358: 
359:                 // If user clicks elsewhere (not multi-cursor operation), reset to single cursor
360:                 if !parent.editorCore.multiCursorState.isMultiCursor {
361:                     parent.editorCore.multiCursorState.reset(to: range.location + range.length)
362:                 }
363:             }
364:         }
365:         
366:         // MARK: - UIScrollViewDelegate methods for reliable user scroll detection
367:         
368:         func scrollViewWillBeginDragging(_ scrollView: UIScrollView) {
369:             // User started dragging - set flag immediately to prevent programmatic scroll fighting
370:             isUserScrolling = true
371:             userScrollDebouncer?.invalidate()
372:         }
373:         
374:         func scrollViewDidEndDragging(_ scrollView: UIScrollView, willDecelerate decelerate: Bool) {
375:             // If not decelerating, user stopped scrolling
376:             if !decelerate {
377:                 // Small delay to let any final scroll events settle
378:                 userScrollDebouncer?.invalidate()
379:                 userScrollDebouncer = Timer.scheduledTimer(withTimeInterval: 0.15, repeats: false) { [weak self] _ in
380:                     self?.isUserScrolling = false
381:                 }
382:             }
383:         }
384:         
385:         func scrollViewDidEndDecelerating(_ scrollView: UIScrollView) {
386:             // Deceleration finished - user scroll is complete
387:             userScrollDebouncer?.invalidate()
388:             userScrollDebouncer = Timer.scheduledTimer(withTimeInterval: 0.15, repeats: false) { [weak self] _ in
389:                 self?.isUserScrolling = false
390:             }
391:         }
392:         
393:         func scrollViewDidScroll(_ scrollView: UIScrollView) {
394:             guard let textView = scrollView as? UITextView, !isUpdatingFromMinimap else { return }
395:             
396:             // Note: isUserScrolling is now set by scrollViewWillBeginDragging for reliable detection
397:             // We still use debouncer as a fallback for edge cases
398:             if isUserScrolling {
399:                 userScrollDebouncer?.invalidate()
400:                 userScrollDebouncer = Timer.scheduledTimer(withTimeInterval: 0.3, repeats: false) { [weak self] _ in
401:                     self?.isUserScrolling = false
402:                 }
403:             }
404:             
405:             updateScrollPosition(textView)
406:         }
407:         
408:         func updateLineCount(_ textView: UITextView) {
409:             let lines = textView.text.components(separatedBy: .newlines)
410:             DispatchQueue.main.async {
411:                 self.parent.totalLines = max(1, lines.count)
412:             }
413:         }
414:         
415:         func updateCursorPosition(_ textView: UITextView) {
416:             guard let selectedRange = textView.selectedTextRange else { return }
417:              let cursorPosition = textView.offset(from: textView.beginningOfDocument, to: selectedRange.start)
418:              
419:              let text = textView.text ?? ""
420:              let prefix = String(text.prefix(cursorPosition))


>>>TOOL search
{"query":"getFoldedLineRanges", "glob":"VSCodeiPadOS/VSCodeiPadOS/**/*"}
>>>END
>>>TOOL search
{"query":"foldedLineRanges", "glob":"VSCodeiPadOS/VSCodeiPadOS/**/*"}
>>>END
>>>TOOL search
{"query":"isLineFolded(", "glob":"VSCodeiPadOS/VSCodeiPadOS/**/*"}
>>>END
>>>TOOL search
{"query":"foldingManager", "glob":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor/**/*"}
>>>END
>>>END

---

## üîß TOOL RESULTS

[search]
Found 1 matches:
VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift:741: func getFoldedLineRanges() -> [ClosedRange<Int>] {

---

[search]
No matches found for "foldedLineRanges"

---

[search]
Found 2 matches:
VSCodeiPadOS/VSCodeiPadOS/ContentView.swift:594: if !foldingManager.isLineFolded(line: lineIndex) {
VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift:672: func isLineFolded(line: Int) -> Bool {

---

[search]
Found 4 matches:
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SplitEditorView.swift:489: @ObservedObject private var foldingManager = CodeFoldingManager.shared
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SplitEditorView.swift:516: if foldingManager.isFoldable(fileId: fileId, line: lineIndex) {
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SplitEditorView.swift:518: foldingManager.toggleFold(fileId: fileId, line: lineIndex)
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SplitEditorView.swift:520: Image(systemName: foldingManager.isFolded(fileId: fileId, line: lineIndex) ? "chevron.right" : "chevron.down")


>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SplitEditorView.swift","start_line":450,"end_line":580}
>>>END
>>>END

---

## üîß TOOL RESULTS

[read_file]
File: VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SplitEditorView.swift (lines 451-580 of 774)
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
451:             RoundedRectangle(cornerRadius: 4)
452:                 .fill(isSelected ? Color(UIColor.systemBackground) : Color.clear)
453:         )
454:         .opacity(isDragging ? 0.5 : 1.0)
455:         .onTapGesture {
456:             pane.selectTab(id: tab.id)
457:             splitManager.activePaneId = pane.id
458:         }
459:         .onDrag {
460:             isDragging = true
461:             return NSItemProvider(object: tab.id.uuidString as NSString)
462:         }
463:         .contextMenu {
464:             Button(action: { pane.closeTab(id: tab.id) }) {
465:                 Label("Close", systemImage: "xmark")
466:             }
467:             
468:             Divider()
469:             
470:             Button(action: { splitManager.moveTabToNewSplit(tab: tab, fromPaneId: pane.id, direction: .horizontal) }) {
471:                 Label("Move to Split Right", systemImage: "rectangle.split.2x1")
472:             }
473:             
474:             Button(action: { splitManager.moveTabToNewSplit(tab: tab, fromPaneId: pane.id, direction: .vertical) }) {
475:                 Label("Move to Split Down", systemImage: "rectangle.split.1x2")
476:             }
477:         }
478:     }
479: }
480: 
481: // MARK: - Pane Editor View
482: 
483: struct PaneEditorView: View {
484:     @ObservedObject var pane: EditorPane
485:     let tab: Tab
486:     @ObservedObject var splitManager: SplitEditorManager
487:     @ObservedObject var editorCore: EditorCore
488:     @ObservedObject private var debugManager = DebugManager.shared
489:     @ObservedObject private var foldingManager = CodeFoldingManager.shared
490:     @State private var text: String = ""
491:     @State private var scrollPosition: Int = 0
492:     @State private var totalLines: Int = 1
493:     @State private var visibleLines: Int = 20
494:     @State private var currentLineNumber: Int = 1
495:     @State private var currentColumn: Int = 1
496:     @State private var lineHeight: CGFloat = 17
497:     @State private var requestedLineSelection: Int? = nil
498: 
499:     @AppStorage("lineNumbersStyle") private var lineNumbersStyle: String = "on"
500:     
501:     private var fileId: String { tab.url?.path ?? tab.fileName }
502:     
503:     var body: some View {
504:         GeometryReader { geometry in
505:             HStack(spacing: 0) {
506:                 // Line numbers + breakpoints + code folding (gutter)
507:                 //
508:                 // IMPORTANT: keep gutter in sync with the editor scroll position. The gutter ScrollView
509:                 // is scroll-disabled, and we offset the content to match the editor's scroll.
510:                 if lineNumbersStyle != "off" {
511:                     ScrollView(showsIndicators: false) {
512:                         VStack(alignment: .trailing, spacing: 0) {
513:                             ForEach(0..<totalLines, id: \ .self) { lineIndex in
514:                                 HStack(spacing: 2) {
515:                                     // Fold chevron icon
516:                                     if foldingManager.isFoldable(fileId: fileId, line: lineIndex) {
517:                                         Button(action: { 
518:                                             foldingManager.toggleFold(fileId: fileId, line: lineIndex)
519:                                         }) {
520:                                             Image(systemName: foldingManager.isFolded(fileId: fileId, line: lineIndex) ? "chevron.right" : "chevron.down")
521:                                                 .font(.system(size: 10, weight: .regular))
522:                                                 .foregroundColor(.secondary.opacity(0.8))
523:                                                 .frame(width: 12, height: lineHeight)
524:                                         }
525:                                         .buttonStyle(.plain)
526:                                     } else {
527:                                         // Spacer for alignment
528:                                         Spacer()
529:                                             .frame(width: 12)
530:                                     }
531:                                     
532:                                     // Breakpoint indicator
533:                                     Button(action: { debugManager.toggleBreakpoint(file: fileId, line: lineIndex) }) {
534:                                         Circle()
535:                                             .fill(debugManager.hasBreakpoint(file: fileId, line: lineIndex) ? Color.red : Color.clear)
536:                                             .overlay(
537:                                                 Circle()
538:                                                     .stroke(Color.red.opacity(0.6), lineWidth: 1)
539:                                                     .opacity(debugManager.hasBreakpoint(file: fileId, line: lineIndex) ? 0 : 0.25)
540:                                             )
541:                                             .frame(width: 10, height: 10)
542:                                     }
543:                                     .buttonStyle(.plain)
544:                                     .frame(width: 14, height: lineHeight)
545: 
546:                                     Text(displayText(for: lineIndex))
547:                                         .font(.system(size: 12, design: .monospaced))
548:                                         .foregroundColor(lineIndex + 1 == currentLineNumber ? .primary : .secondary.opacity(0.6))
549:                                         .frame(height: lineHeight)
550:                                         .contentShape(Rectangle())
551:                                         .onTapGesture {
552:                                             requestedLineSelection = lineIndex
553:                                         }
554:                                 }
555:                                 .frame(maxWidth: .infinity, alignment: .trailing)
556:                             }
557:                         }
558:                         .padding(.trailing, 4)
559:                         .offset(y: -CGFloat(scrollPosition) * lineHeight)
560:                     }
561:                     .frame(width: 70)
562:                     .background(Color(UIColor.secondarySystemBackground).opacity(0.5))
563:                 }
564: 
565:                 // Editor
566:                 SyntaxHighlightingTextView(
567:                     text: $text,
568:                     filename: tab.fileName,
569:                     scrollPosition: $scrollPosition,
570:                     totalLines: $totalLines,
571:                     visibleLines: $visibleLines,
572:                     currentLineNumber: $currentLineNumber,
573:                     currentColumn: $currentColumn,
574:                     lineHeight: $lineHeight,
575:                     isActive: splitManager.activePaneId == pane.id,
576:                     editorCore: editorCore,
577:                     requestedLineSelection: $requestedLineSelection
578:                 )
579:                 .onChange(of: text) { newValue in
580:                     pane.updateTabContent(newValue)


>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SplitEditorView.swift","start_line":579,"end_line":720}
>>>END
>>>END

---

## üîß TOOL RESULTS

[read_file]
File: VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SplitEditorView.swift (lines 580-720 of 774)
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
580:                     pane.updateTabContent(newValue)
581:                     
582:                     // Sync scroll if enabled
583:                     if splitManager.syncScroll {
584:                         splitManager.syncScrollOffset(CGFloat(scrollPosition) * lineHeight, fromPaneId: pane.id)
585:                     }
586:                 }
587:                 
588:                 // Mini minimap
589:                 MinimapView(
590:                     content: text,
591:                     scrollOffset: CGFloat(scrollPosition) * lineHeight,
592:                     scrollViewHeight: geometry.size.height,
593:                     totalContentHeight: CGFloat(totalLines) * lineHeight
594:                 )
595:                 .frame(width: 60)
596:             }
597:             // Sticky Header Overlay (FEAT-040)
598:             StickyHeaderView(
599:                 text: text,
600:                 currentLine: scrollPosition, // Using scrollPosition as approximate top line
601:                 theme: ThemeManager.shared.currentTheme,
602:                 lineHeight: lineHeight,
603:                 onSelect: { line in
604:                     requestedLineSelection = line
605:                 }
606:             )
607:             .padding(.leading, 70) // Offset for line numbers + folding icons
608:             .padding(.trailing, 60) // Offset for minimap
609:             
610:             // Peek Definition Overlay
611:             if let peekState = editorCore.peekState, editorCore.activeTabId == tab.id {
612:                  // Calculate simplified position: center of screen for now, but conceptually "inline"
613:                  // To make it truly inline, we'd need more complex geometry, but overlay is a good start.
614:                  VStack {
615:                      Spacer()
616:                          .frame(height: max(0, CGFloat(peekState.sourceLine - scrollPosition) * lineHeight + lineHeight + 20))
617:                      
618:                      PeekDefinitionView(
619:                          editorCore: editorCore,
620:                          targetFile: peekState.file,
621:                          targetLine: peekState.line,
622:                          content: peekState.content,
623:                          onClose: { editorCore.closePeekDefinition() },
624:                          onOpen: {
625:                              editorCore.openFile(FileItem(name: URL(fileURLWithPath: peekState.file).lastPathComponent, path: peekState.file, isDirectory: false))
626:                              editorCore.closePeekDefinition()
627:                          }
628:                      )
629:                      .padding(.horizontal)
630:                      .padding(.bottom, 20)
631:                      
632:                      Spacer()
633:                  }
634:                  .frame(maxWidth: .infinity, maxHeight: .infinity, alignment: .top)
635:                  .background(Color.black.opacity(0.01)) // Capture taps outside if needed, or let them pass
636:                  .transition(.opacity)
637:                  .zIndex(100)
638:             }
639:         }
640:         .onAppear {
641:             text = tab.content
642:         }
643:         .onChange(of: tab.id) { _ in
644:             text = tab.content
645:         }
646:         .onChange(of: pane.scrollOffset) { newOffset in
647:             if splitManager.syncScroll {
648:                 scrollPosition = Int(newOffset / lineHeight)
649:             }
650:         }
651:     }
652:     
653:     private func displayText(for lineIndex: Int) -> String {
654:         switch lineNumbersStyle {
655:         case "relative":
656:             let lineNumber = lineIndex + 1
657:             if lineNumber == currentLineNumber { return "\(lineNumber)" }
658:             return "\(abs(lineNumber - currentLineNumber))"
659:         case "interval":
660:             let lineNumber = lineIndex + 1
661:             return (lineNumber == 1 || lineNumber % 5 == 0) ? "\(lineNumber)" : ""
662:         default:
663:             return "\(lineIndex + 1)"
664:         }
665:     }
666: }
667: 
668: // MARK: - Split Drag Handle
669: 
670: struct SplitDragHandle: View {
671:     let direction: SplitDirection
672:     let onDrag: (CGFloat) -> Void
673:     
674:     @State private var isDragging = false
675:     @GestureState private var dragOffset: CGFloat = 0
676:     
677:     var body: some View {
678:         ZStack {
679:             // Background
680:             Rectangle()
681:                 .fill(Color(UIColor.separator))
682:             
683:             // Handle indicator
684:             if direction == .horizontal {
685:                 VStack(spacing: 2) {
686:                     ForEach(0..<3, id: \.self) { _ in
687:                         Circle()
688:                             .fill(isDragging ? Color.accentColor : Color.secondary)
689:                             .frame(width: 3, height: 3)
690:                     }
691:                 }
692:             } else {
693:                 HStack(spacing: 2) {
694:                     ForEach(0..<3, id: \.self) { _ in
695:                         Circle()
696:                             .fill(isDragging ? Color.accentColor : Color.secondary)
697:                             .frame(width: 3, height: 3)
698:                     }
699:                 }
700:             }
701:         }
702:         .frame(
703:             width: direction == .horizontal ? 6 : nil,
704:             height: direction == .vertical ? 6 : nil
705:         )
706:         .contentShape(Rectangle())
707:         .gesture(
708:             DragGesture()
709:                 .updating($dragOffset) { value, state, _ in
710:                     let delta = direction == .horizontal ? value.translation.width : value.translation.height
711:                     state = delta
712:                 }
713:                 .onChanged { value in
714:                     isDragging = true
715:                     let delta = direction == .horizontal ? value.translation.width : value.translation.height
716:                     onDrag(delta)
717:                 }
718:                 .onEnded { _ in
719:                     isDragging = false
720:                 }


>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SplitEditorView.swift","start_line":470,"end_line":560}
>>>END
>>>END

---

## üîß TOOL RESULTS

[read_file]
File: VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SplitEditorView.swift (lines 471-560 of 774)
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
471:                 Label("Move to Split Right", systemImage: "rectangle.split.2x1")
472:             }
473:             
474:             Button(action: { splitManager.moveTabToNewSplit(tab: tab, fromPaneId: pane.id, direction: .vertical) }) {
475:                 Label("Move to Split Down", systemImage: "rectangle.split.1x2")
476:             }
477:         }
478:     }
479: }
480: 
481: // MARK: - Pane Editor View
482: 
483: struct PaneEditorView: View {
484:     @ObservedObject var pane: EditorPane
485:     let tab: Tab
486:     @ObservedObject var splitManager: SplitEditorManager
487:     @ObservedObject var editorCore: EditorCore
488:     @ObservedObject private var debugManager = DebugManager.shared
489:     @ObservedObject private var foldingManager = CodeFoldingManager.shared
490:     @State private var text: String = ""
491:     @State private var scrollPosition: Int = 0
492:     @State private var totalLines: Int = 1
493:     @State private var visibleLines: Int = 20
494:     @State private var currentLineNumber: Int = 1
495:     @State private var currentColumn: Int = 1
496:     @State private var lineHeight: CGFloat = 17
497:     @State private var requestedLineSelection: Int? = nil
498: 
499:     @AppStorage("lineNumbersStyle") private var lineNumbersStyle: String = "on"
500:     
501:     private var fileId: String { tab.url?.path ?? tab.fileName }
502:     
503:     var body: some View {
504:         GeometryReader { geometry in
505:             HStack(spacing: 0) {
506:                 // Line numbers + breakpoints + code folding (gutter)
507:                 //
508:                 // IMPORTANT: keep gutter in sync with the editor scroll position. The gutter ScrollView
509:                 // is scroll-disabled, and we offset the content to match the editor's scroll.
510:                 if lineNumbersStyle != "off" {
511:                     ScrollView(showsIndicators: false) {
512:                         VStack(alignment: .trailing, spacing: 0) {
513:                             ForEach(0..<totalLines, id: \ .self) { lineIndex in
514:                                 HStack(spacing: 2) {
515:                                     // Fold chevron icon
516:                                     if foldingManager.isFoldable(fileId: fileId, line: lineIndex) {
517:                                         Button(action: { 
518:                                             foldingManager.toggleFold(fileId: fileId, line: lineIndex)
519:                                         }) {
520:                                             Image(systemName: foldingManager.isFolded(fileId: fileId, line: lineIndex) ? "chevron.right" : "chevron.down")
521:                                                 .font(.system(size: 10, weight: .regular))
522:                                                 .foregroundColor(.secondary.opacity(0.8))
523:                                                 .frame(width: 12, height: lineHeight)
524:                                         }
525:                                         .buttonStyle(.plain)
526:                                     } else {
527:                                         // Spacer for alignment
528:                                         Spacer()
529:                                             .frame(width: 12)
530:                                     }
531:                                     
532:                                     // Breakpoint indicator
533:                                     Button(action: { debugManager.toggleBreakpoint(file: fileId, line: lineIndex) }) {
534:                                         Circle()
535:                                             .fill(debugManager.hasBreakpoint(file: fileId, line: lineIndex) ? Color.red : Color.clear)
536:                                             .overlay(
537:                                                 Circle()
538:                                                     .stroke(Color.red.opacity(0.6), lineWidth: 1)
539:                                                     .opacity(debugManager.hasBreakpoint(file: fileId, line: lineIndex) ? 0 : 0.25)
540:                                             )
541:                                             .frame(width: 10, height: 10)
542:                                     }
543:                                     .buttonStyle(.plain)
544:                                     .frame(width: 14, height: lineHeight)
545: 
546:                                     Text(displayText(for: lineIndex))
547:                                         .font(.system(size: 12, design: .monospaced))
548:                                         .foregroundColor(lineIndex + 1 == currentLineNumber ? .primary : .secondary.opacity(0.6))
549:                                         .frame(height: lineHeight)
550:                                         .contentShape(Rectangle())
551:                                         .onTapGesture {
552:                                             requestedLineSelection = lineIndex
553:                                         }
554:                                 }
555:                                 .frame(maxWidth: .infinity, alignment: .trailing)
556:                             }
557:                         }
558:                         .padding(.trailing, 4)
559:                         .offset(y: -CGFloat(scrollPosition) * lineHeight)
560:                     }


>>>TOOL search
{"query":"detectFoldableRegions(", "glob":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SplitEditorView.swift"}
>>>END
>>>TOOL search
{"query":"CodeFoldingManager", "glob":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift"}
>>>END
>>>TOOL search
{"query":"isLineFolded", "glob":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor/**/*"}
>>>END
>>>TOOL search
{"query":"folding", "glob":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift"}
>>>END
>>>END

---

## üîß TOOL RESULTS

[search]
No matches found for "detectFoldableRegions("

---

[search]
Found 2 matches:
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:615: CodeFoldingManager.shared.foldCurrentLine()
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:619: CodeFoldingManager.shared.unfoldCurrentLine()

---

[search]
No matches found for "isLineFolded"

---

[search]
No matches found for "folding"


>>>TOOL search
{"query":"collapsedLines", "glob":"VSCodeiPadOS/VSCodeiPadOS/**/*"}
>>>END
>>>TOOL search
{"query":"getFoldedLineRanges()", "glob":"VSCodeiPadOS/VSCodeiPadOS/**/*"}
>>>END
>>>TOOL search
{"query":"foldRegionsByFile", "glob":"VSCodeiPadOS/VSCodeiPadOS/**/*"}
>>>END
>>>END

---

## üîß TOOL RESULTS

[search]
Found 5 matches:
VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift:72: @Published var collapsedLines: Set<Int> = []
VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift:673: return collapsedLines.contains(line)
VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift:756: return collapsedLines.count
VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift:779: collapsedLines.removeAll()
VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift:783: collapsedLines.insert(line)

---

[search]
Found 1 matches:
VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift:741: func getFoldedLineRanges() -> [ClosedRange<Int>] {

---

[search]
Found 10 matches:
VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift:75: private var foldRegionsByFile: [String: [FoldRegion]] = [:]
VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift:235: foldRegionsByFile[fileId] = regions
VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift:467: if let fileId = currentFileId, let storedRegions = foldRegionsByFile[fileId] {
VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift:695: guard let regions = foldRegionsByFile[fileId] else { return false }
VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift:701: guard let regions = foldRegionsByFile[fileId] else { return false }
VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift:707: guard var regions = foldRegionsByFile[fileId] else { return }
VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift:711: foldRegionsByFile[fileId] = regions
VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift:726: return foldRegionsByFile[fileId] ?? []
VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift:731: foldRegionsByFile.removeValue(forKey: fileId)
VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift:736: foldRegionsByFile.removeAll()


>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/ContentView.swift","start_line":1,"end_line":120}
>>>END
>>>TOOL search
{"query":"foldingManager = CodeFoldingManager", "glob":"VSCodeiPadOS/VSCodeiPadOS/ContentView.swift"}
>>>END
>>>END

---

## üîß TOOL RESULTS

[read_file]
File: VSCodeiPadOS/VSCodeiPadOS/ContentView.swift (lines 2-120 of 1064)
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
2: import UIKit
3: import UniformTypeIdentifiers
4: 
5: // MARK: - Helper Functions
6: // Moved to Extensions/FileHelpers.swift
7: 
8: // MARK: - Main Content View
9: 
10: struct ContentView: View {
11:     @EnvironmentObject var editorCore: EditorCore
12:     @StateObject private var fileNavigator = FileSystemNavigator()
13:     @StateObject private var themeManager = ThemeManager.shared
14:     
15:     @State private var showingDocumentPicker = false
16:     @State private var showingFolderPicker = false
17:     @State private var showSettings = false
18:     @State private var showTerminal = false
19:     @State private var terminalHeight: CGFloat = 200
20:     @State private var selectedSidebarTab = 0
21:     @State private var pendingTrustURL: URL?
22:     @State private var windowTitle: String = "VS Code"
23:     
24:     @StateObject private var trustManager = WorkspaceTrustManager.shared
25:     
26:     private var theme: Theme { themeManager.currentTheme }
27:     
28:     var body: some View {
29:         ZStack {
30:             VStack(spacing: 0) {
31:                 HStack(spacing: 0) {
32:                     IDEActivityBar(editorCore: editorCore, selectedTab: $selectedSidebarTab, showSettings: $showSettings, showTerminal: $showTerminal)
33:                     
34:                     if editorCore.showSidebar {
35:                         sidebarContent.frame(width: editorCore.sidebarWidth)
36:                     }
37:                     
38:                     VStack(spacing: 0) {
39:                         IDETabBar(editorCore: editorCore, theme: theme)
40:                         
41:                         if let tab = editorCore.activeTab {
42:                             IDEEditorView(editorCore: editorCore, tab: tab, theme: theme)
43:                                 .id(tab.id)  // Force view recreation when tab changes
44:                         } else {
45:                             IDEWelcomeView(editorCore: editorCore, showFolderPicker: $showingFolderPicker, theme: theme)
46:                         }
47:                         
48:                         StatusBarView(editorCore: editorCore)
49:                     }
50:                 }
51:                 
52:                 if showTerminal {
53:                     PanelView(isVisible: $showTerminal, height: $terminalHeight)
54:                 }
55:             }
56:             .background(theme.editorBackground)
57:             
58:             // Overlays - Command Palette (Cmd+Shift+P)
59:             if editorCore.showCommandPalette {
60:                 Color.black.opacity(0.4).ignoresSafeArea().onTapGesture { editorCore.showCommandPalette = false }
61:                 CommandPaletteView(editorCore: editorCore, showSettings: $showSettings, showTerminal: $showTerminal)
62:             }
63:             
64:             // Quick Open (Cmd+P)
65:             if editorCore.showQuickOpen {
66:                 Color.black.opacity(0.4).ignoresSafeArea().onTapGesture { editorCore.showQuickOpen = false }
67:                 QuickOpenView(editorCore: editorCore, fileNavigator: fileNavigator)
68:             }
69:             
70:             // Go To Symbol (Cmd+Shift+O)
71:             if editorCore.showGoToSymbol {
72:                 Color.black.opacity(0.4).ignoresSafeArea().onTapGesture { editorCore.showGoToSymbol = false }
73:                 GoToSymbolView(editorCore: editorCore, onGoToLine: { _ in })
74:             }
75:             
76:             // AI Assistant
77:             if editorCore.showAIAssistant {
78:                 HStack { Spacer(); IDEAIAssistant(editorCore: editorCore, theme: theme).frame(width: 400, height: 500).padding() }
79:             }
80:             
81:             // Go To Line (Ctrl+G)
82:             if editorCore.showGoToLine {
83:                 Color.black.opacity(0.4).ignoresSafeArea().onTapGesture { editorCore.showGoToLine = false }
84:                 GoToLineView(isPresented: $editorCore.showGoToLine, onGoToLine: { _ in })
85:             }
86:             
87:             // Workspace Trust Dialog
88:             if let trustURL = pendingTrustURL {
89:                 Color.black.opacity(0.4).ignoresSafeArea()
90:                 WorkspaceTrustDialog(workspaceURL: trustURL, onTrust: {
91:                     trustManager.trust(url: trustURL)
92:                     finishOpeningWorkspace(trustURL)
93:                     pendingTrustURL = nil
94:                 }, onCancel: {
95:                     pendingTrustURL = nil
96:                 })
97:             }
98:         }
99:         .sheet(isPresented: $showingDocumentPicker) { IDEDocumentPicker(editorCore: editorCore) }
100:         .sheet(isPresented: $showingFolderPicker) {
101:             IDEFolderPicker(fileNavigator: fileNavigator) { url in
102:                 if trustManager.isTrusted(url: url) {
103:                     finishOpeningWorkspace(url)
104:                 } else {
105:                     pendingTrustURL = url
106:                 }
107:             }
108:         }
109:         .sheet(isPresented: $showSettings) { SettingsView(themeManager: themeManager) }
110:         .onChange(of: editorCore.showFilePicker) { show in showingDocumentPicker = show }
111:         .onChange(of: editorCore.activeTab?.fileName) { newFileName in
112:             updateWindowTitle()
113:         }
114:         .onChange(of: editorCore.tabs.count) { _ in
115:             updateWindowTitle()
116:         }
117:         .onAppear {
118:             updateWindowTitle()
119:         }
120:         // MARK: - Notification Handlers for Menu Keyboard Shortcuts

---

[search]
Found 1 matches:
VSCodeiPadOS/VSCodeiPadOS/ContentView.swift:415: @StateObject private var foldingManager = CodeFoldingManager()


>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/ContentView.swift","start_line":360,"end_line":460}
>>>END
>>>END

---

## üîß TOOL RESULTS

[read_file]
File: VSCodeiPadOS/VSCodeiPadOS/ContentView.swift (lines 361-460 of 1064)
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
361:                     IDETabItem(tab: tab, isSelected: editorCore.activeTabId == tab.id, editorCore: editorCore, theme: theme)
362:                 }
363:                 Button(action: { editorCore.addTab() }) {
364:                     Image(systemName: "plus").font(.caption).foregroundColor(theme.tabInactiveForeground).padding(8)
365:                 }
366:             }.padding(.horizontal, 4)
367:         }.frame(height: 36).background(theme.tabBarBackground)
368:     }
369: }
370: 
371: struct IDETabItem: View {
372:     let tab: Tab
373:     let isSelected: Bool
374:     @ObservedObject var editorCore: EditorCore
375:     let theme: Theme
376:     
377:     var body: some View {
378:         HStack(spacing: 6) {
379:             Image(systemName: fileIcon(for: tab.fileName)).font(.caption).foregroundColor(fileColor(for: tab.fileName))
380:             Text(tab.fileName).font(.system(size: 12)).lineLimit(1)
381:                 .foregroundColor(isSelected ? theme.tabActiveForeground : theme.tabInactiveForeground)
382:             if tab.isUnsaved { Circle().fill(Color.orange).frame(width: 6, height: 6) }
383:             Button(action: { editorCore.closeTab(id: tab.id) }) {
384:                 Image(systemName: "xmark").font(.system(size: 9, weight: .medium))
385:                     .foregroundColor(isSelected ? theme.tabActiveForeground.opacity(0.6) : theme.tabInactiveForeground)
386:             }
387:         }
388:         .padding(.horizontal, 12).padding(.vertical, 6)
389:         .background(RoundedRectangle(cornerRadius: 4).fill(isSelected ? theme.tabActiveBackground : theme.tabInactiveBackground))
390:         .onTapGesture { editorCore.selectTab(id: tab.id) }
391:     }
392: }
393: 
394: // MARK: - Editor with Syntax Highlighting + Autocomplete + Folding
395: 
396: struct IDEEditorView: View {
397:     @ObservedObject var editorCore: EditorCore
398:     let tab: Tab
399:     let theme: Theme
400: 
401:     @AppStorage("lineNumbersStyle") private var lineNumbersStyle: String = "on"
402:     @State private var text: String = ""
403:     @State private var scrollPosition: Int = 0
404:     @State private var totalLines: Int = 1
405:     @State private var visibleLines: Int = 20
406:     @State private var currentLineNumber: Int = 1
407:     @State private var currentColumn: Int = 1
408:     @State private var cursorIndex: Int = 0
409:     @State private var lineHeight: CGFloat = 17
410:     @State private var requestedCursorIndex: Int? = nil
411:     @State private var requestedLineSelection: Int? = nil
412: 
413:     @StateObject private var autocomplete = AutocompleteManager()
414:     @State private var showAutocomplete = false
415:     @StateObject private var foldingManager = CodeFoldingManager()
416:     @StateObject private var findViewModel = FindViewModel()
417:     
418:     var body: some View {
419:         VStack(spacing: 0) {
420:             // Find/Replace bar
421:             if editorCore.showSearch {
422:                 FindReplaceView(viewModel: findViewModel)
423:                     .background(theme.tabBarBackground)
424:             }
425:             
426:             BreadcrumbsView(editorCore: editorCore, tab: tab)
427:             
428:             GeometryReader { geometry in
429:                 ZStack(alignment: .topLeading) {
430:                 HStack(spacing: 0) {
431:                     if lineNumbersStyle != "off" {
432:                         LineNumbersWithFolding(
433:                             fileId: tab.url?.path ?? tab.fileName,
434:                             totalLines: totalLines,
435:                             currentLine: currentLineNumber,
436:                             scrollOffset: CGFloat(scrollPosition) * lineHeight,
437:                             lineHeight: lineHeight,
438:                             requestedLineSelection: $requestedLineSelection,
439:                             foldingManager: foldingManager,
440:                             theme: theme
441:                         )
442:                         .frame(width: 60)
443:                         .background(theme.sidebarBackground.opacity(0.5))
444:                     }
445:                     
446:                     if tab.fileName.hasSuffix(".json") {
447:                         // JSON Tree View for .json files
448:                         JSONTreeView(data: text.data(using: .utf8) ?? Data())
449:                             .frame(maxWidth: .infinity, maxHeight: .infinity)
450:                             .background(theme.editorBackground)
451:                     } else {
452:                         SyntaxHighlightingTextView(
453:                             text: $text,
454:                             filename: tab.fileName,
455:                             scrollPosition: $scrollPosition,
456:                             totalLines: $totalLines,
457:                             visibleLines: $visibleLines,
458:                             currentLineNumber: $currentLineNumber,
459:                             currentColumn: $currentColumn,
460:                             cursorIndex: $cursorIndex,


>>>TOOL search
{"query":"NSLayoutManager", "glob":"VSCodeiPadOS/VSCodeiPadOS/**/*"}
>>>END
>>>TOOL search
{"query":"textContainer.exclusionPaths", "glob":"VSCodeiPadOS/VSCodeiPadOS/**/*"}
>>>END
>>>TOOL search
{"query":"LineFragment", "glob":"VSCodeiPadOS/VSCodeiPadOS/**/*"}
>>>END
>>>END

---

## üîß TOOL RESULTS

[search]
No matches found for "NSLayoutManager"

---

[search]
No matches found for "textContainer.exclusionPaths"

---

[search]
Found 1 matches:
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:860: layoutManager.enumerateLineFragments(forGlyphRange: glyphRange) { (rect, usedRect, textContainer, glyphRange, stop) in


>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/ContentView.swift","start_line":400,"end_line":520}
>>>END
>>>END

---

## üîß TOOL RESULTS

[read_file]
File: VSCodeiPadOS/VSCodeiPadOS/ContentView.swift (lines 401-520 of 1064)
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
401:     @AppStorage("lineNumbersStyle") private var lineNumbersStyle: String = "on"
402:     @State private var text: String = ""
403:     @State private var scrollPosition: Int = 0
404:     @State private var totalLines: Int = 1
405:     @State private var visibleLines: Int = 20
406:     @State private var currentLineNumber: Int = 1
407:     @State private var currentColumn: Int = 1
408:     @State private var cursorIndex: Int = 0
409:     @State private var lineHeight: CGFloat = 17
410:     @State private var requestedCursorIndex: Int? = nil
411:     @State private var requestedLineSelection: Int? = nil
412: 
413:     @StateObject private var autocomplete = AutocompleteManager()
414:     @State private var showAutocomplete = false
415:     @StateObject private var foldingManager = CodeFoldingManager()
416:     @StateObject private var findViewModel = FindViewModel()
417:     
418:     var body: some View {
419:         VStack(spacing: 0) {
420:             // Find/Replace bar
421:             if editorCore.showSearch {
422:                 FindReplaceView(viewModel: findViewModel)
423:                     .background(theme.tabBarBackground)
424:             }
425:             
426:             BreadcrumbsView(editorCore: editorCore, tab: tab)
427:             
428:             GeometryReader { geometry in
429:                 ZStack(alignment: .topLeading) {
430:                 HStack(spacing: 0) {
431:                     if lineNumbersStyle != "off" {
432:                         LineNumbersWithFolding(
433:                             fileId: tab.url?.path ?? tab.fileName,
434:                             totalLines: totalLines,
435:                             currentLine: currentLineNumber,
436:                             scrollOffset: CGFloat(scrollPosition) * lineHeight,
437:                             lineHeight: lineHeight,
438:                             requestedLineSelection: $requestedLineSelection,
439:                             foldingManager: foldingManager,
440:                             theme: theme
441:                         )
442:                         .frame(width: 60)
443:                         .background(theme.sidebarBackground.opacity(0.5))
444:                     }
445:                     
446:                     if tab.fileName.hasSuffix(".json") {
447:                         // JSON Tree View for .json files
448:                         JSONTreeView(data: text.data(using: .utf8) ?? Data())
449:                             .frame(maxWidth: .infinity, maxHeight: .infinity)
450:                             .background(theme.editorBackground)
451:                     } else {
452:                         SyntaxHighlightingTextView(
453:                             text: $text,
454:                             filename: tab.fileName,
455:                             scrollPosition: $scrollPosition,
456:                             totalLines: $totalLines,
457:                             visibleLines: $visibleLines,
458:                             currentLineNumber: $currentLineNumber,
459:                             currentColumn: $currentColumn,
460:                             cursorIndex: $cursorIndex,
461:                             lineHeight: $lineHeight,
462:                             isActive: true,
463:                             fontSize: editorCore.editorFontSize,
464:                             requestedLineSelection: $requestedLineSelection,
465:                             requestedCursorIndex: $requestedCursorIndex,
466:                             onAcceptAutocomplete: {
467:                                 guard showAutocomplete else { return false }
468:                                 var tempText = text
469:                                 var tempCursor = cursorIndex
470:                                 autocomplete.commitCurrentSuggestion(into: &tempText, cursorPosition: &tempCursor)
471:                                 if tempText != text {
472:                                     text = tempText
473:                                     cursorIndex = tempCursor
474:                                     requestedCursorIndex = tempCursor
475:                                     showAutocomplete = false
476:                                     return true
477:                                 }
478:                                 return false
479:                             },
480:                             onDismissAutocomplete: {
481:                                 guard showAutocomplete else { return false }
482:                                 autocomplete.hideSuggestions()
483:                                 showAutocomplete = false
484:                                 return true
485:                             }
486:                         )
487:                         .onChange(of: text) { newValue in
488:                             editorCore.updateActiveTabContent(newValue)
489:                             editorCore.cursorPosition = CursorPosition(line: currentLineNumber, column: currentColumn)
490:                             autocomplete.updateSuggestions(for: newValue, cursorPosition: cursorIndex)
491:                             showAutocomplete = autocomplete.showSuggestions
492:                             foldingManager.detectFoldableRegions(in: newValue)
493:                         }
494:                         .onChange(of: cursorIndex) { newCursor in
495:                             autocomplete.updateSuggestions(for: text, cursorPosition: newCursor)
496:                             showAutocomplete = autocomplete.showSuggestions
497:                         }
498:                     }
499:                     
500:                     if !tab.fileName.hasSuffix(".json") {
501:                         MinimapView(
502:                             content: text,
503:                             scrollOffset: CGFloat(scrollPosition) * lineHeight,
504:                             scrollViewHeight: geometry.size.height,
505:                             totalContentHeight: CGFloat(totalLines) * lineHeight,
506:                             onScrollRequested: { newOffset in
507:                                 // Minimap requested scroll - update editor position
508:                                 // Convert back from pixels to line number
509:                                 let newLine = Int(newOffset / lineHeight)
510:                                 scrollPosition = max(0, min(newLine, totalLines - 1))
511:                             }
512:                         )
513:                         .frame(width: 80)
514:                     }
515:                 }
516:                 .background(theme.editorBackground)
517: 
518:                 // Sticky Header Overlay (FEAT-040)
519:                 StickyHeaderView(
520:                     text: text,


>>>TOOL search
{"query":"fold", "glob":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift"}
>>>END
>>>TOOL search
{"query":"CodeFoldingManager.shared", "glob":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift"}
>>>END
>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift","start_line":760,"end_line":980}
>>>END
>>>END

---

## üîß TOOL RESULTS

[search]
Found 10 matches:
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:149: textView.onUnfold = {
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:150: context.coordinator.handleUnfold(in: textView)
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:615: CodeFoldingManager.shared.foldCurrentLine()
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:618: func handleUnfold(in textView: UITextView) {
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:619: CodeFoldingManager.shared.unfoldCurrentLine()
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:771: var onUnfold: (() -> Void)?
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:935: // Unfold: Cmd+Opt+]
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:939: action: #selector(handleUnfold)
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:1070: @objc func handleUnfold() {
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:1071: onUnfold?()

---

[search]
Found 2 matches:
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:615: CodeFoldingManager.shared.foldCurrentLine()
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:619: CodeFoldingManager.shared.unfoldCurrentLine()

---

[read_file]
File: VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift (lines 761-980 of 1995)
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
761:     var onPeekDefinition: (() -> Void)?
762:     var onEscape: (() -> Void)?
763:     var onGoToLine: (() -> Void)?
764:     
765:     // Custom action closures for context menu
766:     var onGoToDefinition: (() -> Void)?
767:     var onFindReferences: (() -> Void)?
768:     var onFormatDocument: (() -> Void)?
769:     var onToggleComment: (() -> Void)?
770:     var onFold: (() -> Void)?
771:     var onUnfold: (() -> Void)?
772: 
773:     // Autocomplete key handling hooks (return true if handled)
774:     var onAcceptAutocomplete: (() -> Bool)?
775:     var onDismissAutocomplete: (() -> Bool)?
776:     
777:     // FEAT-039 & FEAT-043
778:     private var indentGuideColor: UIColor = .separator
779:     private var activeIndentGuideColor: UIColor = .label
780:     private var currentLineHighlightColor: UIColor = .clear
781:     
782:     override init(frame: CGRect, textContainer: NSTextContainer?) {
783:         super.init(frame: frame, textContainer: textContainer)
784:         setup()
785:     }
786:     
787:     required init?(coder: NSCoder) {
788:         super.init(coder: coder)
789:         setup()
790:     }
791:     
792:     private func setup() {
793:         // Ensure we redraw when bounds/selection change
794:         contentMode = .redraw
795:     }
796:     
797:     func updateThemeColors(theme: Theme) {
798:         self.indentGuideColor = UIColor(theme.indentGuide)
799:         self.activeIndentGuideColor = UIColor(theme.indentGuideActive)
800:         self.currentLineHighlightColor = UIColor(theme.currentLineHighlight)
801:         setNeedsDisplay()
802:     }
803:     
804:     override func draw(_ rect: CGRect) {
805:         guard let context = UIGraphicsGetCurrentContext(), let font = self.font else {
806:             super.draw(rect)
807:             return
808:         }
809:         
810:         // 1. Draw Current Line Highlight (FEAT-043)
811:         if let selectedRange = selectedTextRange {
812:             // Get the line rect for the cursor position
813:             let caretRect = self.caretRect(for: selectedRange.start)
814:             let lineRect = CGRect(x: 0, y: caretRect.minY, width: bounds.width, height: caretRect.height)
815:             
816:             context.setFillColor(currentLineHighlightColor.cgColor)
817:             context.fill(lineRect)
818:         }
819:         
820:         // 2. Draw Text (super implementation)
821:         super.draw(rect)
822:         
823:         // 3. Draw Indent Guides (FEAT-039)
824:         // We iterate visible lines and draw vertical lines for indentation
825:         // Optimization: Only draw for visible range
826: 
827:         context.setLineWidth(1.0)
828: 
829:         // Respect editor tab size setting (default 4)
830:         let storedTabSize = UserDefaults.standard.integer(forKey: "tabSize")
831:         let tabSize = storedTabSize > 0 ? storedTabSize : 4
832: 
833:         let spaceWidth = " ".size(withAttributes: [.font: font]).width
834:         let indentWidth = spaceWidth * CGFloat(tabSize)
835: 
836:         // Determine active indent level for caret line (for indentGuideActive)
837:         var activeIndentLevel: Int = 0
838:         if let selected = selectedTextRange {
839:             let caretPos = offset(from: beginningOfDocument, to: selected.start)
840:             let nsText = (self.text ?? "") as NSString
841:             let safeLoc = min(max(0, caretPos), nsText.length)
842:             let caretLineRange = nsText.lineRange(for: NSRange(location: safeLoc, length: 0))
843:             let caretLineText = nsText.substring(with: caretLineRange)
844: 
845:             var spaces = 0
846:             for ch in caretLineText {
847:                 if ch == " " { spaces += 1 }
848:                 else if ch == "\t" { spaces += tabSize }
849:                 else { break }
850:             }
851:             activeIndentLevel = spaces / tabSize
852:         }
853: 
854:         // Iterate visible glyphs/lines
855:         let visibleRect = CGRect(origin: contentOffset, size: bounds.size)
856:         let glyphRange = layoutManager.glyphRange(forBoundingRect: visibleRect, in: textContainer)
857: 
858:         let caretY = selectedTextRange.map { caretRect(for: $0.start).minY }
859: 
860:         layoutManager.enumerateLineFragments(forGlyphRange: glyphRange) { (rect, usedRect, textContainer, glyphRange, stop) in
861:             // Get text for this line
862:             guard let range = self.layoutManager.characterRange(forGlyphRange: glyphRange, actualGlyphRange: nil) as NSRange?,
863:                   let text = self.text as NSString? else { return }
864: 
865:             let lineText = text.substring(with: range)
866: 
867:             // Calculate indentation level
868:             var spaces = 0
869:             for char in lineText {
870:                 if char == " " { spaces += 1 }
871:                 else if char == "\t" { spaces += tabSize } // Handle tabs if present
872:                 else { break }
873:             }
874: 
875:             let indentLevel = spaces / tabSize
876:             guard indentLevel > 0 else { return }
877: 
878:             let isCaretLine = (caretY != nil) && abs(rect.minY - (caretY ?? 0)) < 0.5
879: 
880:             for i in 1...indentLevel {
881:                 let x = CGFloat(i) * indentWidth + self.textContainerInset.left
882:                 let startPoint = CGPoint(x: x, y: rect.minY)
883:                 let endPoint = CGPoint(x: x, y: rect.maxY)
884: 
885:                 let stroke = (isCaretLine && i == activeIndentLevel) ? self.activeIndentGuideColor : self.indentGuideColor
886:                 context.setStrokeColor(stroke.cgColor)
887: 
888:                 context.move(to: startPoint)
889:                 context.addLine(to: endPoint)
890:                 context.strokePath()
891:             }
892:         }
893:     }
894:     
895:     override var keyCommands: [UIKeyCommand]? {
896:         var commands = super.keyCommands ?? []
897:         
898:         // Peek Definition: Alt+F12 (using special key input)
899:         // Note: F12 is not directly available on iPadOS keyboards
900:         // Using Option+D as alternative
901:         commands.append(UIKeyCommand(
902:             input: "d",
903:             modifierFlags: .alternate,
904:             action: #selector(handlePeekDefinition)
905:         ))
906: 
907:         // Go to Line: Cmd+G
908:         commands.append(UIKeyCommand(
909:             input: "g",
910:             modifierFlags: .command,
911:             action: #selector(handleGoToLine)
912:         ))
913: 
914:         // Tab: accept autocomplete if visible, else insert tab
915:         commands.append(UIKeyCommand(
916:             input: "\t",
917:             modifierFlags: [],
918:             action: #selector(handleTab)
919:         ))
920:         
921:         // Escape: dismiss autocomplete if visible, else normal escape behavior
922:         commands.append(UIKeyCommand(
923:             input: UIKeyCommand.inputEscape,
924:             modifierFlags: [],
925:             action: #selector(handleEscape)
926:         ))
927:         
928:         // Fold: Cmd+Opt+[
929:         commands.append(UIKeyCommand(
930:             input: "[",
931:             modifierFlags: [.command, .alternate],
932:             action: #selector(handleFold)
933:         ))
934:         
935:         // Unfold: Cmd+Opt+]
936:         commands.append(UIKeyCommand(
937:             input: "]",
938:             modifierFlags: [.command, .alternate],
939:             action: #selector(handleUnfold)
940:         ))
941:         
942:         // MARK: - App-Level Shortcuts (UITextView captures keyboard, so we MUST register here)
943:         // These post to NotificationCenter so ContentView can handle them
944:         
945:         // Command Palette: Cmd+Shift+P
946:         commands.append(UIKeyCommand(
947:             input: "p",
948:             modifierFlags: [.command, .shift],
949:             action: #selector(handleShowCommandPalette),
950:             discoverabilityTitle: "Command Palette"
951:         ))
952:         
953:         // Toggle Terminal: Cmd+J (VS Code's shortcut)
954:         let toggleTerminalCmd = UIKeyCommand(
955:             input: "j",
956:             modifierFlags: .command,
957:             action: #selector(handleToggleTerminal),
958:             discoverabilityTitle: "Toggle Terminal"
959:         )
960:         toggleTerminalCmd.wantsPriorityOverSystemBehavior = true
961:         commands.append(toggleTerminalCmd)
962:         
963:         // AI Assistant: Cmd+Shift+A
964:         commands.append(UIKeyCommand(
965:             input: "a",
966:             modifierFlags: [.command, .shift],
967:             action: #selector(handleShowAIAssistant),
968:             discoverabilityTitle: "AI Assistant"
969:         ))
970:         
971:         // Toggle Sidebar: Cmd+B
972:         commands.append(UIKeyCommand(
973:             input: "b",
974:             modifierFlags: .command,
975:             action: #selector(handleToggleSidebar),
976:             discoverabilityTitle: "Toggle Sidebar"
977:         ))
978:         
979:         // Quick Open: Cmd+P
980:         commands.append(UIKeyCommand(


>>>TOOL search
{"query":"collapsedLines", "glob":"VSCodeiPadOS/VSCodeiPadOS/**/*"}
>>>END
>>>TOOL search
{"query":"getFoldedLineRanges", "glob":"VSCodeiPadOS/VSCodeiPadOS/**/*"}
>>>END
>>>TOOL search
{"query":"isRegionFolded", "glob":"VSCodeiPadOS/VSCodeiPadOS/**/*"}
>>>END
>>>TOOL search
{"query":"toggleFold(at:", "glob":"VSCodeiPadOS/VSCodeiPadOS/**/*"}
>>>END
>>>END

---

## üîß TOOL RESULTS

[search]
Found 5 matches:
VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift:72: @Published var collapsedLines: Set<Int> = []
VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift:673: return collapsedLines.contains(line)
VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift:756: return collapsedLines.count
VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift:779: collapsedLines.removeAll()
VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift:783: collapsedLines.insert(line)

---

[search]
Found 1 matches:
VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift:741: func getFoldedLineRanges() -> [ClosedRange<Int>] {

---

[search]
Found 1 matches:
VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift:677: func isRegionFolded(at line: Int) -> Bool {

---

[search]
Found 3 matches:
VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift:594: toggleFold(at: region.startLine)
VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift:602: toggleFold(at: region.startLine)
VSCodeiPadOS/VSCodeiPadOS/ContentView.swift:611: Button(action: { foldingManager.toggleFold(at: lineIndex) }) {


>>>TOOL search
{"query":"shouldGenerateGlyphs", "glob":"VSCodeiPadOS/VSCodeiPadOS/**/*"}
>>>END
>>>TOOL search
{"query":"NSLayoutManagerDelegate", "glob":"VSCodeiPadOS/VSCodeiPadOS/**/*"}
>>>END
>>>TOOL search
{"query":"fold", "glob":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift"}
>>>END
>>>TOOL search
{"query":"exclusionPaths", "glob":"VSCodeiPadOS/VSCodeiPadOS/**/*"}
>>>END
>>>END

---

## üîß TOOL RESULTS

[search]
No matches found for "shouldGenerateGlyphs"

---

[search]
No matches found for "NSLayoutManagerDelegate"

---

[search]
Found 10 matches:
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:149: textView.onUnfold = {
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:150: context.coordinator.handleUnfold(in: textView)
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:620: CodeFoldingManager.shared.foldCurrentLine()
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:623: func handleUnfold(in textView: UITextView) {
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:624: CodeFoldingManager.shared.unfoldCurrentLine()
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:776: var onUnfold: (() -> Void)?
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:940: // Unfold: Cmd+Opt+]
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:944: action: #selector(handleUnfold)
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:1075: @objc func handleUnfold() {
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:1076: onUnfold?()

---

[search]
No matches found for "exclusionPaths"


>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift","start_line":1,"end_line":120}
>>>END
>>>END

---

## üîß TOOL RESULTS

[read_file]
File: VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift (lines 2-120 of 2002)
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
2: //  SyntaxHighlightingTextView.swift
3: //  VSCodeiPadOS
4: //
5: //  Upgraded syntax highlighting with VSCode-like colors
6: //
7: 
8: import SwiftUI
9: import UIKit
10: 
11: /// UITextView wrapper with syntax highlighting support
12: struct SyntaxHighlightingTextView: UIViewRepresentable {
13:     @Binding var text: String
14:     let filename: String
15:     @Binding var scrollPosition: Int
16:     @Binding var totalLines: Int
17:     @Binding var visibleLines: Int
18:     @Binding var currentLineNumber: Int
19:     @Binding var currentColumn: Int
20:     @Binding var cursorIndex: Int
21:     @Binding var lineHeight: CGFloat
22:     @Binding var requestedLineSelection: Int?
23:     @Binding var requestedCursorIndex: Int?
24: 
25:     /// Autocomplete key handling hooks (return true if handled)
26:     let onAcceptAutocomplete: (() -> Bool)?
27:     let onDismissAutocomplete: (() -> Bool)?
28: 
29:     let isActive: Bool
30:     let fontSize: CGFloat  // Explicit parameter to trigger SwiftUI updates
31:     @EnvironmentObject var editorCore: EditorCore
32: 
33:     init(
34:         text: Binding<String>,
35:         filename: String,
36:         scrollPosition: Binding<Int>,
37:         totalLines: Binding<Int>,
38:         visibleLines: Binding<Int>,
39:         currentLineNumber: Binding<Int>,
40:         currentColumn: Binding<Int>,
41:         cursorIndex: Binding<Int> = .constant(0),
42:         lineHeight: Binding<CGFloat>,
43:         isActive: Bool,
44:         fontSize: CGFloat = 14.0,
45:         requestedLineSelection: Binding<Int?> = .constant(nil),
46:         requestedCursorIndex: Binding<Int?> = .constant(nil),
47:         onAcceptAutocomplete: (() -> Bool)? = nil,
48:         onDismissAutocomplete: (() -> Bool)? = nil
49:     ) {
50:         self._text = text
51:         self.filename = filename
52:         self._scrollPosition = scrollPosition
53:         self._totalLines = totalLines
54:         self._visibleLines = visibleLines
55:         self._currentLineNumber = currentLineNumber
56:         self._currentColumn = currentColumn
57:         self._cursorIndex = cursorIndex
58:         self._lineHeight = lineHeight
59:         self.isActive = isActive
60:         self.fontSize = fontSize
61:         self._requestedLineSelection = requestedLineSelection
62:         self._requestedCursorIndex = requestedCursorIndex
63:         self.onAcceptAutocomplete = onAcceptAutocomplete
64:         self.onDismissAutocomplete = onDismissAutocomplete
65:     }
66:     
67:     // Compatibility init for older call sites (e.g. SplitEditorView) that pass editorCore explicitly.
68:     init(
69:         text: Binding<String>,
70:         filename: String,
71:         scrollPosition: Binding<Int>,
72:         totalLines: Binding<Int>,
73:         visibleLines: Binding<Int>,
74:         currentLineNumber: Binding<Int>,
75:         currentColumn: Binding<Int>,
76:         cursorIndex: Binding<Int> = .constant(0),
77:         lineHeight: Binding<CGFloat>,
78:         isActive: Bool,
79:         editorCore: EditorCore,
80:         requestedLineSelection: Binding<Int?> = .constant(nil),
81:         requestedCursorIndex: Binding<Int?> = .constant(nil),
82:         onAcceptAutocomplete: (() -> Bool)? = nil,
83:         onDismissAutocomplete: (() -> Bool)? = nil
84:     ) {
85:         self.init(
86:             text: text,
87:             filename: filename,
88:             scrollPosition: scrollPosition,
89:             totalLines: totalLines,
90:             visibleLines: visibleLines,
91:             currentLineNumber: currentLineNumber,
92:             currentColumn: currentColumn,
93:             cursorIndex: cursorIndex,
94:             lineHeight: lineHeight,
95:             isActive: isActive,
96:             fontSize: editorCore.editorFontSize,
97:             requestedLineSelection: requestedLineSelection,
98:             requestedCursorIndex: requestedCursorIndex,
99:             onAcceptAutocomplete: onAcceptAutocomplete,
100:             onDismissAutocomplete: onDismissAutocomplete
101:         )
102:     }
103: 
104:     func makeCoordinator() -> Coordinator {
105:         Coordinator(self)
106:     }
107:     
108:     func makeUIView(context: Context) -> UITextView {
109:         let textView = EditorTextView()
110:         textView.delegate = context.coordinator
111: 
112:         // Autocomplete hooks
113:         textView.onAcceptAutocomplete = onAcceptAutocomplete
114:         textView.onDismissAutocomplete = onDismissAutocomplete
115: 
116:         textView.onPeekDefinition = {
117:             context.coordinator.handlePeekDefinition(in: textView)
118:         }
119: 
120:         textView.onEscape = {


>>>TOOL search
{"query":"func applySyntaxHighlighting", "glob":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift"}
>>>END
>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift","start_line":420,"end_line":620}
>>>END
>>>END

---

## üîß TOOL RESULTS

[search]
Found 1 matches:
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:511: func applySyntaxHighlighting(to textView: UITextView) {

---

[read_file]
File: VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift (lines 421-620 of 2011)
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
421:             updateScrollPosition(textView)
422:         }
423:         
424:         func updateLineCount(_ textView: UITextView) {
425:             let lines = textView.text.components(separatedBy: .newlines)
426:             DispatchQueue.main.async {
427:                 self.parent.totalLines = max(1, lines.count)
428:             }
429:         }
430:         
431:         func updateCursorPosition(_ textView: UITextView) {
432:             guard let selectedRange = textView.selectedTextRange else { return }
433:              let cursorPosition = textView.offset(from: textView.beginningOfDocument, to: selectedRange.start)
434:              
435:              let text = textView.text ?? ""
436:              let prefix = String(text.prefix(cursorPosition))
437:              let lines = prefix.components(separatedBy: .newlines)
438:              
439:              let lineNumber = lines.count
440:              let column = (lines.last?.count ?? 0) + 1
441:              
442:              DispatchQueue.main.async {
443:                  self.parent.currentLineNumber = lineNumber
444:                  self.parent.currentColumn = column
445:                  self.parent.cursorIndex = cursorPosition
446:              }
447:         }
448:         
449:         func updateScrollPosition(_ textView: UITextView) {
450:             guard let font = textView.font else { return }
451:             let lineHeight = font.lineHeight
452:             let scrollOffset = textView.contentOffset.y
453:             let line = Int(scrollOffset / lineHeight)
454:             
455:             // Update both synchronously to prevent feedback loop:
456:             // If we update parent.scrollPosition async, there's a race where
457:             // updateUIView sees old binding value != lastKnownScrollPosition
458:             // and scrolls back to the old position, causing jaggy scrolling.
459:             lastKnownScrollPosition = line
460:             parent.scrollPosition = line
461:         }
462:         
463:         func scrollToLine(_ line: Int, in textView: UITextView) {
464:             guard !isUpdatingFromMinimap else { return }
465:             isUpdatingFromMinimap = true
466:             
467:             let lines = textView.text.components(separatedBy: .newlines)
468:             guard line >= 0 && line < lines.count else {
469:                 isUpdatingFromMinimap = false
470:                 return
471:             }
472:             
473:             var characterPosition = 0
474:             for i in 0..<line {
475:                 characterPosition += lines[i].count + 1
476:             }
477:             
478:             if let position = textView.position(from: textView.beginningOfDocument, offset: characterPosition) {
479:                 let rect = textView.caretRect(for: position)
480:                 let targetY = max(0, rect.origin.y)
481:                 textView.setContentOffset(CGPoint(x: 0, y: targetY), animated: true)
482:             }
483:             
484:             DispatchQueue.main.asyncAfter(deadline: .now() + 0.3) {
485:                 self.isUpdatingFromMinimap = false
486:             }
487:         }
488: 
489:         func scrollToAndSelectLine(_ line: Int, in textView: UITextView) {
490:             let lines = textView.text.components(separatedBy: .newlines)
491:             guard line >= 0 && line < lines.count else { return }
492: 
493:             var characterPosition = 0
494:             for i in 0..<line {
495:                 characterPosition += lines[i].count + 1
496:             }
497: 
498:             // FEAT-041: select entire line (excluding trailing newline)
499:             let lineLength = (lines[line] as NSString).length
500:             let range = NSRange(location: characterPosition, length: lineLength)
501:             textView.selectedRange = range
502: 
503:             // Ensure it's visible
504:             scrollToLine(line, in: textView)
505: 
506:             // Update SwiftUI state
507:             updateCursorPosition(textView)
508:             updateScrollPosition(textView)
509:         }
510: 
511:         func applySyntaxHighlighting(to textView: UITextView) {
512:             let theme = ThemeManager.shared.currentTheme
513:             lastThemeId = theme.id
514: 
515:             let highlighter = VSCodeSyntaxHighlighter(theme: theme, fontSize: parent.editorCore.editorFontSize)
516:             let attributedText = highlighter.highlight(textView.text, filename: parent.filename)
517: 
518:             let selectedRange = textView.selectedRange
519:             textView.attributedText = attributedText
520:             textView.selectedRange = selectedRange
521: 
522:             // Set typing attributes so newly typed characters have correct base styling
523:             // This prevents flicker during the debounce period before full highlighting runs
524:             let fontSize = parent.editorCore.editorFontSize
525:             textView.typingAttributes = [
526:                 .font: UIFont.monospacedSystemFont(ofSize: fontSize, weight: .regular),
527:                 .foregroundColor: UIColor(theme.editorForeground)
528:             ]
529: 
530:             // FEAT-044: restore matching bracket highlight after re-attributing text
531:             updateMatchingBracketHighlight(textView)
532:         }
533:         
534:         func handlePeekDefinition(in textView: UITextView) {
535:             guard let selectedRange = textView.selectedTextRange else { return }
536:             let text = textView.text ?? ""
537:             
538:             if let range = textView.tokenizer.rangeEnclosingPosition(selectedRange.start, with: .word, inDirection: UITextDirection(rawValue: 1)) {
539:                  let location = textView.offset(from: textView.beginningOfDocument, to: range.start)
540:                  
541:                  let prefix = String(text.prefix(location))
542:                  let sourceLine = prefix.components(separatedBy: CharacterSet.newlines).count - 1
543:                  
544:                  parent.editorCore.triggerPeekDefinition(
545:                      file: parent.filename,
546:                      line: sourceLine,
547:                      content: text,
548:                      sourceLine: sourceLine
549:                  )
550:             }
551:         }
552:         
553:         func handleEscape() {
554:             if parent.editorCore.peekState != nil {
555:                 parent.editorCore.closePeekDefinition()
556:             } else {
557:                 parent.editorCore.escapeMultiCursor()
558:             }
559:         }
560:         
561:         func handleGoToDefinition(in textView: UITextView) {
562:             // Reuse the peek definition logic for now
563:             handlePeekDefinition(in: textView)
564:         }
565:         
566:         func handleFindReferences(in textView: UITextView) {
567:             guard let selectedRange = textView.selectedTextRange else { return }
568:             let text = textView.text ?? ""
569:             
570:             if let range = textView.tokenizer.rangeEnclosingPosition(selectedRange.start, with: .word, inDirection: UITextDirection(rawValue: 1)) {
571:                 let location = textView.offset(from: textView.beginningOfDocument, to: range.start)
572:                 
573:                 let prefix = String(text.prefix(location))
574:                 let sourceLine = prefix.components(separatedBy: CharacterSet.newlines).count - 1
575:                 
576:                 // TODO: Implement find references functionality in EditorCore
577:                 // For now, just trigger peek definition as a placeholder
578:                 parent.editorCore.triggerPeekDefinition(
579:                     file: parent.filename,
580:                     line: sourceLine,
581:                     content: text,
582:                     sourceLine: sourceLine
583:                 )
584:             }
585:         }
586:         
587:         func handleFormatDocument(in textView: UITextView) {
588:             // TODO: Implement format document functionality
589:             // This would typically call a formatter in EditorCore
590:             print("Format Document: Not yet implemented")
591:         }
592:         
593:         func handleToggleComment(in textView: UITextView) {
594:             guard let selectedRange = textView.selectedTextRange else { return }
595:             let text = textView.text ?? ""
596:             
597:             // Get the current line range
598:             if let lineRange = textView.tokenizer.rangeEnclosingPosition(selectedRange.start, with: .paragraph, inDirection: UITextDirection(rawValue: 1)) {
599:                 let location = textView.offset(from: textView.beginningOfDocument, to: lineRange.start)
600:                 let length = textView.offset(from: lineRange.start, to: lineRange.end)
601:                 let nsRange = NSRange(location: location, length: length)
602:                 
603:                 if nsRange.location + nsRange.length <= (text as NSString).length {
604:                     let lineText = (text as NSString).substring(with: nsRange)
605:                     let trimmed = lineText.trimmingCharacters(in: .whitespaces)
606:                     
607:                     // Check if line starts with a comment
608:                     let isCommented = trimmed.hasPrefix("//") || trimmed.hasPrefix("#") || trimmed.hasPrefix("/*")
609:                     
610:                     // Toggle comment
611:                     var newLineText: String
612:                     if isCommented {
613:                         // Remove comment
614:                         newLineText = lineText.replacingOccurrences(of: "//", with: "").replacingOccurrences(of: "#", with: "", options: .anchored)
615:                     } else {
616:                         // Add comment (use // for most languages)
617:                         newLineText = "//" + lineText
618:                     }
619:                     
620:                     // Replace the line


>>>TOOL search
{"query":"SyntaxHighlightingTextView(", "glob":"VSCodeiPadOS/VSCodeiPadOS/**/*.swift"}
>>>END
>>>END

---

## üîß TOOL RESULTS

[search]
Found 3 matches:
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView_Update.swift:544: SyntaxHighlightingTextView(
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SplitEditorView.swift:566: SyntaxHighlightingTextView(
VSCodeiPadOS/VSCodeiPadOS/ContentView.swift:452: SyntaxHighlightingTextView(


>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView_Update.swift","start_line":1,"end_line":260}
>>>END
>>>END

---

## üîß TOOL RESULTS

[read_file]
File: VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView_Update.swift (lines 2-260 of 708)
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
2: //  SplitEditorView.swift
3: //  VSCodeiPadOS
4: //
5: //  Split editor panes implementation
6: //  - Split right/down
7: //  - Drag tabs to create splits
8: //  - Independent panes with own tabs
9: //  - Resizable with drag handles
10: //  - Close split buttons
11: //  - Sync scroll option
12: //
13: 
14: import SwiftUI
15: 
16: // MARK: - Split Direction
17: 
18: enum SplitDirection: String, CaseIterable {
19:     case horizontal // side by side
20:     case vertical   // top and bottom
21: }
22: 
23: // MARK: - Editor Pane Model
24: 
25: class EditorPane: ObservableObject, Identifiable {
26:     let id: UUID
27:     @Published var tabs: [Tab]
28:     @Published var activeTabId: UUID?
29:     @Published var scrollOffset: CGFloat = 0
30:     
31:     var activeTab: Tab? {
32:         tabs.first { $0.id == activeTabId }
33:     }
34:     
35:     init(id: UUID = UUID(), tabs: [Tab] = [], activeTabId: UUID? = nil) {
36:         self.id = id
37:         self.tabs = tabs
38:         self.activeTabId = activeTabId ?? tabs.first?.id
39:     }
40:     
41:     func addTab(_ tab: Tab) {
42:         // Check if already exists
43:         if let existing = tabs.first(where: { $0.url == tab.url && tab.url != nil }) {
44:             activeTabId = existing.id
45:             return
46:         }
47:         tabs.append(tab)
48:         activeTabId = tab.id
49:     }
50:     
51:     func closeTab(id: UUID) {
52:         guard let index = tabs.firstIndex(where: { $0.id == id }) else { return }
53:         tabs.remove(at: index)
54:         
55:         if activeTabId == id {
56:             if tabs.isEmpty {
57:                 activeTabId = nil
58:             } else if index >= tabs.count {
59:                 activeTabId = tabs[tabs.count - 1].id
60:             } else {
61:                 activeTabId = tabs[index].id
62:             }
63:         }
64:     }
65:     
66:     func selectTab(id: UUID) {
67:         activeTabId = id
68:     }
69:     
70:     func updateTabContent(_ content: String) {
71:         guard let index = tabs.firstIndex(where: { $0.id == activeTabId }) else { return }
72:         tabs[index].content = content
73:         if tabs[index].url != nil {
74:             tabs[index].isUnsaved = true
75:         }
76:     }
77: }
78: 
79: // MARK: - Split Editor Manager
80: 
81: class SplitEditorManager: ObservableObject {
82:     @Published var panes: [EditorPane] = []
83:     @Published var splitDirection: SplitDirection = .horizontal
84:     @Published var splitRatios: [CGFloat] = [1.0]
85:     @Published var activePaneId: UUID?
86:     @Published var syncScroll: Bool = false
87:     
88:     var activePane: EditorPane? {
89:         panes.first { $0.id == activePaneId }
90:     }
91:     
92:     init() {
93:         let initialPane = EditorPane()
94:         panes = [initialPane]
95:         activePaneId = initialPane.id
96:         splitRatios = [1.0]
97:     }
98:     
99:     // Initialize with EditorCore's tabs
100:     func initializeWithTabs(_ tabs: [Tab], activeTabId: UUID?) {
101:         if panes.isEmpty {
102:             let pane = EditorPane(tabs: tabs, activeTabId: activeTabId)
103:             panes = [pane]
104:             activePaneId = pane.id
105:             splitRatios = [1.0]
106:         } else if let firstPane = panes.first, firstPane.tabs.isEmpty {
107:             firstPane.tabs = tabs
108:             firstPane.activeTabId = activeTabId
109:         }
110:     }
111:     
112:     // MARK: - Split Operations
113:     
114:     func splitPane(direction: SplitDirection, fromPaneId: UUID? = nil) {
115:         let sourcePane = fromPaneId.flatMap { id in panes.first { $0.id == id } } ?? activePane
116:         guard let source = sourcePane else { return }
117:         
118:         // Create new pane with duplicate of active tab (or empty)
119:         var newTabs: [Tab] = []
120:         if let activeTab = source.activeTab {
121:             let duplicateTab = Tab(
122:                 fileName: activeTab.fileName,
123:                 content: activeTab.content,
124:                 language: activeTab.language,
125:                 url: activeTab.url,
126:                 isUnsaved: activeTab.isUnsaved
127:             )
128:             newTabs = [duplicateTab]
129:         }
130:         
131:         let newPane = EditorPane(tabs: newTabs, activeTabId: newTabs.first?.id)
132:         
133:         self.splitDirection = direction
134:         panes.append(newPane)
135:         
136:         // Recalculate ratios equally
137:         let ratio = 1.0 / CGFloat(panes.count)
138:         splitRatios = Array(repeating: ratio, count: panes.count)
139:         
140:         activePaneId = newPane.id
141:     }
142:     
143:     func closePane(id: UUID) {
144:         guard panes.count > 1 else { return } // Keep at least one pane
145:         guard let index = panes.firstIndex(where: { $0.id == id }) else { return }
146:         
147:         panes.remove(at: index)
148:         splitRatios.remove(at: index)
149:         
150:         // Normalize ratios
151:         let total = splitRatios.reduce(0, +)
152:         if total > 0 {
153:             splitRatios = splitRatios.map { $0 / total }
154:         } else {
155:             splitRatios = Array(repeating: 1.0 / CGFloat(panes.count), count: panes.count)
156:         }
157:         
158:         // Update active pane
159:         if activePaneId == id {
160:             activePaneId = panes.first?.id
161:         }
162:     }
163:     
164:     func moveTabToPane(tab: Tab, fromPaneId: UUID, toPaneId: UUID) {
165:         guard let fromPane = panes.first(where: { $0.id == fromPaneId }),
166:               let toPane = panes.first(where: { $0.id == toPaneId }) else { return }
167:         
168:         fromPane.closeTab(id: tab.id)
169:         
170:         // Create new tab (since Tab is a struct)
171:         let newTab = Tab(
172:             fileName: tab.fileName,
173:             content: tab.content,
174:             language: tab.language,
175:             url: tab.url,
176:             isUnsaved: tab.isUnsaved
177:         )
178:         toPane.addTab(newTab)
179:     }
180:     
181:     func moveTabToNewSplit(tab: Tab, fromPaneId: UUID, direction: SplitDirection) {
182:         guard let fromPane = panes.first(where: { $0.id == fromPaneId }) else { return }
183:         
184:         fromPane.closeTab(id: tab.id)
185:         
186:         let newTab = Tab(
187:             fileName: tab.fileName,
188:             content: tab.content,
189:             language: tab.language,
190:             url: tab.url,
191:             isUnsaved: tab.isUnsaved
192:         )
193:         
194:         let newPane = EditorPane(tabs: [newTab], activeTabId: newTab.id)
195:         self.splitDirection = direction
196:         panes.append(newPane)
197:         
198:         let ratio = 1.0 / CGFloat(panes.count)
199:         splitRatios = Array(repeating: ratio, count: panes.count)
200:         activePaneId = newPane.id
201:     }
202:     
203:     func updateRatio(at index: Int, delta: CGFloat, totalSize: CGFloat) {
204:         guard index < splitRatios.count - 1 else { return }
205:         
206:         let deltaRatio = delta / totalSize
207:         let minRatio: CGFloat = 0.15
208:         
209:         let newRatio1 = splitRatios[index] + deltaRatio
210:         let newRatio2 = splitRatios[index + 1] - deltaRatio
211:         
212:         if newRatio1 >= minRatio && newRatio2 >= minRatio {
213:             splitRatios[index] = newRatio1
214:             splitRatios[index + 1] = newRatio2
215:         }
216:     }
217:     
218:     // Sync scroll across panes
219:     func syncScrollOffset(_ offset: CGFloat, fromPaneId: UUID) {
220:         guard syncScroll else { return }
221:         for pane in panes where pane.id != fromPaneId {
222:             pane.scrollOffset = offset
223:         }
224:     }
225: }
226: 
227: // MARK: - Split Editor View
228: 
229: struct SplitEditorView: View {
230:     @ObservedObject var splitManager: SplitEditorManager
231:     @ObservedObject var editorCore: EditorCore
232:     
233:     var body: some View {
234:         GeometryReader { geometry in
235:             ZStack {
236:                 if splitManager.panes.count == 1 {
237:                     // Single pane - no split
238:                     if let pane = splitManager.panes.first {
239:                         SinglePaneView(pane: pane, splitManager: splitManager, editorCore: editorCore)
240:                     }
241:                 } else {
242:                     // Multiple panes with split
243:                     splitContent(geometry: geometry)
244:                 }
245:                 
246:                 // Hover Info Overlay
247:                 HoverInfoView()
248:             }
249:         }
250:     }
251:     
252:     @ViewBuilder
253:     private func splitContent(geometry: GeometryProxy) -> some View {
254:         let totalSize = splitManager.splitDirection == .horizontal ? geometry.size.width : geometry.size.height
255:         
256:         if splitManager.splitDirection == .horizontal {
257:             HStack(spacing: 0) {
258:                 ForEach(Array(splitManager.panes.enumerated()), id: \.element.id) { index, pane in
259:                     SinglePaneView(pane: pane, splitManager: splitManager, editorCore: editorCore)
260:                         .frame(width: totalSize * splitManager.splitRatios[index])


>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift","start_line":420,"end_line":560}
>>>END
>>>END

---

## üîß TOOL RESULTS

[read_file]
File: VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift (lines 421-560 of 2011)
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
421:             updateScrollPosition(textView)
422:         }
423:         
424:         func updateLineCount(_ textView: UITextView) {
425:             let lines = textView.text.components(separatedBy: .newlines)
426:             DispatchQueue.main.async {
427:                 self.parent.totalLines = max(1, lines.count)
428:             }
429:         }
430:         
431:         func updateCursorPosition(_ textView: UITextView) {
432:             guard let selectedRange = textView.selectedTextRange else { return }
433:              let cursorPosition = textView.offset(from: textView.beginningOfDocument, to: selectedRange.start)
434:              
435:              let text = textView.text ?? ""
436:              let prefix = String(text.prefix(cursorPosition))
437:              let lines = prefix.components(separatedBy: .newlines)
438:              
439:              let lineNumber = lines.count
440:              let column = (lines.last?.count ?? 0) + 1
441:              
442:              DispatchQueue.main.async {
443:                  self.parent.currentLineNumber = lineNumber
444:                  self.parent.currentColumn = column
445:                  self.parent.cursorIndex = cursorPosition
446:              }
447:         }
448:         
449:         func updateScrollPosition(_ textView: UITextView) {
450:             guard let font = textView.font else { return }
451:             let lineHeight = font.lineHeight
452:             let scrollOffset = textView.contentOffset.y
453:             let line = Int(scrollOffset / lineHeight)
454:             
455:             // Update both synchronously to prevent feedback loop:
456:             // If we update parent.scrollPosition async, there's a race where
457:             // updateUIView sees old binding value != lastKnownScrollPosition
458:             // and scrolls back to the old position, causing jaggy scrolling.
459:             lastKnownScrollPosition = line
460:             parent.scrollPosition = line
461:         }
462:         
463:         func scrollToLine(_ line: Int, in textView: UITextView) {
464:             guard !isUpdatingFromMinimap else { return }
465:             isUpdatingFromMinimap = true
466:             
467:             let lines = textView.text.components(separatedBy: .newlines)
468:             guard line >= 0 && line < lines.count else {
469:                 isUpdatingFromMinimap = false
470:                 return
471:             }
472:             
473:             var characterPosition = 0
474:             for i in 0..<line {
475:                 characterPosition += lines[i].count + 1
476:             }
477:             
478:             if let position = textView.position(from: textView.beginningOfDocument, offset: characterPosition) {
479:                 let rect = textView.caretRect(for: position)
480:                 let targetY = max(0, rect.origin.y)
481:                 textView.setContentOffset(CGPoint(x: 0, y: targetY), animated: true)
482:             }
483:             
484:             DispatchQueue.main.asyncAfter(deadline: .now() + 0.3) {
485:                 self.isUpdatingFromMinimap = false
486:             }
487:         }
488: 
489:         func scrollToAndSelectLine(_ line: Int, in textView: UITextView) {
490:             let lines = textView.text.components(separatedBy: .newlines)
491:             guard line >= 0 && line < lines.count else { return }
492: 
493:             var characterPosition = 0
494:             for i in 0..<line {
495:                 characterPosition += lines[i].count + 1
496:             }
497: 
498:             // FEAT-041: select entire line (excluding trailing newline)
499:             let lineLength = (lines[line] as NSString).length
500:             let range = NSRange(location: characterPosition, length: lineLength)
501:             textView.selectedRange = range
502: 
503:             // Ensure it's visible
504:             scrollToLine(line, in: textView)
505: 
506:             // Update SwiftUI state
507:             updateCursorPosition(textView)
508:             updateScrollPosition(textView)
509:         }
510: 
511:         func applySyntaxHighlighting(to textView: UITextView) {
512:             let theme = ThemeManager.shared.currentTheme
513:             lastThemeId = theme.id
514: 
515:             let highlighter = VSCodeSyntaxHighlighter(theme: theme, fontSize: parent.editorCore.editorFontSize)
516:             let attributedText = highlighter.highlight(textView.text, filename: parent.filename)
517: 
518:             let selectedRange = textView.selectedRange
519:             textView.attributedText = attributedText
520:             textView.selectedRange = selectedRange
521: 
522:             // Set typing attributes so newly typed characters have correct base styling
523:             // This prevents flicker during the debounce period before full highlighting runs
524:             let fontSize = parent.editorCore.editorFontSize
525:             textView.typingAttributes = [
526:                 .font: UIFont.monospacedSystemFont(ofSize: fontSize, weight: .regular),
527:                 .foregroundColor: UIColor(theme.editorForeground)
528:             ]
529: 
530:             // FEAT-044: restore matching bracket highlight after re-attributing text
531:             updateMatchingBracketHighlight(textView)
532:         }
533:         
534:         func handlePeekDefinition(in textView: UITextView) {
535:             guard let selectedRange = textView.selectedTextRange else { return }
536:             let text = textView.text ?? ""
537:             
538:             if let range = textView.tokenizer.rangeEnclosingPosition(selectedRange.start, with: .word, inDirection: UITextDirection(rawValue: 1)) {
539:                  let location = textView.offset(from: textView.beginningOfDocument, to: range.start)
540:                  
541:                  let prefix = String(text.prefix(location))
542:                  let sourceLine = prefix.components(separatedBy: CharacterSet.newlines).count - 1
543:                  
544:                  parent.editorCore.triggerPeekDefinition(
545:                      file: parent.filename,
546:                      line: sourceLine,
547:                      content: text,
548:                      sourceLine: sourceLine
549:                  )
550:             }
551:         }
552:         
553:         func handleEscape() {
554:             if parent.editorCore.peekState != nil {
555:                 parent.editorCore.closePeekDefinition()
556:             } else {
557:                 parent.editorCore.escapeMultiCursor()
558:             }
559:         }
560:         


>>>TOOL web_search
{"query":"NSLayoutManagerDelegate shouldSetLineFragmentRect lineFragmentUsedRect baselineOffset in textContainer forGlyphRange signature Swift", "max_results": 5}
>>>END
>>>END>>>TOOL web_search
{"query":"NSLayoutManagerDelegate shouldSetLineFragmentRect lineFragmentUsedRect baselineOffset in textContainer forGlyphRange signature Swift", "max_results": 5}
>>>END
>>>END

---

## üîß TOOL RESULTS

[web_search]
üîç DuckDuckGo results for "NSLayoutManagerDelegate shouldSetLineFragmentRect lineFragmentUsedRect baselineOffset in textContainer forGlyphRange signature Swift" (5 results):

1. **NSLayoutManagerDelegate.ShouldSetLineFragmentRect Method (UIKit ...**
   https://learn.microsoft.com/en-us/dotnet/api/uikit.nslayoutmanagerdelegate.shouldsetlinefragmentrect?view=net-ios-26.0-10.0
   public virtual bool ShouldSetLineFragmentRect(UIKit.NSLayoutManager layoutManager, ref CoreGraphics.CGRect lineFragmentRect, ref CoreGraphics.CGRect lineFragmentUsedRect, ref System.Runtime.InteropServices.NFloat baselineOffset, UIKit.NSTextContainer textContainer, Foundation.NSRange glyphRange);

2. **layoutManager (_:shouldSetLineFragmentRect:lineFragmentUsedRect ...**
   https://developer.apple.com/documentation/appkit/nslayoutmanagerdelegate/layoutmanager(_:shouldsetlinefragmentrect:linefragmentusedrect:baselineoffset:in:forglyphrange:)
   Instance Method layoutManager (_:shouldSetLineFragmentRect:lineFragmentUsedRect:baselineOffset:in:forGlyphRange:) Customizes the line fragment geometry before committing it to the layout cache.

3. **GitHub - leavez/Neat: Fix the line height problems of TextKit**
   https://github.com/leavez/Neat
   by implementing method of NSLayoutManagerDelegate: layoutManager:shouldSetLineFragmentRect:lineFragmentUsedRect:baselineOffset:inTextContainer:forGlyphRange: and modify the rects and baseLineOffset. Neat implements both ways, beacuse neither of these methods alone can solve it well. The first can&#x27;t handle the extra line spacing below last line.

4. **LayoutManager Class Reference**
   https://desbeers.github.io/Chord-Provider/Structs/ChordProEditor/LayoutManager.html
   Layout Manager Delegate layoutManager (_: shouldSetLineFragmentRect: lineFragmentUsedRect: baselineOffset: in: forGlyphRange:)

5. **swift - iOS NSLayoutManager&#x27;s usedRect gives wrong rect if the ...**
   https://stackoverflow.com/questions/79620359/ios-nslayoutmanagers-usedrect-gives-wrong-rect-if-the-attributed-string-doesnt
   I am creating a subclass of UILabel in which I need to detect clicks in an NSAttributedString. For various reasons, I am not allowed to use UITextView. So, based on various other SO posts, I am using NSLayoutManager, NSTextContainer, and NSTextStorage to calculate the textBoundingBox. All this works pretty well except my layoutManager.usedRect gives me the wrong textBoundingBox if my ...


>>>TOOL search
{"query":"Folded", "glob":"VSCodeiPadOS/VSCodeiPadOS/**/*"}
>>>END
>>>TOOL search
{"query":"code folding", "glob":"VSCodeiPadOS/VSCodeiPadOS/**/*"}
>>>END
>>>TOOL search
{"query":"toggleFold(fileId", "glob":"VSCodeiPadOS/VSCodeiPadOS/**/*"}
>>>END
>>>END

---

## üîß TOOL RESULTS

[search]
Found 30 matches:
VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift:9: var isFolded: Bool = false
VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift:58: case startLine, endLine, isFolded, type, label
VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift:474: let foldState = regionsToSave.map { FoldStateEntry(startLine: $0.startLine, isFolded: $0.isFolded) }
VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift:493: foldRegions[index].isFolded = savedState.isFolded
VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift:501: let isFolded: Bool
VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift:524: foldRegions[regionIndex].isFolded.toggle()
VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift:537: foldRegions[regionIndex].isFolded = false
VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift:549: foldRegions[regionIndex].isFolded = true
VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift:561: foldRegions[index].isFolded = false
VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift:574: cursorLine >= $0.startLine && cursorLine <= $0.endLine && !$0.isFolded
VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift:584: $0.isFolded && ($0.startLine == cursorLine || (cursorLine >= $0.startLine && cursorLine <= $0.endLine))
VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift:611: if let firstUnfolded = foldRegions.first(where: { !$0.isFolded }) {
VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift:619: if let firstFolded = foldRegions.first(where: { $0.isFolded }) {
VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift:620: expandRegion(at: firstFolded.startLine)
VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift:627: foldRegions[index].isFolded = true
VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift:640: foldRegions[index].isFolded = true
VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift:654: foldRegions[index].isFolded = false
VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift:672: func isLineFolded(line: Int) -> Bool {
VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift:677: func isRegionFolded(at line: Int) -> Bool {
VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift:678: return foldRegions.first { $0.startLine == line }?.isFolded ?? false
VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift:700: func isFolded(fileId: String, line: Int) -> Bool {
VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift:702: return regions.first { $0.startLine == line }?.isFolded ?? false
VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift:710: regions[regionIndex].isFolded.toggle()
VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift:741: func getFoldedLineRanges() -> [ClosedRange<Int>] {
VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift:747: for region in sortedRegions where region.isFolded {
VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift:755: func getFoldedLineCount() -> Int {
VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift:762: let foldedCount = foldRegions.filter { $0.isFolded }.count
VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift:781: for region in foldRegions where region.isFolded {
VSCodeiPadOS/VSCodeiPadOS/ContentView.swift:594: if !foldingManager.isLineFolded(line: lineIndex) {
VSCodeiPadOS/VSCodeiPadOS/ContentView.swift:612: Image(systemName: foldingManager.foldRegions.first(where: { $0.startLine == lineIndex })?.isFolded == true ? "chevron.right" : "chevron.down")

---

[search]
Found 1 matches:
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SplitEditorView.swift:506: // Line numbers + breakpoints + code folding (gutter)

---

[search]
Found 2 matches:
VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift:706: func toggleFold(fileId: String, line: Int) {
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SplitEditorView.swift:518: foldingManager.toggleFold(fileId: fileId, line: lineIndex)


>>>TOOL search
{"query":"CodeFoldingManager.shared", "glob":"VSCodeiPadOS/VSCodeiPadOS/**/*"}
>>>END
>>>TOOL search
{"query":"isFoldable(fileId", "glob":"VSCodeiPadOS/VSCodeiPadOS/**/*"}
>>>END
>>>TOOL search
{"query":"detectFoldableRegions(in:", "glob":"VSCodeiPadOS/VSCodeiPadOS/**/*"}
>>>END
>>>END

---

## üîß TOOL RESULTS

[search]
Found 5 matches:
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:632: CodeFoldingManager.shared.foldCurrentLine()
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:636: CodeFoldingManager.shared.unfoldCurrentLine()
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SplitEditorView.swift:489: @ObservedObject private var foldingManager = CodeFoldingManager.shared
VSCodeiPadOS/VSCodeiPadOS/Views/CommandPalette.swift:313: CodeFoldingManager.shared.collapseAll()
VSCodeiPadOS/VSCodeiPadOS/Views/CommandPalette.swift:317: CodeFoldingManager.shared.expandAll()

---

[search]
Found 2 matches:
VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift:694: func isFoldable(fileId: String, line: Int) -> Bool {
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SplitEditorView.swift:516: if foldingManager.isFoldable(fileId: fileId, line: lineIndex) {

---

[search]
Found 3 matches:
VSCodeiPadOS/VSCodeiPadOS/ContentView.swift:492: foldingManager.detectFoldableRegions(in: newValue)
VSCodeiPadOS/VSCodeiPadOS/ContentView.swift:555: foldingManager.detectFoldableRegions(in: text)
VSCodeiPadOS/VSCodeiPadOS/ContentView.swift:559: foldingManager.detectFoldableRegions(in: text)


>>>TOOL search
{"query":"folded", "glob":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift"}
>>>END
>>>TOOL search
{"query":"CodeFoldingManager", "glob":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift"}
>>>END
>>>TOOL search
{"query":"layoutManager.delegate", "glob":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift"}
>>>END
>>>TOOL search
{"query":"textContainerInset", "glob":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift"}
>>>END
>>>END

---

## üîß TOOL RESULTS

[search]
No matches found for "folded"

---

[search]
Found 2 matches:
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:632: CodeFoldingManager.shared.foldCurrentLine()
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:636: CodeFoldingManager.shared.unfoldCurrentLine()

---

[search]
No matches found for "layoutManager.delegate"

---

[search]
Found 2 matches:
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:175: textView.textContainerInset = UIEdgeInsets(top: 8, left: 8, bottom: 8, right: 8)
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:898: let x = CGFloat(i) * indentWidth + self.textContainerInset.left


>>>TOOL search
{"query":"CodeFoldingManager", "glob":"VSCodeiPadOS/VSCodeiPadOS/**/*.swift"}
>>>END
>>>TOOL search
{"query":"isLineFolded", "glob":"VSCodeiPadOS/VSCodeiPadOS/**/*.swift"}
>>>END
>>>TOOL search
{"query":"collapsedLines", "glob":"VSCodeiPadOS/VSCodeiPadOS/**/*.swift"}
>>>END
>>>END

---

## üîß TOOL RESULTS

[search]
Found 9 matches:
VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift:68: class CodeFoldingManager: ObservableObject {
VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift:69: static let shared = CodeFoldingManager()
VSCodeiPadOS/VSCodeiPadOS/ContentView.swift:415: @StateObject private var foldingManager = CodeFoldingManager()
VSCodeiPadOS/VSCodeiPadOS/ContentView.swift:584: @ObservedObject var foldingManager: CodeFoldingManager
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:632: CodeFoldingManager.shared.foldCurrentLine()
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:636: CodeFoldingManager.shared.unfoldCurrentLine()
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SplitEditorView.swift:489: @ObservedObject private var foldingManager = CodeFoldingManager.shared
VSCodeiPadOS/VSCodeiPadOS/Views/CommandPalette.swift:313: CodeFoldingManager.shared.collapseAll()
VSCodeiPadOS/VSCodeiPadOS/Views/CommandPalette.swift:317: CodeFoldingManager.shared.expandAll()

---

[search]
Found 2 matches:
VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift:672: func isLineFolded(line: Int) -> Bool {
VSCodeiPadOS/VSCodeiPadOS/ContentView.swift:594: if !foldingManager.isLineFolded(line: lineIndex) {

---

[search]
Found 5 matches:
VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift:72: @Published var collapsedLines: Set<Int> = []
VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift:673: return collapsedLines.contains(line)
VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift:756: return collapsedLines.count
VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift:779: collapsedLines.removeAll()
VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift:783: collapsedLines.insert(line)


>>>TOOL search
{"query":".detectFoldableRegions", "glob":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SplitEditorView.swift"}
>>>END
>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SplitEditorView.swift","start_line":560,"end_line":680}
>>>END
>>>END

---

## üîß TOOL RESULTS

[search]
No matches found for ".detectFoldableRegions"

---

[read_file]
File: VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SplitEditorView.swift (lines 561-680 of 774)
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
561:                     .frame(width: 70)
562:                     .background(Color(UIColor.secondarySystemBackground).opacity(0.5))
563:                 }
564: 
565:                 // Editor
566:                 SyntaxHighlightingTextView(
567:                     text: $text,
568:                     filename: tab.fileName,
569:                     scrollPosition: $scrollPosition,
570:                     totalLines: $totalLines,
571:                     visibleLines: $visibleLines,
572:                     currentLineNumber: $currentLineNumber,
573:                     currentColumn: $currentColumn,
574:                     lineHeight: $lineHeight,
575:                     isActive: splitManager.activePaneId == pane.id,
576:                     editorCore: editorCore,
577:                     requestedLineSelection: $requestedLineSelection
578:                 )
579:                 .onChange(of: text) { newValue in
580:                     pane.updateTabContent(newValue)
581:                     
582:                     // Sync scroll if enabled
583:                     if splitManager.syncScroll {
584:                         splitManager.syncScrollOffset(CGFloat(scrollPosition) * lineHeight, fromPaneId: pane.id)
585:                     }
586:                 }
587:                 
588:                 // Mini minimap
589:                 MinimapView(
590:                     content: text,
591:                     scrollOffset: CGFloat(scrollPosition) * lineHeight,
592:                     scrollViewHeight: geometry.size.height,
593:                     totalContentHeight: CGFloat(totalLines) * lineHeight
594:                 )
595:                 .frame(width: 60)
596:             }
597:             // Sticky Header Overlay (FEAT-040)
598:             StickyHeaderView(
599:                 text: text,
600:                 currentLine: scrollPosition, // Using scrollPosition as approximate top line
601:                 theme: ThemeManager.shared.currentTheme,
602:                 lineHeight: lineHeight,
603:                 onSelect: { line in
604:                     requestedLineSelection = line
605:                 }
606:             )
607:             .padding(.leading, 70) // Offset for line numbers + folding icons
608:             .padding(.trailing, 60) // Offset for minimap
609:             
610:             // Peek Definition Overlay
611:             if let peekState = editorCore.peekState, editorCore.activeTabId == tab.id {
612:                  // Calculate simplified position: center of screen for now, but conceptually "inline"
613:                  // To make it truly inline, we'd need more complex geometry, but overlay is a good start.
614:                  VStack {
615:                      Spacer()
616:                          .frame(height: max(0, CGFloat(peekState.sourceLine - scrollPosition) * lineHeight + lineHeight + 20))
617:                      
618:                      PeekDefinitionView(
619:                          editorCore: editorCore,
620:                          targetFile: peekState.file,
621:                          targetLine: peekState.line,
622:                          content: peekState.content,
623:                          onClose: { editorCore.closePeekDefinition() },
624:                          onOpen: {
625:                              editorCore.openFile(FileItem(name: URL(fileURLWithPath: peekState.file).lastPathComponent, path: peekState.file, isDirectory: false))
626:                              editorCore.closePeekDefinition()
627:                          }
628:                      )
629:                      .padding(.horizontal)
630:                      .padding(.bottom, 20)
631:                      
632:                      Spacer()
633:                  }
634:                  .frame(maxWidth: .infinity, maxHeight: .infinity, alignment: .top)
635:                  .background(Color.black.opacity(0.01)) // Capture taps outside if needed, or let them pass
636:                  .transition(.opacity)
637:                  .zIndex(100)
638:             }
639:         }
640:         .onAppear {
641:             text = tab.content
642:         }
643:         .onChange(of: tab.id) { _ in
644:             text = tab.content
645:         }
646:         .onChange(of: pane.scrollOffset) { newOffset in
647:             if splitManager.syncScroll {
648:                 scrollPosition = Int(newOffset / lineHeight)
649:             }
650:         }
651:     }
652:     
653:     private func displayText(for lineIndex: Int) -> String {
654:         switch lineNumbersStyle {
655:         case "relative":
656:             let lineNumber = lineIndex + 1
657:             if lineNumber == currentLineNumber { return "\(lineNumber)" }
658:             return "\(abs(lineNumber - currentLineNumber))"
659:         case "interval":
660:             let lineNumber = lineIndex + 1
661:             return (lineNumber == 1 || lineNumber % 5 == 0) ? "\(lineNumber)" : ""
662:         default:
663:             return "\(lineIndex + 1)"
664:         }
665:     }
666: }
667: 
668: // MARK: - Split Drag Handle
669: 
670: struct SplitDragHandle: View {
671:     let direction: SplitDirection
672:     let onDrag: (CGFloat) -> Void
673:     
674:     @State private var isDragging = false
675:     @GestureState private var dragOffset: CGFloat = 0
676:     
677:     var body: some View {
678:         ZStack {
679:             // Background
680:             Rectangle()


>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift","start_line":80,"end_line":260}
>>>END
>>>END>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift","start_line":260,"end_line":520}
>>>END
>>>END>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift","start_line":520,"end_line":820}
>>>END
>>>END>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift","start_line":80,"end_line":260}
>>>END

---

## üîß TOOL RESULTS

[read_file]
File: VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift (lines 81-260 of 866)
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
81:     
82:     /// Detects all foldable regions in the given code
83:     func detectFoldableRegions(in code: String, filePath: String? = nil) {
84:         self.currentFilePath = filePath
85:         self.currentFileId = filePath
86:         
87:         let lines = code.components(separatedBy: .newlines)
88:         var regions: [FoldRegion] = []
89:         
90:         // Track different types of blocks
91:         var blockStack: [(type: FoldRegion.FoldType, startLine: Int, label: String?)] = []
92:         var commentStack: [(startLine: Int, isMultiline: Bool)] = []
93:         var regionStack: [(startLine: Int, label: String)] = []
94:         
95:         for (index, line) in lines.enumerated() {
96:             let trimmed = line.trimmingCharacters(in: .whitespaces)
97:             let leadingWhitespace = line.prefix { $0 == " " || $0 == "\t" }.count
98:             
99:             // Skip empty lines for most detections
100:             guard !trimmed.isEmpty else { continue }
101:             
102:             // MARK: - Region Detection (#region, #pragma mark, MARK:)
103:             if detectRegionStart(trimmed) != nil {
104:                 if let label = detectRegionStart(trimmed) {
105:                     regionStack.append((index, label))
106:                 }
107:             } else if detectRegionEnd(trimmed) {
108:                 if let region = regionStack.popLast() {
109:                     if index - region.startLine > 1 {
110:                         regions.append(FoldRegion(
111:                             startLine: region.startLine,
112:                             endLine: index,
113:                             type: .region,
114:                             label: region.label
115:                         ))
116:                     }
117:                 }
118:             }
119:             
120:             // MARK: - Import Statement Detection
121:             if trimmed.hasPrefix("import ") {
122:                 // Group consecutive imports
123:                 let importEnd = findConsecutiveImports(from: index, in: lines)
124:                 if importEnd > index {
125:                     regions.append(FoldRegion(
126:                         startLine: index,
127:                         endLine: importEnd,
128:                         type: .importStatement,
129:                         label: "Imports"
130:                     ))
131:                 }
132:             }
133:             
134:             // MARK: - Comment Detection
135:             if detectCommentStart(trimmed) {
136:                 commentStack.append((index, true))
137:             } else if trimmed.starts(with: "//") {
138:                 // Single-line comment - check for consecutive comment blocks
139:                 let commentEnd = findConsecutiveComments(from: index, in: lines)
140:                 if commentEnd > index {
141:                     regions.append(FoldRegion(
142:                         startLine: index,
143:                         endLine: commentEnd,
144:                         type: .comment,
145:                         label: "Comment"
146:                     ))
147:                 }
148:             } else if detectCommentEnd(trimmed) {
149:                 if let comment = commentStack.popLast() {
150:                     if index - comment.startLine > 1 {
151:                         regions.append(FoldRegion(
152:                             startLine: comment.startLine,
153:                             endLine: index,
154:                             type: .comment,
155:                             label: "Comment"
156:                         ))
157:                     }
158:                 }
159:             }
160:             
161:             // MARK: - Class/Struct/Enum/Protocol/Extension Detection
162:             if let declaration = detectDeclaration(trimmed) {
163:                 if trimmed.contains("{") {
164:                     blockStack.append((declaration.type, index, declaration.label))
165:                 } else {
166:                     // Declaration without opening brace - look ahead for it
167:                     if let braceLine = findOpeningBrace(from: index + 1, in: lines) {
168:                         blockStack.append((declaration.type, index, declaration.label))
169:                     }
170:                 }
171:             }
172:             
173:             // MARK: - Function/Method Detection
174:             if let functionInfo = detectFunction(trimmed) {
175:                 if trimmed.contains("{") {
176:                     blockStack.append((.function, index, functionInfo))
177:                 } else {
178:                     // Function without opening brace - look ahead
179:                     if let braceLine = findOpeningBrace(from: index + 1, in: lines) {
180:                         blockStack.append((.function, index, functionInfo))
181:                     }
182:                 }
183:             }
184:             
185:             // MARK: - Control Flow Detection (if, guard, for, while, switch, etc.)
186:             if let controlFlowLabel = detectControlFlow(trimmed) {
187:                 if trimmed.contains("{") {
188:                     blockStack.append((.controlFlow, index, controlFlowLabel))
189:                 } else {
190:                     if let braceLine = findOpeningBrace(from: index + 1, in: lines) {
191:                         blockStack.append((.controlFlow, index, controlFlowLabel))
192:                     }
193:                 }
194:             }
195:             
196:             // MARK: - Generic Block Detection
197:             if trimmed.hasSuffix("{") && !isDeclarationLine(trimmed) && !isFunctionLine(trimmed) {
198:                 blockStack.append((.genericBlock, index, nil))
199:             }
200:             
201:             // MARK: - Block End Detection
202:             if detectBlockEnd(trimmed, leadingWhitespace: leadingWhitespace) {
203:                 if let lastBlock = blockStack.popLast() {
204:                     if index - lastBlock.startLine > 1 {
205:                         regions.append(FoldRegion(
206:                             startLine: lastBlock.startLine,
207:                             endLine: index,
208:                             type: lastBlock.type,
209:                             label: lastBlock.label
210:                         ))
211:                     }
212:                 }
213:             }
214:         }
215:         
216:         // Handle any remaining unclosed blocks
217:         while let lastBlock = blockStack.popLast() {
218:             if lines.count - 1 - lastBlock.startLine > 1 {
219:                 regions.append(FoldRegion(
220:                     startLine: lastBlock.startLine,
221:                     endLine: lines.count - 1,
222:                     type: lastBlock.type,
223:                     label: lastBlock.label
224:                 ))
225:             }
226:         }
227:         
228:         // Sort regions by start line
229:         regions.sort { $0.startLine < $1.startLine }
230:         
231:         self.foldRegions = regions
232:         
233:         // Store regions in the per-file dictionary
234:         if let fileId = currentFileId {
235:             foldRegionsByFile[fileId] = regions
236:         }
237:         
238:         // Restore previous fold state for this file
239:         if let filePath = filePath {
240:             restoreFoldState(for: filePath)
241:         }
242:         
243:         updateCollapsedLines()
244:     }
245:     
246:     // MARK: - Detection Helper Methods
247:     
248:     private func detectRegionStart(_ line: String) -> String? {
249:         // C# / VS style regions
250:         if line.hasPrefix("#region") {
251:             let components = line.components(separatedBy: "#region")
252:             return components.count > 1 ? components[1].trimmingCharacters(in: .whitespaces) : "Region"
253:         }
254:         // Objective-C pragma marks
255:         if line.hasPrefix("#pragma mark") {
256:             let components = line.components(separatedBy: "#pragma mark")
257:             return components.count > 1 ? components[1].trimmingCharacters(in: .whitespaces) : "Mark"
258:         }
259:         // Swift MARK comments
260:         if line.contains("MARK:") {

---

[read_file]
File: VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift (lines 261-520 of 866)
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
261:             let components = line.components(separatedBy: "MARK:")
262:             return components.count > 1 ? components[1].trimmingCharacters(in: .whitespaces) : "Mark"
263:         }
264:         // TODO/FIXME regions
265:         if line.contains("TODO:") {
266:             let components = line.components(separatedBy: "TODO:")
267:             return "TODO: " + (components.count > 1 ? components[1].trimmingCharacters(in: .whitespaces) : "")
268:         }
269:         if line.contains("FIXME:") {
270:             let components = line.components(separatedBy: "FIXME:")
271:             return "FIXME: " + (components.count > 1 ? components[1].trimmingCharacters(in: .whitespaces) : "")
272:         }
273:         return nil
274:     }
275:     
276:     private func detectRegionEnd(_ line: String) -> Bool {
277:         return line.hasPrefix("#endregion") || 
278:                line == "// MARK: -" ||
279:                line.hasPrefix("#pragma mark -")
280:     }
281:     
282:     private func detectCommentStart(_ line: String) -> Bool {
283:         return line.hasPrefix("/*") && !line.contains("*/")
284:     }
285:     
286:     private func detectCommentEnd(_ line: String) -> Bool {
287:         return line.contains("*/") && !line.hasPrefix("/*")
288:     }
289:     
290:     private func findConsecutiveImports(from startIndex: Int, in lines: [String]) -> Int {
291:         var endIndex = startIndex
292:         for i in startIndex..<lines.count {
293:             let trimmed = lines[i].trimmingCharacters(in: .whitespaces)
294:             if trimmed.hasPrefix("import ") {
295:                 endIndex = i
296:             } else if !trimmed.isEmpty {
297:                 break
298:             }
299:         }
300:         return endIndex
301:     }
302:     
303:     private func findConsecutiveComments(from startIndex: Int, in lines: [String]) -> Int {
304:         var endIndex = startIndex
305:         for i in startIndex..<lines.count {
306:             let trimmed = lines[i].trimmingCharacters(in: .whitespaces)
307:             if trimmed.starts(with: "//") {
308:                 endIndex = i
309:             } else if !trimmed.isEmpty {
310:                 break
311:             }
312:         }
313:         return endIndex
314:     }
315:     
316:     private func detectDeclaration(_ line: String) -> (type: FoldRegion.FoldType, label: String)? {
317:         // Class detection
318:         if let className = extractName(from: line, prefix: "class", visibility: ["public", "private", "internal", "fileprivate", "open", "final"]) {
319:             return (.classOrStruct, className)
320:         }
321:         // Struct detection
322:         if let structName = extractName(from: line, prefix: "struct", visibility: ["public", "private", "internal", "fileprivate"]) {
323:             return (.classOrStruct, structName)
324:         }
325:         // Enum detection
326:         if let enumName = extractName(from: line, prefix: "enum", visibility: ["public", "private", "internal", "fileprivate", "indirect"]) {
327:             return (.enumDeclaration, enumName)
328:         }
329:         // Protocol detection
330:         if let protocolName = extractName(from: line, prefix: "protocol", visibility: ["public", "private", "internal", "fileprivate"]) {
331:             return (.protocolDeclaration, protocolName)
332:         }
333:         // Extension detection
334:         if let extensionName = extractName(from: line, prefix: "extension", visibility: []) {
335:             return (.extension, extensionName)
336:         }
337:         return nil
338:     }
339:     
340:     private func detectFunction(_ line: String) -> String? {
341:         // Function detection with visibility modifiers
342:         let visibilityKeywords = ["public", "private", "internal", "fileprivate", "static", "class", "override", "final", "mutating", "convenience"]
343:         
344:         // Check for 'func' keyword
345:         if line.contains("func ") {
346:             // Extract function name
347:             let funcPattern = "func\\s+(\\w+)"
348:             if let regex = try? NSRegularExpression(pattern: funcPattern),
349:                let match = regex.firstMatch(in: line, range: NSRange(line.startIndex..., in: line)),
350:                let nameRange = Range(match.range(at: 1), in: line) {
351:                 let functionName = String(line[nameRange])
352:                 // Check for parameters to create label
353:                 if let parenStart = line.firstIndex(of: "("), let parenEnd = line.firstIndex(of: ")") {
354:                     let params = String(line[parenStart...parenEnd])
355:                     return "\(functionName)\(params)"
356:                 }
357:                 return functionName
358:             }
359:         }
360:         
361:         // Init detection
362:         if let initName = extractName(from: line, prefix: "init", visibility: visibilityKeywords) {
363:             return "\(initName)"
364:         }
365:         
366:         // Deinit detection
367:         if line.contains("deinit") {
368:             return "deinit"
369:         }
370:         
371:         // Computed property with get/set
372:         if line.hasPrefix("var ") && (line.contains("{") || line.contains("get")) {
373:             if let varName = extractVariableName(from: line) {
374:                 return varName
375:             }
376:         }
377:         
378:         return nil
379:     }
380:     
381:     private func detectControlFlow(_ line: String) -> String? {
382:         let controlFlowPatterns = [
383:             ("if ", "if"),
384:             ("guard ", "guard"),
385:             ("else if", "else if"),
386:             ("else", "else"),
387:             ("for ", "for"),
388:             ("while ", "while"),
389:             ("repeat", "repeat"),
390:             ("switch ", "switch"),
391:             ("case ", "case"),
392:             ("default:", "default"),
393:             ("do ", "do"),
394:             ("catch", "catch")
395:         ]
396:         
397:         for (pattern, label) in controlFlowPatterns {
398:             if line.contains(pattern) {
399:                 return label
400:             }
401:         }
402:         return nil
403:     }
404:     
405:     private func extractName(from line: String, prefix: String, visibility: [String]) -> String? {
406:         var components = line.components(separatedBy: .whitespaces).filter { !$0.isEmpty }
407:         
408:         // Remove visibility modifiers
409:         components = components.filter { !visibility.contains($0) }
410:         
411:         // Find prefix index
412:         if let prefixIndex = components.firstIndex(where: { $0 == prefix }),
413:            prefixIndex + 1 < components.count {
414:             var name = components[prefixIndex + 1]
415:             // Remove colons and other trailing characters
416:             name = name.components(separatedBy: ":").first ?? name
417:             name = name.components(separatedBy: "<").first ?? name
418:             name = name.components(separatedBy: ":").first ?? name
419:             return name
420:         }
421:         return nil
422:     }
423:     
424:     private func extractVariableName(from line: String) -> String? {
425:         let components = line.components(separatedBy: .whitespaces).filter { !$0.isEmpty }
426:         if components.count >= 2, components[0] == "var" {
427:             var varName = components[1]
428:             varName = varName.components(separatedBy: ":").first ?? varName
429:             varName = varName.components(separatedBy: "=").first ?? varName
430:             return varName
431:         }
432:         return nil
433:     }
434:     
435:     private func findOpeningBrace(from startIndex: Int, in lines: [String]) -> Int? {
436:         for i in startIndex..<min(startIndex + 5, lines.count) {
437:             if lines[i].contains("{") {
438:                 return i
439:             }
440:         }
441:         return nil
442:     }
443:     
444:     private func isDeclarationLine(_ line: String) -> Bool {
445:         let keywords = ["class", "struct", "enum", "protocol", "extension", "init", "func"]
446:         return keywords.contains { line.contains("\($0) ") }
447:     }
448:     
449:     private func isFunctionLine(_ line: String) -> Bool {
450:         return line.contains("func ") || line.contains("init ")
451:     }
452:     
453:     private func detectBlockEnd(_ line: String, leadingWhitespace: Int) -> Bool {
454:         return (line.hasPrefix("}") || line.starts(with: "}")) && 
455:                (line.trimmingCharacters(in: .whitespaces) == "}" || 
456:                 line.trimmingCharacters(in: .whitespaces).hasPrefix("}"))
457:     }
458:     
459:     // MARK: - Fold State Persistence
460:     
461:     /// Saves the current fold state to UserDefaults
462:     func saveFoldState(for filePath: String) {
463:         let key = UserDefaultsKeys.foldStatePrefix + filePath
464:         
465:         // Use regions from the dictionary if available
466:         let regionsToSave: [FoldRegion]
467:         if let fileId = currentFileId, let storedRegions = foldRegionsByFile[fileId] {
468:             regionsToSave = storedRegions
469:         } else {
470:             regionsToSave = foldRegions
471:         }
472:         
473:         // Create a simplified representation for storage
474:         let foldState = regionsToSave.map { FoldStateEntry(startLine: $0.startLine, isFolded: $0.isFolded) }
475:         
476:         if let data = try? JSONEncoder().encode(foldState) {
477:             UserDefaults.standard.set(data, forKey: key)
478:         }
479:     }
480:     
481:     /// Restores fold state from UserDefaults
482:     private func restoreFoldState(for filePath: String) {
483:         let key = UserDefaultsKeys.foldStatePrefix + filePath
484:         
485:         guard let data = UserDefaults.standard.data(forKey: key),
486:               let foldState = try? JSONDecoder().decode([FoldStateEntry].self, from: data) else {
487:             return
488:         }
489:         
490:         // Apply saved state to current regions
491:         for savedState in foldState {
492:             if let index = foldRegions.firstIndex(where: { $0.startLine == savedState.startLine }) {
493:                 foldRegions[index].isFolded = savedState.isFolded
494:             }
495:         }
496:     }
497:     
498:     /// Helper struct for persisting fold state
499:     private struct FoldStateEntry: Codable {
500:         let startLine: Int
501:         let isFolded: Bool
502:     }
503:     
504:     /// Clears fold state for a specific file
505:     func clearFoldState(for filePath: String) {
506:         let key = UserDefaultsKeys.foldStatePrefix + filePath
507:         UserDefaults.standard.removeObject(forKey: key)
508:     }
509:     
510:     /// Clears all fold states
511:     func clearAllFoldStates() {
512:         let defaults = UserDefaults.standard
513:         let keys = defaults.dictionaryRepresentation().keys.filter { $0.hasPrefix(UserDefaultsKeys.foldStatePrefix) }
514:         for key in keys {
515:             defaults.removeObject(forKey: key)
516:         }
517:     }
518:     
519:     // MARK: - Fold Operations
520:     

---

[read_file]
File: VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift (lines 521-820 of 866)
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
521:     /// Toggles the fold state at a specific line
522:     func toggleFold(at line: Int) {
523:         if let regionIndex = foldRegions.firstIndex(where: { $0.startLine == line }) {
524:             foldRegions[regionIndex].isFolded.toggle()
525:             updateCollapsedLines()
526:             
527:             // Save state after toggling
528:             if let filePath = currentFilePath {
529:                 saveFoldState(for: filePath)
530:             }
531:         }
532:     }
533:     
534:     /// Expands a folded region
535:     func expandRegion(at line: Int) {
536:         if let regionIndex = foldRegions.firstIndex(where: { $0.startLine == line }) {
537:             foldRegions[regionIndex].isFolded = false
538:             updateCollapsedLines()
539:             
540:             if let filePath = currentFilePath {
541:                 saveFoldState(for: filePath)
542:             }
543:         }
544:     }
545:     
546:     /// Collapses a region
547:     func collapseRegion(at line: Int) {
548:         if let regionIndex = foldRegions.firstIndex(where: { $0.startLine == line }) {
549:             foldRegions[regionIndex].isFolded = true
550:             updateCollapsedLines()
551:             
552:             if let filePath = currentFilePath {
553:                 saveFoldState(for: filePath)
554:             }
555:         }
556:     }
557:     
558:     /// Expands all folded regions
559:     func expandAll() {
560:         for index in foldRegions.indices {
561:             foldRegions[index].isFolded = false
562:         }
563:         updateCollapsedLines()
564:         
565:         if let filePath = currentFilePath {
566:             saveFoldState(for: filePath)
567:         }
568:     }
569:     
570:     /// Folds the region containing the given cursor line
571:     func foldAtLine(_ cursorLine: Int) {
572:         // Find the innermost region containing this line
573:         if let region = foldRegions.filter({ 
574:             cursorLine >= $0.startLine && cursorLine <= $0.endLine && !$0.isFolded
575:         }).min(by: { ($0.endLine - $0.startLine) < ($1.endLine - $1.startLine) }) {
576:             collapseRegion(at: region.startLine)
577:         }
578:     }
579:     
580:     /// Unfolds the region containing the given cursor line
581:     func unfoldAtLine(_ cursorLine: Int) {
582:         // Find any folded region that starts at or contains this line
583:         if let region = foldRegions.first(where: { 
584:             $0.isFolded && ($0.startLine == cursorLine || (cursorLine >= $0.startLine && cursorLine <= $0.endLine))
585:         }) {
586:             expandRegion(at: region.startLine)
587:         }
588:     }
589:     
590:     /// Toggle fold at cursor line - convenience method
591:     func toggleFoldAtLine(_ cursorLine: Int) {
592:         // First check if we're on a fold start line
593:         if let region = foldRegions.first(where: { $0.startLine == cursorLine }) {
594:             toggleFold(at: region.startLine)
595:             return
596:         }
597:         
598:         // Otherwise find the innermost region containing this line
599:         if let region = foldRegions.filter({ 
600:             cursorLine >= $0.startLine && cursorLine <= $0.endLine
601:         }).min(by: { ($0.endLine - $0.startLine) < ($1.endLine - $1.startLine) }) {
602:             toggleFold(at: region.startLine)
603:         }
604:     }
605:     
606:     // MARK: - Legacy/Convenience Methods (for keyboard shortcuts)
607:     
608:     /// Folds at the current line (uses line 0 as fallback - caller should use foldAtLine(_:) with actual cursor)
609:     func foldCurrentLine() {
610:         // This is called from keyboard shortcuts - fold at line 0 or first available region
611:         if let firstUnfolded = foldRegions.first(where: { !$0.isFolded }) {
612:             collapseRegion(at: firstUnfolded.startLine)
613:         }
614:     }
615:     
616:     /// Unfolds at the current line (uses line 0 as fallback - caller should use unfoldAtLine(_:) with actual cursor)
617:     func unfoldCurrentLine() {
618:         // This is called from keyboard shortcuts - unfold first folded region
619:         if let firstFolded = foldRegions.first(where: { $0.isFolded }) {
620:             expandRegion(at: firstFolded.startLine)
621:         }
622:     }
623:     
624:     /// Collapses all foldable regions
625:     func collapseAll() {
626:         for index in foldRegions.indices {
627:             foldRegions[index].isFolded = true
628:         }
629:         updateCollapsedLines()
630:         
631:         if let filePath = currentFilePath {
632:             saveFoldState(for: filePath)
633:         }
634:     }
635:     
636:     /// Collapses all regions of a specific type
637:     func collapseAll(ofType type: FoldRegion.FoldType) {
638:         for index in foldRegions.indices {
639:             if foldRegions[index].type == type {
640:                 foldRegions[index].isFolded = true
641:             }
642:         }
643:         updateCollapsedLines()
644:         
645:         if let filePath = currentFilePath {
646:             saveFoldState(for: filePath)
647:         }
648:     }
649:     
650:     /// Expands all regions of a specific type
651:     func expandAll(ofType type: FoldRegion.FoldType) {
652:         for index in foldRegions.indices {
653:             if foldRegions[index].type == type {
654:                 foldRegions[index].isFolded = false
655:             }
656:         }
657:         updateCollapsedLines()
658:         
659:         if let filePath = currentFilePath {
660:             saveFoldState(for: filePath)
661:         }
662:     }
663:     
664:     // MARK: - Query Methods
665:     
666:     /// Checks if a line is foldable
667:     func isFoldable(line: Int) -> Bool {
668:         return foldRegions.contains { $0.startLine == line }
669:     }
670:     
671:     /// Checks if a line is currently folded
672:     func isLineFolded(line: Int) -> Bool {
673:         return collapsedLines.contains(line)
674:     }
675:     
676:     /// Checks if a region at a given line is folded
677:     func isRegionFolded(at line: Int) -> Bool {
678:         return foldRegions.first { $0.startLine == line }?.isFolded ?? false
679:     }
680:     
681:     /// Gets the fold region at a specific line
682:     func getRegion(at line: Int) -> FoldRegion? {
683:         return foldRegions.first { $0.startLine == line }
684:     }
685:     
686:     /// Gets all fold regions of a specific type
687:     func getRegions(ofType type: FoldRegion.FoldType) -> [FoldRegion] {
688:         return foldRegions.filter { $0.type == type }
689:     }
690:     
691:     // MARK: - File-Aware Methods
692:     
693:     /// Checks if a line is foldable for a specific file
694:     func isFoldable(fileId: String, line: Int) -> Bool {
695:         guard let regions = foldRegionsByFile[fileId] else { return false }
696:         return regions.contains { $0.startLine == line }
697:     }
698:     
699:     /// Checks if a region at a given line is folded for a specific file
700:     func isFolded(fileId: String, line: Int) -> Bool {
701:         guard let regions = foldRegionsByFile[fileId] else { return false }
702:         return regions.first { $0.startLine == line }?.isFolded ?? false
703:     }
704:     
705:     /// Toggles the fold state at a specific line for a specific file
706:     func toggleFold(fileId: String, line: Int) {
707:         guard var regions = foldRegionsByFile[fileId] else { return }
708:         
709:         if let regionIndex = regions.firstIndex(where: { $0.startLine == line }) {
710:             regions[regionIndex].isFolded.toggle()
711:             foldRegionsByFile[fileId] = regions
712:             
713:             // Update current file regions if this is the active file
714:             if fileId == currentFileId {
715:                 self.foldRegions = regions
716:                 updateCollapsedLines()
717:             }
718:             
719:             // Save state after toggling
720:             saveFoldState(for: fileId)
721:         }
722:     }
723:     
724:     /// Gets fold regions for a specific file
725:     func getFoldRegions(for fileId: String) -> [FoldRegion] {
726:         return foldRegionsByFile[fileId] ?? []
727:     }
728:     
729:     /// Clears fold regions for a specific file from memory
730:     func clearFoldRegions(for fileId: String) {
731:         foldRegionsByFile.removeValue(forKey: fileId)
732:     }
733:     
734:     /// Clears all fold regions from memory
735:     func clearAllFoldRegions() {
736:         foldRegionsByFile.removeAll()
737:     }
738:     
739:     /// Gets folded line ranges for text hiding
740:     /// Returns an array of closed ranges representing the line numbers that should be hidden
741:     func getFoldedLineRanges() -> [ClosedRange<Int>] {
742:         var ranges: [ClosedRange<Int>] = []
743:         
744:         // Sort regions by start line to ensure proper ordering
745:         let sortedRegions = foldRegions.sorted { $0.startLine < $1.startLine }
746:         
747:         for region in sortedRegions where region.isFolded {
748:             ranges.append((region.startLine + 1)...region.endLine)
749:         }
750:         
751:         return ranges
752:     }
753:     
754:     /// Gets the total count of folded lines
755:     func getFoldedLineCount() -> Int {
756:         return collapsedLines.count
757:     }
758:     
759:     /// Gets a summary of fold statistics
760:     func getFoldStatistics() -> FoldStatistics {
761:         let totalCount = foldRegions.count
762:         let foldedCount = foldRegions.filter { $0.isFolded }.count
763:         
764:         var typeBreakdown: [FoldRegion.FoldType: Int] = [:]
765:         for region in foldRegions {
766:             typeBreakdown[region.type, default: 0] += 1
767:         }
768:         
769:         return FoldStatistics(
770:             totalRegions: totalCount,
771:             foldedRegions: foldedCount,
772:             typeBreakdown: typeBreakdown
773:         )
774:     }
775:     
776:     // MARK: - Private Methods
777:     
778:     private func updateCollapsedLines() {
779:         collapsedLines.removeAll()
780:         
781:         for region in foldRegions where region.isFolded {
782:             for line in (region.startLine + 1)...region.endLine {
783:                 collapsedLines.insert(line)
784:             }
785:         }
786:     }
787: }
788: 
789: // MARK: - Fold Statistics
790: struct FoldStatistics {
791:     let totalRegions: Int
792:     let foldedRegions: Int
793:     let typeBreakdown: [FoldRegion.FoldType: Int]
794:     
795:     var expansionPercentage: Double {
796:         guard totalRegions > 0 else { return 0 }
797:         return Double(foldedCount) / Double(totalRegions) * 100
798:     }
799:     
800:     var foldedCount: Int {
801:         return foldedRegions
802:     }
803:     
804:     var expandedCount: Int {
805:         return totalRegions - foldedRegions
806:     }
807: }
808: 
809: // MARK: - Fold Button View
810: struct FoldButton: View {
811:     let line: Int
812:     let isExpanded: Bool
813:     let foldType: FoldRegion.FoldType?
814:     let action: () -> Void
815:     
816:     var body: some View {
817:         Button(action: action) {
818:             ZStack {
819:                 if let type = foldType {
820:                     Text(type.icon)


>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/ContentView.swift","start_line":380,"end_line":460}
>>>END
>>>END

---

## üîß TOOL RESULTS

[read_file]
File: VSCodeiPadOS/VSCodeiPadOS/ContentView.swift (lines 381-460 of 1064)
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
381:                 .foregroundColor(isSelected ? theme.tabActiveForeground : theme.tabInactiveForeground)
382:             if tab.isUnsaved { Circle().fill(Color.orange).frame(width: 6, height: 6) }
383:             Button(action: { editorCore.closeTab(id: tab.id) }) {
384:                 Image(systemName: "xmark").font(.system(size: 9, weight: .medium))
385:                     .foregroundColor(isSelected ? theme.tabActiveForeground.opacity(0.6) : theme.tabInactiveForeground)
386:             }
387:         }
388:         .padding(.horizontal, 12).padding(.vertical, 6)
389:         .background(RoundedRectangle(cornerRadius: 4).fill(isSelected ? theme.tabActiveBackground : theme.tabInactiveBackground))
390:         .onTapGesture { editorCore.selectTab(id: tab.id) }
391:     }
392: }
393: 
394: // MARK: - Editor with Syntax Highlighting + Autocomplete + Folding
395: 
396: struct IDEEditorView: View {
397:     @ObservedObject var editorCore: EditorCore
398:     let tab: Tab
399:     let theme: Theme
400: 
401:     @AppStorage("lineNumbersStyle") private var lineNumbersStyle: String = "on"
402:     @State private var text: String = ""
403:     @State private var scrollPosition: Int = 0
404:     @State private var totalLines: Int = 1
405:     @State private var visibleLines: Int = 20
406:     @State private var currentLineNumber: Int = 1
407:     @State private var currentColumn: Int = 1
408:     @State private var cursorIndex: Int = 0
409:     @State private var lineHeight: CGFloat = 17
410:     @State private var requestedCursorIndex: Int? = nil
411:     @State private var requestedLineSelection: Int? = nil
412: 
413:     @StateObject private var autocomplete = AutocompleteManager()
414:     @State private var showAutocomplete = false
415:     @StateObject private var foldingManager = CodeFoldingManager()
416:     @StateObject private var findViewModel = FindViewModel()
417:     
418:     var body: some View {
419:         VStack(spacing: 0) {
420:             // Find/Replace bar
421:             if editorCore.showSearch {
422:                 FindReplaceView(viewModel: findViewModel)
423:                     .background(theme.tabBarBackground)
424:             }
425:             
426:             BreadcrumbsView(editorCore: editorCore, tab: tab)
427:             
428:             GeometryReader { geometry in
429:                 ZStack(alignment: .topLeading) {
430:                 HStack(spacing: 0) {
431:                     if lineNumbersStyle != "off" {
432:                         LineNumbersWithFolding(
433:                             fileId: tab.url?.path ?? tab.fileName,
434:                             totalLines: totalLines,
435:                             currentLine: currentLineNumber,
436:                             scrollOffset: CGFloat(scrollPosition) * lineHeight,
437:                             lineHeight: lineHeight,
438:                             requestedLineSelection: $requestedLineSelection,
439:                             foldingManager: foldingManager,
440:                             theme: theme
441:                         )
442:                         .frame(width: 60)
443:                         .background(theme.sidebarBackground.opacity(0.5))
444:                     }
445:                     
446:                     if tab.fileName.hasSuffix(".json") {
447:                         // JSON Tree View for .json files
448:                         JSONTreeView(data: text.data(using: .utf8) ?? Data())
449:                             .frame(maxWidth: .infinity, maxHeight: .infinity)
450:                             .background(theme.editorBackground)
451:                     } else {
452:                         SyntaxHighlightingTextView(
453:                             text: $text,
454:                             filename: tab.fileName,
455:                             scrollPosition: $scrollPosition,
456:                             totalLines: $totalLines,
457:                             visibleLines: $visibleLines,
458:                             currentLineNumber: $currentLineNumber,
459:                             currentColumn: $currentColumn,
460:                             cursorIndex: $cursorIndex,


>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift","start_line":740,"end_line":920}
>>>END
>>>END>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift","start_line":920,"end_line":1150}
>>>END
>>>END>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift","start_line":1150,"end_line":1390}
>>>END
>>>END>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift","start_line":1390,"end_line":1600}
>>>END
>>>END>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift","start_line":1600,"end_line":2000}
>>>END
>>>END>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift","start_line":740,"end_line":1120}
>>>END
>>>END

---

## üîß TOOL RESULTS

[read_file]
File: VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift (lines 741-920 of 2051)
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
741:                         if depth == 0 {
742:                             matchIndex = i
743:                             break
744:                         } else {
745:                             depth -= 1
746:                         }
747:                     }
748:                     i += 1
749:                 }
750:             } else if let open = closeToOpen[bracketChar] {
751:                 // Closing bracket: scan backward
752:                 var depth = 0
753:                 var i = idx - 1
754:                 while i >= 0 {
755:                     let c = nsText.character(at: i)
756:                     if c == bracketChar {
757:                         depth += 1
758:                     } else if c == open {
759:                         if depth == 0 {
760:                             matchIndex = i
761:                             break
762:                         } else {
763:                             depth -= 1
764:                         }
765:                     }
766:                     i -= 1
767:                 }
768:             }
769: 
770:             guard let match = matchIndex else { return }
771: 
772:             let r1 = NSRange(location: idx, length: 1)
773:             let r2 = NSRange(location: match, length: 1)
774: 
775:             textView.textStorage.addAttribute(.backgroundColor, value: bg, range: r1)
776:             textView.textStorage.addAttribute(.backgroundColor, value: bg, range: r2)
777: 
778:             textView.textStorage.addAttribute(.underlineStyle, value: NSUnderlineStyle.single.rawValue, range: r1)
779:             textView.textStorage.addAttribute(.underlineStyle, value: NSUnderlineStyle.single.rawValue, range: r2)
780: 
781:             bracketHighlightRanges = [r1, r2]
782:         }
783:     }
784: }
785: 
786: // Custom text view to handle key commands, indent guides, and line highlighting
787: class EditorTextView: UITextView {
788:     var onPeekDefinition: (() -> Void)?
789:     var onEscape: (() -> Void)?
790:     var onGoToLine: (() -> Void)?
791:     
792:     // Custom action closures for context menu
793:     var onGoToDefinition: (() -> Void)?
794:     var onFindReferences: (() -> Void)?
795:     var onFormatDocument: (() -> Void)?
796:     var onToggleComment: (() -> Void)?
797:     var onFold: (() -> Void)?
798:     var onUnfold: (() -> Void)?
799: 
800:     // Autocomplete key handling hooks (return true if handled)
801:     var onAcceptAutocomplete: (() -> Bool)?
802:     var onDismissAutocomplete: (() -> Bool)?
803:     
804:     // FEAT-039 & FEAT-043
805:     private var indentGuideColor: UIColor = .separator
806:     private var activeIndentGuideColor: UIColor = .label
807:     private var currentLineHighlightColor: UIColor = .clear
808:     
809:     override init(frame: CGRect, textContainer: NSTextContainer?) {
810:         super.init(frame: frame, textContainer: textContainer)
811:         setup()
812:     }
813:     
814:     required init?(coder: NSCoder) {
815:         super.init(coder: coder)
816:         setup()
817:     }
818:     
819:     private func setup() {
820:         // Ensure we redraw when bounds/selection change
821:         contentMode = .redraw
822:     }
823:     
824:     func updateThemeColors(theme: Theme) {
825:         self.indentGuideColor = UIColor(theme.indentGuide)
826:         self.activeIndentGuideColor = UIColor(theme.indentGuideActive)
827:         self.currentLineHighlightColor = UIColor(theme.currentLineHighlight)
828:         setNeedsDisplay()
829:     }
830:     
831:     override func draw(_ rect: CGRect) {
832:         guard let context = UIGraphicsGetCurrentContext(), let font = self.font else {
833:             super.draw(rect)
834:             return
835:         }
836:         
837:         // 1. Draw Current Line Highlight (FEAT-043)
838:         if let selectedRange = selectedTextRange {
839:             // Get the line rect for the cursor position
840:             let caretRect = self.caretRect(for: selectedRange.start)
841:             let lineRect = CGRect(x: 0, y: caretRect.minY, width: bounds.width, height: caretRect.height)
842:             
843:             context.setFillColor(currentLineHighlightColor.cgColor)
844:             context.fill(lineRect)
845:         }
846:         
847:         // 2. Draw Text (super implementation)
848:         super.draw(rect)
849:         
850:         // 3. Draw Indent Guides (FEAT-039)
851:         // We iterate visible lines and draw vertical lines for indentation
852:         // Optimization: Only draw for visible range
853: 
854:         context.setLineWidth(1.0)
855: 
856:         // Respect editor tab size setting (default 4)
857:         let storedTabSize = UserDefaults.standard.integer(forKey: "tabSize")
858:         let tabSize = storedTabSize > 0 ? storedTabSize : 4
859: 
860:         let spaceWidth = " ".size(withAttributes: [.font: font]).width
861:         let indentWidth = spaceWidth * CGFloat(tabSize)
862: 
863:         // Determine active indent level for caret line (for indentGuideActive)
864:         var activeIndentLevel: Int = 0
865:         if let selected = selectedTextRange {
866:             let caretPos = offset(from: beginningOfDocument, to: selected.start)
867:             let nsText = (self.text ?? "") as NSString
868:             let safeLoc = min(max(0, caretPos), nsText.length)
869:             let caretLineRange = nsText.lineRange(for: NSRange(location: safeLoc, length: 0))
870:             let caretLineText = nsText.substring(with: caretLineRange)
871: 
872:             var spaces = 0
873:             for ch in caretLineText {
874:                 if ch == " " { spaces += 1 }
875:                 else if ch == "\t" { spaces += tabSize }
876:                 else { break }
877:             }
878:             activeIndentLevel = spaces / tabSize
879:         }
880: 
881:         // Iterate visible glyphs/lines
882:         let visibleRect = CGRect(origin: contentOffset, size: bounds.size)
883:         let glyphRange = layoutManager.glyphRange(forBoundingRect: visibleRect, in: textContainer)
884: 
885:         let caretY = selectedTextRange.map { caretRect(for: $0.start).minY }
886: 
887:         layoutManager.enumerateLineFragments(forGlyphRange: glyphRange) { (rect, usedRect, textContainer, glyphRange, stop) in
888:             // Get text for this line
889:             guard let range = self.layoutManager.characterRange(forGlyphRange: glyphRange, actualGlyphRange: nil) as NSRange?,
890:                   let text = self.text as NSString? else { return }
891: 
892:             let lineText = text.substring(with: range)
893: 
894:             // Calculate indentation level
895:             var spaces = 0
896:             for char in lineText {
897:                 if char == " " { spaces += 1 }
898:                 else if char == "\t" { spaces += tabSize } // Handle tabs if present
899:                 else { break }
900:             }
901: 
902:             let indentLevel = spaces / tabSize
903:             guard indentLevel > 0 else { return }
904: 
905:             let isCaretLine = (caretY != nil) && abs(rect.minY - (caretY ?? 0)) < 0.5
906: 
907:             for i in 1...indentLevel {
908:                 let x = CGFloat(i) * indentWidth + self.textContainerInset.left
909:                 let startPoint = CGPoint(x: x, y: rect.minY)
910:                 let endPoint = CGPoint(x: x, y: rect.maxY)
911: 
912:                 let stroke = (isCaretLine && i == activeIndentLevel) ? self.activeIndentGuideColor : self.indentGuideColor
913:                 context.setStrokeColor(stroke.cgColor)
914: 
915:                 context.move(to: startPoint)
916:                 context.addLine(to: endPoint)
917:                 context.strokePath()
918:             }
919:         }
920:     }

---

[read_file]
File: VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift (lines 921-1150 of 2051)
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
921:     
922:     override var keyCommands: [UIKeyCommand]? {
923:         var commands = super.keyCommands ?? []
924: 
925:         // Undo / Redo (ensure system shortcuts work even with custom keyCommands)
926:         let undoCmd = UIKeyCommand(
927:             input: "z",
928:             modifierFlags: .command,
929:             action: #selector(handleUndo),
930:             discoverabilityTitle: "Undo"
931:         )
932:         undoCmd.wantsPriorityOverSystemBehavior = true
933:         commands.append(undoCmd)
934: 
935:         let redoCmd = UIKeyCommand(
936:             input: "z",
937:             modifierFlags: [.command, .shift],
938:             action: #selector(handleRedo),
939:             discoverabilityTitle: "Redo"
940:         )
941:         redoCmd.wantsPriorityOverSystemBehavior = true
942:         commands.append(redoCmd)
943:         
944:         // Peek Definition: Alt+F12 (using special key input)
945:         // Note: F12 is not directly available on iPadOS keyboards
946:         // Using Option+D as alternative
947:         commands.append(UIKeyCommand(
948:             input: "d",
949:             modifierFlags: .alternate,
950:             action: #selector(handlePeekDefinition)
951:         ))
952: 
953:         // Go to Line: Cmd+G
954:         commands.append(UIKeyCommand(
955:             input: "g",
956:             modifierFlags: .command,
957:             action: #selector(handleGoToLine)
958:         ))
959: 
960:         // Tab: accept autocomplete if visible, else insert tab
961:         commands.append(UIKeyCommand(
962:             input: "\t",
963:             modifierFlags: [],
964:             action: #selector(handleTab)
965:         ))
966:         
967:         // Escape: dismiss autocomplete if visible, else normal escape behavior
968:         commands.append(UIKeyCommand(
969:             input: UIKeyCommand.inputEscape,
970:             modifierFlags: [],
971:             action: #selector(handleEscape)
972:         ))
973:         
974:         // Fold: Cmd+Opt+[
975:         commands.append(UIKeyCommand(
976:             input: "[",
977:             modifierFlags: [.command, .alternate],
978:             action: #selector(handleFold)
979:         ))
980:         
981:         // Unfold: Cmd+Opt+]
982:         commands.append(UIKeyCommand(
983:             input: "]",
984:             modifierFlags: [.command, .alternate],
985:             action: #selector(handleUnfold)
986:         ))
987:         
988:         // MARK: - App-Level Shortcuts (UITextView captures keyboard, so we MUST register here)
989:         // These post to NotificationCenter so ContentView can handle them
990:         
991:         // Command Palette: Cmd+Shift+P
992:         commands.append(UIKeyCommand(
993:             input: "p",
994:             modifierFlags: [.command, .shift],
995:             action: #selector(handleShowCommandPalette),
996:             discoverabilityTitle: "Command Palette"
997:         ))
998:         
999:         // Toggle Terminal: Cmd+J (VS Code's shortcut)
1000:         let toggleTerminalCmd = UIKeyCommand(
1001:             input: "j",
1002:             modifierFlags: .command,
1003:             action: #selector(handleToggleTerminal),
1004:             discoverabilityTitle: "Toggle Terminal"
1005:         )
1006:         toggleTerminalCmd.wantsPriorityOverSystemBehavior = true
1007:         commands.append(toggleTerminalCmd)
1008:         
1009:         // AI Assistant: Cmd+Shift+A
1010:         commands.append(UIKeyCommand(
1011:             input: "a",
1012:             modifierFlags: [.command, .shift],
1013:             action: #selector(handleShowAIAssistant),
1014:             discoverabilityTitle: "AI Assistant"
1015:         ))
1016:         
1017:         // Toggle Sidebar: Cmd+B
1018:         commands.append(UIKeyCommand(
1019:             input: "b",
1020:             modifierFlags: .command,
1021:             action: #selector(handleToggleSidebar),
1022:             discoverabilityTitle: "Toggle Sidebar"
1023:         ))
1024:         
1025:         // Quick Open: Cmd+P
1026:         commands.append(UIKeyCommand(
1027:             input: "p",
1028:             modifierFlags: .command,
1029:             action: #selector(handleShowQuickOpen),
1030:             discoverabilityTitle: "Quick Open"
1031:         ))
1032:         
1033:         // New File: Cmd+N
1034:         let newFileCmd = UIKeyCommand(
1035:             input: "n",
1036:             modifierFlags: .command,
1037:             action: #selector(handleNewFile),
1038:             discoverabilityTitle: "New File"
1039:         )
1040:         newFileCmd.wantsPriorityOverSystemBehavior = true
1041:         commands.append(newFileCmd)
1042:         
1043:         // Save: Cmd+S
1044:         commands.append(UIKeyCommand(
1045:             input: "s",
1046:             modifierFlags: .command,
1047:             action: #selector(handleSaveFile),
1048:             discoverabilityTitle: "Save"
1049:         ))
1050:         
1051:         // Close Tab: Cmd+W
1052:         let closeTabCmd = UIKeyCommand(
1053:             input: "w",
1054:             modifierFlags: .command,
1055:             action: #selector(handleCloseTab),
1056:             discoverabilityTitle: "Close Tab"
1057:         )
1058:         closeTabCmd.wantsPriorityOverSystemBehavior = true
1059:         commands.append(closeTabCmd)
1060:         
1061:         // Find: Cmd+F
1062:         let findCmd = UIKeyCommand(
1063:             input: "f",
1064:             modifierFlags: .command,
1065:             action: #selector(handleFind),
1066:             discoverabilityTitle: "Find"
1067:         )
1068:         findCmd.wantsPriorityOverSystemBehavior = true
1069:         commands.append(findCmd)
1070:         
1071:         // Zoom In: Cmd+=
1072:         commands.append(UIKeyCommand(
1073:             input: "=",
1074:             modifierFlags: .command,
1075:             action: #selector(handleZoomIn),
1076:             discoverabilityTitle: "Zoom In"
1077:         ))
1078:         
1079:         // Zoom Out: Cmd+-
1080:         commands.append(UIKeyCommand(
1081:             input: "-",
1082:             modifierFlags: .command,
1083:             action: #selector(handleZoomOut),
1084:             discoverabilityTitle: "Zoom Out"
1085:         ))
1086:         
1087:         return commands
1088:     }
1089:     
1090:     @objc func handlePeekDefinition() {
1091:         onPeekDefinition?()
1092:     }
1093: 
1094:     @objc func handleGoToLine() {
1095:         onGoToLine?()
1096:     }
1097: 
1098:     @objc func handleTab() {
1099:         if onAcceptAutocomplete?() == true {
1100:             return
1101:         }
1102:         insertText("\t")
1103:     }
1104:     
1105:     @objc func handleEscape() {
1106:         if onDismissAutocomplete?() == true {
1107:             return
1108:         }
1109:         onEscape?()
1110:     }
1111:     
1112:     @objc func handleFold() {
1113:         onFold?()
1114:     }
1115:     
1116:     @objc func handleUnfold() {
1117:         onUnfold?()
1118:     }
1119: 
1120:     // MARK: - Undo / Redo
1121: 
1122:     @objc func handleUndo() {
1123:         undoManager?.undo()
1124:     }
1125: 
1126:     @objc func handleRedo() {
1127:         undoManager?.redo()
1128:     }
1129:     
1130:     // MARK: - App-Level Shortcut Handlers
1131:     
1132:     @objc func handleShowCommandPalette() {
1133:         NotificationCenter.default.post(name: NSNotification.Name("ShowCommandPalette"), object: nil)
1134:     }
1135:     
1136:     @objc func handleToggleTerminal() {
1137:         NotificationCenter.default.post(name: NSNotification.Name("ToggleTerminal"), object: nil)
1138:     }
1139:     
1140:     @objc func handleShowAIAssistant() {
1141:         NotificationCenter.default.post(name: NSNotification.Name("ShowAIAssistant"), object: nil)
1142:     }
1143:     
1144:     @objc func handleToggleSidebar() {
1145:         NotificationCenter.default.post(name: NSNotification.Name("ToggleSidebar"), object: nil)
1146:     }
1147:     
1148:     @objc func handleShowQuickOpen() {
1149:         NotificationCenter.default.post(name: NSNotification.Name("ShowQuickOpen"), object: nil)
1150:     }

---

[read_file]
File: VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift (lines 1151-1390 of 2051)
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
1151:     
1152:     @objc func handleNewFile() {
1153:         NotificationCenter.default.post(name: NSNotification.Name("NewFile"), object: nil)
1154:     }
1155:     
1156:     @objc func handleSaveFile() {
1157:         NotificationCenter.default.post(name: NSNotification.Name("SaveFile"), object: nil)
1158:     }
1159:     
1160:     @objc func handleCloseTab() {
1161:         NotificationCenter.default.post(name: NSNotification.Name("CloseTab"), object: nil)
1162:     }
1163:     
1164:     @objc func handleFind() {
1165:         NotificationCenter.default.post(name: NSNotification.Name("ShowFind"), object: nil)
1166:     }
1167:     
1168:     @objc func handleZoomIn() {
1169:         NotificationCenter.default.post(name: NSNotification.Name("ZoomIn"), object: nil)
1170:     }
1171:     
1172:     @objc func handleZoomOut() {
1173:         NotificationCenter.default.post(name: NSNotification.Name("ZoomOut"), object: nil)
1174:     }
1175:     
1176:     // MARK: - Custom Actions
1177:     
1178:     @objc private func goToDefinition(_ sender: Any?) {
1179:         onGoToDefinition?()
1180:     }
1181:     
1182:     @objc private func peekDefinition(_ sender: Any?) {
1183:         onPeekDefinition?()
1184:     }
1185:     
1186:     @objc private func findReferences(_ sender: Any?) {
1187:         onFindReferences?()
1188:     }
1189:     
1190:     @objc private func formatDocument(_ sender: Any?) {
1191:         onFormatDocument?()
1192:     }
1193:     
1194:     @objc private func toggleComment(_ sender: Any?) {
1195:         onToggleComment?()
1196:     }
1197:     
1198:     // MARK: - Menu Support
1199:     
1200:     override func canPerformAction(_ action: Selector, withSender sender: Any?) -> Bool {
1201:         // Enable custom actions
1202:         if action == #selector(goToDefinition(_:)) {
1203:             return onGoToDefinition != nil
1204:         }
1205:         if action == #selector(peekDefinition(_:)) {
1206:             return onPeekDefinition != nil
1207:         }
1208:         if action == #selector(findReferences(_:)) {
1209:             return onFindReferences != nil
1210:         }
1211:         if action == #selector(formatDocument(_:)) {
1212:             return onFormatDocument != nil
1213:         }
1214:         if action == #selector(toggleComment(_:)) {
1215:             return onToggleComment != nil
1216:         }
1217:         
1218:         return super.canPerformAction(action, withSender: sender)
1219:     }
1220:     
1221:     override func buildMenu(with builder: UIMenuBuilder) {
1222:         super.buildMenu(with: builder)
1223:         
1224:         guard builder.menu(for: .text) != nil else { return }
1225:         
1226:         // Create custom menu items
1227:         let goToDefinitionAction = UIAction(
1228:             title: "Go to Definition",
1229:             image: UIImage(systemName: "arrow.forward.circle"),
1230:             identifier: UIAction.Identifier("com.vscode.goToDefinition"),
1231:             handler: { [weak self] _ in
1232:                 self?.goToDefinition(nil)
1233:             }
1234:         )
1235:         
1236:         let peekDefinitionAction = UIAction(
1237:             title: "Peek Definition",
1238:             image: UIImage(systemName: "eye"),
1239:             identifier: UIAction.Identifier("com.vscode.peekDefinition"),
1240:             handler: { [weak self] _ in
1241:                 self?.peekDefinition(nil)
1242:             }
1243:         )
1244:         
1245:         let findReferencesAction = UIAction(
1246:             title: "Find All References",
1247:             image: UIImage(systemName: "magnifyingglass"),
1248:             identifier: UIAction.Identifier("com.vscode.findReferences"),
1249:             handler: { [weak self] _ in
1250:                 self?.findReferences(nil)
1251:             }
1252:         )
1253:         
1254:         let formatDocumentAction = UIAction(
1255:             title: "Format Document",
1256:             image: UIImage(systemName: "text.alignleft"),
1257:             identifier: UIAction.Identifier("com.vscode.formatDocument"),
1258:             handler: { [weak self] _ in
1259:                 self?.formatDocument(nil)
1260:             }
1261:         )
1262:         
1263:         let toggleCommentAction = UIAction(
1264:             title: "Toggle Comment",
1265:             image: UIImage(systemName: "text.quote"),
1266:             identifier: UIAction.Identifier("com.vscode.toggleComment"),
1267:             handler: { [weak self] _ in
1268:                 self?.toggleComment(nil)
1269:             }
1270:         )
1271:         
1272:         // Group custom actions
1273:         let customMenu = UIMenu(
1274:             title: "",
1275:             identifier: UIMenu.Identifier("com.vscode.customActions"),
1276:             options: [.displayInline],
1277:             children: [
1278:                 goToDefinitionAction,
1279:                 peekDefinitionAction,
1280:                 findReferencesAction,
1281:                 formatDocumentAction,
1282:                 toggleCommentAction
1283:             ]
1284:         )
1285:         
1286:         // Insert custom menu after standard edit menu
1287:         builder.insertChild(customMenu, atStartOfMenu: .text)
1288:     }
1289: }
1290: 
1291: // MARK: - VSCode-Style Syntax Highlighter
1292: 
1293: enum Language {
1294:     case swift
1295: 
1296:     case javascript
1297:     case typescript
1298:     case jsx
1299:     case tsx
1300: 
1301:     case python
1302:     case ruby
1303:     case go
1304:     case rust
1305:     case java
1306:     case kotlin
1307: 
1308:     case c
1309:     case cpp
1310:     case objectiveC
1311: 
1312:     case html
1313:     case css
1314:     case scss
1315:     case less
1316:     case json
1317:     case xml
1318:     case yaml
1319:     case sql
1320: 
1321:     case shell
1322:     case dockerfile
1323:     case graphql
1324:     case markdown
1325:     case php
1326:     case env
1327: 
1328:     case plainText
1329: }
1330: 
1331: struct VSCodeSyntaxHighlighter {
1332:     private let baseFontSize: CGFloat
1333:     let theme: Theme
1334:     
1335:     init(theme: Theme = ThemeManager.shared.currentTheme, fontSize: CGFloat = 14) {
1336:         self.theme = theme
1337:         self.baseFontSize = fontSize
1338:     }
1339:     
1340:     func highlight(_ text: String, filename: String) -> NSAttributedString {
1341:         let language = detectLanguage(from: filename)
1342:         return highlight(text, language: language)
1343:     }
1344:     
1345:     private func detectLanguage(from filename: String) -> Language {
1346:         let lower = filename.lowercased()
1347:         let ext = (filename as NSString).pathExtension.lowercased()
1348: 
1349:         // Special-case filenames without extensions
1350:         if (filename as NSString).lastPathComponent.lowercased() == "dockerfile" { return .dockerfile }
1351:         if (filename as NSString).lastPathComponent.lowercased() == ".env" { return .env }
1352:         if lower.hasSuffix("/.env") { return .env }
1353: 
1354:         switch ext {
1355:         case "swift": return .swift
1356: 
1357:         case "js", "mjs", "cjs": return .javascript
1358:         case "jsx": return .jsx
1359:         case "ts", "mts", "cts": return .typescript
1360:         case "tsx": return .tsx
1361: 
1362:         case "py", "pyw": return .python
1363:         case "rb", "ruby": return .ruby
1364:         case "go": return .go
1365:         case "rs": return .rust
1366:         case "java": return .java
1367:         case "kt", "kts": return .kotlin
1368: 
1369:         case "c", "h": return .c
1370:         case "cpp", "cc", "cxx", "hpp", "hh", "hxx": return .cpp
1371:         case "m", "mm": return .objectiveC
1372: 
1373:         case "html", "htm": return .html
1374:         case "css": return .css
1375:         case "scss", "sass": return .scss
1376:         case "less": return .less
1377:         case "json", "jsonc": return .json
1378:         case "xml", "plist", "svg": return .xml
1379:         case "yml", "yaml": return .yaml
1380:         case "sql": return .sql
1381: 
1382:         case "sh", "bash", "zsh", "fish": return .shell
1383:         case "dockerfile": return .dockerfile
1384: 
1385:         case "graphql", "gql": return .graphql
1386: 
1387:         case "md", "markdown": return .markdown
1388:         case "php": return .php
1389:         case "env": return .env
1390: 

---

[read_file]
File: VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift (lines 1391-1600 of 2051)
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
1391:         default: return .plainText
1392:         }
1393:     }
1394:     
1395:     private func highlight(_ text: String, language: Language) -> NSAttributedString {
1396:         let attributed = NSMutableAttributedString(string: text)
1397:         let fullRange = NSRange(location: 0, length: text.utf16.count)
1398:         
1399:         // Base attributes
1400:         let baseFont = UIFont.monospacedSystemFont(ofSize: baseFontSize, weight: .regular)
1401:         attributed.addAttribute(.font, value: baseFont, range: fullRange)
1402:         attributed.addAttribute(.foregroundColor, value: UIColor(theme.editorForeground), range: fullRange)
1403:         
1404:         // Apply language-specific highlighting
1405:         switch language {
1406:         case .swift: highlightSwift(attributed, text: text)
1407:         case .javascript, .jsx: highlightJavaScript(attributed, text: text, isTS: false)
1408:         case .typescript, .tsx: highlightJavaScript(attributed, text: text, isTS: true)
1409:         case .python: highlightPython(attributed, text: text)
1410:         case .html, .xml: highlightHTML(attributed, text: text)
1411:         case .css, .scss, .less: highlightCSS(attributed, text: text)
1412:         case .json: highlightJSON(attributed, text: text)
1413:         case .markdown: highlightMarkdown(attributed, text: text)
1414:         case .rust: highlightRust(attributed, text: text)
1415:         case .go: highlightGo(attributed, text: text)
1416:         case .java, .kotlin: highlightJava(attributed, text: text)
1417:         case .c, .cpp, .objectiveC: highlightCpp(attributed, text: text)
1418:         case .ruby: highlightRuby(attributed, text: text)
1419:         case .php: highlightPHP(attributed, text: text)
1420:         case .shell, .dockerfile: highlightShell(attributed, text: text)
1421:         case .yaml, .env: highlightYAML(attributed, text: text)
1422:         case .sql: highlightSQL(attributed, text: text)
1423:         case .graphql: highlightGraphQL(attributed, text: text)
1424:         case .plainText: break
1425:         }
1426:         
1427:         // FEAT-038: Bracket Pair Colorization (applied last)
1428:         highlightBracketPairs(attributed, text: text)
1429:         
1430:         return attributed
1431:     }
1432:     
1433:     // MARK: - Bracket Pair Colorization
1434:     
1435:     private func highlightBracketPairs(_ attributed: NSMutableAttributedString, text: String) {
1436:         let brackets: [Character] = ["{", "}", "[", "]", "(", ")"]
1437:         let pairs: [Character: Character] = ["}": "{", "]": "[", ")": "("]
1438:         
1439:         var stack: [(char: Character, index: Int, depth: Int)] = []
1440:         let colors = [
1441:             UIColor(theme.bracketPair1),
1442:             UIColor(theme.bracketPair2),
1443:             UIColor(theme.bracketPair3),
1444:             UIColor(theme.bracketPair4),
1445:             UIColor(theme.bracketPair5),
1446:             UIColor(theme.bracketPair6)
1447:         ]
1448:         
1449:         // Scan text for brackets
1450:         // Note: In a real implementation, we should skip brackets inside strings/comments
1451:         // But since we apply this LAST, we can try to respect existing string/comment colors
1452:         // OR implement a more robust parser. For now, simple scan.
1453:         
1454:         // Optimization: Use scanner or direct iteration
1455:         let nsString = text as NSString
1456:         var index = 0
1457:         
1458:         while index < text.utf16.count {
1459:             let char = nsString.character(at: index)
1460:             if let scalar = UnicodeScalar(char) {
1461:                 let c = Character(scalar)
1462:                 
1463:                 if brackets.contains(c) {
1464:                     // Check if it's already colored as string/comment (heuristic)
1465:                     // If color is string/comment, skip
1466:                     // (Requires iterating attributes, which is slow. We'll just apply on top for now)
1467:                     
1468:                     if let open = pairs[c] { // Closing bracket
1469:                         if let last = stack.last, last.char == open {
1470:                             // Match found
1471:                             let depth = last.depth
1472:                             let color = colors[depth % colors.count]
1473:                             
1474:                             attributed.addAttribute(.foregroundColor, value: color, range: NSRange(location: index, length: 1))
1475:                             attributed.addAttribute(.foregroundColor, value: color, range: NSRange(location: last.index, length: 1))
1476:                             
1477:                             stack.removeLast()
1478:                         } else {
1479:                             // Mismatched or extra closing bracket - unexpected
1480:                             // Keep default color or mark red? Default for now.
1481:                         }
1482:                     } else { // Opening bracket
1483:                         let depth = stack.count
1484:                         stack.append((c, index, depth))
1485:                         
1486:                         // We'll color it when (and if) we find the match, or here?
1487:                         // Better to color here tentatively, but matching is better.
1488:                         // Let's color tentatively based on depth.
1489:                         let color = colors[depth % colors.count]
1490:                         attributed.addAttribute(.foregroundColor, value: color, range: NSRange(location: index, length: 1))
1491:                     }
1492:                 }
1493:             }
1494:             index += 1
1495:         }
1496:     }
1497:     
1498:     // MARK: - Swift Highlighting
1499:     
1500:     private func highlightSwift(_ attributed: NSMutableAttributedString, text: String) {
1501:         // Keywords (purple/pink)
1502:         let keywords = ["func", "var", "let", "if", "else", "for", "while", "return",
1503:                        "class", "struct", "enum", "protocol", "extension", "import",
1504:                        "private", "public", "internal", "fileprivate", "open",
1505:                        "static", "final", "override", "mutating", "nonmutating",
1506:                        "init", "deinit", "subscript", "typealias", "associatedtype",
1507:                        "where", "throws", "rethrows", "async", "await", "actor",
1508:                        "guard", "defer", "do", "try", "catch", "throw",
1509:                        "switch", "case", "default", "break", "continue", "fallthrough",
1510:                        "in", "is", "as", "inout", "some", "any", "Self",
1511:                        "get", "set", "willSet", "didSet", "lazy", "weak", "unowned",
1512:                        "@State", "@Binding", "@Published", "@ObservedObject", "@StateObject",
1513:                        "@Environment", "@EnvironmentObject", "@ViewBuilder", "@MainActor",
1514:                        "@escaping", "@autoclosure", "@available", "@objc", "@discardableResult"]
1515:         highlightKeywords(attributed, keywords: keywords, color: UIColor(theme.keyword), text: text)
1516:         
1517:         // Types (teal) - CamelCase words that aren't keywords
1518:         let typePattern = "\\b[A-Z][a-zA-Z0-9]*\\b"
1519:         highlightPattern(attributed, pattern: typePattern, color: UIColor(theme.type), text: text)
1520:         
1521:         // Function calls (yellow)
1522:         let funcCallPattern = "\\b([a-z][a-zA-Z0-9]*)\\s*\\("
1523:         highlightPattern(attributed, pattern: funcCallPattern, color: UIColor(theme.function), text: text, captureGroup: 1)
1524:         
1525:         // Constants (blue)
1526:         let constants = ["true", "false", "nil", "self", "super"]
1527:         highlightKeywords(attributed, keywords: constants, color: UIColor(theme.variable), text: text)
1528:         
1529:         // Comments MUST come late (green) - they override everything
1530:         highlightComments(attributed, text: text, singleLine: "//", multiLineStart: "/*", multiLineEnd: "*/")
1531:         
1532:         // Strings AFTER comments (orange)
1533:         highlightStrings(attributed, text: text)
1534:         
1535:         // Numbers (light green)
1536:         highlightNumbers(attributed, text: text)
1537:     }
1538:     
1539:     // MARK: - JavaScript/TypeScript Highlighting
1540:     
1541:     private func highlightJavaScript(_ attributed: NSMutableAttributedString, text: String, isTS: Bool) {
1542:         var keywords = ["function", "var", "let", "const", "if", "else", "for", "while",
1543:                        "return", "class", "extends", "new", "this", "super", "import",
1544:                        "export", "default", "from", "as", "async", "await", "yield",
1545:                        "try", "catch", "finally", "throw", "typeof", "instanceof",
1546:                        "switch", "case", "break", "continue", "do", "in", "of",
1547:                        "get", "set", "static", "constructor", "delete", "void",
1548:                        "with", "debugger"]
1549:         
1550:         if isTS {
1551:             keywords += ["interface", "type", "enum", "namespace", "module", "declare",
1552:                         "implements", "public", "private", "protected", "readonly",
1553:                         "abstract", "override", "keyof", "infer", "never", "unknown",
1554:                         "any", "asserts", "is"]
1555:         }
1556:         
1557:         highlightKeywords(attributed, keywords: keywords, color: UIColor(theme.keyword), text: text)
1558:         
1559:         // Constants
1560:         let constants = ["true", "false", "null", "undefined", "NaN", "Infinity"]
1561:         highlightKeywords(attributed, keywords: constants, color: UIColor(theme.variable), text: text)
1562:         
1563:         // Function names (yellow) - regular calls + arrow functions
1564:         let funcNamePattern = "\\b([a-zA-Z_$][a-zA-Z0-9_$]*)\\b(?=\\s*(?:\\(|=>))"
1565:         highlightPattern(attributed, pattern: funcNamePattern, color: UIColor(theme.function), text: text, captureGroup: 1)
1566:         
1567:         // Types (teal)
1568:         let typePattern = "\\b[A-Z][a-zA-Z0-9]*\\b"
1569:         highlightPattern(attributed, pattern: typePattern, color: UIColor(theme.type), text: text)
1570:         
1571:         highlightComments(attributed, text: text, singleLine: "//", multiLineStart: "/*", multiLineEnd: "*/")
1572:         highlightStrings(attributed, text: text)
1573:         highlightJSTemplateLiterals(attributed, text: text)
1574:         highlightNumbers(attributed, text: text)
1575:     }
1576:     
1577:     // MARK: - Python Highlighting
1578:     
1579:     private func highlightPython(_ attributed: NSMutableAttributedString, text: String) {
1580:         let keywords = ["def", "class", "if", "elif", "else", "for", "while", "return",
1581:                        "import", "from", "as", "try", "except", "finally", "raise",
1582:                        "with", "assert", "yield", "lambda", "pass", "break", "continue",
1583:                        "global", "nonlocal", "del", "in", "not", "and", "or", "is",
1584:                        "async", "await", "match", "case"]
1585:         highlightKeywords(attributed, keywords: keywords, color: UIColor(theme.keyword), text: text)
1586:         
1587:         let constants = ["True", "False", "None", "self", "cls"]
1588:         highlightKeywords(attributed, keywords: constants, color: UIColor(theme.variable), text: text)
1589:         
1590:         // Decorators (yellow)
1591:         let decoratorPattern = "@[a-zA-Z_][a-zA-Z0-9_\\.]*"
1592:         highlightPattern(attributed, pattern: decoratorPattern, color: UIColor(theme.function), text: text)
1593:         
1594:         // Function definitions (yellow)
1595:         let funcDefPattern = "(?<=def\\s)[a-zA-Z_][a-zA-Z0-9_]*"
1596:         highlightPattern(attributed, pattern: funcDefPattern, color: UIColor(theme.function), text: text)
1597:         
1598:         // Class names (teal)
1599:         let classPattern = "(?<=class\\s)[a-zA-Z_][a-zA-Z0-9_]*"
1600:         highlightPattern(attributed, pattern: classPattern, color: UIColor(theme.type), text: text)

---

[read_file]
File: VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift (lines 1601-2000 of 2051)
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
1601:         
1602:         // Built-in functions (yellow)
1603:         let builtins = ["print", "len", "range", "str", "int", "float", "list", "dict", "set",
1604:                        "tuple", "bool", "type", "isinstance", "hasattr", "getattr", "setattr",
1605:                        "open", "input", "map", "filter", "reduce", "zip", "enumerate",
1606:                        "sorted", "reversed", "min", "max", "sum", "abs", "round",
1607:                        "super", "object", "Exception", "ValueError", "TypeError"]
1608:         highlightKeywords(attributed, keywords: builtins, color: UIColor(theme.function), text: text)
1609:         
1610:         highlightComments(attributed, text: text, singleLine: "#", multiLineStart: nil, multiLineEnd: nil)
1611:         highlightPythonStrings(attributed, text: text)
1612:         highlightNumbers(attributed, text: text)
1613:     }
1614:     
1615:     // MARK: - HTML Highlighting
1616:     
1617:     private func highlightHTML(_ attributed: NSMutableAttributedString, text: String) {
1618:         // Tags (blue)
1619:         let tagPattern = "</?\\s*([a-zA-Z][a-zA-Z0-9-]*)(?=[\\s>])"
1620:         highlightPattern(attributed, pattern: tagPattern, color: UIColor(theme.keyword), text: text)
1621:         
1622:         // Attributes (light blue)
1623:         let attrPattern = "\\s([a-zA-Z][a-zA-Z0-9-]*)\\s*="
1624:         highlightPattern(attributed, pattern: attrPattern, color: UIColor(theme.variable), text: text, captureGroup: 1)
1625:         
1626:         // Angle brackets
1627:         let bracketPattern = "[<>/?]"
1628:         highlightPattern(attributed, pattern: bracketPattern, color: UIColor.gray, text: text)
1629:         
1630:         // Comments
1631:         highlightHTMLComments(attributed, text: text)
1632:         
1633:         // Strings
1634:         highlightStrings(attributed, text: text)
1635:     }
1636:     
1637:     // MARK: - CSS Highlighting
1638:     
1639:     private func highlightCSS(_ attributed: NSMutableAttributedString, text: String) {
1640:         // Selectors (yellow)
1641:         let selectorPattern = "([.#]?[a-zA-Z][a-zA-Z0-9_-]*)\\s*\\{"
1642:         highlightPattern(attributed, pattern: selectorPattern, color: UIColor(theme.function), text: text, captureGroup: 1)
1643:         
1644:         // Properties (light blue)
1645:         let propertyPattern = "([a-zA-Z-]+)\\s*:"
1646:         highlightPattern(attributed, pattern: propertyPattern, color: UIColor(theme.variable), text: text, captureGroup: 1)
1647:         
1648:         // Values with units
1649:         let unitPattern = "\\b(\\d+)(px|em|rem|%|vh|vw|pt|cm|mm|in)\\b"
1650:         highlightPattern(attributed, pattern: unitPattern, color: UIColor(theme.number), text: text)
1651:         
1652:         // Colors
1653:         let hexPattern = "#[0-9a-fA-F]{3,8}\\b"
1654:         highlightPattern(attributed, pattern: hexPattern, color: UIColor(theme.number), text: text)
1655:         
1656:         // Keywords
1657:         let keywords = ["important", "inherit", "initial", "unset", "none", "auto",
1658:                        "block", "inline", "flex", "grid", "absolute", "relative", "fixed"]
1659:         highlightKeywords(attributed, keywords: keywords, color: UIColor(theme.keyword), text: text)
1660:         
1661:         highlightComments(attributed, text: text, singleLine: nil, multiLineStart: "/*", multiLineEnd: "*/")
1662:         highlightStrings(attributed, text: text)
1663:         highlightNumbers(attributed, text: text)
1664:     }
1665:     
1666:     // MARK: - JSON Highlighting
1667:     
1668:     private func highlightJSON(_ attributed: NSMutableAttributedString, text: String) {
1669:         // Keys (light blue)
1670:         let keyPattern = "\"([^\"]+)\"\\s*:"
1671:         highlightPattern(attributed, pattern: keyPattern, color: UIColor(theme.variable), text: text, captureGroup: 1)
1672:         
1673:         // String values (orange)
1674:         highlightStrings(attributed, text: text)
1675:         
1676:         // Numbers (light green)
1677:         highlightNumbers(attributed, text: text)
1678:         
1679:         // Booleans and null (use keyword color)
1680:         let constants = ["true", "false", "null"]
1681:         highlightKeywords(attributed, keywords: constants, color: UIColor(theme.keyword), text: text)
1682:     }
1683:     
1684:     // MARK: - Markdown Highlighting
1685:     
1686:     private func highlightMarkdown(_ attributed: NSMutableAttributedString, text: String) {
1687:         // Headers (blue + bold)
1688:         let headerPattern = "^#{1,6}\\s+.+$"
1689:         highlightPattern(attributed, pattern: headerPattern, color: UIColor(theme.keyword), text: text, options: .anchorsMatchLines)
1690:         
1691:         // Bold (orange)
1692:         let boldPattern = "\\*\\*[^*]+\\*\\*|__[^_]+__"
1693:         highlightPattern(attributed, pattern: boldPattern, color: UIColor(theme.string), text: text)
1694:         
1695:         // Italic
1696:         let italicPattern = "(?<!\\*)\\*[^*]+\\*(?!\\*)|(?<!_)_[^_]+_(?!_)"
1697:         highlightPattern(attributed, pattern: italicPattern, color: UIColor.secondaryLabel, text: text)
1698:         
1699:         // Code blocks (green)
1700:         let codeBlockPattern = "```[\\s\\S]*?```|`[^`]+`"
1701:         highlightPattern(attributed, pattern: codeBlockPattern, color: UIColor(theme.comment), text: text)
1702:         
1703:         // Links (light blue)
1704:         let linkPattern = "\\[[^\\]]+\\]\\([^)]+\\)"
1705:         highlightPattern(attributed, pattern: linkPattern, color: UIColor(theme.variable), text: text)
1706:         
1707:         // Lists
1708:         let listPattern = "^\\s*[-*+]\\s"
1709:         highlightPattern(attributed, pattern: listPattern, color: UIColor(theme.keyword), text: text, options: .anchorsMatchLines)
1710:     }
1711:     
1712:     // MARK: - Rust Highlighting
1713:     
1714:     private func highlightRust(_ attributed: NSMutableAttributedString, text: String) {
1715:         let keywords = ["fn", "let", "mut", "const", "if", "else", "match", "loop", "while", "for",
1716:                        "return", "struct", "enum", "impl", "trait", "type", "use", "mod", "pub",
1717:                        "self", "Self", "super", "crate", "as", "in", "ref", "move", "async", "await",
1718:                        "where", "unsafe", "extern", "dyn", "static", "break", "continue"]
1719:         highlightKeywords(attributed, keywords: keywords, color: UIColor(theme.keyword), text: text)
1720:         
1721:         let types = ["i8", "i16", "i32", "i64", "i128", "isize", "u8", "u16", "u32", "u64", "u128", "usize",
1722:                     "f32", "f64", "bool", "char", "str", "String", "Vec", "Option", "Result", "Box"]
1723:         highlightKeywords(attributed, keywords: types, color: UIColor(theme.type), text: text)
1724:         
1725:         let constants = ["true", "false", "None", "Some", "Ok", "Err"]
1726:         highlightKeywords(attributed, keywords: constants, color: UIColor(theme.variable), text: text)
1727:         
1728:         // Macros (yellow)
1729:         let macroPattern = "[a-zA-Z_][a-zA-Z0-9_]*!"
1730:         highlightPattern(attributed, pattern: macroPattern, color: UIColor(theme.function), text: text)
1731:         
1732:         // Lifetimes (orange)
1733:         let lifetimePattern = "'[a-zA-Z_][a-zA-Z0-9_]*"
1734:         highlightPattern(attributed, pattern: lifetimePattern, color: UIColor(theme.string), text: text)
1735:         
1736:         highlightComments(attributed, text: text, singleLine: "//", multiLineStart: "/*", multiLineEnd: "*/")
1737:         highlightStrings(attributed, text: text)
1738:         highlightNumbers(attributed, text: text)
1739:     }
1740:     
1741:     // MARK: - Go Highlighting
1742:     
1743:     private func highlightGo(_ attributed: NSMutableAttributedString, text: String) {
1744:         let keywords = ["func", "var", "const", "type", "struct", "interface", "map", "chan",
1745:                        "if", "else", "for", "range", "switch", "case", "default", "select",
1746:                        "return", "break", "continue", "goto", "fallthrough", "defer", "go",
1747:                        "package", "import"]
1748:         highlightKeywords(attributed, keywords: keywords, color: UIColor(theme.keyword), text: text)
1749:         
1750:         let types = ["int", "int8", "int16", "int32", "int64", "uint", "uint8", "uint16", "uint32", "uint64",
1751:                     "float32", "float64", "complex64", "complex128", "byte", "rune", "string", "bool", "error"]
1752:         highlightKeywords(attributed, keywords: types, color: UIColor(theme.type), text: text)
1753:         
1754:         let constants = ["true", "false", "nil", "iota"]
1755:         highlightKeywords(attributed, keywords: constants, color: UIColor(theme.variable), text: text)
1756:         
1757:         highlightComments(attributed, text: text, singleLine: "//", multiLineStart: "/*", multiLineEnd: "*/")
1758:         highlightStrings(attributed, text: text)
1759:         highlightNumbers(attributed, text: text)
1760:     }
1761:     
1762:     // MARK: - Java Highlighting
1763:     
1764:     private func highlightJava(_ attributed: NSMutableAttributedString, text: String) {
1765:         let keywords = ["public", "private", "protected", "class", "interface", "extends", "implements",
1766:                        "static", "final", "abstract", "native", "synchronized", "volatile", "transient",
1767:                        "if", "else", "for", "while", "do", "switch", "case", "default", "break", "continue",
1768:                        "return", "throw", "throws", "try", "catch", "finally", "new", "this", "super",
1769:                        "import", "package", "instanceof", "assert", "enum", "void"]
1770:         highlightKeywords(attributed, keywords: keywords, color: UIColor(theme.keyword), text: text)
1771:         
1772:         let types = ["int", "long", "short", "byte", "float", "double", "char", "boolean",
1773:                     "String", "Integer", "Long", "Double", "Boolean", "Object", "List", "Map", "Set"]
1774:         highlightKeywords(attributed, keywords: types, color: UIColor(theme.type), text: text)
1775:         
1776:         let constants = ["true", "false", "null"]
1777:         highlightKeywords(attributed, keywords: constants, color: UIColor(theme.variable), text: text)
1778:         
1779:         // Annotations
1780:         let annotationPattern = "@[a-zA-Z][a-zA-Z0-9]*"
1781:         highlightPattern(attributed, pattern: annotationPattern, color: UIColor(theme.function), text: text)
1782:         
1783:         highlightComments(attributed, text: text, singleLine: "//", multiLineStart: "/*", multiLineEnd: "*/")
1784:         highlightStrings(attributed, text: text)
1785:         highlightNumbers(attributed, text: text)
1786:     }
1787:     
1788:     // MARK: - C/C++ Highlighting
1789:     
1790:     private func highlightCpp(_ attributed: NSMutableAttributedString, text: String) {
1791:         let keywords = ["auto", "break", "case", "catch", "class", "const", "continue", "default",
1792:                        "delete", "do", "else", "enum", "explicit", "extern", "for", "friend", "goto",
1793:                        "if", "inline", "mutable", "namespace", "new", "operator", "private", "protected",
1794:                        "public", "register", "return", "sizeof", "static", "struct", "switch", "template",
1795:                        "this", "throw", "try", "typedef", "typename", "union", "using", "virtual",
1796:                        "volatile", "while", "constexpr", "nullptr", "override", "final", "noexcept"]
1797:         highlightKeywords(attributed, keywords: keywords, color: UIColor(theme.keyword), text: text)
1798:         
1799:         let types = ["void", "int", "long", "short", "char", "float", "double", "bool", "signed", "unsigned",
1800:                     "int8_t", "int16_t", "int32_t", "int64_t", "uint8_t", "uint16_t", "uint32_t", "uint64_t",
1801:                     "size_t", "string", "vector", "map", "set", "unique_ptr", "shared_ptr"]
1802:         highlightKeywords(attributed, keywords: types, color: UIColor(theme.type), text: text)
1803:         
1804:         let constants = ["true", "false", "NULL", "nullptr"]
1805:         highlightKeywords(attributed, keywords: constants, color: UIColor(theme.variable), text: text)
1806:         
1807:         // Preprocessor directives
1808:         let preprocPattern = "^\\s*#\\s*(include|define|ifdef|ifndef|endif|if|else|elif|pragma|error|warning).*$"
1809:         highlightPattern(attributed, pattern: preprocPattern, color: UIColor(theme.keyword), text: text, options: .anchorsMatchLines)
1810:         
1811:         highlightComments(attributed, text: text, singleLine: "//", multiLineStart: "/*", multiLineEnd: "*/")
1812:         highlightStrings(attributed, text: text)
1813:         highlightNumbers(attributed, text: text)
1814:     }
1815:     
1816:     // MARK: - Ruby Highlighting
1817:     
1818:     private func highlightRuby(_ attributed: NSMutableAttributedString, text: String) {
1819:         let keywords = ["def", "class", "module", "if", "elsif", "else", "unless", "case", "when",
1820:                        "while", "until", "for", "do", "end", "begin", "rescue", "ensure", "raise",
1821:                        "return", "yield", "break", "next", "redo", "retry", "self", "super",
1822:                        "require", "require_relative", "include", "extend", "attr_reader", "attr_writer", "attr_accessor",
1823:                        "public", "private", "protected", "alias", "and", "or", "not", "in"]
1824:         highlightKeywords(attributed, keywords: keywords, color: UIColor(theme.keyword), text: text)
1825:         
1826:         let constants = ["true", "false", "nil"]
1827:         highlightKeywords(attributed, keywords: constants, color: UIColor(theme.variable), text: text)
1828:         
1829:         // Symbols (orange)
1830:         let symbolPattern = ":[a-zA-Z_][a-zA-Z0-9_]*"
1831:         highlightPattern(attributed, pattern: symbolPattern, color: UIColor(theme.string), text: text)
1832:         
1833:         // Instance variables (light blue)
1834:         let ivarPattern = "@[a-zA-Z_][a-zA-Z0-9_]*"
1835:         highlightPattern(attributed, pattern: ivarPattern, color: UIColor(theme.variable), text: text)
1836:         
1837:         highlightComments(attributed, text: text, singleLine: "#", multiLineStart: "=begin", multiLineEnd: "=end")
1838:         highlightStrings(attributed, text: text)
1839:         highlightNumbers(attributed, text: text)
1840:     }
1841:     
1842:     // MARK: - PHP Highlighting
1843:     
1844:     private func highlightPHP(_ attributed: NSMutableAttributedString, text: String) {
1845:         let keywords = ["function", "class", "interface", "trait", "extends", "implements", "use",
1846:                        "public", "private", "protected", "static", "final", "abstract", "const",
1847:                        "if", "else", "elseif", "switch", "case", "default", "for", "foreach", "while", "do",
1848:                        "return", "break", "continue", "throw", "try", "catch", "finally",
1849:                        "new", "clone", "instanceof", "echo", "print", "die", "exit",
1850:                        "require", "require_once", "include", "include_once", "namespace"]
1851:         highlightKeywords(attributed, keywords: keywords, color: UIColor(theme.keyword), text: text)
1852:         
1853:         let constants = ["true", "false", "null", "TRUE", "FALSE", "NULL"]
1854:         highlightKeywords(attributed, keywords: constants, color: UIColor(theme.variable), text: text)
1855:         
1856:         // Variables (light blue)
1857:         let varPattern = "\\$[a-zA-Z_][a-zA-Z0-9_]*"
1858:         highlightPattern(attributed, pattern: varPattern, color: UIColor(theme.variable), text: text)
1859:         
1860:         highlightComments(attributed, text: text, singleLine: "//", multiLineStart: "/*", multiLineEnd: "*/")
1861:         highlightStrings(attributed, text: text)
1862:         highlightNumbers(attributed, text: text)
1863:     }
1864:     
1865:     // MARK: - Shell Highlighting
1866:     
1867:     private func highlightShell(_ attributed: NSMutableAttributedString, text: String) {
1868:         let keywords = ["if", "then", "else", "elif", "fi", "for", "while", "do", "done", "case", "esac",
1869:                        "function", "return", "exit", "break", "continue", "local", "export", "readonly",
1870:                        "source", "alias", "unalias", "set", "unset", "shift", "eval", "exec",
1871:                        "echo", "printf", "read", "cd", "pwd", "ls", "mkdir", "rm", "cp", "mv"]
1872:         highlightKeywords(attributed, keywords: keywords, color: UIColor(theme.keyword), text: text)
1873:         
1874:         // Variables (light blue)
1875:         let varPattern = "\\$[a-zA-Z_][a-zA-Z0-9_]*|\\$\\{[^}]+\\}"
1876:         highlightPattern(attributed, pattern: varPattern, color: UIColor(theme.variable), text: text)
1877:         
1878:         highlightComments(attributed, text: text, singleLine: "#", multiLineStart: nil, multiLineEnd: nil)
1879:         highlightStrings(attributed, text: text)
1880:         highlightNumbers(attributed, text: text)
1881:     }
1882:     
1883:     // MARK: - YAML Highlighting
1884:     
1885:     private func highlightYAML(_ attributed: NSMutableAttributedString, text: String) {
1886:         // Keys (light blue)
1887:         let keyPattern = "^\\s*([a-zA-Z_][a-zA-Z0-9_-]*)\\s*:"
1888:         highlightPattern(attributed, pattern: keyPattern, color: UIColor(theme.variable), text: text, options: .anchorsMatchLines, captureGroup: 1)
1889:         
1890:         // Booleans and null
1891:         let constants = ["true", "false", "yes", "no", "on", "off", "null", "~"]
1892:         highlightKeywords(attributed, keywords: constants, color: UIColor(theme.variable), text: text)
1893:         
1894:         highlightComments(attributed, text: text, singleLine: "#", multiLineStart: nil, multiLineEnd: nil)
1895:         highlightStrings(attributed, text: text)
1896:         highlightNumbers(attributed, text: text)
1897:     }
1898:     
1899:     // MARK: - SQL Highlighting
1900:     
1901:     private func highlightSQL(_ attributed: NSMutableAttributedString, text: String) {
1902:         let keywords = ["SELECT", "FROM", "WHERE", "AND", "OR", "NOT", "IN", "LIKE", "BETWEEN",
1903:                        "INSERT", "INTO", "VALUES", "UPDATE", "SET", "DELETE", "CREATE", "ALTER", "DROP",
1904:                        "TABLE", "INDEX", "VIEW", "DATABASE", "SCHEMA", "PRIMARY", "KEY", "FOREIGN", "REFERENCES",
1905:                        "JOIN", "INNER", "LEFT", "RIGHT", "OUTER", "FULL", "ON", "AS", "DISTINCT",
1906:                        "ORDER", "BY", "ASC", "DESC", "GROUP", "HAVING", "LIMIT", "OFFSET", "UNION",
1907:                        "NULL", "IS", "TRUE", "FALSE", "CASE", "WHEN", "THEN", "ELSE", "END",
1908:                        "COUNT", "SUM", "AVG", "MIN", "MAX", "COALESCE", "CAST",
1909:                        "select", "from", "where", "and", "or", "not", "in", "like", "between",
1910:                        "insert", "into", "values", "update", "set", "delete", "create", "alter", "drop",
1911:                        "table", "index", "view", "database", "schema", "primary", "key", "foreign", "references",
1912:                        "join", "inner", "left", "right", "outer", "full", "on", "as", "distinct",
1913:                        "order", "by", "asc", "desc", "group", "having", "limit", "offset", "union",
1914:                        "null", "is", "true", "false", "case", "when", "then", "else", "end"]
1915:         highlightKeywords(attributed, keywords: keywords, color: UIColor(theme.keyword), text: text)
1916:         
1917:         let types = ["INT", "INTEGER", "BIGINT", "SMALLINT", "TINYINT", "FLOAT", "DOUBLE", "DECIMAL",
1918:                     "VARCHAR", "CHAR", "TEXT", "BLOB", "DATE", "TIME", "DATETIME", "TIMESTAMP", "BOOLEAN",
1919:                     "int", "integer", "bigint", "smallint", "tinyint", "float", "double", "decimal",
1920:                     "varchar", "char", "text", "blob", "date", "time", "datetime", "timestamp", "boolean"]
1921:         highlightKeywords(attributed, keywords: types, color: UIColor(theme.type), text: text)
1922:         
1923:         highlightComments(attributed, text: text, singleLine: "--", multiLineStart: "/*", multiLineEnd: "*/")
1924:         highlightStrings(attributed, text: text)
1925:         highlightNumbers(attributed, text: text)
1926:     }
1927:     
1928:     // MARK: - GraphQL Highlighting
1929:     
1930:     private func highlightGraphQL(_ attributed: NSMutableAttributedString, text: String) {
1931:         // Keywords
1932:         let keywords = ["query", "mutation", "subscription", "fragment", "on", "type", 
1933:                        "interface", "union", "enum", "scalar", "input", "extend", 
1934:                        "directive", "schema", "implements"]
1935:         highlightKeywords(attributed, keywords: keywords, color: UIColor(theme.keyword), text: text)
1936:         
1937:         // Built-in scalar types
1938:         let types = ["Int", "Float", "String", "Boolean", "ID"]
1939:         highlightKeywords(attributed, keywords: types, color: UIColor(theme.type), text: text)
1940:         
1941:         // Variables ($name)
1942:         let variablePattern = "\\$[a-zA-Z_][a-zA-Z0-9_]*"
1943:         highlightPattern(attributed, pattern: variablePattern, color: UIColor(theme.variable), text: text)
1944:         
1945:         // Directives (@deprecated, @skip, @include, etc.)
1946:         let directivePattern = "@[a-zA-Z_][a-zA-Z0-9_]*"
1947:         highlightPattern(attributed, pattern: directivePattern, color: UIColor(theme.function), text: text)
1948:         
1949:         // Comments (# single line)
1950:         highlightComments(attributed, text: text, singleLine: "#", multiLineStart: nil, multiLineEnd: nil)
1951:         
1952:         // Strings
1953:         highlightStrings(attributed, text: text)
1954:         
1955:         // Numbers
1956:         highlightNumbers(attributed, text: text)
1957:     }
1958:     
1959:     // MARK: - Helper Methods
1960:     
1961:     private func highlightKeywords(_ attributed: NSMutableAttributedString, keywords: [String], color: UIColor, text: String) {
1962:         for keyword in keywords {
1963:             let pattern = "\\b\(NSRegularExpression.escapedPattern(for: keyword))\\b"
1964:             highlightPattern(attributed, pattern: pattern, color: color, text: text)
1965:         }
1966:     }
1967:     
1968:     private func highlightPattern(_ attributed: NSMutableAttributedString, pattern: String, color: UIColor, text: String, options: NSRegularExpression.Options = [], captureGroup: Int = 0) {
1969:         guard let regex = try? NSRegularExpression(pattern: pattern, options: options) else { return }
1970:         let range = NSRange(location: 0, length: text.utf16.count)
1971:         
1972:         regex.enumerateMatches(in: text, options: [], range: range) { match, _, _ in
1973:             guard let match = match else { return }
1974:             let matchRange = captureGroup > 0 && match.numberOfRanges > captureGroup
1975:                 ? match.range(at: captureGroup)
1976:                 : match.range
1977:             if matchRange.location != NSNotFound {
1978:                 attributed.addAttribute(.foregroundColor, value: color, range: matchRange)
1979:             }
1980:         }
1981:     }
1982:     
1983:     private func highlightStrings(_ attributed: NSMutableAttributedString, text: String) {
1984:         // Double-quoted strings
1985:         let doublePattern = "\"(?:[^\"\\\\]|\\\\.)*\""
1986:         highlightPattern(attributed, pattern: doublePattern, color: UIColor(theme.string), text: text)
1987:         
1988:         // Single-quoted strings
1989:         let singlePattern = "'(?:[^'\\\\]|\\\\.)*'"
1990:         highlightPattern(attributed, pattern: singlePattern, color: UIColor(theme.string), text: text)
1991:     }
1992:     
1993:     private func highlightPythonStrings(_ attributed: NSMutableAttributedString, text: String) {
1994:         // Triple-quoted strings first
1995:         let tripleDoublePattern = "\"\"\"[\\s\\S]*?\"\"\""
1996:         highlightPattern(attributed, pattern: tripleDoublePattern, color: UIColor(theme.string), text: text)
1997:         
1998:         let tripleSinglePattern = "'''[\\s\\S]*?'''"
1999:         highlightPattern(attributed, pattern: tripleSinglePattern, color: UIColor(theme.string), text: text)
2000:         


>>>TOOL create_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor/FoldingLayoutManager.swift","content":"import UIKit\n\n/// TextKit layout manager that collapses line fragments for lines marked folded in CodeFoldingManager.\n///\n/// This is a view-level folding implementation (it does NOT modify the underlying text).\nfinal class FoldingLayoutManager: NSLayoutManager, NSLayoutManagerDelegate {\n    weak var ownerTextView: EditorTextView?\n\n    override init() {\n        super.init()\n        self.delegate = self\n    }\n\n    required init?(coder: NSCoder) {\n        super.init(coder: coder)\n        self.delegate = self\n    }\n\n    func layoutManager(\n        _ layoutManager: NSLayoutManager,\n        shouldSetLineFragmentRect lineFragmentRect: UnsafeMutablePointer<CGRect>,\n        lineFragmentUsedRect: UnsafeMutablePointer<CGRect>,\n        baselineOffset: UnsafeMutablePointer<CGFloat>,\n        in textContainer: NSTextContainer,\n        forGlyphRange glyphRange: NSRange\n    ) -> Bool {\n        guard let owner = ownerTextView,\n              let foldingManager = owner.foldingManager,\n              let fileId = owner.fileId\n        else {\n            return false\n        }\n\n        // Convert glyphRange -> characterRange so we can compute the line index.\n        let charRange = self.characterRange(forGlyphRange: glyphRange, actualGlyphRange: nil)\n        let loc = max(0, charRange.location)\n\n        let full = (self.textStorage?.string ?? \"\") as NSString\n        let lineIndex = FoldingLayoutManager.lineIndex(atUTF16Location: loc, in: full)\n\n        if foldingManager.isLineFolded(fileId: fileId, line: lineIndex) {\n            // Collapse this visual line fragment.\n            lineFragmentRect.pointee.size.height = 0\n            lineFragmentUsedRect.pointee.size.height = 0\n            baselineOffset.pointee = 0\n            return true\n        }\n\n        return false\n    }\n\n    private static func lineIndex(atUTF16Location loc: Int, in text: NSString) -> Int {\n        if loc <= 0 { return 0 }\n\n        let capped = min(loc, text.length)\n        var line = 0\n        var searchStart = 0\n\n        while searchStart < capped {\n            let r = text.range(of: \"\\n\", options: [], range: NSRange(location: searchStart, length: capped - searchStart))\n            if r.location == NSNotFound { break }\n            line += 1\n            let next = r.location + 1\n            if next >= capped { break }\n            searchStart = next\n        }\n\n        return line\n    }\n}\n"}
>>>END
>>>END

---

## üîß TOOL RESULTS

[create_file]
‚úÖ Created: VSCodeiPadOS/VSCodeiPadOS/Views/Editor/FoldingLayoutManager.swift


>>>TOOL search
{"query":"func toggleFold(fileId:", "glob":"VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift"}
>>>END
>>>TOOL search
{"query":"private var foldRegionsByFile", "glob":"VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift"}
>>>END
>>>END>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift","start_line":60,"end_line":120}
>>>END
>>>END>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift","start_line":84,"end_line":220}
>>>END
>>>END>>>FILE VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift
>>>FIND
        // Track different types of blocks
        var blockStack: [(type: FoldRegion.FoldType, startLine: Int, label: String?)] = []
        var commentStack: [(startLine: Int, isMultiline: Bool)] = []
        var regionStack: [(startLine: Int, label: String)] = []
        
        for (index, line) in lines.enumerated() {
            let trimmed = line.trimmingCharacters(in: .whitespaces)
            let leadingWhitespace = line.prefix { $0 == " " || $0 == "\t" }.count
            
            // Skip empty lines for most detections
            guard !trimmed.isEmpty else { continue }
            
            // MARK: - Region Detection (#region, #pragma mark, MARK:)
            if detectRegionStart(trimmed) != nil {
                if let label = detectRegionStart(trimmed) {
                    regionStack.append((index, label))
                }
            } else if detectRegionEnd(trimmed) {
                if let region = regionStack.popLast() {
                    if index - region.startLine > 1 {
                        regions.append(FoldRegion(
                            startLine: region.startLine,
                            endLine: index,
                            type: .region,
                            label: region.label
                        ))
                    }
                }
            }
            
            // MARK: - Import Statement Detection
            if trimmed.hasPrefix("import ") {
                // Group consecutive imports
                let importEnd = findConsecutiveImports(from: index, in: lines)
                if importEnd > index {
                    regions.append(FoldRegion(
                        startLine: index,
                        endLine: importEnd,
                        type: .importStatement,
                        label: "Imports"
                    ))
                }
            }
            
            // MARK: - Comment Detection
            if detectCommentStart(trimmed) {
                commentStack.append((index, true))
            } else if trimmed.starts(with: "//") {
                // Single-line comment - check for consecutive comment blocks
                let commentEnd = findConsecutiveComments(from: index, in: lines)
                if commentEnd > index {
                    regions.append(FoldRegion(
                        startLine: index,
                        endLine: commentEnd,
                        type: .comment,
                        label: "Comment"
                    ))
                }
            } else if detectCommentEnd(trimmed) {
                if let comment = commentStack.popLast() {
                    if index - comment.startLine > 1 {
                        regions.append(FoldRegion(
                            startLine: comment.startLine,
                            endLine: index,
                            type: .comment,
                            label: "Comment"
                        ))
                    }
                }
            }
            
            // MARK: - Class/Struct/Enum/Protocol/Extension Detection
            if let declaration = detectDeclaration(trimmed) {
                if trimmed.contains("{") {
                    blockStack.append((declaration.type, index, declaration.label))
                } else {
                    // Declaration without opening brace - look ahead for it
                    if let braceLine = findOpeningBrace(from: index + 1, in: lines) {
                        blockStack.append((declaration.type, index, declaration.label))
                    }
                }
            }
            
            // MARK: - Function/Method Detection
            if let functionInfo = detectFunction(trimmed) {
                if trimmed.contains("{") {
                    blockStack.append((.function, index, functionInfo))
                } else {
                    // Function without opening brace - look ahead
                    if let braceLine = findOpeningBrace(from: index + 1, in: lines) {
                        blockStack.append((.function, index, functionInfo))
                    }
                }
            }
            
            // MARK: - Control Flow Detection (if, guard, for, while, switch, etc.)
            if let controlFlowLabel = detectControlFlow(trimmed) {
                if trimmed.contains("{") {
                    blockStack.append((.controlFlow, index, controlFlowLabel))
                } else {
                    if let braceLine = findOpeningBrace(from: index + 1, in: lines) {
                        blockStack.append((.controlFlow, index, controlFlowLabel))
                    }
                }
            }
            
            // MARK: - Generic Block Detection
            if trimmed.hasSuffix("{") && !isDeclarationLine(trimmed) && !isFunctionLine(trimmed) {
                blockStack.append((.genericBlock, index, nil))
            }
            
            // MARK: - Block End Detection
            if detectBlockEnd(trimmed, leadingWhitespace: leadingWhitespace) {
                if let lastBlock = blockStack.popLast() {
                    if index - lastBlock.startLine > 1 {
                        regions.append(FoldRegion(
                            startLine: lastBlock.startLine,
                            endLine: index,
                            type: lastBlock.type,
                            label: lastBlock.label
                        ))
                    }
                }
            }
        }
>>>REPLACE
        // Track different types of blocks
        var blockStack: [(type: FoldRegion.FoldType, startLine: Int, label: String?)] = []
        var commentStack: [(startLine: Int, isMultiline: Bool)] = []
        var regionStack: [(startLine: Int, label: String)] = []

        // If we detect a declaration/function/control-flow whose opening brace is on a later line,
        // we mark that brace line so it won't be treated as a standalone generic block.
        var braceLinesClaimed: Set<Int> = []

        // Used to prevent duplicate regions for grouped constructs (imports, // comments)
        var previousNonEmptyWasImport = false
        var previousNonEmptyWasSingleLineComment = false
        
        for (index, line) in lines.enumerated() {
            let trimmed = line.trimmingCharacters(in: .whitespaces)
            let leadingWhitespace = line.prefix { $0 == " " || $0 == "\t" }.count
            
            // Skip empty lines for most detections
            guard !trimmed.isEmpty else { continue }

            // MARK: - Close blocks BEFORE opening new ones (handles "} else {" correctly)
            if trimmed.hasPrefix("}") {
                // Count consecutive leading '}' so we can pop multiple blocks for lines like "}}"
                let closeCount = max(1, trimmed.prefix { $0 == "}" }.count)
                for _ in 0..<closeCount {
                    if let lastBlock = blockStack.popLast() {
                        if index - lastBlock.startLine > 1 {
                            regions.append(FoldRegion(
                                startLine: lastBlock.startLine,
                                endLine: index,
                                type: lastBlock.type,
                                label: lastBlock.label
                            ))
                        }
                    }
                }
            }
            
            // MARK: - Region Detection (#region, #pragma mark, MARK:)
            if let label = detectRegionStart(trimmed) {
                regionStack.append((index, label))
            } else if detectRegionEnd(trimmed) {
                if let region = regionStack.popLast() {
                    if index - region.startLine > 1 {
                        regions.append(FoldRegion(
                            startLine: region.startLine,
                            endLine: index,
                            type: .region,
                            label: region.label
                        ))
                    }
                }
            }
            
            // MARK: - Import Statement Detection (group consecutive imports once)
            if trimmed.hasPrefix("import ") {
                if !previousNonEmptyWasImport {
                    let importEnd = findConsecutiveImports(from: index, in: lines)
                    if importEnd > index {
                        regions.append(FoldRegion(
                            startLine: index,
                            endLine: importEnd,
                            type: .importStatement,
                            label: "Imports"
                        ))
                    }
                }
                previousNonEmptyWasImport = true
            } else {
                previousNonEmptyWasImport = false
            }
            
            // MARK: - Comment Detection
            if detectCommentStart(trimmed) {
                commentStack.append((index, true))
                previousNonEmptyWasSingleLineComment = false
            } else if trimmed.starts(with: "//") {
                // Only create a fold region at the start of a consecutive // block
                if !previousNonEmptyWasSingleLineComment {
                    let commentEnd = findConsecutiveComments(from: index, in: lines)
                    if commentEnd > index {
                        regions.append(FoldRegion(
                            startLine: index,
                            endLine: commentEnd,
                            type: .comment,
                            label: "Comment"
                        ))
                    }
                }
                previousNonEmptyWasSingleLineComment = true
            } else if detectCommentEnd(trimmed) {
                previousNonEmptyWasSingleLineComment = false
                if let comment = commentStack.popLast() {
                    if index - comment.startLine > 1 {
                        regions.append(FoldRegion(
                            startLine: comment.startLine,
                            endLine: index,
                            type: .comment,
                            label: "Comment"
                        ))
                    }
                }
            } else {
                previousNonEmptyWasSingleLineComment = false
            }
            
            // MARK: - Class/Struct/Enum/Protocol/Extension Detection
            if let declaration = detectDeclaration(trimmed) {
                if trimmed.contains("{") {
                    blockStack.append((declaration.type, index, declaration.label))
                } else {
                    // Declaration without opening brace - look ahead for it
                    if let braceLine = findOpeningBrace(from: index + 1, in: lines) {
                        braceLinesClaimed.insert(braceLine)
                        blockStack.append((declaration.type, index, declaration.label))
                    }
                }
            }
            
            // MARK: - Function/Method Detection
            if let functionInfo = detectFunction(trimmed) {
                if trimmed.contains("{") {
                    blockStack.append((.function, index, functionInfo))
                } else {
                    // Function without opening brace - look ahead
                    if let braceLine = findOpeningBrace(from: index + 1, in: lines) {
                        braceLinesClaimed.insert(braceLine)
                        blockStack.append((.function, index, functionInfo))
                    }
                }
            }
            
            // MARK: - Control Flow Detection (if, guard, for, while, switch, etc.)
            if let controlFlowLabel = detectControlFlow(trimmed) {
                if trimmed.contains("{") {
                    blockStack.append((.controlFlow, index, controlFlowLabel))
                } else {
                    if let braceLine = findOpeningBrace(from: index + 1, in: lines) {
                        braceLinesClaimed.insert(braceLine)
                        blockStack.append((.controlFlow, index, controlFlowLabel))
                    }
                }
            }
            
            // MARK: - Generic Block Detection
            // Avoid adding a generic block for a standalone "{" that belongs to a previously detected declaration.
            if trimmed.hasSuffix("{"),
               trimmed != "{",
               !braceLinesClaimed.contains(index),
               !isDeclarationLine(trimmed),
               !isFunctionLine(trimmed) {
                blockStack.append((.genericBlock, index, nil))
            }

            _ = leadingWhitespace // keep param for potential future heuristics
        }
>>>END
>>>END>>>FILE VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift
>>>FIND
    private func detectDeclaration(_ line: String) -> (type: FoldRegion.FoldType, label: String)? {
        // Class detection
        if let className = extractName(from: line, prefix: "class", visibility: ["public", "private", "internal", "fileprivate", "open", "final"]) {
            return (.classOrStruct, className)
        }
        // Struct detection
        if let structName = extractName(from: line, prefix: "struct", visibility: ["public", "private", "internal", "fileprivate"]) {
            return (.classOrStruct, structName)
        }
        // Enum detection
        if let enumName = extractName(from: line, prefix: "enum", visibility: ["public", "private", "internal", "fileprivate", "indirect"]) {
            return (.enumDeclaration, enumName)
        }
        // Protocol detection
        if let protocolName = extractName(from: line, prefix: "protocol", visibility: ["public", "private", "internal", "fileprivate"]) {
            return (.protocolDeclaration, protocolName)
        }
        // Extension detection
        if let extensionName = extractName(from: line, prefix: "extension", visibility: []) {
            return (.extension, extensionName)
        }
        return nil
    }
>>>REPLACE
    private func detectDeclaration(_ line: String) -> (type: FoldRegion.FoldType, label: String)? {
        func matchName(pattern: String) -> String? {
            guard let regex = try? NSRegularExpression(pattern: pattern, options: []) else { return nil }
            guard let match = regex.firstMatch(in: line, range: NSRange(line.startIndex..., in: line)),
                  match.numberOfRanges >= 2,
                  let r = Range(match.range(at: 1), in: line)
            else { return nil }
            return String(line[r])
        }

        // Allow leading attributes like "@MainActor", "@available(...)"
        // Allow common modifiers in any order (best-effort).
        let prefix = #"^(?:\s*@\w+(?:\([^\)]*\))?\s+)*(?:\s*(?:public|private|internal|fileprivate|open|final|indirect|lazy|static|class|override|mutating|nonmutating)\s+)*"#

        // IMPORTANT: avoid treating "class func"/"class var" as a type declaration.
        if let name = matchName(pattern: prefix + #"class\s+(?!func\b|var\b|let\b)([A-Za-z_]\w*)"#) {
            return (.classOrStruct, name)
        }

        // Actor (Swift concurrency) ‚Äì fold like a class/struct
        if let name = matchName(pattern: prefix + #"actor\s+([A-Za-z_]\w*)"#) {
            return (.classOrStruct, name)
        }

        if let name = matchName(pattern: prefix + #"struct\s+([A-Za-z_]\w*)"#) {
            return (.classOrStruct, name)
        }

        if let name = matchName(pattern: prefix + #"enum\s+([A-Za-z_]\w*)"#) {
            return (.enumDeclaration, name)
        }

        if let name = matchName(pattern: prefix + #"protocol\s+([A-Za-z_]\w*)"#) {
            return (.protocolDeclaration, name)
        }

        // Extensions can include dotted names (Foo.Bar)
        if let name = matchName(pattern: prefix + #"extension\s+([A-Za-z_][A-Za-z0-9_\.]*)"#) {
            return (.extension, name)
        }

        return nil
    }
>>>END
>>>END>>>TOOL search
{"query":"let prefix = #\"^(?:\\s*@\\w+", "glob":"VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift"}
>>>END
>>>END>>>FILE VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift
>>>FIND
        let prefix = #"^(?:\s*@\w+(?:\([^\)]*\))?\s+)*(?:\s*(?:public|private|internal|fileprivate|open|final|indirect|lazy|static|class|override|mutating|nonmutating)\s+)*"#
>>>REPLACE
        let prefix = #"^(?:\s*@\w+(?:\([^\)]*\))?\s+)*(?:\s*(?:public|private|internal|fileprivate|open|final|indirect|lazy|static|override|mutating|nonmutating)\s+)*"#
>>>END
>>>END>>>FILE VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift
>>>FIND
    /// Checks if a line is currently folded
    func isLineFolded(line: Int) -> Bool {
        return collapsedLines.contains(line)
    }
>>>REPLACE
    /// Checks if a line is currently folded (for the currently active file in `foldRegions`)
    func isLineFolded(line: Int) -> Bool {
        return collapsedLines.contains(line)
    }

    /// Checks if a line should be hidden for a specific file (does not rely on `collapsedLines`)
    func isLineFolded(fileId: String, line: Int) -> Bool {
        guard let regions = foldRegionsByFile[fileId] else { return false }
        for region in regions where region.isFolded {
            if line > region.startLine && line <= region.endLine {
                return true
            }
        }
        return false
    }
>>>END
>>>END>>>FILE VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift
>>>FIND
    func toggleFold(fileId: String, line: Int) {
        guard var regions = foldRegionsByFile[fileId] else { return }
        
        if let regionIndex = regions.firstIndex(where: { $0.startLine == line }) {
            regions[regionIndex].isFolded.toggle()
            foldRegionsByFile[fileId] = regions
            
            // Update current file regions if this is the active file
            if fileId == currentFileId {
                self.foldRegions = regions
                updateCollapsedLines()
            }
            
            // Save state after toggling
            saveFoldState(for: fileId)
        }
    }
>>>REPLACE
    func toggleFold(fileId: String, line: Int) {
        guard var regions = foldRegionsByFile[fileId] else { return }
        
        if let regionIndex = regions.firstIndex(where: { $0.startLine == line }) {
            regions[regionIndex].isFolded.toggle()
            foldRegionsByFile[fileId] = regions
            
            // Update current file regions if this is the active file
            if fileId == currentFileId {
                self.foldRegions = regions
                updateCollapsedLines()
            } else {
                // Ensure SwiftUI updates for gutters rendering using file-aware queries.
                objectWillChange.send()
            }
            
            // Save state after toggling
            saveFoldState(for: fileId)
        }
    }
>>>END
>>>END>>>FILE VSCodeiPadOS/VSCodeiPadOS/ContentView.swift
>>>FIND
    @StateObject private var autocomplete = AutocompleteManager()
    @State private var showAutocomplete = false
    @StateObject private var foldingManager = CodeFoldingManager()
    @StateObject private var findViewModel = FindViewModel()
>>>REPLACE
    @StateObject private var autocomplete = AutocompleteManager()
    @State private var showAutocomplete = false
    @ObservedObject private var foldingManager = CodeFoldingManager.shared
    @StateObject private var findViewModel = FindViewModel()
>>>END
>>>END>>>TOOL search
{"query":"foldingManager.detectFoldableRegions", "glob":"VSCodeiPadOS/VSCodeiPadOS/ContentView.swift"}
>>>END
>>>END>>>FILE VSCodeiPadOS/VSCodeiPadOS/ContentView.swift
>>>FIND
                            foldingManager.detectFoldableRegions(in: newValue)
>>>REPLACE
                            foldingManager.detectFoldableRegions(in: newValue, filePath: tab.url?.path ?? tab.fileName)
>>>END
>>>END>>>FILE VSCodeiPadOS/VSCodeiPadOS/ContentView.swift
>>>FIND
            foldingManager.detectFoldableRegions(in: text)
>>>REPLACE
            foldingManager.detectFoldableRegions(in: text, filePath: tab.url?.path ?? tab.fileName)
>>>END
>>>END>>>FILE VSCodeiPadOS/VSCodeiPadOS/ContentView.swift
>>>FIND
            foldingManager.detectFoldableRegions(in: text)
>>>REPLACE
            foldingManager.detectFoldableRegions(in: text, filePath: tab.url?.path ?? tab.fileName)
>>>END
>>>END>>>TOOL search
{"query":"SyntaxHighlightingTextView_Update.swift", "glob":"VSCodeiPadOS/VSCodeiPadOS.xcodeproj/project.pbxproj"}
>>>END
>>>END>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS.xcodeproj/project.pbxproj","start_line":1,"end_line":220}
>>>END
>>>END>>>TOOL search
{"query":"SyntaxHighlightingTextView_Update.swift", "glob":"VSCodeiPadOS/VSCodeiPadOS.xcodeproj/project.pbxproj"}
>>>END
>>>END>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS.xcodeproj/project.pbxproj","start_line":220,"end_line":340}
>>>END
>>>END

---

## üîß TOOL RESULTS

[search]
Found 1 matches:
VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift:706: func toggleFold(fileId: String, line: Int) {

---

[search]
Found 1 matches:
VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift:75: private var foldRegionsByFile: [String: [FoldRegion]] = [:]

---

[read_file]
File: VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift (lines 61-120 of 866)
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
61: 
62: // MARK: - UserDefaults Keys
63: struct UserDefaultsKeys {
64:     static let foldStatePrefix = "codeFoldingState_"
65: }
66: 
67: // MARK: - Code Folding Manager
68: class CodeFoldingManager: ObservableObject {
69:     static let shared = CodeFoldingManager()
70:     
71:     @Published var foldRegions: [FoldRegion] = []
72:     @Published var collapsedLines: Set<Int> = []
73:     
74:     // Dictionary to manage fold regions per file
75:     private var foldRegionsByFile: [String: [FoldRegion]] = [:]
76:     
77:     private var currentFilePath: String?
78:     private var currentFileId: String?
79:     
80:     // MARK: - Enhanced Fold Detection
81:     
82:     /// Detects all foldable regions in the given code
83:     func detectFoldableRegions(in code: String, filePath: String? = nil) {
84:         self.currentFilePath = filePath
85:         self.currentFileId = filePath
86:         
87:         let lines = code.components(separatedBy: .newlines)
88:         var regions: [FoldRegion] = []
89:         
90:         // Track different types of blocks
91:         var blockStack: [(type: FoldRegion.FoldType, startLine: Int, label: String?)] = []
92:         var commentStack: [(startLine: Int, isMultiline: Bool)] = []
93:         var regionStack: [(startLine: Int, label: String)] = []
94:         
95:         for (index, line) in lines.enumerated() {
96:             let trimmed = line.trimmingCharacters(in: .whitespaces)
97:             let leadingWhitespace = line.prefix { $0 == " " || $0 == "\t" }.count
98:             
99:             // Skip empty lines for most detections
100:             guard !trimmed.isEmpty else { continue }
101:             
102:             // MARK: - Region Detection (#region, #pragma mark, MARK:)
103:             if detectRegionStart(trimmed) != nil {
104:                 if let label = detectRegionStart(trimmed) {
105:                     regionStack.append((index, label))
106:                 }
107:             } else if detectRegionEnd(trimmed) {
108:                 if let region = regionStack.popLast() {
109:                     if index - region.startLine > 1 {
110:                         regions.append(FoldRegion(
111:                             startLine: region.startLine,
112:                             endLine: index,
113:                             type: .region,
114:                             label: region.label
115:                         ))
116:                     }
117:                 }
118:             }
119:             
120:             // MARK: - Import Statement Detection

---

[read_file]
File: VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift (lines 85-220 of 866)
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
85:         self.currentFileId = filePath
86:         
87:         let lines = code.components(separatedBy: .newlines)
88:         var regions: [FoldRegion] = []
89:         
90:         // Track different types of blocks
91:         var blockStack: [(type: FoldRegion.FoldType, startLine: Int, label: String?)] = []
92:         var commentStack: [(startLine: Int, isMultiline: Bool)] = []
93:         var regionStack: [(startLine: Int, label: String)] = []
94:         
95:         for (index, line) in lines.enumerated() {
96:             let trimmed = line.trimmingCharacters(in: .whitespaces)
97:             let leadingWhitespace = line.prefix { $0 == " " || $0 == "\t" }.count
98:             
99:             // Skip empty lines for most detections
100:             guard !trimmed.isEmpty else { continue }
101:             
102:             // MARK: - Region Detection (#region, #pragma mark, MARK:)
103:             if detectRegionStart(trimmed) != nil {
104:                 if let label = detectRegionStart(trimmed) {
105:                     regionStack.append((index, label))
106:                 }
107:             } else if detectRegionEnd(trimmed) {
108:                 if let region = regionStack.popLast() {
109:                     if index - region.startLine > 1 {
110:                         regions.append(FoldRegion(
111:                             startLine: region.startLine,
112:                             endLine: index,
113:                             type: .region,
114:                             label: region.label
115:                         ))
116:                     }
117:                 }
118:             }
119:             
120:             // MARK: - Import Statement Detection
121:             if trimmed.hasPrefix("import ") {
122:                 // Group consecutive imports
123:                 let importEnd = findConsecutiveImports(from: index, in: lines)
124:                 if importEnd > index {
125:                     regions.append(FoldRegion(
126:                         startLine: index,
127:                         endLine: importEnd,
128:                         type: .importStatement,
129:                         label: "Imports"
130:                     ))
131:                 }
132:             }
133:             
134:             // MARK: - Comment Detection
135:             if detectCommentStart(trimmed) {
136:                 commentStack.append((index, true))
137:             } else if trimmed.starts(with: "//") {
138:                 // Single-line comment - check for consecutive comment blocks
139:                 let commentEnd = findConsecutiveComments(from: index, in: lines)
140:                 if commentEnd > index {
141:                     regions.append(FoldRegion(
142:                         startLine: index,
143:                         endLine: commentEnd,
144:                         type: .comment,
145:                         label: "Comment"
146:                     ))
147:                 }
148:             } else if detectCommentEnd(trimmed) {
149:                 if let comment = commentStack.popLast() {
150:                     if index - comment.startLine > 1 {
151:                         regions.append(FoldRegion(
152:                             startLine: comment.startLine,
153:                             endLine: index,
154:                             type: .comment,
155:                             label: "Comment"
156:                         ))
157:                     }
158:                 }
159:             }
160:             
161:             // MARK: - Class/Struct/Enum/Protocol/Extension Detection
162:             if let declaration = detectDeclaration(trimmed) {
163:                 if trimmed.contains("{") {
164:                     blockStack.append((declaration.type, index, declaration.label))
165:                 } else {
166:                     // Declaration without opening brace - look ahead for it
167:                     if let braceLine = findOpeningBrace(from: index + 1, in: lines) {
168:                         blockStack.append((declaration.type, index, declaration.label))
169:                     }
170:                 }
171:             }
172:             
173:             // MARK: - Function/Method Detection
174:             if let functionInfo = detectFunction(trimmed) {
175:                 if trimmed.contains("{") {
176:                     blockStack.append((.function, index, functionInfo))
177:                 } else {
178:                     // Function without opening brace - look ahead
179:                     if let braceLine = findOpeningBrace(from: index + 1, in: lines) {
180:                         blockStack.append((.function, index, functionInfo))
181:                     }
182:                 }
183:             }
184:             
185:             // MARK: - Control Flow Detection (if, guard, for, while, switch, etc.)
186:             if let controlFlowLabel = detectControlFlow(trimmed) {
187:                 if trimmed.contains("{") {
188:                     blockStack.append((.controlFlow, index, controlFlowLabel))
189:                 } else {
190:                     if let braceLine = findOpeningBrace(from: index + 1, in: lines) {
191:                         blockStack.append((.controlFlow, index, controlFlowLabel))
192:                     }
193:                 }
194:             }
195:             
196:             // MARK: - Generic Block Detection
197:             if trimmed.hasSuffix("{") && !isDeclarationLine(trimmed) && !isFunctionLine(trimmed) {
198:                 blockStack.append((.genericBlock, index, nil))
199:             }
200:             
201:             // MARK: - Block End Detection
202:             if detectBlockEnd(trimmed, leadingWhitespace: leadingWhitespace) {
203:                 if let lastBlock = blockStack.popLast() {
204:                     if index - lastBlock.startLine > 1 {
205:                         regions.append(FoldRegion(
206:                             startLine: lastBlock.startLine,
207:                             endLine: index,
208:                             type: lastBlock.type,
209:                             label: lastBlock.label
210:                         ))
211:                     }
212:                 }
213:             }
214:         }
215:         
216:         // Handle any remaining unclosed blocks
217:         while let lastBlock = blockStack.popLast() {
218:             if lines.count - 1 - lastBlock.startLine > 1 {
219:                 regions.append(FoldRegion(
220:                     startLine: lastBlock.startLine,

---

[search]
No matches found for "let prefix = #"^(?:\s*@\w+"

---

[search]
Found 3 matches:
VSCodeiPadOS/VSCodeiPadOS/ContentView.swift:492: foldingManager.detectFoldableRegions(in: newValue)
VSCodeiPadOS/VSCodeiPadOS/ContentView.swift:555: foldingManager.detectFoldableRegions(in: text)
VSCodeiPadOS/VSCodeiPadOS/ContentView.swift:559: foldingManager.detectFoldableRegions(in: text)

---

[search]
No matches found for "SyntaxHighlightingTextView_Update.swift"

---

[read_file]
File: VSCodeiPadOS/VSCodeiPadOS.xcodeproj/project.pbxproj (lines 2-220 of 756)
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
2: {
3: 	archiveVersion = 1;
4: 	classes = {
5: 	};
6: 	objectVersion = 56;
7: 	objects = {
8: 
9: /* Begin PBXBuildFile section */
10: 		1001 /* ContentView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2001 /* ContentView.swift */; };
11: 		1002 /* VSCodeiPadOSApp.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2002 /* VSCodeiPadOSApp.swift */; };
12: 		1003 /* AppCommands.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2003 /* AppCommands.swift */; };
13: 		1004 /* Color+Hex.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2004 /* Color+Hex.swift */; };
14: 		1005 /* FileManager+Extension.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2005 /* FileManager+Extension.swift */; };
15: 		1006 /* FileManager+Extensions.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2006 /* FileManager+Extensions.swift */; };
16: 		1007 /* NSAttributedStringSyntaxHighlighter.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2007 /* NSAttributedStringSyntaxHighlighter.swift */; };
17: 		1009 /* EditorState.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2009 /* EditorState.swift */; };
18: 		1012 /* FileItem.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2012 /* FileItem.swift */; };
19: 		1013 /* FileItemUTType.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2013 /* FileItemUTType.swift */; };
20: 		1015 /* FindViewModel.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2015 /* FindViewModel.swift */; };
21: 		1016 /* MultiCursor.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2016 /* MultiCursor.swift */; };
22: 		1017 /* Tab.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2017 /* Tab.swift */; };
23: 		1018 /* Theme.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2018 /* Theme.swift */; };
24: 		1020 /* ThemeManager.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2020 /* ThemeManager.swift */; };
25: 		1019 /* AutocompleteManager.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2019 /* AutocompleteManager.swift */; };
26: 		1022 /* CodeFoldingManager.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2022 /* CodeFoldingManager.swift */; };
27: 		1023 /* EditorCore.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2023 /* EditorCore.swift */; };
28: 		1025 /* FileSystemNavigator.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2025 /* FileSystemNavigator.swift */; };
29: 		1035 /* MinimapView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2035 /* MinimapView.swift */; };
30: 		1036 /* SyntaxHighlightingTextView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2036 /* SyntaxHighlightingTextView.swift */; };
31: 		1043 /* GitView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2043 /* GitView.swift */; };
32: 		1044 /* GoToLineView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2044 /* GoToLineView.swift */; };
33: 		1050 /* SettingsView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2050 /* SettingsView.swift */; };
34: 		1051 /* TerminalView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2051 /* TerminalView.swift */; };
35: 		1052 /* DebugManager.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2052 /* DebugManager.swift */; };
36: 		1053 /* DebugView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2053 /* DebugView.swift */; };
37: 		1054 /* WorkspaceTrustManager.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2054 /* WorkspaceTrustManager.swift */; };
38: 		1055 /* AIManager.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2055 /* AIManager.swift */; };
39: 		1056 /* ColorPickerManager.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2056 /* ColorPickerManager.swift */; };
40: 		1057 /* GitManager.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2057 /* GitManager.swift */; };
41: 		1058 /* GitService.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2058 /* GitService.swift */; };
42: 		1059 /* HoverInfoManager.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2059 /* HoverInfoManager.swift */; };
43: 		1060 /* LaunchManager.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2060 /* LaunchManager.swift */; };
44: 		1061 /* NavigationManager.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2061 /* NavigationManager.swift */; };
45: 		1062 /* RecentFileManager.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2062 /* RecentFileManager.swift */; };
46: 		1063 /* SearchManager.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2063 /* SearchManager.swift */; };
47: 		1064 /* SettingsManager.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2064 /* SettingsManager.swift */; };
48: 		1065 /* SnippetsManager.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2065 /* SnippetsManager.swift */; };
49: 		1066 /* TasksManager.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2066 /* TasksManager.swift */; };
50: 		1067 /* WorkspaceManager.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2067 /* WorkspaceManager.swift */; };
51: 		1068 /* FileIcons.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2068 /* FileIcons.swift */; };
52: 		1069 /* FileTreeView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2069 /* FileTreeView.swift */; };
53: 		1070 /* SpotlightManager.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2070 /* SpotlightManager.swift */; };
54: 		1101 /* BranchMenu.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2101 /* BranchMenu.swift */; };
55: 		1102 /* CommandPalette.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2102 /* CommandPalette.swift */; };
56: 		1103 /* DiffComponents.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2103 /* DiffComponents.swift */; };
57: 		1104 /* FileIconView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2104 /* FileIconView.swift */; };
58: 		1105 /* GoToSymbol.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2105 /* GoToSymbol.swift */; };
59: 		1106 /* LaunchConfigView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2106 /* LaunchConfigView.swift */; };
60: 		1107 /* QuickOpen.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2107 /* QuickOpen.swift */; };
61: 		1108 /* SidebarView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2108 /* SidebarView.swift */; };
62: 		1109 /* SnippetPickerView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2109 /* SnippetPickerView.swift */; };
63: 		1110 /* StatusBarView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2110 /* StatusBarView.swift */; };
64: 		1111 /* TabBarView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2111 /* TabBarView.swift */; };
65: 		1112 /* TasksView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2112 /* TasksView.swift */; };
66: 		1113 /* WorkspaceSettingsView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2113 /* WorkspaceSettingsView.swift */; };
67: 		1114 /* WorkspaceTrustDialog.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2114 /* WorkspaceTrustDialog.swift */; };
68: 		1115 /* OutputView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2115 /* OutputView.swift */; };
69: 		1116 /* SearchView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2116 /* SearchView.swift */; };
70: 		1117 /* MarkdownPreviewView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2117 /* MarkdownPreviewView.swift */; };
71: 		1118 /* AIAssistantView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2118 /* AIAssistantView.swift */; };
72: 		1119 /* GitQuickActionsView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2119 /* GitQuickActionsView.swift */; };
73: 		1120 /* MarkdownPreviewWrapper.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2120 /* MarkdownPreviewWrapper.swift */; };
74: 		1121 /* TestView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2121 /* TestView.swift */; };
75: 		1122 /* PanelView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2122 /* PanelView.swift */; };
76: 		1123 /* ProblemsView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2123 /* ProblemsView.swift */; };
77: 		1124 /* OutlineView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2124 /* OutlineView.swift */; };
78: 		1125 /* TimelineView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2125 /* TimelineView.swift */; };
79: 		1126 /* DebugConsoleView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2126 /* DebugConsoleView.swift */; };
80: 		1127 /* SplitEditorView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2127 /* SplitEditorView.swift */; };
81: 		1128 /* StickyHeaderView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2128 /* StickyHeaderView.swift */; };
82: 		1129 /* ColorPickerView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2129 /* ColorPickerView.swift */; };
83: 		1130 /* MultiCursorTextView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2130 /* MultiCursorTextView.swift */; };
84: 		1131 /* JSONTreeView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2131 /* JSONTreeView.swift */; };
85: 		1132 /* EditorSplitView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2132 /* EditorSplitView.swift */; };
86: 		1133 /* InlayHintsOverlay.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2133 /* InlayHintsOverlay.swift */; };
87: 
88: 		1135 /* HoverInfoView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2135 /* HoverInfoView.swift */; };
89: 		1136 /* BreadcrumbsView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2136 /* BreadcrumbsView.swift */; };
90: 
91: 		1138 /* PeekDefinitionView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2138 /* PeekDefinitionView.swift */; };
92: 		1139 /* InlayHintsManager.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2139 /* InlayHintsManager.swift */; };
93: 		1140 /* FileHelpers.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2140 /* FileHelpers.swift */; };
94: 		1141 /* Notification+Search.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2141 /* Notification+Search.swift */; };
95: 		1142 /* SSHManager.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2142 /* SSHManager.swift */; };
96: 		1143 /* AppDelegate.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2143 /* AppDelegate.swift */; };
97: 		1144 /* SceneDelegate.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2144 /* SceneDelegate.swift */; };
98: 		1099 /* Assets.xcassets in Resources */ = {isa = PBXBuildFile; fileRef = 2099 /* Assets.xcassets */; };
99: /* End PBXBuildFile section */
100: 
101: /* Begin PBXFileReference section */
102: 		2001 /* ContentView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ContentView.swift; sourceTree = "<group>"; };
103: 		2002 /* VSCodeiPadOSApp.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = VSCodeiPadOSApp.swift; sourceTree = "<group>"; };
104: 		2003 /* AppCommands.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = AppCommands.swift; sourceTree = "<group>"; };
105: 		2004 /* Color+Hex.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = "Color+Hex.swift"; sourceTree = "<group>"; };
106: 		2005 /* FileManager+Extension.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = "FileManager+Extension.swift"; sourceTree = "<group>"; };
107: 		2006 /* FileManager+Extensions.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = "FileManager+Extensions.swift"; sourceTree = "<group>"; };
108: 		2007 /* NSAttributedStringSyntaxHighlighter.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = NSAttributedStringSyntaxHighlighter.swift; sourceTree = "<group>"; };
109: 		2009 /* EditorState.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = EditorState.swift; sourceTree = "<group>"; };
110: 		2012 /* FileItem.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = FileItem.swift; sourceTree = "<group>"; };
111: 		2013 /* FileItemUTType.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = FileItemUTType.swift; sourceTree = "<group>"; };
112: 		2015 /* FindViewModel.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = FindViewModel.swift; sourceTree = "<group>"; };
113: 		2016 /* MultiCursor.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = MultiCursor.swift; sourceTree = "<group>"; };
114: 		2017 /* Tab.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = Tab.swift; sourceTree = "<group>"; };
115: 		2018 /* Theme.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = Theme.swift; sourceTree = "<group>"; };
116: 		2019 /* AutocompleteManager.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = AutocompleteManager.swift; sourceTree = "<group>"; };
117: 		2020 /* ThemeManager.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ThemeManager.swift; sourceTree = "<group>"; };
118: 		2022 /* CodeFoldingManager.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = CodeFoldingManager.swift; sourceTree = "<group>"; };
119: 		2023 /* EditorCore.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = EditorCore.swift; sourceTree = "<group>"; };
120: 		2025 /* FileSystemNavigator.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = FileSystemNavigator.swift; sourceTree = "<group>"; };
121: 		2035 /* MinimapView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = MinimapView.swift; sourceTree = "<group>"; };
122: 		2036 /* SyntaxHighlightingTextView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SyntaxHighlightingTextView.swift; sourceTree = "<group>"; };
123: 		2043 /* GitView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = GitView.swift; sourceTree = "<group>"; };
124: 		2044 /* GoToLineView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = GoToLineView.swift; sourceTree = "<group>"; };
125: 		2050 /* SettingsView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SettingsView.swift; sourceTree = "<group>"; };
126: 		2051 /* TerminalView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = TerminalView.swift; sourceTree = "<group>"; };
127: 		2052 /* DebugManager.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = DebugManager.swift; sourceTree = "<group>"; };
128: 		2053 /* DebugView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = DebugView.swift; sourceTree = "<group>"; };
129: 		2054 /* WorkspaceTrustManager.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = WorkspaceTrustManager.swift; sourceTree = "<group>"; };
130: 		2055 /* AIManager.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = AIManager.swift; sourceTree = "<group>"; };
131: 		2056 /* ColorPickerManager.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ColorPickerManager.swift; sourceTree = "<group>"; };
132: 		2057 /* GitManager.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = GitManager.swift; sourceTree = "<group>"; };
133: 		2058 /* GitService.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = GitService.swift; sourceTree = "<group>"; };
134: 		2059 /* HoverInfoManager.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = HoverInfoManager.swift; sourceTree = "<group>"; };
135: 		2060 /* LaunchManager.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = LaunchManager.swift; sourceTree = "<group>"; };
136: 		2061 /* NavigationManager.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = NavigationManager.swift; sourceTree = "<group>"; };
137: 		2062 /* RecentFileManager.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = RecentFileManager.swift; sourceTree = "<group>"; };
138: 		2063 /* SearchManager.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SearchManager.swift; sourceTree = "<group>"; };
139: 		2064 /* SettingsManager.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SettingsManager.swift; sourceTree = "<group>"; };
140: 		2065 /* SnippetsManager.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SnippetsManager.swift; sourceTree = "<group>"; };
141: 		2066 /* TasksManager.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = TasksManager.swift; sourceTree = "<group>"; };
142: 		2067 /* WorkspaceManager.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = WorkspaceManager.swift; sourceTree = "<group>"; };
143: 		2068 /* FileIcons.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = FileIcons.swift; sourceTree = "<group>"; };
144: 		2069 /* FileTreeView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = FileTreeView.swift; sourceTree = "<group>"; };
145: 		2070 /* SpotlightManager.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SpotlightManager.swift; sourceTree = "<group>"; };
146: 		2101 /* BranchMenu.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = BranchMenu.swift; sourceTree = "<group>"; };
147: 		2102 /* CommandPalette.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = CommandPalette.swift; sourceTree = "<group>"; };
148: 		2103 /* DiffComponents.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = DiffComponents.swift; sourceTree = "<group>"; };
149: 		2104 /* FileIconView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = FileIconView.swift; sourceTree = "<group>"; };
150: 		2105 /* GoToSymbol.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = GoToSymbol.swift; sourceTree = "<group>"; };
151: 		2106 /* LaunchConfigView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = LaunchConfigView.swift; sourceTree = "<group>"; };
152: 		2107 /* QuickOpen.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = QuickOpen.swift; sourceTree = "<group>"; };
153: 		2108 /* SidebarView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SidebarView.swift; sourceTree = "<group>"; };
154: 		2109 /* SnippetPickerView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SnippetPickerView.swift; sourceTree = "<group>"; };
155: 		2110 /* StatusBarView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = StatusBarView.swift; sourceTree = "<group>"; };
156: 		2111 /* TabBarView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = TabBarView.swift; sourceTree = "<group>"; };
157: 		2112 /* TasksView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = TasksView.swift; sourceTree = "<group>"; };
158: 		2113 /* WorkspaceSettingsView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = WorkspaceSettingsView.swift; sourceTree = "<group>"; };
159: 		2114 /* WorkspaceTrustDialog.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = WorkspaceTrustDialog.swift; sourceTree = "<group>"; };
160: 		2115 /* OutputView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = OutputView.swift; sourceTree = "<group>"; };
161: 		2116 /* SearchView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SearchView.swift; sourceTree = "<group>"; };
162: 		2117 /* MarkdownPreviewView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = MarkdownPreviewView.swift; sourceTree = "<group>"; };
163: 		2118 /* AIAssistantView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = AIAssistantView.swift; sourceTree = "<group>"; };
164: 		2119 /* GitQuickActionsView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = GitQuickActionsView.swift; sourceTree = "<group>"; };
165: 		2120 /* MarkdownPreviewWrapper.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = MarkdownPreviewWrapper.swift; sourceTree = "<group>"; };
166: 		2121 /* TestView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = TestView.swift; sourceTree = "<group>"; };
167: 		2122 /* PanelView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PanelView.swift; sourceTree = "<group>"; };
168: 		2123 /* ProblemsView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ProblemsView.swift; sourceTree = "<group>"; };
169: 		2124 /* OutlineView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = OutlineView.swift; sourceTree = "<group>"; };
170: 		2125 /* TimelineView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = TimelineView.swift; sourceTree = "<group>"; };
171: 		2126 /* DebugConsoleView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = DebugConsoleView.swift; sourceTree = "<group>"; };
172: 		2127 /* SplitEditorView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SplitEditorView.swift; sourceTree = "<group>"; };
173: 		2128 /* StickyHeaderView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = StickyHeaderView.swift; sourceTree = "<group>"; };
174: 		2129 /* ColorPickerView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ColorPickerView.swift; sourceTree = "<group>"; };
175: 		2130 /* MultiCursorTextView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = MultiCursorTextView.swift; sourceTree = "<group>"; };
176: 		2131 /* JSONTreeView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = JSONTreeView.swift; sourceTree = "<group>"; };
177: 		2132 /* EditorSplitView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = EditorSplitView.swift; sourceTree = "<group>"; };
178: 		2133 /* InlayHintsOverlay.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = InlayHintsOverlay.swift; sourceTree = "<group>"; };
179: 
180: 		2135 /* HoverInfoView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = HoverInfoView.swift; sourceTree = "<group>"; };
181: 		2136 /* BreadcrumbsView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = BreadcrumbsView.swift; sourceTree = "<group>"; };
182: 
183: 		2138 /* PeekDefinitionView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PeekDefinitionView.swift; sourceTree = "<group>"; };
184: 		2139 /* InlayHintsManager.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = InlayHintsManager.swift; sourceTree = "<group>"; };
185: 		2140 /* FileHelpers.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = FileHelpers.swift; sourceTree = "<group>"; };
186: 		2141 /* Notification+Search.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = "Notification+Search.swift"; sourceTree = "<group>"; };
187: 		2142 /* SSHManager.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SSHManager.swift; sourceTree = "<group>"; };
188: 		2143 /* AppDelegate.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = AppDelegate.swift; sourceTree = "<group>"; };
189: 		2144 /* SceneDelegate.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SceneDelegate.swift; sourceTree = "<group>"; };
190: 		2099 /* Assets.xcassets */ = {isa = PBXFileReference; lastKnownFileType = folder.assetcatalog; path = Assets.xcassets; sourceTree = "<group>"; };
191: 		3000 /* VSCodeiPadOS.app */ = {isa = PBXFileReference; explicitFileType = wrapper.application; includeInIndex = 0; path = VSCodeiPadOS.app; sourceTree = BUILT_PRODUCTS_DIR; };
192: /* End PBXFileReference section */
193: 
194: /* Begin PBXGroup section */
195: 		4000 = {
196: 			isa = PBXGroup;
197: 			children = (
198: 				4001 /* VSCodeiPadOS */,
199: 				4099 /* Products */,
200: 			);
201: 			sourceTree = "<group>";
202: 		};
203: 		4001 /* VSCodeiPadOS */ = {
204: 			isa = PBXGroup;
205: 			children = (
206: 				2001 /* ContentView.swift */,
207: 				2099 /* Assets.xcassets */,
208: 				4002 /* App */,
209: 				4003 /* Commands */,
210: 				4004 /* Extensions */,
211: 				4005 /* Models */,
212: 				4006 /* Services */,
213: 				4007 /* Views */,
214: 			);
215: 			path = VSCodeiPadOS;
216: 			sourceTree = "<group>";
217: 		};
218: 		4002 /* App */ = {
219: 			isa = PBXGroup;
220: 			children = (

---

[read_file]
File: VSCodeiPadOS/VSCodeiPadOS.xcodeproj/project.pbxproj (lines 221-340 of 756)
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
221: 				2002 /* VSCodeiPadOSApp.swift */,
222: 				2143 /* AppDelegate.swift */,
223: 				2144 /* SceneDelegate.swift */,
224: 			);
225: 			path = App;
226: 			sourceTree = "<group>";
227: 		};
228: 		4003 /* Commands */ = {
229: 			isa = PBXGroup;
230: 			children = (
231: 				2003 /* AppCommands.swift */,
232: 			);
233: 			path = Commands;
234: 			sourceTree = "<group>";
235: 		};
236: 		4004 /* Extensions */ = {
237: 			isa = PBXGroup;
238: 			children = (
239: 				2004 /* Color+Hex.swift */,
240: 				2005 /* FileManager+Extension.swift */,
241: 				2006 /* FileManager+Extensions.swift */,
242: 				2007 /* NSAttributedStringSyntaxHighlighter.swift */,
243: 				2068 /* FileIcons.swift */,
244: 				2140 /* FileHelpers.swift */,
245: 				2141 /* Notification+Search.swift */,
246: 			);
247: 			path = Extensions;
248: 			sourceTree = "<group>";
249: 		};
250: 		4005 /* Models */ = {
251: 			isa = PBXGroup;
252: 			children = (
253: 				2009 /* EditorState.swift */,
254: 				2012 /* FileItem.swift */,
255: 				2013 /* FileItemUTType.swift */,
256: 				2015 /* FindViewModel.swift */,
257: 				2016 /* MultiCursor.swift */,
258: 				2017 /* Tab.swift */,
259: 				2018 /* Theme.swift */,
260: 				2020 /* ThemeManager.swift */,
261: 			);
262: 			path = Models;
263: 			sourceTree = "<group>";
264: 		};
265: 		4006 /* Services */ = {
266: 			isa = PBXGroup;
267: 			children = (
268: 				2019 /* AutocompleteManager.swift */,
269: 				2022 /* CodeFoldingManager.swift */,
270: 				2023 /* EditorCore.swift */,
271: 				2025 /* FileSystemNavigator.swift */,
272: 				2052 /* DebugManager.swift */,
273: 				2054 /* WorkspaceTrustManager.swift */,
274: 				2055 /* AIManager.swift */,
275: 				2056 /* ColorPickerManager.swift */,
276: 				2057 /* GitManager.swift */,
277: 				2058 /* GitService.swift */,
278: 				2059 /* HoverInfoManager.swift */,
279: 				2060 /* LaunchManager.swift */,
280: 				2061 /* NavigationManager.swift */,
281: 				2062 /* RecentFileManager.swift */,
282: 				2063 /* SearchManager.swift */,
283: 				2064 /* SettingsManager.swift */,
284: 				2065 /* SnippetsManager.swift */,
285: 				2066 /* TasksManager.swift */,
286: 				2067 /* WorkspaceManager.swift */,
287: 				2139 /* InlayHintsManager.swift */,
288: 				2070 /* SpotlightManager.swift */,
289: 				2142 /* SSHManager.swift */,
290: 			);
291: 			path = Services;
292: 			sourceTree = "<group>";
293: 		};
294: 		4007 /* Views */ = {
295: 			isa = PBXGroup;
296: 			children = (
297: 				2069 /* FileTreeView.swift */,
298: 				2104 /* FileIconView.swift */,
299: 				2109 /* SnippetPickerView.swift */,
300: 				2108 /* SidebarView.swift */,
301: 				2106 /* LaunchConfigView.swift */,
302: 				2111 /* TabBarView.swift */,
303: 				2103 /* DiffComponents.swift */,
304: 				2105 /* GoToSymbol.swift */,
305: 				2113 /* WorkspaceSettingsView.swift */,
306: 				2102 /* CommandPalette.swift */,
307: 				2110 /* StatusBarView.swift */,
308: 				2112 /* TasksView.swift */,
309: 				2107 /* QuickOpen.swift */,
310: 				2101 /* BranchMenu.swift */,
311: 				2114 /* WorkspaceTrustDialog.swift */,
312: 				4008 /* Editor */,
313: 				4009 /* Main */,
314: 				4010 /* Panels */,
315: 				4011 /* Sidebar */,
316: 				4012 /* StatusBar */,
317: 			);
318: 			path = Views;
319: 			sourceTree = "<group>";
320: 		};
321: 		4008 /* Editor */ = {
322: 			isa = PBXGroup;
323: 			children = (
324: 				2136 /* BreadcrumbsView.swift */,
325: 				2129 /* ColorPickerView.swift */,
326: 				2132 /* EditorSplitView.swift */,
327: 				2135 /* HoverInfoView.swift */,
328: 				2133 /* InlayHintsOverlay.swift */,
329: 				2131 /* JSONTreeView.swift */,
330: 				2130 /* MultiCursorTextView.swift */,
331: 				2138 /* PeekDefinitionView.swift */,
332: 				2127 /* SplitEditorView.swift */,
333: 
334: 				2128 /* StickyHeaderView.swift */,
335: 
336: 				2035 /* MinimapView.swift */,
337: 				2036 /* SyntaxHighlightingTextView.swift */,
338: 			);
339: 			path = Editor;
340: 			sourceTree = "<group>";

---

[FILE VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift]
Applied 1 patch(es)

---

[FILE VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift]
Applied 1 patch(es)

---

[FILE VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift]
Applied 1 patch(es)

---

[FILE VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift]
Applied 1 patch(es)

---

[FILE VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift]
Applied 1 patch(es)

---

[FILE VSCodeiPadOS/VSCodeiPadOS/ContentView.swift]
Applied 1 patch(es)

---

[FILE VSCodeiPadOS/VSCodeiPadOS/ContentView.swift]
Applied 1 patch(es)

---

[FILE VSCodeiPadOS/VSCodeiPadOS/ContentView.swift]
Applied 1 patch(es)

---

[FILE VSCodeiPadOS/VSCodeiPadOS/ContentView.swift]
Applied 1 patch(es)


>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift","start_line":70,"end_line":260}
>>>END
>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift","start_line":300,"end_line":420}
>>>END
>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift","start_line":640,"end_line":760}
>>>END
>>>END

---

## üîß TOOL RESULTS

[read_file]
File: VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift (lines 71-260 of 931)
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
71:     @Published var foldRegions: [FoldRegion] = []
72:     @Published var collapsedLines: Set<Int> = []
73:     
74:     // Dictionary to manage fold regions per file
75:     private var foldRegionsByFile: [String: [FoldRegion]] = [:]
76:     
77:     private var currentFilePath: String?
78:     private var currentFileId: String?
79:     
80:     // MARK: - Enhanced Fold Detection
81:     
82:     /// Detects all foldable regions in the given code
83:     func detectFoldableRegions(in code: String, filePath: String? = nil) {
84:         self.currentFilePath = filePath
85:         self.currentFileId = filePath
86:         
87:         let lines = code.components(separatedBy: .newlines)
88:         var regions: [FoldRegion] = []
89:         
90:         // Track different types of blocks
91:         var blockStack: [(type: FoldRegion.FoldType, startLine: Int, label: String?)] = []
92:         var commentStack: [(startLine: Int, isMultiline: Bool)] = []
93:         var regionStack: [(startLine: Int, label: String)] = []
94: 
95:         // If we detect a declaration/function/control-flow whose opening brace is on a later line,
96:         // we mark that brace line so it won't be treated as a standalone generic block.
97:         var braceLinesClaimed: Set<Int> = []
98: 
99:         // Used to prevent duplicate regions for grouped constructs (imports, // comments)
100:         var previousNonEmptyWasImport = false
101:         var previousNonEmptyWasSingleLineComment = false
102:         
103:         for (index, line) in lines.enumerated() {
104:             let trimmed = line.trimmingCharacters(in: .whitespaces)
105:             let leadingWhitespace = line.prefix { $0 == " " || $0 == "\t" }.count
106:             
107:             // Skip empty lines for most detections
108:             guard !trimmed.isEmpty else { continue }
109: 
110:             // MARK: - Close blocks BEFORE opening new ones (handles "} else {" correctly)
111:             if trimmed.hasPrefix("}") {
112:                 // Count consecutive leading '}' so we can pop multiple blocks for lines like "}}"
113:                 let closeCount = max(1, trimmed.prefix { $0 == "}" }.count)
114:                 for _ in 0..<closeCount {
115:                     if let lastBlock = blockStack.popLast() {
116:                         if index - lastBlock.startLine > 1 {
117:                             regions.append(FoldRegion(
118:                                 startLine: lastBlock.startLine,
119:                                 endLine: index,
120:                                 type: lastBlock.type,
121:                                 label: lastBlock.label
122:                             ))
123:                         }
124:                     }
125:                 }
126:             }
127:             
128:             // MARK: - Region Detection (#region, #pragma mark, MARK:)
129:             if let label = detectRegionStart(trimmed) {
130:                 regionStack.append((index, label))
131:             } else if detectRegionEnd(trimmed) {
132:                 if let region = regionStack.popLast() {
133:                     if index - region.startLine > 1 {
134:                         regions.append(FoldRegion(
135:                             startLine: region.startLine,
136:                             endLine: index,
137:                             type: .region,
138:                             label: region.label
139:                         ))
140:                     }
141:                 }
142:             }
143:             
144:             // MARK: - Import Statement Detection (group consecutive imports once)
145:             if trimmed.hasPrefix("import ") {
146:                 if !previousNonEmptyWasImport {
147:                     let importEnd = findConsecutiveImports(from: index, in: lines)
148:                     if importEnd > index {
149:                         regions.append(FoldRegion(
150:                             startLine: index,
151:                             endLine: importEnd,
152:                             type: .importStatement,
153:                             label: "Imports"
154:                         ))
155:                     }
156:                 }
157:                 previousNonEmptyWasImport = true
158:             } else {
159:                 previousNonEmptyWasImport = false
160:             }
161:             
162:             // MARK: - Comment Detection
163:             if detectCommentStart(trimmed) {
164:                 commentStack.append((index, true))
165:                 previousNonEmptyWasSingleLineComment = false
166:             } else if trimmed.starts(with: "//") {
167:                 // Only create a fold region at the start of a consecutive // block
168:                 if !previousNonEmptyWasSingleLineComment {
169:                     let commentEnd = findConsecutiveComments(from: index, in: lines)
170:                     if commentEnd > index {
171:                         regions.append(FoldRegion(
172:                             startLine: index,
173:                             endLine: commentEnd,
174:                             type: .comment,
175:                             label: "Comment"
176:                         ))
177:                     }
178:                 }
179:                 previousNonEmptyWasSingleLineComment = true
180:             } else if detectCommentEnd(trimmed) {
181:                 previousNonEmptyWasSingleLineComment = false
182:                 if let comment = commentStack.popLast() {
183:                     if index - comment.startLine > 1 {
184:                         regions.append(FoldRegion(
185:                             startLine: comment.startLine,
186:                             endLine: index,
187:                             type: .comment,
188:                             label: "Comment"
189:                         ))
190:                     }
191:                 }
192:             } else {
193:                 previousNonEmptyWasSingleLineComment = false
194:             }
195:             
196:             // MARK: - Class/Struct/Enum/Protocol/Extension Detection
197:             if let declaration = detectDeclaration(trimmed) {
198:                 if trimmed.contains("{") {
199:                     blockStack.append((declaration.type, index, declaration.label))
200:                 } else {
201:                     // Declaration without opening brace - look ahead for it
202:                     if let braceLine = findOpeningBrace(from: index + 1, in: lines) {
203:                         braceLinesClaimed.insert(braceLine)
204:                         blockStack.append((declaration.type, index, declaration.label))
205:                     }
206:                 }
207:             }
208:             
209:             // MARK: - Function/Method Detection
210:             if let functionInfo = detectFunction(trimmed) {
211:                 if trimmed.contains("{") {
212:                     blockStack.append((.function, index, functionInfo))
213:                 } else {
214:                     // Function without opening brace - look ahead
215:                     if let braceLine = findOpeningBrace(from: index + 1, in: lines) {
216:                         braceLinesClaimed.insert(braceLine)
217:                         blockStack.append((.function, index, functionInfo))
218:                     }
219:                 }
220:             }
221:             
222:             // MARK: - Control Flow Detection (if, guard, for, while, switch, etc.)
223:             if let controlFlowLabel = detectControlFlow(trimmed) {
224:                 if trimmed.contains("{") {
225:                     blockStack.append((.controlFlow, index, controlFlowLabel))
226:                 } else {
227:                     if let braceLine = findOpeningBrace(from: index + 1, in: lines) {
228:                         braceLinesClaimed.insert(braceLine)
229:                         blockStack.append((.controlFlow, index, controlFlowLabel))
230:                     }
231:                 }
232:             }
233:             
234:             // MARK: - Generic Block Detection
235:             // Avoid adding a generic block for a standalone "{" that belongs to a previously detected declaration.
236:             if trimmed.hasSuffix("{"),
237:                trimmed != "{",
238:                !braceLinesClaimed.contains(index),
239:                !isDeclarationLine(trimmed),
240:                !isFunctionLine(trimmed) {
241:                 blockStack.append((.genericBlock, index, nil))
242:             }
243: 
244:             _ = leadingWhitespace // keep param for potential future heuristics
245:         }
246:         
247:         // Handle any remaining unclosed blocks
248:         while let lastBlock = blockStack.popLast() {
249:             if lines.count - 1 - lastBlock.startLine > 1 {
250:                 regions.append(FoldRegion(
251:                     startLine: lastBlock.startLine,
252:                     endLine: lines.count - 1,
253:                     type: lastBlock.type,
254:                     label: lastBlock.label
255:                 ))
256:             }
257:         }
258:         
259:         // Sort regions by start line
260:         regions.sort { $0.startLine < $1.startLine }

---

[read_file]
File: VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift (lines 301-420 of 931)
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
301:             let components = line.components(separatedBy: "FIXME:")
302:             return "FIXME: " + (components.count > 1 ? components[1].trimmingCharacters(in: .whitespaces) : "")
303:         }
304:         return nil
305:     }
306:     
307:     private func detectRegionEnd(_ line: String) -> Bool {
308:         return line.hasPrefix("#endregion") || 
309:                line == "// MARK: -" ||
310:                line.hasPrefix("#pragma mark -")
311:     }
312:     
313:     private func detectCommentStart(_ line: String) -> Bool {
314:         return line.hasPrefix("/*") && !line.contains("*/")
315:     }
316:     
317:     private func detectCommentEnd(_ line: String) -> Bool {
318:         return line.contains("*/") && !line.hasPrefix("/*")
319:     }
320:     
321:     private func findConsecutiveImports(from startIndex: Int, in lines: [String]) -> Int {
322:         var endIndex = startIndex
323:         for i in startIndex..<lines.count {
324:             let trimmed = lines[i].trimmingCharacters(in: .whitespaces)
325:             if trimmed.hasPrefix("import ") {
326:                 endIndex = i
327:             } else if !trimmed.isEmpty {
328:                 break
329:             }
330:         }
331:         return endIndex
332:     }
333:     
334:     private func findConsecutiveComments(from startIndex: Int, in lines: [String]) -> Int {
335:         var endIndex = startIndex
336:         for i in startIndex..<lines.count {
337:             let trimmed = lines[i].trimmingCharacters(in: .whitespaces)
338:             if trimmed.starts(with: "//") {
339:                 endIndex = i
340:             } else if !trimmed.isEmpty {
341:                 break
342:             }
343:         }
344:         return endIndex
345:     }
346:     
347:     private func detectDeclaration(_ line: String) -> (type: FoldRegion.FoldType, label: String)? {
348:         func matchName(pattern: String) -> String? {
349:             guard let regex = try? NSRegularExpression(pattern: pattern, options: []) else { return nil }
350:             guard let match = regex.firstMatch(in: line, range: NSRange(line.startIndex..., in: line)),
351:                   match.numberOfRanges >= 2,
352:                   let r = Range(match.range(at: 1), in: line)
353:             else { return nil }
354:             return String(line[r])
355:         }
356: 
357:         // Allow leading attributes like "@MainActor", "@available(...)"
358:         // Allow common modifiers in any order (best-effort).
359:         let prefix = #"^(?:\s*@\w+(?:\([^\)]*\))?\s+)*(?:\s*(?:public|private|internal|fileprivate|open|final|indirect|lazy|static|override|mutating|nonmutating)\s+)*"#
360: 
361:         // IMPORTANT: avoid treating "class func"/"class var" as a type declaration.
362:         if let name = matchName(pattern: prefix + #"class\s+(?!func\b|var\b|let\b)([A-Za-z_]\w*)"#) {
363:             return (.classOrStruct, name)
364:         }
365: 
366:         // Actor (Swift concurrency) ‚Äì fold like a class/struct
367:         if let name = matchName(pattern: prefix + #"actor\s+([A-Za-z_]\w*)"#) {
368:             return (.classOrStruct, name)
369:         }
370: 
371:         if let name = matchName(pattern: prefix + #"struct\s+([A-Za-z_]\w*)"#) {
372:             return (.classOrStruct, name)
373:         }
374: 
375:         if let name = matchName(pattern: prefix + #"enum\s+([A-Za-z_]\w*)"#) {
376:             return (.enumDeclaration, name)
377:         }
378: 
379:         if let name = matchName(pattern: prefix + #"protocol\s+([A-Za-z_]\w*)"#) {
380:             return (.protocolDeclaration, name)
381:         }
382: 
383:         // Extensions can include dotted names (Foo.Bar)
384:         if let name = matchName(pattern: prefix + #"extension\s+([A-Za-z_][A-Za-z0-9_\.]*)"#) {
385:             return (.extension, name)
386:         }
387: 
388:         return nil
389:     }
390:     
391:     private func detectFunction(_ line: String) -> String? {
392:         // Function detection with visibility modifiers
393:         let visibilityKeywords = ["public", "private", "internal", "fileprivate", "static", "class", "override", "final", "mutating", "convenience"]
394:         
395:         // Check for 'func' keyword
396:         if line.contains("func ") {
397:             // Extract function name
398:             let funcPattern = "func\\s+(\\w+)"
399:             if let regex = try? NSRegularExpression(pattern: funcPattern),
400:                let match = regex.firstMatch(in: line, range: NSRange(line.startIndex..., in: line)),
401:                let nameRange = Range(match.range(at: 1), in: line) {
402:                 let functionName = String(line[nameRange])
403:                 // Check for parameters to create label
404:                 if let parenStart = line.firstIndex(of: "("), let parenEnd = line.firstIndex(of: ")") {
405:                     let params = String(line[parenStart...parenEnd])
406:                     return "\(functionName)\(params)"
407:                 }
408:                 return functionName
409:             }
410:         }
411:         
412:         // Init detection
413:         if let initName = extractName(from: line, prefix: "init", visibility: visibilityKeywords) {
414:             return "\(initName)"
415:         }
416:         
417:         // Deinit detection
418:         if line.contains("deinit") {
419:             return "deinit"
420:         }

---

[read_file]
File: VSCodeiPadOS/VSCodeiPadOS/Services/CodeFoldingManager.swift (lines 641-760 of 931)
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
641:     /// Toggle fold at cursor line - convenience method
642:     func toggleFoldAtLine(_ cursorLine: Int) {
643:         // First check if we're on a fold start line
644:         if let region = foldRegions.first(where: { $0.startLine == cursorLine }) {
645:             toggleFold(at: region.startLine)
646:             return
647:         }
648:         
649:         // Otherwise find the innermost region containing this line
650:         if let region = foldRegions.filter({ 
651:             cursorLine >= $0.startLine && cursorLine <= $0.endLine
652:         }).min(by: { ($0.endLine - $0.startLine) < ($1.endLine - $1.startLine) }) {
653:             toggleFold(at: region.startLine)
654:         }
655:     }
656:     
657:     // MARK: - Legacy/Convenience Methods (for keyboard shortcuts)
658:     
659:     /// Folds at the current line (uses line 0 as fallback - caller should use foldAtLine(_:) with actual cursor)
660:     func foldCurrentLine() {
661:         // This is called from keyboard shortcuts - fold at line 0 or first available region
662:         if let firstUnfolded = foldRegions.first(where: { !$0.isFolded }) {
663:             collapseRegion(at: firstUnfolded.startLine)
664:         }
665:     }
666:     
667:     /// Unfolds at the current line (uses line 0 as fallback - caller should use unfoldAtLine(_:) with actual cursor)
668:     func unfoldCurrentLine() {
669:         // This is called from keyboard shortcuts - unfold first folded region
670:         if let firstFolded = foldRegions.first(where: { $0.isFolded }) {
671:             expandRegion(at: firstFolded.startLine)
672:         }
673:     }
674:     
675:     /// Collapses all foldable regions
676:     func collapseAll() {
677:         for index in foldRegions.indices {
678:             foldRegions[index].isFolded = true
679:         }
680:         updateCollapsedLines()
681:         
682:         if let filePath = currentFilePath {
683:             saveFoldState(for: filePath)
684:         }
685:     }
686:     
687:     /// Collapses all regions of a specific type
688:     func collapseAll(ofType type: FoldRegion.FoldType) {
689:         for index in foldRegions.indices {
690:             if foldRegions[index].type == type {
691:                 foldRegions[index].isFolded = true
692:             }
693:         }
694:         updateCollapsedLines()
695:         
696:         if let filePath = currentFilePath {
697:             saveFoldState(for: filePath)
698:         }
699:     }
700:     
701:     /// Expands all regions of a specific type
702:     func expandAll(ofType type: FoldRegion.FoldType) {
703:         for index in foldRegions.indices {
704:             if foldRegions[index].type == type {
705:                 foldRegions[index].isFolded = false
706:             }
707:         }
708:         updateCollapsedLines()
709:         
710:         if let filePath = currentFilePath {
711:             saveFoldState(for: filePath)
712:         }
713:     }
714:     
715:     // MARK: - Query Methods
716:     
717:     /// Checks if a line is foldable
718:     func isFoldable(line: Int) -> Bool {
719:         return foldRegions.contains { $0.startLine == line }
720:     }
721:     
722:     /// Checks if a line is currently folded (for the currently active file in `foldRegions`)
723:     func isLineFolded(line: Int) -> Bool {
724:         return collapsedLines.contains(line)
725:     }
726: 
727:     /// Checks if a line should be hidden for a specific file (does not rely on `collapsedLines`)
728:     func isLineFolded(fileId: String, line: Int) -> Bool {
729:         guard let regions = foldRegionsByFile[fileId] else { return false }
730:         for region in regions where region.isFolded {
731:             if line > region.startLine && line <= region.endLine {
732:                 return true
733:             }
734:         }
735:         return false
736:     }
737:     
738:     /// Checks if a region at a given line is folded
739:     func isRegionFolded(at line: Int) -> Bool {
740:         return foldRegions.first { $0.startLine == line }?.isFolded ?? false
741:     }
742:     
743:     /// Gets the fold region at a specific line
744:     func getRegion(at line: Int) -> FoldRegion? {
745:         return foldRegions.first { $0.startLine == line }
746:     }
747:     
748:     /// Gets all fold regions of a specific type
749:     func getRegions(ofType type: FoldRegion.FoldType) -> [FoldRegion] {
750:         return foldRegions.filter { $0.type == type }
751:     }
752:     
753:     // MARK: - File-Aware Methods
754:     
755:     /// Checks if a line is foldable for a specific file
756:     func isFoldable(fileId: String, line: Int) -> Bool {
757:         guard let regions = foldRegionsByFile[fileId] else { return false }
758:         return regions.contains { $0.startLine == line }
759:     }
760:     




>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/ContentView.swift","start_line":404,"end_line":520}
>>>END
>>>END

---

## üîß TOOL RESULTS

[read_file]
File: VSCodeiPadOS/VSCodeiPadOS/ContentView.swift (lines 405-520 of 1064)
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
405:     @State private var visibleLines: Int = 20
406:     @State private var currentLineNumber: Int = 1
407:     @State private var currentColumn: Int = 1
408:     @State private var cursorIndex: Int = 0
409:     @State private var lineHeight: CGFloat = 17
410:     @State private var requestedCursorIndex: Int? = nil
411:     @State private var requestedLineSelection: Int? = nil
412: 
413:     @StateObject private var autocomplete = AutocompleteManager()
414:     @State private var showAutocomplete = false
415:     @ObservedObject private var foldingManager = CodeFoldingManager.shared
416:     @StateObject private var findViewModel = FindViewModel()
417:     
418:     var body: some View {
419:         VStack(spacing: 0) {
420:             // Find/Replace bar
421:             if editorCore.showSearch {
422:                 FindReplaceView(viewModel: findViewModel)
423:                     .background(theme.tabBarBackground)
424:             }
425:             
426:             BreadcrumbsView(editorCore: editorCore, tab: tab)
427:             
428:             GeometryReader { geometry in
429:                 ZStack(alignment: .topLeading) {
430:                 HStack(spacing: 0) {
431:                     if lineNumbersStyle != "off" {
432:                         LineNumbersWithFolding(
433:                             fileId: tab.url?.path ?? tab.fileName,
434:                             totalLines: totalLines,
435:                             currentLine: currentLineNumber,
436:                             scrollOffset: CGFloat(scrollPosition) * lineHeight,
437:                             lineHeight: lineHeight,
438:                             requestedLineSelection: $requestedLineSelection,
439:                             foldingManager: foldingManager,
440:                             theme: theme
441:                         )
442:                         .frame(width: 60)
443:                         .background(theme.sidebarBackground.opacity(0.5))
444:                     }
445:                     
446:                     if tab.fileName.hasSuffix(".json") {
447:                         // JSON Tree View for .json files
448:                         JSONTreeView(data: text.data(using: .utf8) ?? Data())
449:                             .frame(maxWidth: .infinity, maxHeight: .infinity)
450:                             .background(theme.editorBackground)
451:                     } else {
452:                         SyntaxHighlightingTextView(
453:                             text: $text,
454:                             filename: tab.fileName,
455:                             scrollPosition: $scrollPosition,
456:                             totalLines: $totalLines,
457:                             visibleLines: $visibleLines,
458:                             currentLineNumber: $currentLineNumber,
459:                             currentColumn: $currentColumn,
460:                             cursorIndex: $cursorIndex,
461:                             lineHeight: $lineHeight,
462:                             isActive: true,
463:                             fontSize: editorCore.editorFontSize,
464:                             requestedLineSelection: $requestedLineSelection,
465:                             requestedCursorIndex: $requestedCursorIndex,
466:                             onAcceptAutocomplete: {
467:                                 guard showAutocomplete else { return false }
468:                                 var tempText = text
469:                                 var tempCursor = cursorIndex
470:                                 autocomplete.commitCurrentSuggestion(into: &tempText, cursorPosition: &tempCursor)
471:                                 if tempText != text {
472:                                     text = tempText
473:                                     cursorIndex = tempCursor
474:                                     requestedCursorIndex = tempCursor
475:                                     showAutocomplete = false
476:                                     return true
477:                                 }
478:                                 return false
479:                             },
480:                             onDismissAutocomplete: {
481:                                 guard showAutocomplete else { return false }
482:                                 autocomplete.hideSuggestions()
483:                                 showAutocomplete = false
484:                                 return true
485:                             }
486:                         )
487:                         .onChange(of: text) { newValue in
488:                             editorCore.updateActiveTabContent(newValue)
489:                             editorCore.cursorPosition = CursorPosition(line: currentLineNumber, column: currentColumn)
490:                             autocomplete.updateSuggestions(for: newValue, cursorPosition: cursorIndex)
491:                             showAutocomplete = autocomplete.showSuggestions
492:                             foldingManager.detectFoldableRegions(in: newValue, filePath: tab.url?.path ?? tab.fileName)
493:                         }
494:                         .onChange(of: cursorIndex) { newCursor in
495:                             autocomplete.updateSuggestions(for: text, cursorPosition: newCursor)
496:                             showAutocomplete = autocomplete.showSuggestions
497:                         }
498:                     }
499:                     
500:                     if !tab.fileName.hasSuffix(".json") {
501:                         MinimapView(
502:                             content: text,
503:                             scrollOffset: CGFloat(scrollPosition) * lineHeight,
504:                             scrollViewHeight: geometry.size.height,
505:                             totalContentHeight: CGFloat(totalLines) * lineHeight,
506:                             onScrollRequested: { newOffset in
507:                                 // Minimap requested scroll - update editor position
508:                                 // Convert back from pixels to line number
509:                                 let newLine = Int(newOffset / lineHeight)
510:                                 scrollPosition = max(0, min(newLine, totalLines - 1))
511:                             }
512:                         )
513:                         .frame(width: 80)
514:                     }
515:                 }
516:                 .background(theme.editorBackground)
517: 
518:                 // Sticky Header Overlay (FEAT-040)
519:                 StickyHeaderView(
520:                     text: text,


>>>TOOL search
{"query":"SyntaxHighlightingTextView_Update.swift", "glob":"VSCodeiPadOS/VSCodeiPadOS.xcodeproj/project.pbxproj"}
>>>END
>>>TOOL search
{"query":"FoldingLayoutManager.swift", "glob":"VSCodeiPadOS/VSCodeiPadOS.xcodeproj/project.pbxproj"}
>>>END
>>>END

---

## üîß TOOL RESULTS

[search]
No matches found for "SyntaxHighlightingTextView_Update.swift"

---

[search]
No matches found for "FoldingLayoutManager.swift"


>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/ContentView.swift","start_line":400,"end_line":520}
>>>END
>>>END

---

## üîß TOOL RESULTS

[read_file]
File: VSCodeiPadOS/VSCodeiPadOS/ContentView.swift (lines 401-520 of 1064)
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
401:     @AppStorage("lineNumbersStyle") private var lineNumbersStyle: String = "on"
402:     @State private var text: String = ""
403:     @State private var scrollPosition: Int = 0
404:     @State private var totalLines: Int = 1
405:     @State private var visibleLines: Int = 20
406:     @State private var currentLineNumber: Int = 1
407:     @State private var currentColumn: Int = 1
408:     @State private var cursorIndex: Int = 0
409:     @State private var lineHeight: CGFloat = 17
410:     @State private var requestedCursorIndex: Int? = nil
411:     @State private var requestedLineSelection: Int? = nil
412: 
413:     @StateObject private var autocomplete = AutocompleteManager()
414:     @State private var showAutocomplete = false
415:     @ObservedObject private var foldingManager = CodeFoldingManager.shared
416:     @StateObject private var findViewModel = FindViewModel()
417:     
418:     var body: some View {
419:         VStack(spacing: 0) {
420:             // Find/Replace bar
421:             if editorCore.showSearch {
422:                 FindReplaceView(viewModel: findViewModel)
423:                     .background(theme.tabBarBackground)
424:             }
425:             
426:             BreadcrumbsView(editorCore: editorCore, tab: tab)
427:             
428:             GeometryReader { geometry in
429:                 ZStack(alignment: .topLeading) {
430:                 HStack(spacing: 0) {
431:                     if lineNumbersStyle != "off" {
432:                         LineNumbersWithFolding(
433:                             fileId: tab.url?.path ?? tab.fileName,
434:                             totalLines: totalLines,
435:                             currentLine: currentLineNumber,
436:                             scrollOffset: CGFloat(scrollPosition) * lineHeight,
437:                             lineHeight: lineHeight,
438:                             requestedLineSelection: $requestedLineSelection,
439:                             foldingManager: foldingManager,
440:                             theme: theme
441:                         )
442:                         .frame(width: 60)
443:                         .background(theme.sidebarBackground.opacity(0.5))
444:                     }
445:                     
446:                     if tab.fileName.hasSuffix(".json") {
447:                         // JSON Tree View for .json files
448:                         JSONTreeView(data: text.data(using: .utf8) ?? Data())
449:                             .frame(maxWidth: .infinity, maxHeight: .infinity)
450:                             .background(theme.editorBackground)
451:                     } else {
452:                         SyntaxHighlightingTextView(
453:                             text: $text,
454:                             filename: tab.fileName,
455:                             scrollPosition: $scrollPosition,
456:                             totalLines: $totalLines,
457:                             visibleLines: $visibleLines,
458:                             currentLineNumber: $currentLineNumber,
459:                             currentColumn: $currentColumn,
460:                             cursorIndex: $cursorIndex,
461:                             lineHeight: $lineHeight,
462:                             isActive: true,
463:                             fontSize: editorCore.editorFontSize,
464:                             requestedLineSelection: $requestedLineSelection,
465:                             requestedCursorIndex: $requestedCursorIndex,
466:                             onAcceptAutocomplete: {
467:                                 guard showAutocomplete else { return false }
468:                                 var tempText = text
469:                                 var tempCursor = cursorIndex
470:                                 autocomplete.commitCurrentSuggestion(into: &tempText, cursorPosition: &tempCursor)
471:                                 if tempText != text {
472:                                     text = tempText
473:                                     cursorIndex = tempCursor
474:                                     requestedCursorIndex = tempCursor
475:                                     showAutocomplete = false
476:                                     return true
477:                                 }
478:                                 return false
479:                             },
480:                             onDismissAutocomplete: {
481:                                 guard showAutocomplete else { return false }
482:                                 autocomplete.hideSuggestions()
483:                                 showAutocomplete = false
484:                                 return true
485:                             }
486:                         )
487:                         .onChange(of: text) { newValue in
488:                             editorCore.updateActiveTabContent(newValue)
489:                             editorCore.cursorPosition = CursorPosition(line: currentLineNumber, column: currentColumn)
490:                             autocomplete.updateSuggestions(for: newValue, cursorPosition: cursorIndex)
491:                             showAutocomplete = autocomplete.showSuggestions
492:                             foldingManager.detectFoldableRegions(in: newValue, filePath: tab.url?.path ?? tab.fileName)
493:                         }
494:                         .onChange(of: cursorIndex) { newCursor in
495:                             autocomplete.updateSuggestions(for: text, cursorPosition: newCursor)
496:                             showAutocomplete = autocomplete.showSuggestions
497:                         }
498:                     }
499:                     
500:                     if !tab.fileName.hasSuffix(".json") {
501:                         MinimapView(
502:                             content: text,
503:                             scrollOffset: CGFloat(scrollPosition) * lineHeight,
504:                             scrollViewHeight: geometry.size.height,
505:                             totalContentHeight: CGFloat(totalLines) * lineHeight,
506:                             onScrollRequested: { newOffset in
507:                                 // Minimap requested scroll - update editor position
508:                                 // Convert back from pixels to line number
509:                                 let newLine = Int(newOffset / lineHeight)
510:                                 scrollPosition = max(0, min(newLine, totalLines - 1))
511:                             }
512:                         )
513:                         .frame(width: 80)
514:                     }
515:                 }
516:                 .background(theme.editorBackground)
517: 
518:                 // Sticky Header Overlay (FEAT-040)
519:                 StickyHeaderView(
520:                     text: text,


>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift","start_line":100,"end_line":210}
>>>END
>>>END

---

## üîß TOOL RESULTS

[read_file]
File: VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift (lines 101-210 of 2050)
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
101:         )
102:     }
103: 
104:     func makeCoordinator() -> Coordinator {
105:         Coordinator(self)
106:     }
107:     
108:     func makeUIView(context: Context) -> UITextView {
109:         let textView = EditorTextView()
110:         textView.delegate = context.coordinator
111:         textView.editorCore = editorCore
112: 
113:         // Autocomplete hooks
114:         textView.onAcceptAutocomplete = onAcceptAutocomplete
115:         textView.onDismissAutocomplete = onDismissAutocomplete
116: 
117:         textView.onPeekDefinition = {
118:             context.coordinator.handlePeekDefinition(in: textView)
119:         }
120: 
121:         textView.onEscape = {
122:             context.coordinator.handleEscape()
123:         }
124: 
125:         textView.onGoToLine = {
126:             self.editorCore.showGoToLine = true
127:         }
128:         
129:         // Wire up custom context menu actions
130:         textView.onGoToDefinition = {
131:             context.coordinator.handleGoToDefinition(in: textView)
132:         }
133:         
134:         textView.onFindReferences = {
135:             context.coordinator.handleFindReferences(in: textView)
136:         }
137:         
138:         textView.onFormatDocument = {
139:             context.coordinator.handleFormatDocument(in: textView)
140:         }
141:         
142:         textView.onToggleComment = {
143:             context.coordinator.handleToggleComment(in: textView)
144:         }
145:         
146:         textView.onFold = {
147:             context.coordinator.handleFold(in: textView)
148:         }
149:         
150:         textView.onUnfold = {
151:             context.coordinator.handleUnfold(in: textView)
152:         }
153:         
154:         // Add pinch gesture for zoom (with delegate to allow simultaneous text selection)
155:         let pinchGesture = UIPinchGestureRecognizer(target: context.coordinator, action: #selector(Coordinator.handlePinch(_:)))
156:         pinchGesture.delegate = context.coordinator
157:         textView.addGestureRecognizer(pinchGesture)
158:         context.coordinator.pinchGesture = pinchGesture
159:         
160:         // Configure text view
161:         textView.isEditable = true
162:         textView.isSelectable = true
163:         textView.autocapitalizationType = .none
164:         textView.autocorrectionType = .no
165:         textView.smartDashesType = .no
166:         textView.smartQuotesType = .no
167:         textView.smartInsertDeleteType = .no
168:         textView.spellCheckingType = .no
169:         
170:         // Set font and appearance (use editorCore.editorFontSize)
171:         textView.font = UIFont.monospacedSystemFont(ofSize: editorCore.editorFontSize, weight: .regular)
172:         textView.textColor = UIColor(ThemeManager.shared.currentTheme.editorForeground)
173:         textView.backgroundColor = UIColor(ThemeManager.shared.currentTheme.editorBackground)
174:         textView.tintColor = UIColor(ThemeManager.shared.currentTheme.cursor)
175:         textView.keyboardType = .default
176:         textView.textContainerInset = UIEdgeInsets(top: 8, left: 8, bottom: 8, right: 8)
177:         
178:         // Enable line wrapping
179:         textView.textContainer.lineBreakMode = .byCharWrapping
180:         textView.textContainer.widthTracksTextView = true
181:         
182:         // Calculate line height
183:         if let font = textView.font {
184:             DispatchQueue.main.async {
185:                 self.lineHeight = font.lineHeight
186:             }
187:         }
188:         
189:         // Set initial text with syntax highlighting
190:         textView.text = text
191:         context.coordinator.applySyntaxHighlighting(to: textView)
192:         context.coordinator.updateLineCount(textView)
193:         
194:         return textView
195:     }
196:     
197:     func updateUIView(_ textView: UITextView, context: Context) {
198:         // CRITICAL: Update coordinator's parent reference to current struct
199:         // SwiftUI creates new struct instances on each update, so this keeps
200:         // coordinator in sync with current bindings and properties
201:         context.coordinator.parent = self
202:         
203:         // CRITICAL FIX: Apply initial highlighting FIRST on the very first updateUIView call
204:         // This fixes the bug where syntax highlighting only appears after typing.
205:         // makeUIView applies it, but the view may not be fully in hierarchy yet,
206:         // causing the attributed text to be lost. This ensures it's applied reliably.
207:         if !context.coordinator.hasAppliedInitialHighlighting && !textView.text.isEmpty {
208:             context.coordinator.applySyntaxHighlighting(to: textView)
209:             context.coordinator.hasAppliedInitialHighlighting = true
210:         }


>>>TOOL search
{"query":"var editorCore", "glob":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift"}
>>>END
>>>TOOL search
{"query":"class EditorTextView", "glob":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift"}
>>>END
>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift","start_line":720,"end_line":820}
>>>END
>>>END

---

## üîß TOOL RESULTS

[search]
Found 1 matches:
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:31: @EnvironmentObject var editorCore: EditorCore

---

[search]
Found 1 matches:
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:788: class EditorTextView: MultiCursorTextView {

---

[read_file]
File: VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift (lines 721-820 of 2050)
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
721: 
722:             guard let idx = bracketIndex else { return }
723: 
724:             // Define bracket pairs
725:             let openToClose: [unichar: unichar] = [123: 125, 40: 41, 91: 93] // { -> }, ( -> ), [ -> ]
726:             let closeToOpen: [unichar: unichar] = [125: 123, 41: 40, 93: 91] // } -> {, ) -> (, ] -> [
727: 
728:             let theme = ThemeManager.shared.currentTheme
729:             let bg = UIColor(theme.selection).withAlphaComponent(theme.isDark ? 0.35 : 0.22)
730: 
731:             var matchIndex: Int?
732: 
733:             if let close = openToClose[bracketChar] {
734:                 // Opening bracket: scan forward
735:                 var depth = 0
736:                 var i = idx + 1
737:                 while i < length {
738:                     let c = nsText.character(at: i)
739:                     if c == bracketChar {
740:                         depth += 1
741:                     } else if c == close {
742:                         if depth == 0 {
743:                             matchIndex = i
744:                             break
745:                         } else {
746:                             depth -= 1
747:                         }
748:                     }
749:                     i += 1
750:                 }
751:             } else if let open = closeToOpen[bracketChar] {
752:                 // Closing bracket: scan backward
753:                 var depth = 0
754:                 var i = idx - 1
755:                 while i >= 0 {
756:                     let c = nsText.character(at: i)
757:                     if c == bracketChar {
758:                         depth += 1
759:                     } else if c == open {
760:                         if depth == 0 {
761:                             matchIndex = i
762:                             break
763:                         } else {
764:                             depth -= 1
765:                         }
766:                     }
767:                     i -= 1
768:                 }
769:             }
770: 
771:             guard let match = matchIndex else { return }
772: 
773:             let r1 = NSRange(location: idx, length: 1)
774:             let r2 = NSRange(location: match, length: 1)
775: 
776:             textView.textStorage.addAttribute(.backgroundColor, value: bg, range: r1)
777:             textView.textStorage.addAttribute(.backgroundColor, value: bg, range: r2)
778: 
779:             textView.textStorage.addAttribute(.underlineStyle, value: NSUnderlineStyle.single.rawValue, range: r1)
780:             textView.textStorage.addAttribute(.underlineStyle, value: NSUnderlineStyle.single.rawValue, range: r2)
781: 
782:             bracketHighlightRanges = [r1, r2]
783:         }
784:     }
785: }
786: 
787: // Custom text view to handle key commands, indent guides, and line highlighting
788: class EditorTextView: MultiCursorTextView {
789:     var onPeekDefinition: (() -> Void)?
790:     var onEscape: (() -> Void)?
791:     var onGoToLine: (() -> Void)?
792:     
793:     // Custom action closures for context menu
794:     var onGoToDefinition: (() -> Void)?
795:     var onFindReferences: (() -> Void)?
796:     var onFormatDocument: (() -> Void)?
797:     var onToggleComment: (() -> Void)?
798:     var onFold: (() -> Void)?
799:     var onUnfold: (() -> Void)?
800: 
801:     // Autocomplete key handling hooks are inherited from MultiCursorTextView
802:     
803:     // FEAT-039 & FEAT-043
804:     private var indentGuideColor: UIColor = .separator
805:     private var activeIndentGuideColor: UIColor = .label
806:     private var currentLineHighlightColor: UIColor = .clear
807:     
808:     override init(frame: CGRect, textContainer: NSTextContainer?) {
809:         super.init(frame: frame, textContainer: textContainer)
810:         setup()
811:     }
812:     
813:     required init?(coder: NSCoder) {
814:         super.init(coder: coder)
815:         setup()
816:     }
817:     
818:     private func setup() {
819:         // Ensure we redraw when bounds/selection change
820:         contentMode = .redraw


>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/ContentView.swift","start_line":410,"end_line":575}
>>>END
>>>TOOL search
{"query":"detectFoldableRegions(in:", "glob":"VSCodeiPadOS/VSCodeiPadOS/ContentView.swift"}
>>>END
>>>END

---

## üîß TOOL RESULTS

[read_file]
File: VSCodeiPadOS/VSCodeiPadOS/ContentView.swift (lines 411-575 of 1064)
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
411:     @State private var requestedLineSelection: Int? = nil
412: 
413:     @StateObject private var autocomplete = AutocompleteManager()
414:     @State private var showAutocomplete = false
415:     @ObservedObject private var foldingManager = CodeFoldingManager.shared
416:     @StateObject private var findViewModel = FindViewModel()
417:     
418:     var body: some View {
419:         VStack(spacing: 0) {
420:             // Find/Replace bar
421:             if editorCore.showSearch {
422:                 FindReplaceView(viewModel: findViewModel)
423:                     .background(theme.tabBarBackground)
424:             }
425:             
426:             BreadcrumbsView(editorCore: editorCore, tab: tab)
427:             
428:             GeometryReader { geometry in
429:                 ZStack(alignment: .topLeading) {
430:                 HStack(spacing: 0) {
431:                     if lineNumbersStyle != "off" {
432:                         LineNumbersWithFolding(
433:                             fileId: tab.url?.path ?? tab.fileName,
434:                             totalLines: totalLines,
435:                             currentLine: currentLineNumber,
436:                             scrollOffset: CGFloat(scrollPosition) * lineHeight,
437:                             lineHeight: lineHeight,
438:                             requestedLineSelection: $requestedLineSelection,
439:                             foldingManager: foldingManager,
440:                             theme: theme
441:                         )
442:                         .frame(width: 60)
443:                         .background(theme.sidebarBackground.opacity(0.5))
444:                     }
445:                     
446:                     if tab.fileName.hasSuffix(".json") {
447:                         // JSON Tree View for .json files
448:                         JSONTreeView(data: text.data(using: .utf8) ?? Data())
449:                             .frame(maxWidth: .infinity, maxHeight: .infinity)
450:                             .background(theme.editorBackground)
451:                     } else {
452:                         SyntaxHighlightingTextView(
453:                             text: $text,
454:                             filename: tab.fileName,
455:                             scrollPosition: $scrollPosition,
456:                             totalLines: $totalLines,
457:                             visibleLines: $visibleLines,
458:                             currentLineNumber: $currentLineNumber,
459:                             currentColumn: $currentColumn,
460:                             cursorIndex: $cursorIndex,
461:                             lineHeight: $lineHeight,
462:                             isActive: true,
463:                             fontSize: editorCore.editorFontSize,
464:                             requestedLineSelection: $requestedLineSelection,
465:                             requestedCursorIndex: $requestedCursorIndex,
466:                             onAcceptAutocomplete: {
467:                                 guard showAutocomplete else { return false }
468:                                 var tempText = text
469:                                 var tempCursor = cursorIndex
470:                                 autocomplete.commitCurrentSuggestion(into: &tempText, cursorPosition: &tempCursor)
471:                                 if tempText != text {
472:                                     text = tempText
473:                                     cursorIndex = tempCursor
474:                                     requestedCursorIndex = tempCursor
475:                                     showAutocomplete = false
476:                                     return true
477:                                 }
478:                                 return false
479:                             },
480:                             onDismissAutocomplete: {
481:                                 guard showAutocomplete else { return false }
482:                                 autocomplete.hideSuggestions()
483:                                 showAutocomplete = false
484:                                 return true
485:                             }
486:                         )
487:                         .onChange(of: text) { newValue in
488:                             editorCore.updateActiveTabContent(newValue)
489:                             editorCore.cursorPosition = CursorPosition(line: currentLineNumber, column: currentColumn)
490:                             autocomplete.updateSuggestions(for: newValue, cursorPosition: cursorIndex)
491:                             showAutocomplete = autocomplete.showSuggestions
492:                             foldingManager.detectFoldableRegions(in: newValue, filePath: tab.url?.path ?? tab.fileName)
493:                         }
494:                         .onChange(of: cursorIndex) { newCursor in
495:                             autocomplete.updateSuggestions(for: text, cursorPosition: newCursor)
496:                             showAutocomplete = autocomplete.showSuggestions
497:                         }
498:                     }
499:                     
500:                     if !tab.fileName.hasSuffix(".json") {
501:                         MinimapView(
502:                             content: text,
503:                             scrollOffset: CGFloat(scrollPosition) * lineHeight,
504:                             scrollViewHeight: geometry.size.height,
505:                             totalContentHeight: CGFloat(totalLines) * lineHeight,
506:                             onScrollRequested: { newOffset in
507:                                 // Minimap requested scroll - update editor position
508:                                 // Convert back from pixels to line number
509:                                 let newLine = Int(newOffset / lineHeight)
510:                                 scrollPosition = max(0, min(newLine, totalLines - 1))
511:                             }
512:                         )
513:                         .frame(width: 80)
514:                     }
515:                 }
516:                 .background(theme.editorBackground)
517: 
518:                 // Sticky Header Overlay (FEAT-040)
519:                 StickyHeaderView(
520:                     text: text,
521:                     currentLine: scrollPosition,
522:                     theme: theme,
523:                     lineHeight: lineHeight,
524:                     onSelect: { line in
525:                         requestedLineSelection = line
526:                     }
527:                 )
528:                 .padding(.leading, lineNumbersStyle != "off" ? 60 : 0)
529:                 .padding(.trailing, tab.fileName.hasSuffix(".json") ? 0 : 80)
530: 
531:                 if showAutocomplete && !autocomplete.suggestionItems.isEmpty {
532:                     AutocompletePopup(
533:                         suggestions: autocomplete.suggestionItems,
534:                         selectedIndex: autocomplete.selectedIndex,
535:                         theme: theme
536:                     ) { index in
537:                         autocomplete.selectedIndex = index
538:                         var tempText = text
539:                         var tempCursor = cursorIndex
540:                         autocomplete.commitCurrentSuggestion(into: &tempText, cursorPosition: &tempCursor)
541:                         if tempText != text {
542:                             text = tempText
543:                             cursorIndex = tempCursor
544:                             requestedCursorIndex = tempCursor
545:                         }
546:                         showAutocomplete = false
547:                     }
548:                     .offset(x: 70, y: CGFloat(currentLineNumber) * lineHeight)
549:                 }
550:             }
551:         }
552:         }
553:         .onAppear {
554:             text = tab.content
555:             foldingManager.detectFoldableRegions(in: text, filePath: tab.url?.path ?? tab.fileName)
556:         }
557:         .onChange(of: tab.id) { _ in
558:             text = tab.content
559:             foldingManager.detectFoldableRegions(in: text, filePath: tab.url?.path ?? tab.fileName)
560:         }
561:         .onChange(of: currentLineNumber) { line in
562:             editorCore.cursorPosition = CursorPosition(line: line, column: currentColumn)
563:         }
564:         .onChange(of: currentColumn) { col in
565:             editorCore.cursorPosition = CursorPosition(line: currentLineNumber, column: col)
566:         }
567:         .onAppear {
568:             findViewModel.editorCore = editorCore
569:         }
570:     }
571:     
572:     // Autocomplete insertion is handled by AutocompleteManager.acceptSuggestion(...)
573: }
574: 
575: // MARK: - Line Numbers with Folding

---

[search]
Found 3 matches:
VSCodeiPadOS/VSCodeiPadOS/ContentView.swift:492: foldingManager.detectFoldableRegions(in: newValue, filePath: tab.url?.path ?? tab.fileName)
VSCodeiPadOS/VSCodeiPadOS/ContentView.swift:555: foldingManager.detectFoldableRegions(in: text, filePath: tab.url?.path ?? tab.fileName)
VSCodeiPadOS/VSCodeiPadOS/ContentView.swift:559: foldingManager.detectFoldableRegions(in: text, filePath: tab.url?.path ?? tab.fileName)


>>>TOOL search
{"query":"var editorCore", "glob":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift"}
>>>END
>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift","start_line":780,"end_line":860}
>>>END
>>>END

---

## üîß TOOL RESULTS

[search]
Found 1 matches:
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:31: @EnvironmentObject var editorCore: EditorCore

---

[read_file]
File: VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift (lines 781-860 of 2050)
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
781: 
782:             bracketHighlightRanges = [r1, r2]
783:         }
784:     }
785: }
786: 
787: // Custom text view to handle key commands, indent guides, and line highlighting
788: class EditorTextView: MultiCursorTextView {
789:     var onPeekDefinition: (() -> Void)?
790:     var onEscape: (() -> Void)?
791:     var onGoToLine: (() -> Void)?
792:     
793:     // Custom action closures for context menu
794:     var onGoToDefinition: (() -> Void)?
795:     var onFindReferences: (() -> Void)?
796:     var onFormatDocument: (() -> Void)?
797:     var onToggleComment: (() -> Void)?
798:     var onFold: (() -> Void)?
799:     var onUnfold: (() -> Void)?
800: 
801:     // Autocomplete key handling hooks are inherited from MultiCursorTextView
802:     
803:     // FEAT-039 & FEAT-043
804:     private var indentGuideColor: UIColor = .separator
805:     private var activeIndentGuideColor: UIColor = .label
806:     private var currentLineHighlightColor: UIColor = .clear
807:     
808:     override init(frame: CGRect, textContainer: NSTextContainer?) {
809:         super.init(frame: frame, textContainer: textContainer)
810:         setup()
811:     }
812:     
813:     required init?(coder: NSCoder) {
814:         super.init(coder: coder)
815:         setup()
816:     }
817:     
818:     private func setup() {
819:         // Ensure we redraw when bounds/selection change
820:         contentMode = .redraw
821:     }
822:     
823:     func updateThemeColors(theme: Theme) {
824:         self.indentGuideColor = UIColor(theme.indentGuide)
825:         self.activeIndentGuideColor = UIColor(theme.indentGuideActive)
826:         self.currentLineHighlightColor = UIColor(theme.currentLineHighlight)
827:         setNeedsDisplay()
828:     }
829:     
830:     override func draw(_ rect: CGRect) {
831:         guard let context = UIGraphicsGetCurrentContext(), let font = self.font else {
832:             super.draw(rect)
833:             return
834:         }
835:         
836:         // 1. Draw Current Line Highlight (FEAT-043)
837:         if let selectedRange = selectedTextRange {
838:             // Get the line rect for the cursor position
839:             let caretRect = self.caretRect(for: selectedRange.start)
840:             let lineRect = CGRect(x: 0, y: caretRect.minY, width: bounds.width, height: caretRect.height)
841:             
842:             context.setFillColor(currentLineHighlightColor.cgColor)
843:             context.fill(lineRect)
844:         }
845:         
846:         // 2. Draw Text (super implementation)
847:         super.draw(rect)
848:         
849:         // 3. Draw Indent Guides (FEAT-039)
850:         // We iterate visible lines and draw vertical lines for indentation
851:         // Optimization: Only draw for visible range
852: 
853:         context.setLineWidth(1.0)
854: 
855:         // Respect editor tab size setting (default 4)
856:         let storedTabSize = UserDefaults.standard.integer(forKey: "tabSize")
857:         let tabSize = storedTabSize > 0 ? storedTabSize : 4
858: 
859:         let spaceWidth = " ".size(withAttributes: [.font: font]).width
860:         let indentWidth = spaceWidth * CGFloat(tabSize)


>>>TOOL search
{"query":"class MultiCursorTextView", "glob":"VSCodeiPadOS/VSCodeiPadOS/**/*.swift"}
>>>END
>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor/MultiCursorTextView.swift","start_line":1,"end_line":220}
>>>END
>>>END

---

## üîß TOOL RESULTS

[search]
Found 1 matches:
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/MultiCursorTextView.swift:11: class MultiCursorTextView: UITextView, UIGestureRecognizerDelegate {

---

[read_file]
File: VSCodeiPadOS/VSCodeiPadOS/Views/Editor/MultiCursorTextView.swift (lines 2-220 of 320)
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
2: //  VSCodeiPadOS
3: //
4: //  Custom UITextView subclass that supports multiple cursor display
5: //
6: 
7: import UIKit
8: import SwiftUI
9: 
10: /// Custom UITextView that displays multiple cursors
11: class MultiCursorTextView: UITextView, UIGestureRecognizerDelegate {
12: 
13:     /// Reference to the editor core for multi-cursor state
14:     weak var editorCore: EditorCore?
15: 
16:     /// Autocomplete key handling hooks (return true if handled)
17:     var onAcceptAutocomplete: (() -> Bool)?
18:     var onDismissAutocomplete: (() -> Bool)?
19: 
20:     /// Layer for drawing additional cursors
21:     private var cursorLayers: [CALayer] = []
22: 
23:     /// Layer for drawing selection highlights for additional cursors
24:     private var selectionLayers: [CALayer] = []
25: 
26:     /// Timer for cursor blink animation
27:     private var blinkTimer: Timer?
28:     private var cursorVisible = true
29: 
30:     /// Cursor appearance
31:     private let cursorWidth: CGFloat = 2
32:     private let cursorColor = UIColor.systemBlue
33:     private let secondaryCursorColor = UIColor.systemCyan
34:     private let selectionColor = UIColor.systemBlue.withAlphaComponent(0.3)
35:     private let secondarySelectionColor = UIColor.systemCyan.withAlphaComponent(0.25)
36: 
37:     override init(frame: CGRect, textContainer: NSTextContainer?) {
38:         super.init(frame: frame, textContainer: textContainer)
39:         setupCursorBlinking()
40:         setupOptionClickAddCursor()
41:     }
42: 
43:     required init?(coder: NSCoder) {
44:         super.init(coder: coder)
45:         setupCursorBlinking()
46:         setupOptionClickAddCursor()
47:     }
48: 
49:     deinit {
50:         blinkTimer?.invalidate()
51:     }
52: 
53:     private func setupCursorBlinking() {
54:         blinkTimer = Timer.scheduledTimer(withTimeInterval: 0.5, repeats: true) { [weak self] _ in
55:             self?.cursorVisible.toggle()
56:             self?.updateCursorVisibility()
57:         }
58:     }
59: 
60:     private func updateCursorVisibility() {
61:         let alpha: Float = cursorVisible ? 1.0 : 0.0
62:         cursorLayers.forEach { $0.opacity = alpha }
63:     }
64: 
65:     // MARK: - Option+Click (Alt+Click) Add Cursor
66: 
67:     private weak var optionClickTapRecognizer: UITapGestureRecognizer?
68: 
69:     private func setupOptionClickAddCursor() {
70:         let tap = UITapGestureRecognizer(target: self, action: #selector(handleOptionClickTap(_:)))
71:         tap.delegate = self
72:         tap.cancelsTouchesInView = false
73:         addGestureRecognizer(tap)
74:         optionClickTapRecognizer = tap
75:     }
76: 
77:     func gestureRecognizerShouldBegin(_ gestureRecognizer: UIGestureRecognizer) -> Bool {
78:         if gestureRecognizer === optionClickTapRecognizer {
79:             // Only handle when Option/Alt is pressed.
80:             return gestureRecognizer.modifierFlags.contains(.alternate)
81:         }
82:         return true
83:     }
84: 
85:     @objc private func handleOptionClickTap(_ gestureRecognizer: UITapGestureRecognizer) {
86:         guard gestureRecognizer.modifierFlags.contains(.alternate) else { return }
87:         guard let editorCore = editorCore else { return }
88: 
89:         let point = gestureRecognizer.location(in: self)
90:         guard let pos = closestPosition(to: point) else { return }
91: 
92:         let offset = self.offset(from: beginningOfDocument, to: pos)
93: 
94:         editorCore.addCursorAtPosition(offset)
95: 
96:         // Make the newly added cursor the UIKit caret too.
97:         selectedRange = NSRange(location: offset, length: 0)
98:         delegate?.textViewDidChangeSelection?(self)
99: 
100:         updateCursorDisplay()
101:     }
102: 
103:     /// Updates the display of all cursors and selections
104:     func updateCursorDisplay() {
105:         // Remove existing cursor and selection layers
106:         cursorLayers.forEach { $0.removeFromSuperlayer() }
107:         cursorLayers.removeAll()
108:         selectionLayers.forEach { $0.removeFromSuperlayer() }
109:         selectionLayers.removeAll()
110: 
111:         guard let editorCore = editorCore else { return }
112:         let cursors = editorCore.multiCursorState.cursors
113: 
114:         // Only show additional cursors if we have multiple
115:         guard cursors.count > 1 else { return }
116: 
117:         // Draw each cursor (skip the primary one as UITextView handles it)
118:         for (index, cursor) in cursors.enumerated() {
119:             // Primary selection is handled by UITextView.selectedRange; only draw additional selections.
120:             if !cursor.isPrimary, let selectionRange = cursor.selectionRange {
121:                 drawSelection(for: selectionRange, isPrimary: false, index: index)
122:             }
123: 
124:             // Draw cursor line (skip primary cursor as system handles it)
125:             if !cursor.isPrimary {
126:                 drawCursor(at: cursor.position, isPrimary: false, index: index)
127:             }
128:         }
129:     }
130: 
131:     private func drawCursor(at position: Int, isPrimary: Bool, index: Int) {
132:         guard let textPosition = self.position(from: beginningOfDocument, offset: position) else { return }
133: 
134:         let caretRect = self.caretRect(for: textPosition)
135: 
136:         let cursorLayer = CALayer()
137:         cursorLayer.backgroundColor = (isPrimary ? cursorColor : secondaryCursorColor).cgColor
138:         cursorLayer.frame = CGRect(
139:             x: caretRect.origin.x,
140:             y: caretRect.origin.y,
141:             width: cursorWidth,
142:             height: caretRect.height
143:         )
144:         cursorLayer.cornerRadius = 1
145: 
146:         layer.addSublayer(cursorLayer)
147:         cursorLayers.append(cursorLayer)
148:     }
149: 
150:     private func drawSelection(for range: NSRange, isPrimary: Bool, index: Int) {
151:         guard let start = position(from: beginningOfDocument, offset: range.location),
152:               let end = position(from: beginningOfDocument, offset: range.location + range.length),
153:               let textRange = self.textRange(from: start, to: end) else { return }
154: 
155:         let selectionRects = selectionRects(for: textRange)
156: 
157:         for rect in selectionRects {
158:             let selectionLayer = CALayer()
159:             selectionLayer.backgroundColor = (isPrimary ? selectionColor : secondarySelectionColor).cgColor
160:             selectionLayer.frame = rect.rect
161: 
162:             // Insert behind text
163:             if let textLayer = layer.sublayers?.first {
164:                 layer.insertSublayer(selectionLayer, below: textLayer)
165:             } else {
166:                 layer.addSublayer(selectionLayer)
167:             }
168:             selectionLayers.append(selectionLayer)
169:         }
170:     }
171: 
172:     // MARK: - Text Input Handling for Multi-Cursor
173: 
174:     override func insertText(_ text: String) {
175:         guard let editorCore = editorCore,
176:               editorCore.multiCursorState.isMultiCursor else {
177:             super.insertText(text)
178:             return
179:         }
180: 
181:         // Handle multi-cursor insert
182:         var content = self.text ?? ""
183:         editorCore.multiCursorState.insertText(text, in: &content)
184: 
185:         // Update text view
186:         let cursorPosition = editorCore.multiCursorState.primaryCursor?.position ?? 0
187:         self.text = content
188: 
189:         // Position the main cursor
190:         if let newPosition = position(from: beginningOfDocument, offset: cursorPosition) {
191:             selectedTextRange = textRange(from: newPosition, to: newPosition)
192:         }
193: 
194:         // Trigger text change notification
195:         delegate?.textViewDidChange?(self)
196: 
197:         updateCursorDisplay()
198:     }
199: 
200:     override func deleteBackward() {
201:         guard let editorCore = editorCore,
202:               editorCore.multiCursorState.isMultiCursor else {
203:             super.deleteBackward()
204:             return
205:         }
206: 
207:         // Handle multi-cursor delete
208:         var content = self.text ?? ""
209:         editorCore.multiCursorState.deleteBackward(in: &content)
210: 
211:         // Update text view
212:         let cursorPosition = editorCore.multiCursorState.primaryCursor?.position ?? 0
213:         self.text = content
214: 
215:         // Position the main cursor
216:         if let newPosition = position(from: beginningOfDocument, offset: cursorPosition) {
217:             selectedTextRange = textRange(from: newPosition, to: newPosition)
218:         }
219: 
220:         // Trigger text change notification




>>>TOOL search
{"query":"MultiCursorTextView.swift", "glob":"VSCodeiPadOS/VSCodeiPadOS/**/*"}
>>>END
>>>TOOL list_dir
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor"}
>>>END
>>>END

---

## üîß TOOL RESULTS

[search]
No matches found for "MultiCursorTextView.swift"

---

[list_dir]
üìÅ VSCodeiPadOS/VSCodeiPadOS/Views/Editor/
   BreadcrumbsView.swift
   ColorPickerView.swift
   EditorSplitView.swift
   FoldingLayoutManager.swift
   GitGutterView.swift
   HoverInfoView.swift
   InlayHintsOverlay.swift
   InlineSuggestionView.swift
   JSONTreeView.swift
   MergeConflictView.swift
   MinimapView.swift
   ModifierTapGestureRecognizer.swift
   MultiCursorTextView.swift
   PeekDefinitionView.swift
   SplitEditorView.swift
   StickyHeaderView.swift
   SyntaxHighlightingTextView_Update.swift
   SyntaxHighlightingTextView.swift


>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor/MultiCursorTextView.swift","start_line":1,"end_line":260}
>>>END
>>>END

---

## üîß TOOL RESULTS

[read_file]
File: VSCodeiPadOS/VSCodeiPadOS/Views/Editor/MultiCursorTextView.swift (lines 2-260 of 320)
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
2: //  VSCodeiPadOS
3: //
4: //  Custom UITextView subclass that supports multiple cursor display
5: //
6: 
7: import UIKit
8: import SwiftUI
9: 
10: /// Custom UITextView that displays multiple cursors
11: class MultiCursorTextView: UITextView, UIGestureRecognizerDelegate {
12: 
13:     /// Reference to the editor core for multi-cursor state
14:     weak var editorCore: EditorCore?
15: 
16:     /// Autocomplete key handling hooks (return true if handled)
17:     var onAcceptAutocomplete: (() -> Bool)?
18:     var onDismissAutocomplete: (() -> Bool)?
19: 
20:     /// Layer for drawing additional cursors
21:     private var cursorLayers: [CALayer] = []
22: 
23:     /// Layer for drawing selection highlights for additional cursors
24:     private var selectionLayers: [CALayer] = []
25: 
26:     /// Timer for cursor blink animation
27:     private var blinkTimer: Timer?
28:     private var cursorVisible = true
29: 
30:     /// Cursor appearance
31:     private let cursorWidth: CGFloat = 2
32:     private let cursorColor = UIColor.systemBlue
33:     private let secondaryCursorColor = UIColor.systemCyan
34:     private let selectionColor = UIColor.systemBlue.withAlphaComponent(0.3)
35:     private let secondarySelectionColor = UIColor.systemCyan.withAlphaComponent(0.25)
36: 
37:     override init(frame: CGRect, textContainer: NSTextContainer?) {
38:         super.init(frame: frame, textContainer: textContainer)
39:         setupCursorBlinking()
40:         setupOptionClickAddCursor()
41:     }
42: 
43:     required init?(coder: NSCoder) {
44:         super.init(coder: coder)
45:         setupCursorBlinking()
46:         setupOptionClickAddCursor()
47:     }
48: 
49:     deinit {
50:         blinkTimer?.invalidate()
51:     }
52: 
53:     private func setupCursorBlinking() {
54:         blinkTimer = Timer.scheduledTimer(withTimeInterval: 0.5, repeats: true) { [weak self] _ in
55:             self?.cursorVisible.toggle()
56:             self?.updateCursorVisibility()
57:         }
58:     }
59: 
60:     private func updateCursorVisibility() {
61:         let alpha: Float = cursorVisible ? 1.0 : 0.0
62:         cursorLayers.forEach { $0.opacity = alpha }
63:     }
64: 
65:     // MARK: - Option+Click (Alt+Click) Add Cursor
66: 
67:     private weak var optionClickTapRecognizer: UITapGestureRecognizer?
68: 
69:     private func setupOptionClickAddCursor() {
70:         let tap = UITapGestureRecognizer(target: self, action: #selector(handleOptionClickTap(_:)))
71:         tap.delegate = self
72:         tap.cancelsTouchesInView = false
73:         addGestureRecognizer(tap)
74:         optionClickTapRecognizer = tap
75:     }
76: 
77:     func gestureRecognizerShouldBegin(_ gestureRecognizer: UIGestureRecognizer) -> Bool {
78:         if gestureRecognizer === optionClickTapRecognizer {
79:             // Only handle when Option/Alt is pressed.
80:             return gestureRecognizer.modifierFlags.contains(.alternate)
81:         }
82:         return true
83:     }
84: 
85:     @objc private func handleOptionClickTap(_ gestureRecognizer: UITapGestureRecognizer) {
86:         guard gestureRecognizer.modifierFlags.contains(.alternate) else { return }
87:         guard let editorCore = editorCore else { return }
88: 
89:         let point = gestureRecognizer.location(in: self)
90:         guard let pos = closestPosition(to: point) else { return }
91: 
92:         let offset = self.offset(from: beginningOfDocument, to: pos)
93: 
94:         editorCore.addCursorAtPosition(offset)
95: 
96:         // Make the newly added cursor the UIKit caret too.
97:         selectedRange = NSRange(location: offset, length: 0)
98:         delegate?.textViewDidChangeSelection?(self)
99: 
100:         updateCursorDisplay()
101:     }
102: 
103:     /// Updates the display of all cursors and selections
104:     func updateCursorDisplay() {
105:         // Remove existing cursor and selection layers
106:         cursorLayers.forEach { $0.removeFromSuperlayer() }
107:         cursorLayers.removeAll()
108:         selectionLayers.forEach { $0.removeFromSuperlayer() }
109:         selectionLayers.removeAll()
110: 
111:         guard let editorCore = editorCore else { return }
112:         let cursors = editorCore.multiCursorState.cursors
113: 
114:         // Only show additional cursors if we have multiple
115:         guard cursors.count > 1 else { return }
116: 
117:         // Draw each cursor (skip the primary one as UITextView handles it)
118:         for (index, cursor) in cursors.enumerated() {
119:             // Primary selection is handled by UITextView.selectedRange; only draw additional selections.
120:             if !cursor.isPrimary, let selectionRange = cursor.selectionRange {
121:                 drawSelection(for: selectionRange, isPrimary: false, index: index)
122:             }
123: 
124:             // Draw cursor line (skip primary cursor as system handles it)
125:             if !cursor.isPrimary {
126:                 drawCursor(at: cursor.position, isPrimary: false, index: index)
127:             }
128:         }
129:     }
130: 
131:     private func drawCursor(at position: Int, isPrimary: Bool, index: Int) {
132:         guard let textPosition = self.position(from: beginningOfDocument, offset: position) else { return }
133: 
134:         let caretRect = self.caretRect(for: textPosition)
135: 
136:         let cursorLayer = CALayer()
137:         cursorLayer.backgroundColor = (isPrimary ? cursorColor : secondaryCursorColor).cgColor
138:         cursorLayer.frame = CGRect(
139:             x: caretRect.origin.x,
140:             y: caretRect.origin.y,
141:             width: cursorWidth,
142:             height: caretRect.height
143:         )
144:         cursorLayer.cornerRadius = 1
145: 
146:         layer.addSublayer(cursorLayer)
147:         cursorLayers.append(cursorLayer)
148:     }
149: 
150:     private func drawSelection(for range: NSRange, isPrimary: Bool, index: Int) {
151:         guard let start = position(from: beginningOfDocument, offset: range.location),
152:               let end = position(from: beginningOfDocument, offset: range.location + range.length),
153:               let textRange = self.textRange(from: start, to: end) else { return }
154: 
155:         let selectionRects = selectionRects(for: textRange)
156: 
157:         for rect in selectionRects {
158:             let selectionLayer = CALayer()
159:             selectionLayer.backgroundColor = (isPrimary ? selectionColor : secondarySelectionColor).cgColor
160:             selectionLayer.frame = rect.rect
161: 
162:             // Insert behind text
163:             if let textLayer = layer.sublayers?.first {
164:                 layer.insertSublayer(selectionLayer, below: textLayer)
165:             } else {
166:                 layer.addSublayer(selectionLayer)
167:             }
168:             selectionLayers.append(selectionLayer)
169:         }
170:     }
171: 
172:     // MARK: - Text Input Handling for Multi-Cursor
173: 
174:     override func insertText(_ text: String) {
175:         guard let editorCore = editorCore,
176:               editorCore.multiCursorState.isMultiCursor else {
177:             super.insertText(text)
178:             return
179:         }
180: 
181:         // Handle multi-cursor insert
182:         var content = self.text ?? ""
183:         editorCore.multiCursorState.insertText(text, in: &content)
184: 
185:         // Update text view
186:         let cursorPosition = editorCore.multiCursorState.primaryCursor?.position ?? 0
187:         self.text = content
188: 
189:         // Position the main cursor
190:         if let newPosition = position(from: beginningOfDocument, offset: cursorPosition) {
191:             selectedTextRange = textRange(from: newPosition, to: newPosition)
192:         }
193: 
194:         // Trigger text change notification
195:         delegate?.textViewDidChange?(self)
196: 
197:         updateCursorDisplay()
198:     }
199: 
200:     override func deleteBackward() {
201:         guard let editorCore = editorCore,
202:               editorCore.multiCursorState.isMultiCursor else {
203:             super.deleteBackward()
204:             return
205:         }
206: 
207:         // Handle multi-cursor delete
208:         var content = self.text ?? ""
209:         editorCore.multiCursorState.deleteBackward(in: &content)
210: 
211:         // Update text view
212:         let cursorPosition = editorCore.multiCursorState.primaryCursor?.position ?? 0
213:         self.text = content
214: 
215:         // Position the main cursor
216:         if let newPosition = position(from: beginningOfDocument, offset: cursorPosition) {
217:             selectedTextRange = textRange(from: newPosition, to: newPosition)
218:         }
219: 
220:         // Trigger text change notification
221:         delegate?.textViewDidChange?(self)
222: 
223:         updateCursorDisplay()
224:     }
225: 
226:     // MARK: - Layout Updates
227: 
228:     override func layoutSubviews() {
229:         super.layoutSubviews()
230:         // Refresh cursor positions when layout changes
231:         updateCursorDisplay()
232:     }
233: 
234:     override var contentOffset: CGPoint {
235:         didSet {
236:             // Update cursor positions when scrolling
237:             updateCursorDisplay()
238:         }
239:     }
240: }
241: 
242: // MARK: - Key Commands for Multi-Cursor + Autocomplete
243: 
244: extension MultiCursorTextView {
245: 
246:     override var keyCommands: [UIKeyCommand]? {
247:         var commands = super.keyCommands ?? []
248: 
249:         // Cmd+D: Add next occurrence
250:         commands.append(UIKeyCommand(
251:             title: "Add Next Occurrence",
252:             action: #selector(addNextOccurrence),
253:             input: "d",
254:             modifierFlags: .command
255:         ))
256: 
257:         // Cmd+Shift+L: Select all occurrences
258:         commands.append(UIKeyCommand(
259:             title: "Select All Occurrences",
260:             action: #selector(selectAllOccurrences),


>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift","start_line":1,"end_line":120}
>>>END
>>>END

---

## üîß TOOL RESULTS

[read_file]
File: VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift (lines 2-120 of 2058)
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
2: //  SyntaxHighlightingTextView.swift
3: //  VSCodeiPadOS
4: //
5: //  Upgraded syntax highlighting with VSCode-like colors
6: //
7: 
8: import SwiftUI
9: import UIKit
10: 
11: /// UITextView wrapper with syntax highlighting support
12: struct SyntaxHighlightingTextView: UIViewRepresentable {
13:     @Binding var text: String
14:     let filename: String
15:     @Binding var scrollPosition: Int
16:     @Binding var totalLines: Int
17:     @Binding var visibleLines: Int
18:     @Binding var currentLineNumber: Int
19:     @Binding var currentColumn: Int
20:     @Binding var cursorIndex: Int
21:     @Binding var lineHeight: CGFloat
22:     @Binding var requestedLineSelection: Int?
23:     @Binding var requestedCursorIndex: Int?
24: 
25:     /// Autocomplete key handling hooks (return true if handled)
26:     let onAcceptAutocomplete: (() -> Bool)?
27:     let onDismissAutocomplete: (() -> Bool)?
28: 
29:     let isActive: Bool
30:     let fontSize: CGFloat  // Explicit parameter to trigger SwiftUI updates
31:     @EnvironmentObject var editorCore: EditorCore
32: 
33:     init(
34:         text: Binding<String>,
35:         filename: String,
36:         scrollPosition: Binding<Int>,
37:         totalLines: Binding<Int>,
38:         visibleLines: Binding<Int>,
39:         currentLineNumber: Binding<Int>,
40:         currentColumn: Binding<Int>,
41:         cursorIndex: Binding<Int> = .constant(0),
42:         lineHeight: Binding<CGFloat>,
43:         isActive: Bool,
44:         fontSize: CGFloat = 14.0,
45:         requestedLineSelection: Binding<Int?> = .constant(nil),
46:         requestedCursorIndex: Binding<Int?> = .constant(nil),
47:         onAcceptAutocomplete: (() -> Bool)? = nil,
48:         onDismissAutocomplete: (() -> Bool)? = nil
49:     ) {
50:         self._text = text
51:         self.filename = filename
52:         self._scrollPosition = scrollPosition
53:         self._totalLines = totalLines
54:         self._visibleLines = visibleLines
55:         self._currentLineNumber = currentLineNumber
56:         self._currentColumn = currentColumn
57:         self._cursorIndex = cursorIndex
58:         self._lineHeight = lineHeight
59:         self.isActive = isActive
60:         self.fontSize = fontSize
61:         self._requestedLineSelection = requestedLineSelection
62:         self._requestedCursorIndex = requestedCursorIndex
63:         self.onAcceptAutocomplete = onAcceptAutocomplete
64:         self.onDismissAutocomplete = onDismissAutocomplete
65:     }
66:     
67:     // Compatibility init for older call sites (e.g. SplitEditorView) that pass editorCore explicitly.
68:     init(
69:         text: Binding<String>,
70:         filename: String,
71:         scrollPosition: Binding<Int>,
72:         totalLines: Binding<Int>,
73:         visibleLines: Binding<Int>,
74:         currentLineNumber: Binding<Int>,
75:         currentColumn: Binding<Int>,
76:         cursorIndex: Binding<Int> = .constant(0),
77:         lineHeight: Binding<CGFloat>,
78:         isActive: Bool,
79:         editorCore: EditorCore,
80:         requestedLineSelection: Binding<Int?> = .constant(nil),
81:         requestedCursorIndex: Binding<Int?> = .constant(nil),
82:         onAcceptAutocomplete: (() -> Bool)? = nil,
83:         onDismissAutocomplete: (() -> Bool)? = nil
84:     ) {
85:         self.init(
86:             text: text,
87:             filename: filename,
88:             scrollPosition: scrollPosition,
89:             totalLines: totalLines,
90:             visibleLines: visibleLines,
91:             currentLineNumber: currentLineNumber,
92:             currentColumn: currentColumn,
93:             cursorIndex: cursorIndex,
94:             lineHeight: lineHeight,
95:             isActive: isActive,
96:             fontSize: editorCore.editorFontSize,
97:             requestedLineSelection: requestedLineSelection,
98:             requestedCursorIndex: requestedCursorIndex,
99:             onAcceptAutocomplete: onAcceptAutocomplete,
100:             onDismissAutocomplete: onDismissAutocomplete
101:         )
102:     }
103: 
104:     func makeCoordinator() -> Coordinator {
105:         Coordinator(self)
106:     }
107:     
108:     func makeUIView(context: Context) -> UITextView {
109:         let textView = EditorTextView()
110:         textView.delegate = context.coordinator
111:         textView.editorCore = editorCore
112: 
113:         // Autocomplete hooks
114:         textView.onAcceptAutocomplete = onAcceptAutocomplete
115:         textView.onDismissAutocomplete = onDismissAutocomplete
116: 
117:         textView.onPeekDefinition = {
118:             context.coordinator.handlePeekDefinition(in: textView)
119:         }
120: 


>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor/MultiCursorTextView.swift","start_line":1,"end_line":260}
>>>END
>>>END

---

## üîß TOOL RESULTS

[read_file]
File: VSCodeiPadOS/VSCodeiPadOS/Views/Editor/MultiCursorTextView.swift (lines 2-260 of 281)
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
2: //  VSCodeiPadOS
3: //
4: //  Custom UITextView subclass that supports multiple cursor display
5: //
6: 
7: import UIKit
8: import SwiftUI
9: 
10: /// Custom UITextView that displays multiple cursors
11: class MultiCursorTextView: UITextView {
12: 
13:     /// Reference to the editor core for multi-cursor state
14:     weak var editorCore: EditorCore?
15: 
16:     /// Autocomplete key handling hooks (return true if handled)
17:     var onAcceptAutocomplete: (() -> Bool)?
18:     var onDismissAutocomplete: (() -> Bool)?
19: 
20:     /// Layer for drawing additional cursors
21:     private var cursorLayers: [CALayer] = []
22: 
23:     /// Layer for drawing selection highlights for additional cursors
24:     private var selectionLayers: [CALayer] = []
25: 
26:     /// Timer for cursor blink animation
27:     private var blinkTimer: Timer?
28:     private var cursorVisible = true
29: 
30:     /// Cursor appearance
31:     private let cursorWidth: CGFloat = 2
32:     private let cursorColor = UIColor.systemBlue
33:     private let secondaryCursorColor = UIColor.systemCyan
34:     private let selectionColor = UIColor.systemBlue.withAlphaComponent(0.3)
35:     private let secondarySelectionColor = UIColor.systemCyan.withAlphaComponent(0.25)
36: 
37:     override init(frame: CGRect, textContainer: NSTextContainer?) {
38:         super.init(frame: frame, textContainer: textContainer)
39:         setupCursorBlinking()
40:     }
41: 
42:     required init?(coder: NSCoder) {
43:         super.init(coder: coder)
44:         setupCursorBlinking()
45:     }
46: 
47:     deinit {
48:         blinkTimer?.invalidate()
49:     }
50: 
51:     private func setupCursorBlinking() {
52:         blinkTimer = Timer.scheduledTimer(withTimeInterval: 0.5, repeats: true) { [weak self] _ in
53:             self?.cursorVisible.toggle()
54:             self?.updateCursorVisibility()
55:         }
56:     }
57: 
58:     private func updateCursorVisibility() {
59:         let alpha: Float = cursorVisible ? 1.0 : 0.0
60:         cursorLayers.forEach { $0.opacity = alpha }
61:     }
62: 
63:     /// Updates the display of all cursors and selections
64:     func updateCursorDisplay() {
65:         // Remove existing cursor and selection layers
66:         cursorLayers.forEach { $0.removeFromSuperlayer() }
67:         cursorLayers.removeAll()
68:         selectionLayers.forEach { $0.removeFromSuperlayer() }
69:         selectionLayers.removeAll()
70: 
71:         guard let editorCore = editorCore else { return }
72:         let cursors = editorCore.multiCursorState.cursors
73: 
74:         // Only show additional cursors if we have multiple
75:         guard cursors.count > 1 else { return }
76: 
77:         // Draw each cursor (skip the primary one as UITextView handles it)
78:         for (index, cursor) in cursors.enumerated() {
79:             // Draw selection if present
80:             if let selectionRange = cursor.selectionRange {
81:                 drawSelection(for: selectionRange, isPrimary: cursor.isPrimary, index: index)
82:             }
83: 
84:             // Draw cursor line (skip primary cursor as system handles it)
85:             if !cursor.isPrimary {
86:                 drawCursor(at: cursor.position, isPrimary: false, index: index)
87:             }
88:         }
89:     }
90: 
91:     private func drawCursor(at position: Int, isPrimary: Bool, index: Int) {
92:         guard let textPosition = self.position(from: beginningOfDocument, offset: position) else { return }
93: 
94:         let caretRect = self.caretRect(for: textPosition)
95: 
96:         let cursorLayer = CALayer()
97:         cursorLayer.backgroundColor = (isPrimary ? cursorColor : secondaryCursorColor).cgColor
98:         cursorLayer.frame = CGRect(
99:             x: caretRect.origin.x,
100:             y: caretRect.origin.y,
101:             width: cursorWidth,
102:             height: caretRect.height
103:         )
104:         cursorLayer.cornerRadius = 1
105: 
106:         layer.addSublayer(cursorLayer)
107:         cursorLayers.append(cursorLayer)
108:     }
109: 
110:     private func drawSelection(for range: NSRange, isPrimary: Bool, index: Int) {
111:         guard let start = position(from: beginningOfDocument, offset: range.location),
112:               let end = position(from: beginningOfDocument, offset: range.location + range.length),
113:               let textRange = self.textRange(from: start, to: end) else { return }
114: 
115:         let selectionRects = selectionRects(for: textRange)
116: 
117:         for rect in selectionRects {
118:             let selectionLayer = CALayer()
119:             selectionLayer.backgroundColor = (isPrimary ? selectionColor : secondarySelectionColor).cgColor
120:             selectionLayer.frame = rect.rect
121: 
122:             // Insert behind text
123:             if let textLayer = layer.sublayers?.first {
124:                 layer.insertSublayer(selectionLayer, below: textLayer)
125:             } else {
126:                 layer.addSublayer(selectionLayer)
127:             }
128:             selectionLayers.append(selectionLayer)
129:         }
130:     }
131: 
132:     // MARK: - Text Input Handling for Multi-Cursor
133: 
134:     override func insertText(_ text: String) {
135:         guard let editorCore = editorCore,
136:               editorCore.multiCursorState.isMultiCursor else {
137:             super.insertText(text)
138:             return
139:         }
140: 
141:         // Handle multi-cursor insert
142:         var content = self.text ?? ""
143:         editorCore.multiCursorState.insertText(text, in: &content)
144: 
145:         // Update text view
146:         let cursorPosition = editorCore.multiCursorState.primaryCursor?.position ?? 0
147:         self.text = content
148: 
149:         // Position the main cursor
150:         if let newPosition = position(from: beginningOfDocument, offset: cursorPosition) {
151:             selectedTextRange = textRange(from: newPosition, to: newPosition)
152:         }
153: 
154:         // Trigger text change notification
155:         delegate?.textViewDidChange?(self)
156: 
157:         updateCursorDisplay()
158:     }
159: 
160:     override func deleteBackward() {
161:         guard let editorCore = editorCore,
162:               editorCore.multiCursorState.isMultiCursor else {
163:             super.deleteBackward()
164:             return
165:         }
166: 
167:         // Handle multi-cursor delete
168:         var content = self.text ?? ""
169:         editorCore.multiCursorState.deleteBackward(in: &content)
170: 
171:         // Update text view
172:         let cursorPosition = editorCore.multiCursorState.primaryCursor?.position ?? 0
173:         self.text = content
174: 
175:         // Position the main cursor
176:         if let newPosition = position(from: beginningOfDocument, offset: cursorPosition) {
177:             selectedTextRange = textRange(from: newPosition, to: newPosition)
178:         }
179: 
180:         // Trigger text change notification
181:         delegate?.textViewDidChange?(self)
182: 
183:         updateCursorDisplay()
184:     }
185: 
186:     // MARK: - Layout Updates
187: 
188:     override func layoutSubviews() {
189:         super.layoutSubviews()
190:         // Refresh cursor positions when layout changes
191:         updateCursorDisplay()
192:     }
193: 
194:     override var contentOffset: CGPoint {
195:         didSet {
196:             // Update cursor positions when scrolling
197:             updateCursorDisplay()
198:         }
199:     }
200: }
201: 
202: // MARK: - Key Commands for Multi-Cursor + Autocomplete
203: 
204: extension MultiCursorTextView {
205: 
206:     override var keyCommands: [UIKeyCommand]? {
207:         var commands = super.keyCommands ?? []
208: 
209:         // Tab: accept autocomplete (if showing), else insert tab
210:         commands.append(UIKeyCommand(
211:             title: "Accept Suggestion",
212:             action: #selector(tabAcceptAutocomplete),
213:             input: "\t",
214:             modifierFlags: []
215:         ))
216: 
217:         // Cmd+D: Add next occurrence
218:         commands.append(UIKeyCommand(
219:             title: "Add Next Occurrence",
220:             action: #selector(addNextOccurrence),
221:             input: "d",
222:             modifierFlags: .command
223:         ))
224: 
225:         // Cmd+Shift+L: Select all occurrences
226:         commands.append(UIKeyCommand(
227:             title: "Select All Occurrences",
228:             action: #selector(selectAllOccurrences),
229:             input: "l",
230:             modifierFlags: [.command, .shift]
231:         ))
232: 
233:         // Cmd+G: Go to Line
234:         commands.append(UIKeyCommand(
235:             title: "Go to Line",
236:             action: #selector(goToLine),
237:             input: "g",
238:             modifierFlags: .command
239:         ))
240: 
241:         // Escape: Dismiss autocomplete if visible, else exit multi-cursor mode
242:         commands.append(UIKeyCommand(
243:             title: "Escape",
244:             action: #selector(escapeKeyPressed),
245:             input: UIKeyCommand.inputEscape,
246:             modifierFlags: []
247:         ))
248: 
249:         return commands
250:     }
251: 
252:     @objc private func tabAcceptAutocomplete() {
253:         if onAcceptAutocomplete?() == true {
254:             return
255:         }
256:         insertText("\t")
257:     }
258: 
259:     @objc private func addNextOccurrence() {
260:         editorCore?.addNextOccurrence()


>>>TOOL search
{"query":"SyntaxHighlightingTextView.swift", "glob":"VSCodeiPadOS/VSCodeiPadOS.xcodeproj/project.pbxproj"}
>>>END
>>>TOOL search
{"query":"MultiCursorTextView.swift", "glob":"VSCodeiPadOS/VSCodeiPadOS.xcodeproj/project.pbxproj"}
>>>END
>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS.xcodeproj/project.pbxproj","start_line":1,"end_line":120}
>>>END
>>>END

---

## üîß TOOL RESULTS

[search]
Found 4 matches:
VSCodeiPadOS/VSCodeiPadOS.xcodeproj/project.pbxproj:30: 1036 /* SyntaxHighlightingTextView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2036 /* SyntaxHighlightingTextView.swift */; };
VSCodeiPadOS/VSCodeiPadOS.xcodeproj/project.pbxproj:122: 2036 /* SyntaxHighlightingTextView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SyntaxHighlightingTextView.swift; sourceTree = "<group>"; };
VSCodeiPadOS/VSCodeiPadOS.xcodeproj/project.pbxproj:337: 2036 /* SyntaxHighlightingTextView.swift */,
VSCodeiPadOS/VSCodeiPadOS.xcodeproj/project.pbxproj:517: 1036 /* SyntaxHighlightingTextView.swift in Sources */,

---

[search]
Found 4 matches:
VSCodeiPadOS/VSCodeiPadOS.xcodeproj/project.pbxproj:83: 1130 /* MultiCursorTextView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2130 /* MultiCursorTextView.swift */; };
VSCodeiPadOS/VSCodeiPadOS.xcodeproj/project.pbxproj:175: 2130 /* MultiCursorTextView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = MultiCursorTextView.swift; sourceTree = "<group>"; };
VSCodeiPadOS/VSCodeiPadOS.xcodeproj/project.pbxproj:330: 2130 /* MultiCursorTextView.swift */,
VSCodeiPadOS/VSCodeiPadOS.xcodeproj/project.pbxproj:507: 1130 /* MultiCursorTextView.swift in Sources */,

---

[read_file]
File: VSCodeiPadOS/VSCodeiPadOS.xcodeproj/project.pbxproj (lines 2-120 of 756)
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
2: {
3: 	archiveVersion = 1;
4: 	classes = {
5: 	};
6: 	objectVersion = 56;
7: 	objects = {
8: 
9: /* Begin PBXBuildFile section */
10: 		1001 /* ContentView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2001 /* ContentView.swift */; };
11: 		1002 /* VSCodeiPadOSApp.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2002 /* VSCodeiPadOSApp.swift */; };
12: 		1003 /* AppCommands.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2003 /* AppCommands.swift */; };
13: 		1004 /* Color+Hex.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2004 /* Color+Hex.swift */; };
14: 		1005 /* FileManager+Extension.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2005 /* FileManager+Extension.swift */; };
15: 		1006 /* FileManager+Extensions.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2006 /* FileManager+Extensions.swift */; };
16: 		1007 /* NSAttributedStringSyntaxHighlighter.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2007 /* NSAttributedStringSyntaxHighlighter.swift */; };
17: 		1009 /* EditorState.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2009 /* EditorState.swift */; };
18: 		1012 /* FileItem.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2012 /* FileItem.swift */; };
19: 		1013 /* FileItemUTType.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2013 /* FileItemUTType.swift */; };
20: 		1015 /* FindViewModel.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2015 /* FindViewModel.swift */; };
21: 		1016 /* MultiCursor.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2016 /* MultiCursor.swift */; };
22: 		1017 /* Tab.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2017 /* Tab.swift */; };
23: 		1018 /* Theme.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2018 /* Theme.swift */; };
24: 		1020 /* ThemeManager.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2020 /* ThemeManager.swift */; };
25: 		1019 /* AutocompleteManager.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2019 /* AutocompleteManager.swift */; };
26: 		1022 /* CodeFoldingManager.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2022 /* CodeFoldingManager.swift */; };
27: 		1023 /* EditorCore.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2023 /* EditorCore.swift */; };
28: 		1025 /* FileSystemNavigator.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2025 /* FileSystemNavigator.swift */; };
29: 		1035 /* MinimapView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2035 /* MinimapView.swift */; };
30: 		1036 /* SyntaxHighlightingTextView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2036 /* SyntaxHighlightingTextView.swift */; };
31: 		1043 /* GitView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2043 /* GitView.swift */; };
32: 		1044 /* GoToLineView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2044 /* GoToLineView.swift */; };
33: 		1050 /* SettingsView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2050 /* SettingsView.swift */; };
34: 		1051 /* TerminalView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2051 /* TerminalView.swift */; };
35: 		1052 /* DebugManager.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2052 /* DebugManager.swift */; };
36: 		1053 /* DebugView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2053 /* DebugView.swift */; };
37: 		1054 /* WorkspaceTrustManager.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2054 /* WorkspaceTrustManager.swift */; };
38: 		1055 /* AIManager.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2055 /* AIManager.swift */; };
39: 		1056 /* ColorPickerManager.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2056 /* ColorPickerManager.swift */; };
40: 		1057 /* GitManager.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2057 /* GitManager.swift */; };
41: 		1058 /* GitService.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2058 /* GitService.swift */; };
42: 		1059 /* HoverInfoManager.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2059 /* HoverInfoManager.swift */; };
43: 		1060 /* LaunchManager.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2060 /* LaunchManager.swift */; };
44: 		1061 /* NavigationManager.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2061 /* NavigationManager.swift */; };
45: 		1062 /* RecentFileManager.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2062 /* RecentFileManager.swift */; };
46: 		1063 /* SearchManager.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2063 /* SearchManager.swift */; };
47: 		1064 /* SettingsManager.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2064 /* SettingsManager.swift */; };
48: 		1065 /* SnippetsManager.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2065 /* SnippetsManager.swift */; };
49: 		1066 /* TasksManager.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2066 /* TasksManager.swift */; };
50: 		1067 /* WorkspaceManager.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2067 /* WorkspaceManager.swift */; };
51: 		1068 /* FileIcons.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2068 /* FileIcons.swift */; };
52: 		1069 /* FileTreeView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2069 /* FileTreeView.swift */; };
53: 		1070 /* SpotlightManager.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2070 /* SpotlightManager.swift */; };
54: 		1101 /* BranchMenu.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2101 /* BranchMenu.swift */; };
55: 		1102 /* CommandPalette.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2102 /* CommandPalette.swift */; };
56: 		1103 /* DiffComponents.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2103 /* DiffComponents.swift */; };
57: 		1104 /* FileIconView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2104 /* FileIconView.swift */; };
58: 		1105 /* GoToSymbol.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2105 /* GoToSymbol.swift */; };
59: 		1106 /* LaunchConfigView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2106 /* LaunchConfigView.swift */; };
60: 		1107 /* QuickOpen.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2107 /* QuickOpen.swift */; };
61: 		1108 /* SidebarView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2108 /* SidebarView.swift */; };
62: 		1109 /* SnippetPickerView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2109 /* SnippetPickerView.swift */; };
63: 		1110 /* StatusBarView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2110 /* StatusBarView.swift */; };
64: 		1111 /* TabBarView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2111 /* TabBarView.swift */; };
65: 		1112 /* TasksView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2112 /* TasksView.swift */; };
66: 		1113 /* WorkspaceSettingsView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2113 /* WorkspaceSettingsView.swift */; };
67: 		1114 /* WorkspaceTrustDialog.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2114 /* WorkspaceTrustDialog.swift */; };
68: 		1115 /* OutputView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2115 /* OutputView.swift */; };
69: 		1116 /* SearchView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2116 /* SearchView.swift */; };
70: 		1117 /* MarkdownPreviewView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2117 /* MarkdownPreviewView.swift */; };
71: 		1118 /* AIAssistantView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2118 /* AIAssistantView.swift */; };
72: 		1119 /* GitQuickActionsView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2119 /* GitQuickActionsView.swift */; };
73: 		1120 /* MarkdownPreviewWrapper.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2120 /* MarkdownPreviewWrapper.swift */; };
74: 		1121 /* TestView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2121 /* TestView.swift */; };
75: 		1122 /* PanelView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2122 /* PanelView.swift */; };
76: 		1123 /* ProblemsView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2123 /* ProblemsView.swift */; };
77: 		1124 /* OutlineView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2124 /* OutlineView.swift */; };
78: 		1125 /* TimelineView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2125 /* TimelineView.swift */; };
79: 		1126 /* DebugConsoleView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2126 /* DebugConsoleView.swift */; };
80: 		1127 /* SplitEditorView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2127 /* SplitEditorView.swift */; };
81: 		1128 /* StickyHeaderView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2128 /* StickyHeaderView.swift */; };
82: 		1129 /* ColorPickerView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2129 /* ColorPickerView.swift */; };
83: 		1130 /* MultiCursorTextView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2130 /* MultiCursorTextView.swift */; };
84: 		1131 /* JSONTreeView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2131 /* JSONTreeView.swift */; };
85: 		1132 /* EditorSplitView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2132 /* EditorSplitView.swift */; };
86: 		1133 /* InlayHintsOverlay.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2133 /* InlayHintsOverlay.swift */; };
87: 
88: 		1135 /* HoverInfoView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2135 /* HoverInfoView.swift */; };
89: 		1136 /* BreadcrumbsView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2136 /* BreadcrumbsView.swift */; };
90: 
91: 		1138 /* PeekDefinitionView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2138 /* PeekDefinitionView.swift */; };
92: 		1139 /* InlayHintsManager.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2139 /* InlayHintsManager.swift */; };
93: 		1140 /* FileHelpers.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2140 /* FileHelpers.swift */; };
94: 		1141 /* Notification+Search.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2141 /* Notification+Search.swift */; };
95: 		1142 /* SSHManager.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2142 /* SSHManager.swift */; };
96: 		1143 /* AppDelegate.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2143 /* AppDelegate.swift */; };
97: 		1144 /* SceneDelegate.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2144 /* SceneDelegate.swift */; };
98: 		1099 /* Assets.xcassets in Resources */ = {isa = PBXBuildFile; fileRef = 2099 /* Assets.xcassets */; };
99: /* End PBXBuildFile section */
100: 
101: /* Begin PBXFileReference section */
102: 		2001 /* ContentView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ContentView.swift; sourceTree = "<group>"; };
103: 		2002 /* VSCodeiPadOSApp.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = VSCodeiPadOSApp.swift; sourceTree = "<group>"; };
104: 		2003 /* AppCommands.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = AppCommands.swift; sourceTree = "<group>"; };
105: 		2004 /* Color+Hex.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = "Color+Hex.swift"; sourceTree = "<group>"; };
106: 		2005 /* FileManager+Extension.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = "FileManager+Extension.swift"; sourceTree = "<group>"; };
107: 		2006 /* FileManager+Extensions.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = "FileManager+Extensions.swift"; sourceTree = "<group>"; };
108: 		2007 /* NSAttributedStringSyntaxHighlighter.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = NSAttributedStringSyntaxHighlighter.swift; sourceTree = "<group>"; };
109: 		2009 /* EditorState.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = EditorState.swift; sourceTree = "<group>"; };
110: 		2012 /* FileItem.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = FileItem.swift; sourceTree = "<group>"; };
111: 		2013 /* FileItemUTType.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = FileItemUTType.swift; sourceTree = "<group>"; };
112: 		2015 /* FindViewModel.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = FindViewModel.swift; sourceTree = "<group>"; };
113: 		2016 /* MultiCursor.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = MultiCursor.swift; sourceTree = "<group>"; };
114: 		2017 /* Tab.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = Tab.swift; sourceTree = "<group>"; };
115: 		2018 /* Theme.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = Theme.swift; sourceTree = "<group>"; };
116: 		2019 /* AutocompleteManager.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = AutocompleteManager.swift; sourceTree = "<group>"; };
117: 		2020 /* ThemeManager.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ThemeManager.swift; sourceTree = "<group>"; };
118: 		2022 /* CodeFoldingManager.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = CodeFoldingManager.swift; sourceTree = "<group>"; };
119: 		2023 /* EditorCore.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = EditorCore.swift; sourceTree = "<group>"; };
120: 		2025 /* FileSystemNavigator.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = FileSystemNavigator.swift; sourceTree = "<group>"; };


>>>TOOL search
{"query":"2145", "glob":"VSCodeiPadOS/VSCodeiPadOS.xcodeproj/project.pbxproj"}
>>>END
>>>TOOL search
{"query":"1145", "glob":"VSCodeiPadOS/VSCodeiPadOS.xcodeproj/project.pbxproj"}
>>>END
>>>TOOL search
{"query":"FoldingLayoutManager.swift", "glob":"VSCodeiPadOS/VSCodeiPadOS.xcodeproj/project.pbxproj"}
>>>END
>>>END

---

## üîß TOOL RESULTS

[search]
No matches found for "2145"

---

[search]
No matches found for "1145"

---

[search]
No matches found for "FoldingLayoutManager.swift"


>>>TOOL web_fetch
{"url":"https://developer.apple.com/documentation/uikit/nslayoutmanagerdelegate/layoutmanager(_:shouldsetlinefragmentrect:linefragmentusedrect:baselineoffset:in:forglyphrange:)", "max_length": 1200}
>>>END
>>>END

---

## üîß TOOL RESULTS

[web_fetch]
üåê https://developer.apple.com/documentation/uikit/nslayoutmanagerdelegate/layoutmanager(_:shouldsetlinefragmentrect:linefragmentusedrect:baselineoffset:in:forglyphrange:)

‚Ä¢ 
‚Ä¢ layoutManager(_:shouldSetLineFragmentRect:lineFragmentUsedRect:baselineOffset:in:forGlyphRange:) | Apple Developer Documentation
‚Ä¢ 
‚Ä¢ 
‚Ä¢ 
# This page requires JavaScript.

Please turn on JavaScript in your browser and refresh the page to view its content.


>>>TOOL search
{"query":"Views", "glob":"VSCodeiPadOS/VSCodeiPadOS.xcodeproj/project.pbxproj"}
>>>END
>>>TOOL search
{"query":"FoldingLayoutManager", "glob":"VSCodeiPadOS/VSCodeiPadOS.xcodeproj/project.pbxproj"}
>>>END
>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS.xcodeproj/project.pbxproj","start_line":110,"end_line":220}
>>>END
>>>END

---

## üîß TOOL RESULTS

[search]
Found 3 matches:
VSCodeiPadOS/VSCodeiPadOS.xcodeproj/project.pbxproj:213: 4007 /* Views */,
VSCodeiPadOS/VSCodeiPadOS.xcodeproj/project.pbxproj:294: 4007 /* Views */ = {
VSCodeiPadOS/VSCodeiPadOS.xcodeproj/project.pbxproj:318: path = Views;

---

[search]
No matches found for "FoldingLayoutManager"

---

[read_file]
File: VSCodeiPadOS/VSCodeiPadOS.xcodeproj/project.pbxproj (lines 111-220 of 756)
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
111: 		2013 /* FileItemUTType.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = FileItemUTType.swift; sourceTree = "<group>"; };
112: 		2015 /* FindViewModel.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = FindViewModel.swift; sourceTree = "<group>"; };
113: 		2016 /* MultiCursor.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = MultiCursor.swift; sourceTree = "<group>"; };
114: 		2017 /* Tab.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = Tab.swift; sourceTree = "<group>"; };
115: 		2018 /* Theme.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = Theme.swift; sourceTree = "<group>"; };
116: 		2019 /* AutocompleteManager.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = AutocompleteManager.swift; sourceTree = "<group>"; };
117: 		2020 /* ThemeManager.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ThemeManager.swift; sourceTree = "<group>"; };
118: 		2022 /* CodeFoldingManager.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = CodeFoldingManager.swift; sourceTree = "<group>"; };
119: 		2023 /* EditorCore.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = EditorCore.swift; sourceTree = "<group>"; };
120: 		2025 /* FileSystemNavigator.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = FileSystemNavigator.swift; sourceTree = "<group>"; };
121: 		2035 /* MinimapView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = MinimapView.swift; sourceTree = "<group>"; };
122: 		2036 /* SyntaxHighlightingTextView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SyntaxHighlightingTextView.swift; sourceTree = "<group>"; };
123: 		2043 /* GitView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = GitView.swift; sourceTree = "<group>"; };
124: 		2044 /* GoToLineView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = GoToLineView.swift; sourceTree = "<group>"; };
125: 		2050 /* SettingsView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SettingsView.swift; sourceTree = "<group>"; };
126: 		2051 /* TerminalView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = TerminalView.swift; sourceTree = "<group>"; };
127: 		2052 /* DebugManager.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = DebugManager.swift; sourceTree = "<group>"; };
128: 		2053 /* DebugView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = DebugView.swift; sourceTree = "<group>"; };
129: 		2054 /* WorkspaceTrustManager.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = WorkspaceTrustManager.swift; sourceTree = "<group>"; };
130: 		2055 /* AIManager.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = AIManager.swift; sourceTree = "<group>"; };
131: 		2056 /* ColorPickerManager.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ColorPickerManager.swift; sourceTree = "<group>"; };
132: 		2057 /* GitManager.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = GitManager.swift; sourceTree = "<group>"; };
133: 		2058 /* GitService.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = GitService.swift; sourceTree = "<group>"; };
134: 		2059 /* HoverInfoManager.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = HoverInfoManager.swift; sourceTree = "<group>"; };
135: 		2060 /* LaunchManager.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = LaunchManager.swift; sourceTree = "<group>"; };
136: 		2061 /* NavigationManager.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = NavigationManager.swift; sourceTree = "<group>"; };
137: 		2062 /* RecentFileManager.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = RecentFileManager.swift; sourceTree = "<group>"; };
138: 		2063 /* SearchManager.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SearchManager.swift; sourceTree = "<group>"; };
139: 		2064 /* SettingsManager.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SettingsManager.swift; sourceTree = "<group>"; };
140: 		2065 /* SnippetsManager.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SnippetsManager.swift; sourceTree = "<group>"; };
141: 		2066 /* TasksManager.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = TasksManager.swift; sourceTree = "<group>"; };
142: 		2067 /* WorkspaceManager.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = WorkspaceManager.swift; sourceTree = "<group>"; };
143: 		2068 /* FileIcons.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = FileIcons.swift; sourceTree = "<group>"; };
144: 		2069 /* FileTreeView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = FileTreeView.swift; sourceTree = "<group>"; };
145: 		2070 /* SpotlightManager.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SpotlightManager.swift; sourceTree = "<group>"; };
146: 		2101 /* BranchMenu.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = BranchMenu.swift; sourceTree = "<group>"; };
147: 		2102 /* CommandPalette.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = CommandPalette.swift; sourceTree = "<group>"; };
148: 		2103 /* DiffComponents.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = DiffComponents.swift; sourceTree = "<group>"; };
149: 		2104 /* FileIconView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = FileIconView.swift; sourceTree = "<group>"; };
150: 		2105 /* GoToSymbol.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = GoToSymbol.swift; sourceTree = "<group>"; };
151: 		2106 /* LaunchConfigView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = LaunchConfigView.swift; sourceTree = "<group>"; };
152: 		2107 /* QuickOpen.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = QuickOpen.swift; sourceTree = "<group>"; };
153: 		2108 /* SidebarView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SidebarView.swift; sourceTree = "<group>"; };
154: 		2109 /* SnippetPickerView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SnippetPickerView.swift; sourceTree = "<group>"; };
155: 		2110 /* StatusBarView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = StatusBarView.swift; sourceTree = "<group>"; };
156: 		2111 /* TabBarView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = TabBarView.swift; sourceTree = "<group>"; };
157: 		2112 /* TasksView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = TasksView.swift; sourceTree = "<group>"; };
158: 		2113 /* WorkspaceSettingsView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = WorkspaceSettingsView.swift; sourceTree = "<group>"; };
159: 		2114 /* WorkspaceTrustDialog.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = WorkspaceTrustDialog.swift; sourceTree = "<group>"; };
160: 		2115 /* OutputView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = OutputView.swift; sourceTree = "<group>"; };
161: 		2116 /* SearchView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SearchView.swift; sourceTree = "<group>"; };
162: 		2117 /* MarkdownPreviewView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = MarkdownPreviewView.swift; sourceTree = "<group>"; };
163: 		2118 /* AIAssistantView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = AIAssistantView.swift; sourceTree = "<group>"; };
164: 		2119 /* GitQuickActionsView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = GitQuickActionsView.swift; sourceTree = "<group>"; };
165: 		2120 /* MarkdownPreviewWrapper.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = MarkdownPreviewWrapper.swift; sourceTree = "<group>"; };
166: 		2121 /* TestView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = TestView.swift; sourceTree = "<group>"; };
167: 		2122 /* PanelView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PanelView.swift; sourceTree = "<group>"; };
168: 		2123 /* ProblemsView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ProblemsView.swift; sourceTree = "<group>"; };
169: 		2124 /* OutlineView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = OutlineView.swift; sourceTree = "<group>"; };
170: 		2125 /* TimelineView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = TimelineView.swift; sourceTree = "<group>"; };
171: 		2126 /* DebugConsoleView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = DebugConsoleView.swift; sourceTree = "<group>"; };
172: 		2127 /* SplitEditorView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SplitEditorView.swift; sourceTree = "<group>"; };
173: 		2128 /* StickyHeaderView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = StickyHeaderView.swift; sourceTree = "<group>"; };
174: 		2129 /* ColorPickerView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ColorPickerView.swift; sourceTree = "<group>"; };
175: 		2130 /* MultiCursorTextView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = MultiCursorTextView.swift; sourceTree = "<group>"; };
176: 		2131 /* JSONTreeView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = JSONTreeView.swift; sourceTree = "<group>"; };
177: 		2132 /* EditorSplitView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = EditorSplitView.swift; sourceTree = "<group>"; };
178: 		2133 /* InlayHintsOverlay.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = InlayHintsOverlay.swift; sourceTree = "<group>"; };
179: 
180: 		2135 /* HoverInfoView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = HoverInfoView.swift; sourceTree = "<group>"; };
181: 		2136 /* BreadcrumbsView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = BreadcrumbsView.swift; sourceTree = "<group>"; };
182: 
183: 		2138 /* PeekDefinitionView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PeekDefinitionView.swift; sourceTree = "<group>"; };
184: 		2139 /* InlayHintsManager.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = InlayHintsManager.swift; sourceTree = "<group>"; };
185: 		2140 /* FileHelpers.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = FileHelpers.swift; sourceTree = "<group>"; };
186: 		2141 /* Notification+Search.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = "Notification+Search.swift"; sourceTree = "<group>"; };
187: 		2142 /* SSHManager.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SSHManager.swift; sourceTree = "<group>"; };
188: 		2143 /* AppDelegate.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = AppDelegate.swift; sourceTree = "<group>"; };
189: 		2144 /* SceneDelegate.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SceneDelegate.swift; sourceTree = "<group>"; };
190: 		2099 /* Assets.xcassets */ = {isa = PBXFileReference; lastKnownFileType = folder.assetcatalog; path = Assets.xcassets; sourceTree = "<group>"; };
191: 		3000 /* VSCodeiPadOS.app */ = {isa = PBXFileReference; explicitFileType = wrapper.application; includeInIndex = 0; path = VSCodeiPadOS.app; sourceTree = BUILT_PRODUCTS_DIR; };
192: /* End PBXFileReference section */
193: 
194: /* Begin PBXGroup section */
195: 		4000 = {
196: 			isa = PBXGroup;
197: 			children = (
198: 				4001 /* VSCodeiPadOS */,
199: 				4099 /* Products */,
200: 			);
201: 			sourceTree = "<group>";
202: 		};
203: 		4001 /* VSCodeiPadOS */ = {
204: 			isa = PBXGroup;
205: 			children = (
206: 				2001 /* ContentView.swift */,
207: 				2099 /* Assets.xcassets */,
208: 				4002 /* App */,
209: 				4003 /* Commands */,
210: 				4004 /* Extensions */,
211: 				4005 /* Models */,
212: 				4006 /* Services */,
213: 				4007 /* Views */,
214: 			);
215: 			path = VSCodeiPadOS;
216: 			sourceTree = "<group>";
217: 		};
218: 		4002 /* App */ = {
219: 			isa = PBXGroup;
220: 			children = (


>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift","start_line":1,"end_line":130}
>>>END
>>>END

---

## üîß TOOL RESULTS

[read_file]
File: VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift (lines 2-130 of 2062)
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
2: //  SyntaxHighlightingTextView.swift
3: //  VSCodeiPadOS
4: //
5: //  Upgraded syntax highlighting with VSCode-like colors
6: //
7: 
8: import SwiftUI
9: import UIKit
10: 
11: /// UITextView wrapper with syntax highlighting support
12: struct SyntaxHighlightingTextView: UIViewRepresentable {
13:     @Binding var text: String
14:     let filename: String
15:     @Binding var scrollPosition: Int
16:     /// Pixel scroll offset (contentOffset.y) for smooth gutter alignment.
17:     @Binding var scrollOffset: CGFloat
18:     @Binding var totalLines: Int
19:     @Binding var visibleLines: Int
20:     @Binding var currentLineNumber: Int
21:     @Binding var currentColumn: Int
22:     @Binding var cursorIndex: Int
23:     @Binding var lineHeight: CGFloat
24:     @Binding var requestedLineSelection: Int?
25:     @Binding var requestedCursorIndex: Int?
26: 
27:     /// Autocomplete key handling hooks (return true if handled)
28:     let onAcceptAutocomplete: (() -> Bool)?
29:     let onDismissAutocomplete: (() -> Bool)?
30: 
31:     let isActive: Bool
32:     let fontSize: CGFloat  // Explicit parameter to trigger SwiftUI updates
33:     @EnvironmentObject var editorCore: EditorCore
34: 
35:     init(
36:         text: Binding<String>,
37:         filename: String,
38:         scrollPosition: Binding<Int>,
39:         scrollOffset: Binding<CGFloat> = .constant(0),
40:         totalLines: Binding<Int>,
41:         visibleLines: Binding<Int>,
42:         currentLineNumber: Binding<Int>,
43:         currentColumn: Binding<Int>,
44:         cursorIndex: Binding<Int> = .constant(0),
45:         lineHeight: Binding<CGFloat>,
46:         isActive: Bool,
47:         fontSize: CGFloat = 14.0,
48:         requestedLineSelection: Binding<Int?> = .constant(nil),
49:         requestedCursorIndex: Binding<Int?> = .constant(nil),
50:         onAcceptAutocomplete: (() -> Bool)? = nil,
51:         onDismissAutocomplete: (() -> Bool)? = nil
52:     ) {
53:         self._text = text
54:         self.filename = filename
55:         self._scrollPosition = scrollPosition
56:         self._scrollOffset = scrollOffset
57:         self._totalLines = totalLines
58:         self._visibleLines = visibleLines
59:         self._currentLineNumber = currentLineNumber
60:         self._currentColumn = currentColumn
61:         self._cursorIndex = cursorIndex
62:         self._lineHeight = lineHeight
63:         self.isActive = isActive
64:         self.fontSize = fontSize
65:         self._requestedLineSelection = requestedLineSelection
66:         self._requestedCursorIndex = requestedCursorIndex
67:         self.onAcceptAutocomplete = onAcceptAutocomplete
68:         self.onDismissAutocomplete = onDismissAutocomplete
69:     }
70:     
71:     // Compatibility init for older call sites (e.g. SplitEditorView) that pass editorCore explicitly.
72:     init(
73:         text: Binding<String>,
74:         filename: String,
75:         scrollPosition: Binding<Int>,
76:         scrollOffset: Binding<CGFloat> = .constant(0),
77:         totalLines: Binding<Int>,
78:         visibleLines: Binding<Int>,
79:         currentLineNumber: Binding<Int>,
80:         currentColumn: Binding<Int>,
81:         cursorIndex: Binding<Int> = .constant(0),
82:         lineHeight: Binding<CGFloat>,
83:         isActive: Bool,
84:         editorCore: EditorCore,
85:         requestedLineSelection: Binding<Int?> = .constant(nil),
86:         requestedCursorIndex: Binding<Int?> = .constant(nil),
87:         onAcceptAutocomplete: (() -> Bool)? = nil,
88:         onDismissAutocomplete: (() -> Bool)? = nil
89:     ) {
90:         self.init(
91:             text: text,
92:             filename: filename,
93:             scrollPosition: scrollPosition,
94:             scrollOffset: scrollOffset,
95:             totalLines: totalLines,
96:             visibleLines: visibleLines,
97:             currentLineNumber: currentLineNumber,
98:             currentColumn: currentColumn,
99:             cursorIndex: cursorIndex,
100:             lineHeight: lineHeight,
101:             isActive: isActive,
102:             fontSize: editorCore.editorFontSize,
103:             requestedLineSelection: requestedLineSelection,
104:             requestedCursorIndex: requestedCursorIndex,
105:             onAcceptAutocomplete: onAcceptAutocomplete,
106:             onDismissAutocomplete: onDismissAutocomplete
107:         )
108:     }
109: 
110:     func makeCoordinator() -> Coordinator {
111:         Coordinator(self)
112:     }
113:     
114:     func makeUIView(context: Context) -> UITextView {
115:         let textView = EditorTextView()
116:         textView.delegate = context.coordinator
117:         textView.editorCore = editorCore
118: 
119:         // Autocomplete hooks
120:         textView.onAcceptAutocomplete = onAcceptAutocomplete
121:         textView.onDismissAutocomplete = onDismissAutocomplete
122: 
123:         textView.onPeekDefinition = {
124:             context.coordinator.handlePeekDefinition(in: textView)
125:         }
126: 
127:         textView.onEscape = {
128:             context.coordinator.handleEscape()
129:         }
130: 


>>>TOOL search
{"query":"Begin PBXSourcesBuildPhase section", "glob":"VSCodeiPadOS/VSCodeiPadOS.xcodeproj/project.pbxproj"}
>>>END
>>>TOOL read_file
{"path":"VSCodeiPadOS/VSCodeiPadOS.xcodeproj/project.pbxproj","start_line":440,"end_line":560}
>>>END
>>>END

---

## üîß TOOL RESULTS

[search]
Found 1 matches:
VSCodeiPadOS/VSCodeiPadOS.xcodeproj/project.pbxproj:458: /* Begin PBXSourcesBuildPhase section */

---

[read_file]
File: VSCodeiPadOS/VSCodeiPadOS.xcodeproj/project.pbxproj (lines 441-560 of 756)
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
441: 			targets = (
442: 				5000 /* VSCodeiPadOS */,
443: 			);
444: 		};
445: /* End PBXProject section */
446: 
447: /* Begin PBXResourcesBuildPhase section */
448: 		5002 /* Resources */ = {
449: 			isa = PBXResourcesBuildPhase;
450: 			buildActionMask = 2147483647;
451: 			files = (
452: 				1099 /* Assets.xcassets in Resources */,
453: 			);
454: 			runOnlyForDeploymentPostprocessing = 0;
455: 		};
456: /* End PBXResourcesBuildPhase section */
457: 
458: /* Begin PBXSourcesBuildPhase section */
459: 		5001 /* Sources */ = {
460: 			isa = PBXSourcesBuildPhase;
461: 			buildActionMask = 2147483647;
462: 			files = (
463: 				1001 /* ContentView.swift in Sources */,
464: 				1002 /* VSCodeiPadOSApp.swift in Sources */,
465: 				1003 /* AppCommands.swift in Sources */,
466: 				1004 /* Color+Hex.swift in Sources */,
467: 				1005 /* FileManager+Extension.swift in Sources */,
468: 				1006 /* FileManager+Extensions.swift in Sources */,
469: 				1007 /* NSAttributedStringSyntaxHighlighter.swift in Sources */,
470: 				1068 /* FileIcons.swift in Sources */,
471: 				1140 /* FileHelpers.swift in Sources */,
472: 				1141 /* Notification+Search.swift in Sources */,
473: 				1142 /* SSHManager.swift in Sources */,
474: 				1143 /* AppDelegate.swift in Sources */,
475: 				1144 /* SceneDelegate.swift in Sources */,
476: 				1009 /* EditorState.swift in Sources */,
477: 				1012 /* FileItem.swift in Sources */,
478: 				1013 /* FileItemUTType.swift in Sources */,
479: 				1015 /* FindViewModel.swift in Sources */,
480: 				1016 /* MultiCursor.swift in Sources */,
481: 				1017 /* Tab.swift in Sources */,
482: 				1018 /* Theme.swift in Sources */,
483: 				1019 /* AutocompleteManager.swift in Sources */,
484: 				1020 /* ThemeManager.swift in Sources */,
485: 				1022 /* CodeFoldingManager.swift in Sources */,
486: 				1023 /* EditorCore.swift in Sources */,
487: 				1025 /* FileSystemNavigator.swift in Sources */,
488: 				1139 /* InlayHintsManager.swift in Sources */,
489: 				1069 /* FileTreeView.swift in Sources */,
490: 				1104 /* FileIconView.swift in Sources */,
491: 				1109 /* SnippetPickerView.swift in Sources */,
492: 				1108 /* SidebarView.swift in Sources */,
493: 				1106 /* LaunchConfigView.swift in Sources */,
494: 				1111 /* TabBarView.swift in Sources */,
495: 				1103 /* DiffComponents.swift in Sources */,
496: 				1105 /* GoToSymbol.swift in Sources */,
497: 				1113 /* WorkspaceSettingsView.swift in Sources */,
498: 				1102 /* CommandPalette.swift in Sources */,
499: 				1110 /* StatusBarView.swift in Sources */,
500: 				1112 /* TasksView.swift in Sources */,
501: 				1107 /* QuickOpen.swift in Sources */,
502: 				1101 /* BranchMenu.swift in Sources */,
503: 				1114 /* WorkspaceTrustDialog.swift in Sources */,
504: 				1127 /* SplitEditorView.swift in Sources */,
505: 				1128 /* StickyHeaderView.swift in Sources */,
506: 				1129 /* ColorPickerView.swift in Sources */,
507: 				1130 /* MultiCursorTextView.swift in Sources */,
508: 				1131 /* JSONTreeView.swift in Sources */,
509: 				1132 /* EditorSplitView.swift in Sources */,
510: 				1133 /* InlayHintsOverlay.swift in Sources */,
511: 
512: 				1135 /* HoverInfoView.swift in Sources */,
513: 				1136 /* BreadcrumbsView.swift in Sources */,
514: 
515: 				1138 /* PeekDefinitionView.swift in Sources */,
516: 				1035 /* MinimapView.swift in Sources */,
517: 				1036 /* SyntaxHighlightingTextView.swift in Sources */,
518: 				1043 /* GitView.swift in Sources */,
519: 				1119 /* GitQuickActionsView.swift in Sources */,
520: 				1044 /* GoToLineView.swift in Sources */,
521: 				1124 /* OutlineView.swift in Sources */,
522: 				1115 /* OutputView.swift in Sources */,
523: 				1122 /* PanelView.swift in Sources */,
524: 				1123 /* ProblemsView.swift in Sources */,
525: 				1116 /* SearchView.swift in Sources */,
526: 				1117 /* MarkdownPreviewView.swift in Sources */,
527: 				1120 /* MarkdownPreviewWrapper.swift in Sources */,
528: 				1125 /* TimelineView.swift in Sources */,
529: 				1126 /* DebugConsoleView.swift in Sources */,
530: 				1118 /* AIAssistantView.swift in Sources */,
531: 				1121 /* TestView.swift in Sources */,
532: 				1050 /* SettingsView.swift in Sources */,
533: 				1051 /* TerminalView.swift in Sources */,
534: 				1052 /* DebugManager.swift in Sources */,
535: 				1053 /* DebugView.swift in Sources */,
536: 				1054 /* WorkspaceTrustManager.swift in Sources */,
537: 				1055 /* AIManager.swift in Sources */,
538: 				1056 /* ColorPickerManager.swift in Sources */,
539: 				1057 /* GitManager.swift in Sources */,
540: 				1058 /* GitService.swift in Sources */,
541: 				1059 /* HoverInfoManager.swift in Sources */,
542: 				1060 /* LaunchManager.swift in Sources */,
543: 				1061 /* NavigationManager.swift in Sources */,
544: 				1062 /* RecentFileManager.swift in Sources */,
545: 				1063 /* SearchManager.swift in Sources */,
546: 				1064 /* SettingsManager.swift in Sources */,
547: 				1065 /* SnippetsManager.swift in Sources */,
548: 				1066 /* TasksManager.swift in Sources */,
549: 				1067 /* WorkspaceManager.swift in Sources */,
550: 				1070 /* SpotlightManager.swift in Sources */,
551: 			);
552: 			runOnlyForDeploymentPostprocessing = 0;
553: 		};
554: /* End PBXSourcesBuildPhase section */
555: 
556: /* Begin XCBuildConfiguration section */
557: 		6001 /* Debug */ = {
558: 			isa = XCBuildConfiguration;
559: 			buildSettings = {
560: 				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;


‚ùå API Error (iteration 57): terminated
