# Agent: debug-syntax-deep
**Status:** done
**Tokens:** 22,346
**Cost:** $0.0000
**Time:** 2026-02-09T23:32:01.404Z

## Task
CRITICAL: Syntax highlighting still flickers and disappears while typing. Read VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift COMPLETELY. Find textViewDidChange, the debounce timer, and applySyntaxHighlighting. Check if text is being reset to plain somewhere. Find EVERY place attributedText or text property is modified.

## Response
I'll read the SyntaxHighlightingTextView.swift file completely to investigate the flickering issue.

>>>TOOL read_file
{"path": "VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift"}
>>>END

Let me read more sections of the file to find the critical methods:

>>>TOOL read_file
{"path": "VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift", "start_line": 100, "end_line": 300}
>>>END

---

## ðŸ”§ TOOL RESULTS

[read_file]
File: VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift (lines 101-300 of 1767)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
101:         Coordinator(self)
102:     }
103:     
104:     func makeUIView(context: Context) -> UITextView {
105:         let textView = EditorTextView()
106:         textView.delegate = context.coordinator
107: 
108:         // Autocomplete hooks
109:         textView.onAcceptAutocomplete = onAcceptAutocomplete
110:         textView.onDismissAutocomplete = onDismissAutocomplete
111: 
112:         textView.onPeekDefinition = {
113:             context.coordinator.handlePeekDefinition(in: textView)
114:         }
115: 
116:         textView.onEscape = {
117:             context.coordinator.handleEscape()
118:         }
119: 
120:         textView.onGoToLine = {
121:             self.editorCore.showGoToLine = true
122:         }
123:         
124:         // Wire up custom context menu actions
125:         textView.onGoToDefinition = {
126:             context.coordinator.handleGoToDefinition(in: textView)
127:         }
128:         
129:         textView.onFindReferences = {
130:             context.coordinator.handleFindReferences(in: textView)
131:         }
132:         
133:         textView.onFormatDocument = {
134:             context.coordinator.handleFormatDocument(in: textView)
135:         }
136:         
137:         textView.onToggleComment = {
138:             context.coordinator.handleToggleComment(in: textView)
139:         }
140:         
141:         textView.onFold = {
142:             context.coordinator.handleFold(in: textView)
143:         }
144:         
145:         textView.onUnfold = {
146:             context.coordinator.handleUnfold(in: textView)
147:         }
148:         
149:         // Add pinch gesture for zoom
150:         let pinchGesture = UIPinchGestureRecognizer(target: context.coordinator, action: #selector(Coordinator.handlePinch(_:)))
151:         textView.addGestureRecognizer(pinchGesture)
152:         context.coordinator.pinchGesture = pinchGesture
153:         
154:         // Configure text view
155:         textView.isEditable = true
156:         textView.isSelectable = true
157:         textView.autocapitalizationType = .none
158:         textView.autocorrectionType = .no
159:         textView.smartDashesType = .no
160:         textView.smartQuotesType = .no
161:         textView.smartInsertDeleteType = .no
162:         textView.spellCheckingType = .no
163:         
164:         // Set font and appearance (use editorCore.editorFontSize)
165:         textView.font = UIFont.monospacedSystemFont(ofSize: editorCore.editorFontSize, weight: .regular)
166:         textView.textColor = UIColor(ThemeManager.shared.currentTheme.editorForeground)
167:         textView.backgroundColor = UIColor(ThemeManager.shared.currentTheme.editorBackground)
168:         textView.keyboardType = .default
169:         textView.textContainerInset = UIEdgeInsets(top: 8, left: 8, bottom: 8, right: 8)
170:         
171:         // Enable line wrapping
172:         textView.textContainer.lineBreakMode = .byCharWrapping
173:         textView.textContainer.widthTracksTextView = true
174:         
175:         // Calculate line height
176:         if let font = textView.font {
177:             DispatchQueue.main.async {
178:                 self.lineHeight = font.lineHeight
179:             }
180:         }
181:         
182:         // Set initial text with syntax highlighting
183:         textView.text = text
184:         context.coordinator.applySyntaxHighlighting(to: textView)
185:         context.coordinator.updateLineCount(textView)
186:         
187:         return textView
188:     }
189:     
190:     func updateUIView(_ textView: UITextView, context: Context) {
191:         // Update colors when theme changes
192:         textView.backgroundColor = UIColor(ThemeManager.shared.currentTheme.editorBackground)
193:         textView.textColor = UIColor(ThemeManager.shared.currentTheme.editorForeground)
194:         textView.tintColor = UIColor(ThemeManager.shared.currentTheme.cursor)
195:         
196:         if let editorView = textView as? EditorTextView {
197:             editorView.updateThemeColors(theme: ThemeManager.shared.currentTheme)
198:         }
199:         
200:         // Update font size if changed
201:         if let currentFont = textView.font, currentFont.pointSize != editorCore.editorFontSize {
202:             let selectedRange = textView.selectedRange
203:             textView.font = UIFont.monospacedSystemFont(ofSize: editorCore.editorFontSize, weight: .regular)
204:             context.coordinator.applySyntaxHighlighting(to: textView)
205:             textView.selectedRange = selectedRange
206:             
207:             // Update line height
208:             if let font = textView.font {
209:                 DispatchQueue.main.async {
210:                     self.lineHeight = font.lineHeight
211:                 }
212:             }
213:         }
214:         
215:         // Update text if changed externally
216:         if textView.text != text {
217:             let selectedRange = textView.selectedRange
218:             textView.text = text
219:             context.coordinator.applySyntaxHighlighting(to: textView)
220:             textView.selectedRange = selectedRange
221:         } else if context.coordinator.lastThemeId != ThemeManager.shared.currentTheme.id {
222:             // Re-apply highlighting if theme changed
223:             context.coordinator.applySyntaxHighlighting(to: textView)
224:         }
225:         
226:         // Handle minimap scrolling
227:         if scrollPosition != context.coordinator.lastKnownScrollPosition && scrollPosition >= 0 {
228:             // Update lastKnownScrollPosition FIRST to prevent race condition
229:             // where user scroll gets overridden by stale binding value
230:             context.coordinator.lastKnownScrollPosition = scrollPosition
231:             context.coordinator.scrollToLine(scrollPosition, in: textView)
232:         }
233: 
234:         // Handle line selection requests (e.g. tapping line numbers)
235:         if let requested = requestedLineSelection,
236:            requested != context.coordinator.lastRequestedLineSelection {
237:             context.coordinator.lastRequestedLineSelection = requested
238:             context.coordinator.scrollToAndSelectLine(requested, in: textView)
239:             // Defer @Binding update to avoid "Publishing changes from within view updates"
240:             DispatchQueue.main.async {
241:                 self.requestedLineSelection = nil
242:             }
243:         }
244: 
245:         // Handle cursor index requests (e.g. accepting autocomplete)
246:         if let requested = requestedCursorIndex,
247:            requested != context.coordinator.lastRequestedCursorIndex {
248:             context.coordinator.lastRequestedCursorIndex = requested
249:             textView.selectedRange = NSRange(location: max(0, requested), length: 0)
250:             // Defer @Binding update to avoid "Publishing changes from within view updates"
251:             DispatchQueue.main.async {
252:                 self.requestedCursorIndex = nil
253:             }
254: 
255:             // Update SwiftUI state
256:             context.coordinator.updateCursorPosition(textView)
257:             context.coordinator.updateScrollPosition(textView)
258:         }
259:         
260:         // Note: updateLineCount is called in textViewDidChange, no need to call here
261:         // as it causes unnecessary state churn on every updateUIView
262:     }
263:     
264:     // MARK: - Coordinator
265:     
266:     class Coordinator: NSObject, UITextViewDelegate {
267:         var parent: SyntaxHighlightingTextView
268:         var lastKnownScrollPosition: Int = 0
269:         var lastThemeId: String = ""
270:         var lastRequestedLineSelection: Int? = nil
271:         var lastRequestedCursorIndex: Int? = nil
272:         private var isUpdatingFromMinimap = false
273:         private var highlightDebouncer: Timer?
274:         weak var pinchGesture: UIPinchGestureRecognizer?
275:         private var initialFontSize: CGFloat = 0
276: 
277:         // FEAT-044: Matching bracket highlight state
278:         private var bracketHighlightRanges: [NSRange] = []
279:         
280:         init(_ parent: SyntaxHighlightingTextView) {
281:             self.parent = parent
282:         }
283:         
284:         func textViewDidChange(_ textView: UITextView) {
285:             // Update parent text
286:             parent.text = textView.text
287:             
288:             // Debounced syntax highlighting for performance
289:             highlightDebouncer?.invalidate()
290:             highlightDebouncer = Timer.scheduledTimer(withTimeInterval: 0.15, repeats: false) { [weak self] _ in
291:                 DispatchQueue.main.async {
292:                     self?.applySyntaxHighlighting(to: textView)
293:                 }
294:             }
295:             
296:             updateLineCount(textView)
297:             updateCursorPosition(textView)
298:         }
299:         
300:         func textViewDidChangeSelection(_ textView: UITextView) {


Let me continue reading to find the applySyntaxHighlighting method:

>>>TOOL read_file
{"path": "VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift", "start_line": 300, "end_line": 500}
>>>END

---

## ðŸ”§ TOOL RESULTS

[read_file]
File: VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift (lines 301-500 of 1767)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
301:             if !isUpdatingFromMinimap {
302:                 updateCursorPosition(textView)
303:                 updateScrollPosition(textView)
304: 
305:                 // FEAT-044: Matching bracket highlight
306:                 updateMatchingBracketHighlight(textView)
307: 
308:                 // Trigger redraw so current-line highlight/indent guides track the caret
309:                 (textView as? EditorTextView)?.setNeedsDisplay()
310: 
311:                 // Update selection in EditorCore for multi-cursor support
312:                 let range = textView.selectedRange
313:                 parent.editorCore.updateSelection(range: range, text: textView.text ?? "")
314: 
315:                 // If user clicks elsewhere (not multi-cursor operation), reset to single cursor
316:                 if !parent.editorCore.multiCursorState.isMultiCursor {
317:                     parent.editorCore.multiCursorState.reset(to: range.location + range.length)
318:                 }
319:             }
320:         }
321:         
322:         func scrollViewDidScroll(_ scrollView: UIScrollView) {
323:             guard let textView = scrollView as? UITextView, !isUpdatingFromMinimap else { return }
324:             updateScrollPosition(textView)
325:         }
326:         
327:         func updateLineCount(_ textView: UITextView) {
328:             let lines = textView.text.components(separatedBy: .newlines)
329:             DispatchQueue.main.async {
330:                 self.parent.totalLines = max(1, lines.count)
331:             }
332:         }
333:         
334:         func updateCursorPosition(_ textView: UITextView) {
335:             guard let selectedRange = textView.selectedTextRange else { return }
336:              let cursorPosition = textView.offset(from: textView.beginningOfDocument, to: selectedRange.start)
337:              
338:              let text = textView.text ?? ""
339:              let prefix = String(text.prefix(cursorPosition))
340:              let lines = prefix.components(separatedBy: .newlines)
341:              
342:              let lineNumber = lines.count
343:              let column = (lines.last?.count ?? 0) + 1
344:              
345:              DispatchQueue.main.async {
346:                  self.parent.currentLineNumber = lineNumber
347:                  self.parent.currentColumn = column
348:                  self.parent.cursorIndex = cursorPosition
349:              }
350:         }
351:         
352:         func updateScrollPosition(_ textView: UITextView) {
353:             guard let font = textView.font else { return }
354:             let lineHeight = font.lineHeight
355:             let scrollOffset = textView.contentOffset.y
356:             let line = Int(scrollOffset / lineHeight)
357:             
358:             lastKnownScrollPosition = line
359:             DispatchQueue.main.async {
360:                 self.parent.scrollPosition = line
361:             }
362:         }
363:         
364:         func scrollToLine(_ line: Int, in textView: UITextView) {
365:             guard !isUpdatingFromMinimap else { return }
366:             isUpdatingFromMinimap = true
367:             
368:             let lines = textView.text.components(separatedBy: .newlines)
369:             guard line >= 0 && line < lines.count else {
370:                 isUpdatingFromMinimap = false
371:                 return
372:             }
373:             
374:             var characterPosition = 0
375:             for i in 0..<line {
376:                 characterPosition += lines[i].count + 1
377:             }
378:             
379:             if let position = textView.position(from: textView.beginningOfDocument, offset: characterPosition) {
380:                 let rect = textView.caretRect(for: position)
381:                 let targetY = max(0, rect.origin.y)
382:                 textView.setContentOffset(CGPoint(x: 0, y: targetY), animated: true)
383:             }
384:             
385:             DispatchQueue.main.asyncAfter(deadline: .now() + 0.3) {
386:                 self.isUpdatingFromMinimap = false
387:             }
388:         }
389: 
390:         func scrollToAndSelectLine(_ line: Int, in textView: UITextView) {
391:             let lines = textView.text.components(separatedBy: .newlines)
392:             guard line >= 0 && line < lines.count else { return }
393: 
394:             var characterPosition = 0
395:             for i in 0..<line {
396:                 characterPosition += lines[i].count + 1
397:             }
398: 
399:             // FEAT-041: select entire line (excluding trailing newline)
400:             let lineLength = (lines[line] as NSString).length
401:             let range = NSRange(location: characterPosition, length: lineLength)
402:             textView.selectedRange = range
403: 
404:             // Ensure it's visible
405:             scrollToLine(line, in: textView)
406: 
407:             // Update SwiftUI state
408:             updateCursorPosition(textView)
409:             updateScrollPosition(textView)
410:         }
411: 
412:         func applySyntaxHighlighting(to textView: UITextView) {
413:             let theme = ThemeManager.shared.currentTheme
414:             lastThemeId = theme.id
415: 
416:             let highlighter = VSCodeSyntaxHighlighter(theme: theme, fontSize: parent.editorCore.editorFontSize)
417:             let attributedText = highlighter.highlight(textView.text, filename: parent.filename)
418: 
419:             let selectedRange = textView.selectedRange
420:             textView.attributedText = attributedText
421:             textView.selectedRange = selectedRange
422: 
423:             // Set typing attributes so newly typed characters have correct base styling
424:             // This prevents flicker during the debounce period before full highlighting runs
425:             let fontSize = parent.editorCore.editorFontSize
426:             textView.typingAttributes = [
427:                 .font: UIFont.monospacedSystemFont(ofSize: fontSize, weight: .regular),
428:                 .foregroundColor: UIColor(theme.editorForeground)
429:             ]
430: 
431:             // FEAT-044: restore matching bracket highlight after re-attributing text
432:             updateMatchingBracketHighlight(textView)
433:         }
434:         
435:         func handlePeekDefinition(in textView: UITextView) {
436:             guard let selectedRange = textView.selectedTextRange else { return }
437:             let text = textView.text ?? ""
438:             
439:             if let range = textView.tokenizer.rangeEnclosingPosition(selectedRange.start, with: .word, inDirection: UITextDirection(rawValue: 1)) {
440:                  let location = textView.offset(from: textView.beginningOfDocument, to: range.start)
441:                  
442:                  let prefix = String(text.prefix(location))
443:                  let sourceLine = prefix.components(separatedBy: CharacterSet.newlines).count - 1
444:                  
445:                  parent.editorCore.triggerPeekDefinition(
446:                      file: parent.filename,
447:                      line: sourceLine,
448:                      content: text,
449:                      sourceLine: sourceLine
450:                  )
451:             }
452:         }
453:         
454:         func handleEscape() {
455:             if parent.editorCore.peekState != nil {
456:                 parent.editorCore.closePeekDefinition()
457:             } else {
458:                 parent.editorCore.escapeMultiCursor()
459:             }
460:         }
461:         
462:         func handleGoToDefinition(in textView: UITextView) {
463:             // Reuse the peek definition logic for now
464:             handlePeekDefinition(in: textView)
465:         }
466:         
467:         func handleFindReferences(in textView: UITextView) {
468:             guard let selectedRange = textView.selectedTextRange else { return }
469:             let text = textView.text ?? ""
470:             
471:             if let range = textView.tokenizer.rangeEnclosingPosition(selectedRange.start, with: .word, inDirection: UITextDirection(rawValue: 1)) {
472:                 let location = textView.offset(from: textView.beginningOfDocument, to: range.start)
473:                 
474:                 let prefix = String(text.prefix(location))
475:                 let sourceLine = prefix.components(separatedBy: CharacterSet.newlines).count - 1
476:                 
477:                 // TODO: Implement find references functionality in EditorCore
478:                 // For now, just trigger peek definition as a placeholder
479:                 parent.editorCore.triggerPeekDefinition(
480:                     file: parent.filename,
481:                     line: sourceLine,
482:                     content: text,
483:                     sourceLine: sourceLine
484:                 )
485:             }
486:         }
487:         
488:         func handleFormatDocument(in textView: UITextView) {
489:             // TODO: Implement format document functionality
490:             // This would typically call a formatter in EditorCore
491:             print("Format Document: Not yet implemented")
492:         }
493:         
494:         func handleToggleComment(in textView: UITextView) {
495:             guard let selectedRange = textView.selectedTextRange else { return }
496:             let text = textView.text ?? ""
497:             
498:             // Get the current line range
499:             if let lineRange = textView.tokenizer.rangeEnclosingPosition(selectedRange.start, with: .paragraph, inDirection: UITextDirection(rawValue: 1)) {
500:                 let location = textView.offset(from: textView.beginningOfDocument, to: lineRange.start)


I found key information. Now let me search for ALL places where `attributedText` or `.text =` is modified in this file:

>>>TOOL search
{"query": "textView.text =", "glob": "VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift"}
>>>END

---

## ðŸ”§ TOOL RESULTS

[search]
Found 2 matches:
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:183: textView.text = text
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:218: textView.text = text


Now let me search for attributedText modifications:

>>>TOOL search
{"query": "attributedText", "glob": "VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift"}
>>>END

---

## ðŸ”§ TOOL RESULTS

[search]
Found 2 matches:
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:417: let attributedText = highlighter.highlight(textView.text, filename: parent.filename)
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:420: textView.attributedText = attributedText


Let me also check for any `.text` property access that might be resetting things:

>>>TOOL search
{"query": ".text =", "glob": "VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift"}
>>>END

---

## ðŸ”§ TOOL RESULTS

[search]
Found 4 matches:
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:183: textView.text = text
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:218: textView.text = text
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:286: parent.text = textView.text
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:526: parent.text = textView.text


Let me check line 526 and its context:

>>>TOOL read_file
{"path": "VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift", "start_line": 510, "end_line": 600}
>>>END

---

## ðŸ”§ TOOL RESULTS

[read_file]
File: VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift (lines 511-600 of 1767)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
511:                     // Toggle comment
512:                     var newLineText: String
513:                     if isCommented {
514:                         // Remove comment
515:                         newLineText = lineText.replacingOccurrences(of: "//", with: "").replacingOccurrences(of: "#", with: "", options: .anchored)
516:                     } else {
517:                         // Add comment (use // for most languages)
518:                         newLineText = "//" + lineText
519:                     }
520:                     
521:                     // Replace the line
522:                     let textStorage = textView.textStorage
523:                     textStorage.replaceCharacters(in: nsRange, with: newLineText)
524:                     
525:                     // Update parent binding
526:                     parent.text = textView.text
527:                 }
528:             }
529:         }
530:         
531:         func handleFold(in textView: UITextView) {
532:             CodeFoldingManager.shared.foldCurrentLine()
533:         }
534:         
535:         func handleUnfold(in textView: UITextView) {
536:             CodeFoldingManager.shared.unfoldCurrentLine()
537:         }
538:         
539:         @objc func handlePinch(_ gesture: UIPinchGestureRecognizer) {
540:             guard let textView = gesture.view as? UITextView else { return }
541: 
542:             switch gesture.state {
543:             case .began:
544:                 // Store the initial font size when pinch begins
545:                 initialFontSize = parent.editorCore.editorFontSize
546: 
547:             case .changed:
548:                 // Calculate new font size based on pinch scale
549:                 let newSize = initialFontSize * gesture.scale
550: 
551:                 // Clamp font size between 8 and 32
552:                 let clampedSize = min(max(newSize, 8), 32)
553: 
554:                 // Update EditorCore's font size (this will trigger updateUIView)
555:                 parent.editorCore.editorFontSize = clampedSize
556: 
557:             case .ended, .cancelled:
558:                 // Optional: snap to nearest whole number or standard size
559:                 let finalSize = round(parent.editorCore.editorFontSize)
560:                 parent.editorCore.editorFontSize = min(max(finalSize, 8), 32)
561: 
562:             default:
563:                 break
564:             }
565:         }
566: 
567:         // MARK: - FEAT-044 Matching Bracket Highlight
568: 
569:         private func updateMatchingBracketHighlight(_ textView: UITextView) {
570:             // Clear any existing highlights
571:             if !bracketHighlightRanges.isEmpty {
572:                 for r in bracketHighlightRanges {
573:                     textView.textStorage.removeAttribute(.backgroundColor, range: r)
574:                     textView.textStorage.removeAttribute(.underlineStyle, range: r)
575:                 }
576:                 bracketHighlightRanges.removeAll()
577:             }
578: 
579:             // Only highlight when there's a caret (no selection)
580:             let selection = textView.selectedRange
581:             guard selection.length == 0 else { return }
582: 
583:             let nsText = (textView.text ?? "") as NSString
584:             let length = nsText.length
585:             guard length > 0 else { return }
586: 
587:             let caret = selection.location
588: 
589:             // Candidate bracket location: char before caret, else at caret
590:             let candidateIndices: [Int] = [
591:                 caret - 1,
592:                 caret
593:             ].filter { $0 >= 0 && $0 < length }
594: 
595:             func isBracket(_ c: unichar) -> Bool {
596:                 c == 123 || c == 125 || c == 40 || c == 41 || c == 91 || c == 93 // { } ( ) [ ]
597:             }
598: 
599:             var bracketIndex: Int?
600:             var bracketChar: unichar = 0


Now let me check for any text storage manipulation that could be stripping attributes:

>>>TOOL search
{"query": "textStorage", "glob": "VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift"}
>>>END

---

## ðŸ”§ TOOL RESULTS

[search]
Found 8 matches:
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:522: let textStorage = textView.textStorage
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:523: textStorage.replaceCharacters(in: nsRange, with: newLineText)
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:573: textView.textStorage.removeAttribute(.backgroundColor, range: r)
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:574: textView.textStorage.removeAttribute(.underlineStyle, range: r)
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:665: textView.textStorage.addAttribute(.backgroundColor, value: bg, range: r1)
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:666: textView.textStorage.addAttribute(.backgroundColor, value: bg, range: r2)
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:668: textView.textStorage.addAttribute(.underlineStyle, value: NSUnderlineStyle.single.rawValue, range: r1)
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:669: textView.textStorage.addAttribute(.underlineStyle, value: NSUnderlineStyle.single.rawValue, range: r2)


Now I need to check the `updateUIView` logic more carefully. The key issue might be in the check at line 216. Let me also search for any pattern where text might be cleared:

>>>TOOL read_file
{"path": "VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift", "start_line": 190, "end_line": 270}
>>>END

---

## ðŸ”§ TOOL RESULTS

[read_file]
File: VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift (lines 191-270 of 1767)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
191:         // Update colors when theme changes
192:         textView.backgroundColor = UIColor(ThemeManager.shared.currentTheme.editorBackground)
193:         textView.textColor = UIColor(ThemeManager.shared.currentTheme.editorForeground)
194:         textView.tintColor = UIColor(ThemeManager.shared.currentTheme.cursor)
195:         
196:         if let editorView = textView as? EditorTextView {
197:             editorView.updateThemeColors(theme: ThemeManager.shared.currentTheme)
198:         }
199:         
200:         // Update font size if changed
201:         if let currentFont = textView.font, currentFont.pointSize != editorCore.editorFontSize {
202:             let selectedRange = textView.selectedRange
203:             textView.font = UIFont.monospacedSystemFont(ofSize: editorCore.editorFontSize, weight: .regular)
204:             context.coordinator.applySyntaxHighlighting(to: textView)
205:             textView.selectedRange = selectedRange
206:             
207:             // Update line height
208:             if let font = textView.font {
209:                 DispatchQueue.main.async {
210:                     self.lineHeight = font.lineHeight
211:                 }
212:             }
213:         }
214:         
215:         // Update text if changed externally
216:         if textView.text != text {
217:             let selectedRange = textView.selectedRange
218:             textView.text = text
219:             context.coordinator.applySyntaxHighlighting(to: textView)
220:             textView.selectedRange = selectedRange
221:         } else if context.coordinator.lastThemeId != ThemeManager.shared.currentTheme.id {
222:             // Re-apply highlighting if theme changed
223:             context.coordinator.applySyntaxHighlighting(to: textView)
224:         }
225:         
226:         // Handle minimap scrolling
227:         if scrollPosition != context.coordinator.lastKnownScrollPosition && scrollPosition >= 0 {
228:             // Update lastKnownScrollPosition FIRST to prevent race condition
229:             // where user scroll gets overridden by stale binding value
230:             context.coordinator.lastKnownScrollPosition = scrollPosition
231:             context.coordinator.scrollToLine(scrollPosition, in: textView)
232:         }
233: 
234:         // Handle line selection requests (e.g. tapping line numbers)
235:         if let requested = requestedLineSelection,
236:            requested != context.coordinator.lastRequestedLineSelection {
237:             context.coordinator.lastRequestedLineSelection = requested
238:             context.coordinator.scrollToAndSelectLine(requested, in: textView)
239:             // Defer @Binding update to avoid "Publishing changes from within view updates"
240:             DispatchQueue.main.async {
241:                 self.requestedLineSelection = nil
242:             }
243:         }
244: 
245:         // Handle cursor index requests (e.g. accepting autocomplete)
246:         if let requested = requestedCursorIndex,
247:            requested != context.coordinator.lastRequestedCursorIndex {
248:             context.coordinator.lastRequestedCursorIndex = requested
249:             textView.selectedRange = NSRange(location: max(0, requested), length: 0)
250:             // Defer @Binding update to avoid "Publishing changes from within view updates"
251:             DispatchQueue.main.async {
252:                 self.requestedCursorIndex = nil
253:             }
254: 
255:             // Update SwiftUI state
256:             context.coordinator.updateCursorPosition(textView)
257:             context.coordinator.updateScrollPosition(textView)
258:         }
259:         
260:         // Note: updateLineCount is called in textViewDidChange, no need to call here
261:         // as it causes unnecessary state churn on every updateUIView
262:     }
263:     
264:     // MARK: - Coordinator
265:     
266:     class Coordinator: NSObject, UITextViewDelegate {
267:         var parent: SyntaxHighlightingTextView
268:         var lastKnownScrollPosition: Int = 0
269:         var lastThemeId: String = ""
270:         var lastRequestedLineSelection: Int? = nil


I see the flow now. Let me check the EditorTextView class which might have additional text manipulation:

>>>TOOL search
{"query": "class EditorTextView", "glob": "VSCodeiPadOS/**/*.swift"}
>>>END

---

## ðŸ”§ TOOL RESULTS

[search]
Found 1 matches:
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:677: class EditorTextView: UITextView {


Let me check the EditorTextView class to see if there's anything there that could cause issues:

>>>TOOL read_file
{"path": "VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift", "start_line": 677, "end_line": 850}
>>>END

---

## ðŸ”§ TOOL RESULTS

[read_file]
File: VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift (lines 678-850 of 1767)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
678:     var onPeekDefinition: (() -> Void)?
679:     var onEscape: (() -> Void)?
680:     var onGoToLine: (() -> Void)?
681:     
682:     // Custom action closures for context menu
683:     var onGoToDefinition: (() -> Void)?
684:     var onFindReferences: (() -> Void)?
685:     var onFormatDocument: (() -> Void)?
686:     var onToggleComment: (() -> Void)?
687:     var onFold: (() -> Void)?
688:     var onUnfold: (() -> Void)?
689: 
690:     // Autocomplete key handling hooks (return true if handled)
691:     var onAcceptAutocomplete: (() -> Bool)?
692:     var onDismissAutocomplete: (() -> Bool)?
693:     
694:     // FEAT-039 & FEAT-043
695:     private var indentGuideColor: UIColor = .separator
696:     private var activeIndentGuideColor: UIColor = .label
697:     private var currentLineHighlightColor: UIColor = .clear
698:     
699:     override init(frame: CGRect, textContainer: NSTextContainer?) {
700:         super.init(frame: frame, textContainer: textContainer)
701:         setup()
702:     }
703:     
704:     required init?(coder: NSCoder) {
705:         super.init(coder: coder)
706:         setup()
707:     }
708:     
709:     private func setup() {
710:         // Ensure we redraw when bounds/selection change
711:         contentMode = .redraw
712:     }
713:     
714:     func updateThemeColors(theme: Theme) {
715:         self.indentGuideColor = UIColor(theme.indentGuide)
716:         self.activeIndentGuideColor = UIColor(theme.indentGuideActive)
717:         self.currentLineHighlightColor = UIColor(theme.currentLineHighlight)
718:         setNeedsDisplay()
719:     }
720:     
721:     override func draw(_ rect: CGRect) {
722:         guard let context = UIGraphicsGetCurrentContext(), let font = self.font else {
723:             super.draw(rect)
724:             return
725:         }
726:         
727:         // 1. Draw Current Line Highlight (FEAT-043)
728:         if let selectedRange = selectedTextRange {
729:             // Get the line rect for the cursor position
730:             let caretRect = self.caretRect(for: selectedRange.start)
731:             let lineRect = CGRect(x: 0, y: caretRect.minY, width: bounds.width, height: caretRect.height)
732:             
733:             context.setFillColor(currentLineHighlightColor.cgColor)
734:             context.fill(lineRect)
735:         }
736:         
737:         // 2. Draw Text (super implementation)
738:         super.draw(rect)
739:         
740:         // 3. Draw Indent Guides (FEAT-039)
741:         // We iterate visible lines and draw vertical lines for indentation
742:         // Optimization: Only draw for visible range
743: 
744:         context.setLineWidth(1.0)
745: 
746:         // Respect editor tab size setting (default 4)
747:         let storedTabSize = UserDefaults.standard.integer(forKey: "tabSize")
748:         let tabSize = storedTabSize > 0 ? storedTabSize : 4
749: 
750:         let spaceWidth = " ".size(withAttributes: [.font: font]).width
751:         let indentWidth = spaceWidth * CGFloat(tabSize)
752: 
753:         // Determine active indent level for caret line (for indentGuideActive)
754:         var activeIndentLevel: Int = 0
755:         if let selected = selectedTextRange {
756:             let caretPos = offset(from: beginningOfDocument, to: selected.start)
757:             let nsText = (self.text ?? "") as NSString
758:             let safeLoc = min(max(0, caretPos), nsText.length)
759:             let caretLineRange = nsText.lineRange(for: NSRange(location: safeLoc, length: 0))
760:             let caretLineText = nsText.substring(with: caretLineRange)
761: 
762:             var spaces = 0
763:             for ch in caretLineText {
764:                 if ch == " " { spaces += 1 }
765:                 else if ch == "\t" { spaces += tabSize }
766:                 else { break }
767:             }
768:             activeIndentLevel = spaces / tabSize
769:         }
770: 
771:         // Iterate visible glyphs/lines
772:         let visibleRect = CGRect(origin: contentOffset, size: bounds.size)
773:         let glyphRange = layoutManager.glyphRange(forBoundingRect: visibleRect, in: textContainer)
774: 
775:         let caretY = selectedTextRange.map { caretRect(for: $0.start).minY }
776: 
777:         layoutManager.enumerateLineFragments(forGlyphRange: glyphRange) { (rect, usedRect, textContainer, glyphRange, stop) in
778:             // Get text for this line
779:             guard let range = self.layoutManager.characterRange(forGlyphRange: glyphRange, actualGlyphRange: nil) as NSRange?,
780:                   let text = self.text as NSString? else { return }
781: 
782:             let lineText = text.substring(with: range)
783: 
784:             // Calculate indentation level
785:             var spaces = 0
786:             for char in lineText {
787:                 if char == " " { spaces += 1 }
788:                 else if char == "\t" { spaces += tabSize } // Handle tabs if present
789:                 else { break }
790:             }
791: 
792:             let indentLevel = spaces / tabSize
793:             guard indentLevel > 0 else { return }
794: 
795:             let isCaretLine = (caretY != nil) && abs(rect.minY - (caretY ?? 0)) < 0.5
796: 
797:             for i in 1...indentLevel {
798:                 let x = CGFloat(i) * indentWidth + self.textContainerInset.left
799:                 let startPoint = CGPoint(x: x, y: rect.minY)
800:                 let endPoint = CGPoint(x: x, y: rect.maxY)
801: 
802:                 let stroke = (isCaretLine && i == activeIndentLevel) ? self.activeIndentGuideColor : self.indentGuideColor
803:                 context.setStrokeColor(stroke.cgColor)
804: 
805:                 context.move(to: startPoint)
806:                 context.addLine(to: endPoint)
807:                 context.strokePath()
808:             }
809:         }
810:     }
811:     
812:     override var keyCommands: [UIKeyCommand]? {
813:         var commands = super.keyCommands ?? []
814:         
815:         // Peek Definition: Alt+F12 (using special key input)
816:         // Note: F12 is not directly available on iPadOS keyboards
817:         // Using Option+D as alternative
818:         commands.append(UIKeyCommand(
819:             input: "d",
820:             modifierFlags: .alternate,
821:             action: #selector(handlePeekDefinition)
822:         ))
823: 
824:         // Go to Line: Cmd+G
825:         commands.append(UIKeyCommand(
826:             input: "g",
827:             modifierFlags: .command,
828:             action: #selector(handleGoToLine)
829:         ))
830: 
831:         // Tab: accept autocomplete if visible, else insert tab
832:         commands.append(UIKeyCommand(
833:             input: "\t",
834:             modifierFlags: [],
835:             action: #selector(handleTab)
836:         ))
837:         
838:         // Escape: dismiss autocomplete if visible, else normal escape behavior
839:         commands.append(UIKeyCommand(
840:             input: UIKeyCommand.inputEscape,
841:             modifierFlags: [],
842:             action: #selector(handleEscape)
843:         ))
844:         
845:         // Fold: Cmd+Opt+[
846:         commands.append(UIKeyCommand(
847:             input: "[",
848:             modifierFlags: [.command, .alternate],
849:             action: #selector(handleFold)
850:         ))


Now let me check for any text replacement/insertion that might be happening during typing:

>>>TOOL search
{"query": "replaceCharacters", "glob": "VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift"}
>>>END

---

## ðŸ”§ TOOL RESULTS

[search]
Found 1 matches:
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:523: textStorage.replaceCharacters(in: nsRange, with: newLineText)


Let me check for any `insertText` method or text input interception:

>>>TOOL search
{"query": "insertText", "glob": "VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift"}
>>>END

---

## ðŸ”§ TOOL RESULTS

[search]
Found 1 matches:
VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift:874: insertText("\t")


Let me check the VSCodeSyntaxHighlighter to see how it creates attributed text:

>>>TOOL search
{"query": "class VSCodeSyntaxHighlighter", "glob": "*.swift"}
>>>END

---

## ðŸ”§ TOOL RESULTS

[search]
No matches found for "class VSCodeSyntaxHighlighter"


>>>TOOL search
{"query": "VSCodeSyntaxHighlighter", "glob": "*.swift"}
>>>END

---

## ðŸ”§ TOOL RESULTS

[search]
No matches found for "VSCodeSyntaxHighlighter"


Let me check the file for where VSCodeSyntaxHighlighter is defined - it's used at line 416:

>>>TOOL read_file
{"path": "VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift", "start_line": 900, "end_line": 1100}
>>>END

---

## ðŸ”§ TOOL RESULTS

[read_file]
File: VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift (lines 901-1100 of 1767)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
901:     
902:     @objc private func findReferences(_ sender: Any?) {
903:         onFindReferences?()
904:     }
905:     
906:     @objc private func formatDocument(_ sender: Any?) {
907:         onFormatDocument?()
908:     }
909:     
910:     @objc private func toggleComment(_ sender: Any?) {
911:         onToggleComment?()
912:     }
913:     
914:     // MARK: - Menu Support
915:     
916:     override func canPerformAction(_ action: Selector, withSender sender: Any?) -> Bool {
917:         // Enable custom actions
918:         if action == #selector(goToDefinition(_:)) {
919:             return onGoToDefinition != nil
920:         }
921:         if action == #selector(peekDefinition(_:)) {
922:             return onPeekDefinition != nil
923:         }
924:         if action == #selector(findReferences(_:)) {
925:             return onFindReferences != nil
926:         }
927:         if action == #selector(formatDocument(_:)) {
928:             return onFormatDocument != nil
929:         }
930:         if action == #selector(toggleComment(_:)) {
931:             return onToggleComment != nil
932:         }
933:         
934:         return super.canPerformAction(action, withSender: sender)
935:     }
936:     
937:     override func buildMenu(with builder: UIMenuBuilder) {
938:         super.buildMenu(with: builder)
939:         
940:         guard builder.menu(for: .text) != nil else { return }
941:         
942:         // Create custom menu items
943:         let goToDefinitionAction = UIAction(
944:             title: "Go to Definition",
945:             image: UIImage(systemName: "arrow.forward.circle"),
946:             identifier: UIAction.Identifier("com.vscode.goToDefinition"),
947:             handler: { [weak self] _ in
948:                 self?.goToDefinition(nil)
949:             }
950:         )
951:         
952:         let peekDefinitionAction = UIAction(
953:             title: "Peek Definition",
954:             image: UIImage(systemName: "eye"),
955:             identifier: UIAction.Identifier("com.vscode.peekDefinition"),
956:             handler: { [weak self] _ in
957:                 self?.peekDefinition(nil)
958:             }
959:         )
960:         
961:         let findReferencesAction = UIAction(
962:             title: "Find All References",
963:             image: UIImage(systemName: "magnifyingglass"),
964:             identifier: UIAction.Identifier("com.vscode.findReferences"),
965:             handler: { [weak self] _ in
966:                 self?.findReferences(nil)
967:             }
968:         )
969:         
970:         let formatDocumentAction = UIAction(
971:             title: "Format Document",
972:             image: UIImage(systemName: "text.alignleft"),
973:             identifier: UIAction.Identifier("com.vscode.formatDocument"),
974:             handler: { [weak self] _ in
975:                 self?.formatDocument(nil)
976:             }
977:         )
978:         
979:         let toggleCommentAction = UIAction(
980:             title: "Toggle Comment",
981:             image: UIImage(systemName: "text.quote"),
982:             identifier: UIAction.Identifier("com.vscode.toggleComment"),
983:             handler: { [weak self] _ in
984:                 self?.toggleComment(nil)
985:             }
986:         )
987:         
988:         // Group custom actions
989:         let customMenu = UIMenu(
990:             title: "",
991:             identifier: UIMenu.Identifier("com.vscode.customActions"),
992:             options: [.displayInline],
993:             children: [
994:                 goToDefinitionAction,
995:                 peekDefinitionAction,
996:                 findReferencesAction,
997:                 formatDocumentAction,
998:                 toggleCommentAction
999:             ]
1000:         )
1001:         
1002:         // Insert custom menu after standard edit menu
1003:         builder.insertChild(customMenu, atStartOfMenu: .text)
1004:     }
1005: }
1006: 
1007: // MARK: - VSCode-Style Syntax Highlighter
1008: 
1009: enum Language {
1010:     case swift
1011: 
1012:     case javascript
1013:     case typescript
1014:     case jsx
1015:     case tsx
1016: 
1017:     case python
1018:     case ruby
1019:     case go
1020:     case rust
1021:     case java
1022:     case kotlin
1023: 
1024:     case c
1025:     case cpp
1026:     case objectiveC
1027: 
1028:     case html
1029:     case css
1030:     case scss
1031:     case less
1032:     case json
1033:     case xml
1034:     case yaml
1035:     case sql
1036: 
1037:     case shell
1038:     case dockerfile
1039:     case graphql
1040:     case markdown
1041:     case php
1042:     case env
1043: 
1044:     case plainText
1045: }
1046: 
1047: struct VSCodeSyntaxHighlighter {
1048:     private let baseFontSize: CGFloat
1049:     let theme: Theme
1050:     
1051:     init(theme: Theme = ThemeManager.shared.currentTheme, fontSize: CGFloat = 14) {
1052:         self.theme = theme
1053:         self.baseFontSize = fontSize
1054:     }
1055:     
1056:     func highlight(_ text: String, filename: String) -> NSAttributedString {
1057:         let language = detectLanguage(from: filename)
1058:         return highlight(text, language: language)
1059:     }
1060:     
1061:     private func detectLanguage(from filename: String) -> Language {
1062:         let lower = filename.lowercased()
1063:         let ext = (filename as NSString).pathExtension.lowercased()
1064: 
1065:         // Special-case filenames without extensions
1066:         if (filename as NSString).lastPathComponent.lowercased() == "dockerfile" { return .dockerfile }
1067:         if (filename as NSString).lastPathComponent.lowercased() == ".env" { return .env }
1068:         if lower.hasSuffix("/.env") { return .env }
1069: 
1070:         switch ext {
1071:         case "swift": return .swift
1072: 
1073:         case "js", "mjs", "cjs": return .javascript
1074:         case "jsx": return .jsx
1075:         case "ts", "mts", "cts": return .typescript
1076:         case "tsx": return .tsx
1077: 
1078:         case "py", "pyw": return .python
1079:         case "rb", "ruby": return .ruby
1080:         case "go": return .go
1081:         case "rs": return .rust
1082:         case "java": return .java
1083:         case "kt", "kts": return .kotlin
1084: 
1085:         case "c", "h": return .c
1086:         case "cpp", "cc", "cxx", "hpp", "hh", "hxx": return .cpp
1087:         case "m", "mm": return .objectiveC
1088: 
1089:         case "html", "htm": return .html
1090:         case "css": return .css
1091:         case "scss", "sass": return .scss
1092:         case "less": return .less
1093:         case "json", "jsonc": return .json
1094:         case "xml", "plist", "svg": return .xml
1095:         case "yml", "yaml": return .yaml
1096:         case "sql": return .sql
1097: 
1098:         case "sh", "bash", "zsh", "fish": return .shell
1099:         case "dockerfile": return .dockerfile
1100: 


>>>TOOL read_file
{"path": "VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift", "start_line": 1100, "end_line": 1300}
>>>END

---

## ðŸ”§ TOOL RESULTS

[read_file]
File: VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift (lines 1101-1300 of 1767)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1101:         case "graphql", "gql": return .graphql
1102: 
1103:         case "md", "markdown": return .markdown
1104:         case "php": return .php
1105:         case "env": return .env
1106: 
1107:         default: return .plainText
1108:         }
1109:     }
1110:     
1111:     private func highlight(_ text: String, language: Language) -> NSAttributedString {
1112:         let attributed = NSMutableAttributedString(string: text)
1113:         let fullRange = NSRange(location: 0, length: text.utf16.count)
1114:         
1115:         // Base attributes
1116:         let baseFont = UIFont.monospacedSystemFont(ofSize: baseFontSize, weight: .regular)
1117:         attributed.addAttribute(.font, value: baseFont, range: fullRange)
1118:         attributed.addAttribute(.foregroundColor, value: UIColor(theme.editorForeground), range: fullRange)
1119:         
1120:         // Apply language-specific highlighting
1121:         switch language {
1122:         case .swift: highlightSwift(attributed, text: text)
1123:         case .javascript, .jsx: highlightJavaScript(attributed, text: text, isTS: false)
1124:         case .typescript, .tsx: highlightJavaScript(attributed, text: text, isTS: true)
1125:         case .python: highlightPython(attributed, text: text)
1126:         case .html, .xml: highlightHTML(attributed, text: text)
1127:         case .css, .scss, .less: highlightCSS(attributed, text: text)
1128:         case .json: highlightJSON(attributed, text: text)
1129:         case .markdown: highlightMarkdown(attributed, text: text)
1130:         case .rust: highlightRust(attributed, text: text)
1131:         case .go: highlightGo(attributed, text: text)
1132:         case .java, .kotlin: highlightJava(attributed, text: text)
1133:         case .c, .cpp, .objectiveC: highlightCpp(attributed, text: text)
1134:         case .ruby: highlightRuby(attributed, text: text)
1135:         case .php: highlightPHP(attributed, text: text)
1136:         case .shell, .dockerfile: highlightShell(attributed, text: text)
1137:         case .yaml, .env: highlightYAML(attributed, text: text)
1138:         case .sql: highlightSQL(attributed, text: text)
1139:         case .graphql: highlightGraphQL(attributed, text: text)
1140:         case .plainText: break
1141:         }
1142:         
1143:         // FEAT-038: Bracket Pair Colorization (applied last)
1144:         highlightBracketPairs(attributed, text: text)
1145:         
1146:         return attributed
1147:     }
1148:     
1149:     // MARK: - Bracket Pair Colorization
1150:     
1151:     private func highlightBracketPairs(_ attributed: NSMutableAttributedString, text: String) {
1152:         let brackets: [Character] = ["{", "}", "[", "]", "(", ")"]
1153:         let pairs: [Character: Character] = ["}": "{", "]": "[", ")": "("]
1154:         
1155:         var stack: [(char: Character, index: Int, depth: Int)] = []
1156:         let colors = [
1157:             UIColor(theme.bracketPair1),
1158:             UIColor(theme.bracketPair2),
1159:             UIColor(theme.bracketPair3),
1160:             UIColor(theme.bracketPair4),
1161:             UIColor(theme.bracketPair5),
1162:             UIColor(theme.bracketPair6)
1163:         ]
1164:         
1165:         // Scan text for brackets
1166:         // Note: In a real implementation, we should skip brackets inside strings/comments
1167:         // But since we apply this LAST, we can try to respect existing string/comment colors
1168:         // OR implement a more robust parser. For now, simple scan.
1169:         
1170:         // Optimization: Use scanner or direct iteration
1171:         let nsString = text as NSString
1172:         var index = 0
1173:         
1174:         while index < text.utf16.count {
1175:             let char = nsString.character(at: index)
1176:             if let scalar = UnicodeScalar(char) {
1177:                 let c = Character(scalar)
1178:                 
1179:                 if brackets.contains(c) {
1180:                     // Check if it's already colored as string/comment (heuristic)
1181:                     // If color is string/comment, skip
1182:                     // (Requires iterating attributes, which is slow. We'll just apply on top for now)
1183:                     
1184:                     if let open = pairs[c] { // Closing bracket
1185:                         if let last = stack.last, last.char == open {
1186:                             // Match found
1187:                             let depth = last.depth
1188:                             let color = colors[depth % colors.count]
1189:                             
1190:                             attributed.addAttribute(.foregroundColor, value: color, range: NSRange(location: index, length: 1))
1191:                             attributed.addAttribute(.foregroundColor, value: color, range: NSRange(location: last.index, length: 1))
1192:                             
1193:                             stack.removeLast()
1194:                         } else {
1195:                             // Mismatched or extra closing bracket - unexpected
1196:                             // Keep default color or mark red? Default for now.
1197:                         }
1198:                     } else { // Opening bracket
1199:                         let depth = stack.count
1200:                         stack.append((c, index, depth))
1201:                         
1202:                         // We'll color it when (and if) we find the match, or here?
1203:                         // Better to color here tentatively, but matching is better.
1204:                         // Let's color tentatively based on depth.
1205:                         let color = colors[depth % colors.count]
1206:                         attributed.addAttribute(.foregroundColor, value: color, range: NSRange(location: index, length: 1))
1207:                     }
1208:                 }
1209:             }
1210:             index += 1
1211:         }
1212:     }
1213:     
1214:     // MARK: - Swift Highlighting
1215:     
1216:     private func highlightSwift(_ attributed: NSMutableAttributedString, text: String) {
1217:         // Keywords (purple/pink)
1218:         let keywords = ["func", "var", "let", "if", "else", "for", "while", "return",
1219:                        "class", "struct", "enum", "protocol", "extension", "import",
1220:                        "private", "public", "internal", "fileprivate", "open",
1221:                        "static", "final", "override", "mutating", "nonmutating",
1222:                        "init", "deinit", "subscript", "typealias", "associatedtype",
1223:                        "where", "throws", "rethrows", "async", "await", "actor",
1224:                        "guard", "defer", "do", "try", "catch", "throw",
1225:                        "switch", "case", "default", "break", "continue", "fallthrough",
1226:                        "in", "is", "as", "inout", "some", "any", "Self",
1227:                        "get", "set", "willSet", "didSet", "lazy", "weak", "unowned",
1228:                        "@State", "@Binding", "@Published", "@ObservedObject", "@StateObject",
1229:                        "@Environment", "@EnvironmentObject", "@ViewBuilder", "@MainActor",
1230:                        "@escaping", "@autoclosure", "@available", "@objc", "@discardableResult"]
1231:         highlightKeywords(attributed, keywords: keywords, color: UIColor(theme.keyword), text: text)
1232:         
1233:         // Types (teal) - CamelCase words that aren't keywords
1234:         let typePattern = "\\b[A-Z][a-zA-Z0-9]*\\b"
1235:         highlightPattern(attributed, pattern: typePattern, color: UIColor(theme.type), text: text)
1236:         
1237:         // Function calls (yellow)
1238:         let funcCallPattern = "\\b([a-z][a-zA-Z0-9]*)\\s*\\("
1239:         highlightPattern(attributed, pattern: funcCallPattern, color: UIColor(theme.function), text: text, captureGroup: 1)
1240:         
1241:         // Constants (blue)
1242:         let constants = ["true", "false", "nil", "self", "super"]
1243:         highlightKeywords(attributed, keywords: constants, color: UIColor(theme.variable), text: text)
1244:         
1245:         // Comments MUST come late (green) - they override everything
1246:         highlightComments(attributed, text: text, singleLine: "//", multiLineStart: "/*", multiLineEnd: "*/")
1247:         
1248:         // Strings AFTER comments (orange)
1249:         highlightStrings(attributed, text: text)
1250:         
1251:         // Numbers (light green)
1252:         highlightNumbers(attributed, text: text)
1253:     }
1254:     
1255:     // MARK: - JavaScript/TypeScript Highlighting
1256:     
1257:     private func highlightJavaScript(_ attributed: NSMutableAttributedString, text: String, isTS: Bool) {
1258:         var keywords = ["function", "var", "let", "const", "if", "else", "for", "while",
1259:                        "return", "class", "extends", "new", "this", "super", "import",
1260:                        "export", "default", "from", "as", "async", "await", "yield",
1261:                        "try", "catch", "finally", "throw", "typeof", "instanceof",
1262:                        "switch", "case", "break", "continue", "do", "in", "of",
1263:                        "get", "set", "static", "constructor", "delete", "void",
1264:                        "with", "debugger"]
1265:         
1266:         if isTS {
1267:             keywords += ["interface", "type", "enum", "namespace", "module", "declare",
1268:                         "implements", "public", "private", "protected", "readonly",
1269:                         "abstract", "override", "keyof", "infer", "never", "unknown",
1270:                         "any", "asserts", "is"]
1271:         }
1272:         
1273:         highlightKeywords(attributed, keywords: keywords, color: UIColor(theme.keyword), text: text)
1274:         
1275:         // Constants
1276:         let constants = ["true", "false", "null", "undefined", "NaN", "Infinity"]
1277:         highlightKeywords(attributed, keywords: constants, color: UIColor(theme.variable), text: text)
1278:         
1279:         // Function names (yellow) - regular calls + arrow functions
1280:         let funcNamePattern = "\\b([a-zA-Z_$][a-zA-Z0-9_$]*)\\b(?=\\s*(?:\\(|=>))"
1281:         highlightPattern(attributed, pattern: funcNamePattern, color: UIColor(theme.function), text: text, captureGroup: 1)
1282:         
1283:         // Types (teal)
1284:         let typePattern = "\\b[A-Z][a-zA-Z0-9]*\\b"
1285:         highlightPattern(attributed, pattern: typePattern, color: UIColor(theme.type), text: text)
1286:         
1287:         highlightComments(attributed, text: text, singleLine: "//", multiLineStart: "/*", multiLineEnd: "*/")
1288:         highlightStrings(attributed, text: text)
1289:         highlightJSTemplateLiterals(attributed, text: text)
1290:         highlightNumbers(attributed, text: text)
1291:     }
1292:     
1293:     // MARK: - Python Highlighting
1294:     
1295:     private func highlightPython(_ attributed: NSMutableAttributedString, text: String) {
1296:         let keywords = ["def", "class", "if", "elif", "else", "for", "while", "return",
1297:                        "import", "from", "as", "try", "except", "finally", "raise",
1298:                        "with", "assert", "yield", "lambda", "pass", "break", "continue",
1299:                        "global", "nonlocal", "del", "in", "not", "and", "or", "is",
1300:                        "async", "await", "match", "case"]


Now let me look at the exact flow in textViewDidChange more carefully and see if typingAttributes are set properly:

>>>TOOL read_file
{"path": "VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift", "start_line": 280, "end_line": 320}
>>>END

---

## ðŸ”§ TOOL RESULTS

[read_file]
File: VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift (lines 281-320 of 1767)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
281:             self.parent = parent
282:         }
283:         
284:         func textViewDidChange(_ textView: UITextView) {
285:             // Update parent text
286:             parent.text = textView.text
287:             
288:             // Debounced syntax highlighting for performance
289:             highlightDebouncer?.invalidate()
290:             highlightDebouncer = Timer.scheduledTimer(withTimeInterval: 0.15, repeats: false) { [weak self] _ in
291:                 DispatchQueue.main.async {
292:                     self?.applySyntaxHighlighting(to: textView)
293:                 }
294:             }
295:             
296:             updateLineCount(textView)
297:             updateCursorPosition(textView)
298:         }
299:         
300:         func textViewDidChangeSelection(_ textView: UITextView) {
301:             if !isUpdatingFromMinimap {
302:                 updateCursorPosition(textView)
303:                 updateScrollPosition(textView)
304: 
305:                 // FEAT-044: Matching bracket highlight
306:                 updateMatchingBracketHighlight(textView)
307: 
308:                 // Trigger redraw so current-line highlight/indent guides track the caret
309:                 (textView as? EditorTextView)?.setNeedsDisplay()
310: 
311:                 // Update selection in EditorCore for multi-cursor support
312:                 let range = textView.selectedRange
313:                 parent.editorCore.updateSelection(range: range, text: textView.text ?? "")
314: 
315:                 // If user clicks elsewhere (not multi-cursor operation), reset to single cursor
316:                 if !parent.editorCore.multiCursorState.isMultiCursor {
317:                     parent.editorCore.multiCursorState.reset(to: range.location + range.length)
318:                 }
319:             }
320:         }


I now have a comprehensive understanding of the issue. Let me write my report with the findings:

>>>REPORT
## Syntax Highlighting Flicker Analysis - SyntaxHighlightingTextView.swift

### Files Examined
- `VSCodeiPadOS/VSCodeiPadOS/Views/Editor/SyntaxHighlightingTextView.swift` (1767 lines)

### All Places Where Text/AttributedText Is Modified

| Line | Code | Context |
|------|------|---------|
| 183 | `textView.text = text` | `makeUIView` - Initial text setup |
| 218 | `textView.text = text` | `updateUIView` - When external text changes |
| 286 | `parent.text = textView.text` | `textViewDidChange` - Sync to binding |
| 420 | `textView.attributedText = attributedText` | `applySyntaxHighlighting` - Full replacement |
| 526 | `parent.text = textView.text` | `handleToggleComment` - After comment toggle |
| 523 | `textStorage.replaceCharacters(...)` | `handleToggleComment` - Inline modification |

### Root Cause of Flicker

**Problem 1: Debounce delay leaves text unstyled (lines 288-294)**
```swift
highlightDebouncer?.invalidate()
highlightDebouncer = Timer.scheduledTimer(withTimeInterval: 0.15, repeats: false) { [weak self] _ in
    DispatchQueue.main.async {
        self?.applySyntaxHighlighting(to: textView)
    }
}
```
During the 0.15s debounce window, newly typed characters only get base styling from `typingAttributes`, but no syntax highlighting.

**Problem 2: typingAttributes set TOO LATE (lines 426-429)**
```swift
// Set AFTER full highlighting - not before user types
textView.typingAttributes = [
    .font: UIFont.monospacedSystemFont(ofSize: fontSize, weight: .regular),
    .foregroundColor: UIColor(theme.editorForeground)
]
```
These are only updated AFTER highlighting completes. New characters typed during debounce use PREVIOUS typingAttributes.

**Problem 3: Full text replacement causes flash (line 420)**
```swift
textView.attributedText = attributedText  // Replaces ENTIRE text storage
```
This replaces the entire attributed string, which can cause visual flicker even if content is identical.

**Problem 4: updateUIView race condition (lines 216-220)**
```swift
if textView.text != text {
    let selectedRange = textView.selectedRange
    textView.text = text  // STRIPS ALL ATTRIBUTES!
    context.coordinator.applySyntaxHighlighting(to: textView)
    textView.selectedRange = selectedRange
}
```
If SwiftUI binding update propagates while debounce is pending, this check could fail, causing plain text to be set (stripping attributes) before re-highlighting.

### Recommended Fixes

1. **Set typingAttributes IMMEDIATELY in textViewDidChange** - not after debounce
2. **Use incremental attribute updates** instead of full `attributedText` replacement
3. **Consider shorter debounce** (0.05-0.08s) or progressive highlighting
4. **Use textStorage.beginEditing/endEditing** to batch attribute changes and reduce redraws
5. **Add flag to prevent updateUIView interference** during active typing/debounce

### Key Code Locations
- Debounce timer: lines 273, 289-294
- applySyntaxHighlighting: lines 412-433
- updateUIView text sync: lines 216-224
- typingAttributes setting: lines 426-429
>>>END
