//
//  GoToSymbol.swift
//  VSCodeiPadOS
//
//  VS Code-style Go to Symbol (Cmd+Shift+O)
//

import SwiftUI

// MARK: - Symbol Types

enum SymbolType: String, CaseIterable {
    case function = "function"
    case method = "method"
    case property = "property"
    case variable = "variable"
    case constant = "constant"
    case `class` = "class"
    case `struct` = "struct"
    case `enum` = "enum"
    case `protocol` = "protocol"
    case interface = "interface"
    case type = "type"
    case namespace = "namespace"
    case module = "module"
    case field = "field"
    case constructor = "constructor"
    case unknown = "unknown"
    
    var icon: String {
        switch self {
        case .function, .method: return "f.square"
        case .property, .field: return "p.square"
        case .variable: return "v.square"
        case .constant: return "c.square"
        case .class: return "c.square.fill"
        case .struct: return "s.square.fill"
        case .enum: return "e.square.fill"
        case .protocol, .interface: return "i.square"
        case .type: return "t.square"
        case .namespace, .module: return "n.square"
        case .constructor: return "hammer"
        case .unknown: return "questionmark.square"
        }
    }
    
    var color: Color {
        switch self {
        case .function, .method: return .purple
        case .property, .field: return .blue
        case .variable: return .cyan
        case .constant: return .orange
        case .class: return .yellow
        case .struct: return .green
        case .enum: return .mint
        case .protocol, .interface: return .pink
        case .type: return .indigo
        case .namespace, .module: return .brown
        case .constructor: return .red
        case .unknown: return .gray
        }
    }
}

// MARK: - Symbol Model

struct CodeSymbol: Identifiable {
    let id = UUID()
    let name: String
    let type: SymbolType
    let line: Int
    let column: Int
    let detail: String?
    let containerName: String?
    
    var displayDetail: String {
        if let detail = detail {
            return detail
        }
        return "Line \(line)"
    }
}

// MARK: - Symbol Parser

class SymbolParser {
    static func parseSymbols(from content: String, language: CodeLanguage) -> [CodeSymbol] {
        switch language {
        case .swift:
            return parseSwiftSymbols(from: content)
        case .javascript, .typescript:
            return parseJSSymbols(from: content)
        case .python:
            return parsePythonSymbols(from: content)
        default:
            return parseGenericSymbols(from: content)
        }
    }
    
    // MARK: - Swift Parser
    
    private static func parseSwiftSymbols(from content: String) -> [CodeSymbol] {
        var symbols: [CodeSymbol] = []
        let lines = content.components(separatedBy: .newlines)
        
        let patterns: [(pattern: String, type: SymbolType)] = [
            // Functions
            (#"^\s*(public |private |internal |fileprivate |open )?func\s+(\w+)"#, .function),
            // Classes
            (#"^\s*(public |private |internal |fileprivate |open )?(final )?class\s+(\w+)"#, .class),
            // Structs
            (#"^\s*(public |private |internal |fileprivate |open )?struct\s+(\w+)"#, .struct),
            // Enums
            (#"^\s*(public |private |internal |fileprivate |open )?enum\s+(\w+)"#, .enum),
            // Protocols
            (#"^\s*(public |private |internal |fileprivate |open )?protocol\s+(\w+)"#, .protocol),
            // Properties
            (#"^\s*(public |private |internal |fileprivate |open )?(static |class )?(var|let)\s+(\w+)"#, .property),
            // Init
            (#"^\s*(public |private |internal |fileprivate |open )?(required |convenience )?init"#, .constructor),
        ]
        
        for (lineIndex, line) in lines.enumerated() {
            for (pattern, type) in patterns {
                if let regex = try? NSRegularExpression(pattern: pattern, options: []),
                   let match = regex.firstMatch(in: line, options: [], range: NSRange(line.startIndex..., in: line)) {
                    
                    var name: String
                    
                    // Extract the name based on type
                    if type == .constructor {
                        name = "init"
                        // Try to get parameters
                        if let parenRange = line.range(of: "(") {
                            let afterParen = String(line[parenRange.lowerBound...])
                            if let closeRange = afterParen.range(of: ")") {
                                let params = String(afterParen[afterParen.index(after: afterParen.startIndex)..<closeRange.lowerBound])
                                if !params.isEmpty {
                                    name = "init(\(params.trimmingCharacters(in: .whitespaces)))"
                                }
                            }
                        }
                    } else {
                        // Get the last capture group which should be the name
                        let lastGroupIndex = match.numberOfRanges - 1
                        if lastGroupIndex > 0,
                           let range = Range(match.range(at: lastGroupIndex), in: line) {
                            name = String(line[range])
                        } else {
                            continue
                        }
                    }
                    
                    symbols.append(CodeSymbol(
                        name: name,
                        type: type,
                        line: lineIndex + 1,
                        column: 1,
                        detail: nil,
                        containerName: nil
                    ))
                    break
                }
            }
        }
        
        return symbols
    }
    
    // MARK: - JavaScript/TypeScript Parser
    
    private static func parseJSSymbols(from content: String) -> [CodeSymbol] {
        var symbols: [CodeSymbol] = []
        let lines = content.components(separatedBy: .newlines)
        
        let patterns: [(pattern: String, type: SymbolType)] = [
            // Functions
            (#"^\s*(export )?(async )?function\s+(\w+)"#, .function),
            // Arrow functions assigned to const/let
            (#"^\s*(export )?(const|let|var)\s+(\w+)\s*=\s*(async )?\(.*\)\s*=>"#, .function),
            // Classes
            (#"^\s*(export )?(default )?class\s+(\w+)"#, .class),
            // Interfaces (TypeScript)
            (#"^\s*(export )?interface\s+(\w+)"#, .interface),
            // Types (TypeScript)
            (#"^\s*(export )?type\s+(\w+)"#, .type),
            // Enums (TypeScript)
            (#"^\s*(export )?enum\s+(\w+)"#, .enum),
            // Const/Let/Var
            (#"^\s*(export )?(const|let|var)\s+(\w+)\s*="#, .variable),
            // Methods in class
            (#"^\s*(static )?(async )?(\w+)\s*\(.*\)\s*\{"#, .method),
        ]
        
        for (lineIndex, line) in lines.enumerated() {
            for (pattern, type) in patterns {
                if let regex = try? NSRegularExpression(pattern: pattern, options: []),
                   let match = regex.firstMatch(in: line, options: [], range: NSRange(line.startIndex..., in: line)) {
                    
                    let lastGroupIndex = match.numberOfRanges - 1
                    guard lastGroupIndex > 0,
                          let range = Range(match.range(at: lastGroupIndex), in: line) else { continue }
                    
                    let name = String(line[range])
                    
                    // Skip common keywords
                    guard !["if", "else", "for", "while", "switch", "catch", "return"].contains(name) else { continue }
                    
                    symbols.append(CodeSymbol(
                        name: name,
                        type: type,
                        line: lineIndex + 1,
                        column: 1,
                        detail: nil,
                        containerName: nil
                    ))
                    break
                }
            }
        }
        
        return symbols
    }
    
    // MARK: - Python Parser
    
    private static func parsePythonSymbols(from content: String) -> [CodeSymbol] {
        var symbols: [CodeSymbol] = []
        let lines = content.components(separatedBy: .newlines)
        
        let patterns: [(pattern: String, type: SymbolType)] = [
            // Classes
            (#"^class\s+(\w+)"#, .class),
            // Functions/Methods
            (#"^\s*def\s+(\w+)"#, .function),
            // Async functions
            (#"^\s*async\s+def\s+(\w+)"#, .function),
        ]
        
        for (lineIndex, line) in lines.enumerated() {
            for (pattern, type) in patterns {
                if let regex = try? NSRegularExpression(pattern: pattern, options: []),
                   let match = regex.firstMatch(in: line, options: [], range: NSRange(line.startIndex..., in: line)) {
                    
                    guard match.numberOfRanges > 1,
                          let range = Range(match.range(at: 1), in: line) else { continue }
                    
                    let name = String(line[range])
                    let symbolType: SymbolType = line.hasPrefix("    ") || line.hasPrefix("\t") ? .method : type
                    
                    symbols.append(CodeSymbol(
                        name: name,
                        type: symbolType,
                        line: lineIndex + 1,
                        column: 1,
                        detail: nil,
                        containerName: nil
                    ))
                    break
                }
            }
        }
        
        return symbols
    }
    
    // MARK: - Generic Parser
    
    private static func parseGenericSymbols(from content: String) -> [CodeSymbol] {
        var symbols: [CodeSymbol] = []
        let lines = content.components(separatedBy: .newlines)
        
        // Generic patterns for common constructs
        let patterns: [(pattern: String, type: SymbolType)] = [
            (#"function\s+(\w+)"#, .function),
            (#"class\s+(\w+)"#, .class),
            (#"def\s+(\w+)"#, .function),
        ]
        
        for (lineIndex, line) in lines.enumerated() {
            for (pattern, type) in patterns {
                if let regex = try? NSRegularExpression(pattern: pattern, options: []),
                   let match = regex.firstMatch(in: line, options: [], range: NSRange(line.startIndex..., in: line)),
                   match.numberOfRanges > 1,
                   let range = Range(match.range(at: 1), in: line) {
                    
                    symbols.append(CodeSymbol(
                        name: String(line[range]),
                        type: type,
                        line: lineIndex + 1,
                        column: 1,
                        detail: nil,
                        containerName: nil
                    ))
                    break
                }
            }
        }
        
        return symbols
    }
}

// MARK: - Go To Symbol View

struct GoToSymbolView: View {
    @ObservedObject var editorCore: EditorCore
    let onGoToLine: (Int) -> Void
    
    @State private var searchText = ""
    @State private var selectedIndex = 0
    @State private var symbols: [CodeSymbol] = []
    @State private var groupByType = false
    @FocusState private var isSearchFocused: Bool
    
    private var filteredSymbols: [CodeSymbol] {
        if searchText.isEmpty {
            return symbols
        }
        
        // Check for type filter prefix (e.g., "@:function")
        if searchText.hasPrefix(":") {
            let typeFilter = String(searchText.dropFirst()).lowercased()
            return symbols.filter { $0.type.rawValue.lowercased().contains(typeFilter) }
        }
        
        return symbols
            .compactMap { symbol -> (CodeSymbol, Int)? in
                guard let score = FuzzyMatcher.score(query: searchText, target: symbol.name) else {
                    return nil
                }
                return (symbol, score)
            }
            .sorted { $0.1 > $1.1 }
            .map { $0.0 }
    }
    
    private var groupedSymbols: [(SymbolType, [CodeSymbol])] {
        let grouped = Dictionary(grouping: filteredSymbols) { $0.type }
        return grouped.sorted { $0.key.rawValue < $1.key.rawValue }
    }
    
    private func dismiss() {
        editorCore.showGoToSymbol = false
    }
    
    private func goToSymbol(_ symbol: CodeSymbol) {
        onGoToLine(symbol.line)
        dismiss()
    }
    
    var body: some View {
        VStack(spacing: 0) {
            // Search Header
            HStack(spacing: 12) {
                Image(systemName: "at")
                    .font(.system(size: 14, weight: .medium))
                    .foregroundColor(.secondary)
                
                TextField("", text: $searchText, prompt: Text("Go to Symbol (: to filter by type)").foregroundColor(.secondary))
                    .font(.system(size: 14))
                    .textFieldStyle(.plain)
                    .focused($isSearchFocused)
                    .onSubmit {
                        if let symbol = selectedIndex < filteredSymbols.count ? filteredSymbols[selectedIndex] : nil {
                            goToSymbol(symbol)
                        }
                    }
                
                // Group toggle
                Button(action: { groupByType.toggle() }) {
                    Image(systemName: groupByType ? "list.bullet.indent" : "list.bullet")
                        .font(.system(size: 14))
                        .foregroundColor(groupByType ? .accentColor : .secondary)
                }
                .buttonStyle(.plain)
                .help("Group by type")
                
                if !searchText.isEmpty {
                    Button(action: { searchText = "" }) {
                        Image(systemName: "xmark.circle.fill")
                            .foregroundColor(.secondary)
                    }
                    .buttonStyle(.plain)
                }
            }
            .padding(.horizontal, 16)
            .padding(.vertical, 12)
            .background(Color(UIColor.secondarySystemBackground))
            
            Divider()
            
            // Symbols List
            if symbols.isEmpty {
                VStack(spacing: 12) {
                    Image(systemName: "number")
                        .font(.system(size: 40))
                        .foregroundColor(.secondary.opacity(0.5))
                    Text("No symbols found in this file")
                        .font(.system(size: 14))
                        .foregroundColor(.secondary)
                }
                .frame(maxWidth: .infinity, maxHeight: .infinity)
                .frame(height: 200)
            } else if filteredSymbols.isEmpty {
                VStack(spacing: 12) {
                    Image(systemName: "magnifyingglass")
                        .font(.system(size: 40))
                        .foregroundColor(.secondary.opacity(0.5))
                    Text("No matching symbols")
                        .font(.system(size: 14))
                        .foregroundColor(.secondary)
                }
                .frame(maxWidth: .infinity, maxHeight: .infinity)
                .frame(height: 200)
            } else {
                ScrollViewReader { proxy in
                    ScrollView {
                        LazyVStack(spacing: 0) {
                            if groupByType {
                                ForEach(groupedSymbols, id: \.0) { type, typeSymbols in
                                    // Type header
                                    HStack {
                                        Image(systemName: type.icon)
                                            .font(.system(size: 10))
                                            .foregroundColor(type.color)
                                        Text(type.rawValue.capitalized)
                                            .font(.system(size: 11, weight: .medium))
                                            .foregroundColor(.secondary)
                                        Spacer()
                                        Text("\(typeSymbols.count)")
                                            .font(.system(size: 10))
                                            .foregroundColor(.secondary)
                                    }
                                    .padding(.horizontal, 16)
                                    .padding(.vertical, 6)
                                    .background(Color(UIColor.tertiarySystemBackground))
                                    
                                    ForEach(typeSymbols) { symbol in
                                        let globalIndex = filteredSymbols.firstIndex(where: { $0.id == symbol.id }) ?? 0
                                        SymbolRowView(
                                            symbol: symbol,
                                            searchQuery: searchText,
                                            isSelected: globalIndex == selectedIndex
                                        )
                                        .id(globalIndex)
                                        .onTapGesture {
                                            goToSymbol(symbol)
                                        }
                                    }
                                }
                            } else {
                                ForEach(Array(filteredSymbols.enumerated()), id: \.element.id) { index, symbol in
                                    SymbolRowView(
                                        symbol: symbol,
                                        searchQuery: searchText,
                                        isSelected: index == selectedIndex
                                    )
                                    .id(index)
                                    .onTapGesture {
                                        goToSymbol(symbol)
                                    }
                                }
                            }
                        }
                    }
                    .onChange(of: selectedIndex) { newIndex in
                        withAnimation(.easeInOut(duration: 0.1)) {
                            proxy.scrollTo(newIndex, anchor: .center)
                        }
                    }
                }
                .frame(maxHeight: 350)
            }
            
            // Footer
            HStack(spacing: 16) {
                FooterHint(keys: ["↑", "↓"], description: "navigate")
                FooterHint(keys: ["↵"], description: "go to")
                FooterHint(keys: ["esc"], description: "close")
                Spacer()
                Text("\(filteredSymbols.count) symbols")
                    .font(.system(size: 11))
                    .foregroundColor(.secondary)
            }
            .padding(.horizontal, 16)
            .padding(.vertical, 8)
            .background(Color(UIColor.tertiarySystemBackground))
        }
        .frame(width: 600)
        .background(Color(UIColor.systemBackground))
        .cornerRadius(12)
        .shadow(color: .black.opacity(0.3), radius: 30, x: 0, y: 10)
        .onAppear {
            isSearchFocused = true
            selectedIndex = 0
            parseSymbols()
        }
        .onChange(of: editorCore.activeTabId) { _ in
            parseSymbols()
        }
        .onChange(of: searchText) { _ in
            selectedIndex = 0
        }
        .modifier(GoToSymbolKeyboardModifier(
            selectedIndex: $selectedIndex,
            maxIndex: filteredSymbols.count - 1,
            onEscape: { dismiss() }
        ))
    }
    
    private func parseSymbols() {
        guard let tab = editorCore.activeTab else {
            symbols = []
            return
        }
        
        symbols = SymbolParser.parseSymbols(from: tab.content, language: tab.language)
    }
}

// MARK: - Symbol Row View

struct SymbolRowView: View {
    let symbol: CodeSymbol
    let searchQuery: String
    let isSelected: Bool
    
    var body: some View {
        HStack(spacing: 12) {
            // Symbol type icon
            Image(systemName: symbol.type.icon)
                .font(.system(size: 14))
                .foregroundColor(isSelected ? .white : symbol.type.color)
                .frame(width: 24)
            
            VStack(alignment: .leading, spacing: 2) {
                // Symbol name with highlighting
                highlightedName
                
                // Container and line info
                HStack(spacing: 4) {
                    if let container = symbol.containerName {
                        Text(container)
                            .font(.system(size: 11))
                            .foregroundColor(isSelected ? .white.opacity(0.7) : .secondary)
                        Text("•")
                            .font(.system(size: 11))
                            .foregroundColor(isSelected ? .white.opacity(0.5) : .secondary.opacity(0.5))
                    }
                    Text("Line \(symbol.line)")
                        .font(.system(size: 11))
                        .foregroundColor(isSelected ? .white.opacity(0.7) : .secondary)
                }
            }
            
            Spacer()
            
            // Type badge
            Text(symbol.type.rawValue)
                .font(.system(size: 10, weight: .medium))
                .foregroundColor(isSelected ? .white.opacity(0.8) : symbol.type.color)
                .padding(.horizontal, 6)
                .padding(.vertical, 2)
                .background(
                    RoundedRectangle(cornerRadius: 4)
                        .fill(isSelected ? Color.white.opacity(0.2) : symbol.type.color.opacity(0.15))
                )
        }
        .padding(.horizontal, 16)
        .padding(.vertical, 8)
        .background(
            RoundedRectangle(cornerRadius: 6)
                .fill(isSelected ? Color.accentColor : Color.clear)
        )
        .padding(.horizontal, 8)
        .padding(.vertical, 1)
        .contentShape(Rectangle())
    }
    
    @ViewBuilder
    private var highlightedName: some View {
        if searchQuery.isEmpty || searchQuery.hasPrefix(":") {
            Text(symbol.name)
                .font(.system(size: 13, design: .monospaced))
                .foregroundColor(isSelected ? .white : .primary)
        } else {
            let parts = FuzzyMatcher.highlight(query: searchQuery, in: symbol.name)
            HStack(spacing: 0) {
                ForEach(Array(parts.enumerated()), id: \.offset) { _, part in
                    Text(part.0)
                        .font(.system(size: 13, weight: part.1 ? .bold : .regular, design: .monospaced))
                        .foregroundColor(isSelected ? .white : (part.1 ? .accentColor : .primary))
                }
            }
        }
    }
}

// MARK: - Preview

#Preview {
    ZStack {
        Color.black.opacity(0.5)
        GoToSymbolView(
            editorCore: EditorCore(),
            onGoToLine: { _ in }
        )
    }
}
