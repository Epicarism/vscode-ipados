import Foundation
import Combine

// SearchManager
// Implements find-in-files style searching with options (case sensitivity, whole word, regex),
// include/exclude glob patterns, query history, and replace-in-files.
//
// NOTE: This file is intentionally self-contained so it can integrate with varying app models.

public final class SearchManager: ObservableObject {

    // MARK: - Types

    public struct SearchOptions: Codable, Hashable, Sendable {
        public var isCaseSensitive: Bool
        public var isWholeWord: Bool
        public var isRegex: Bool

        public init(isCaseSensitive: Bool = false,
                    isWholeWord: Bool = false,
                    isRegex: Bool = false) {
            self.isCaseSensitive = isCaseSensitive
            self.isWholeWord = isWholeWord
            self.isRegex = isRegex
        }
    }

    public struct SearchQuery: Codable, Hashable, Sendable {
        public var text: String
        public var options: SearchOptions
        /// Include file globs (e.g. ["**/*.swift", "**/*.md"]) - empty means include all.
        public var includeGlobs: [String]
        /// Exclude file globs (e.g. ["**/.git/**", "**/DerivedData/**"]).
        public var excludeGlobs: [String]

        public init(text: String,
                    options: SearchOptions = .init(),
                    includeGlobs: [String] = [],
                    excludeGlobs: [String] = []) {
            self.text = text
            self.options = options
            self.includeGlobs = includeGlobs
            self.excludeGlobs = excludeGlobs
        }
    }

    public struct MatchLocation: Codable, Hashable, Sendable {
        public var line: Int
        public var column: Int
        public var length: Int

        public init(line: Int, column: Int, length: Int) {
            self.line = line
            self.column = column
            self.length = length
        }
    }

    public struct FileMatch: Codable, Hashable, Sendable, Identifiable {
        public var id: String { filePath }
        public var filePath: String
        public var matches: [Match]

        public init(filePath: String, matches: [Match]) {
            self.filePath = filePath
            self.matches = matches
        }

        public struct Match: Codable, Hashable, Sendable, Identifiable {
            public var id: String { "\(location.line):\(location.column):\(location.length):\(preview)" }
            public var location: MatchLocation
            public var preview: String

            public init(location: MatchLocation, preview: String) {
                self.location = location
                self.preview = preview
            }
        }
    }

    public struct ReplaceResult: Codable, Hashable, Sendable {
        public var filesTouched: Int
        public var replacements: Int
        public var fileResults: [PerFile]

        public init(filesTouched: Int, replacements: Int, fileResults: [PerFile]) {
            self.filesTouched = filesTouched
            self.replacements = replacements
            self.fileResults = fileResults
        }

        public struct PerFile: Codable, Hashable, Sendable {
            public var filePath: String
            public var replacements: Int
            public init(filePath: String, replacements: Int) {
                self.filePath = filePath
                self.replacements = replacements
            }
        }
    }

    public enum SearchError: Error, LocalizedError {
        case emptyQuery
        case invalidRegex(String)
        case ioError(String)

        public var errorDescription: String? {
            switch self {
            case .emptyQuery:
                return "Search query is empty."
            case .invalidRegex(let pattern):
                return "Invalid regular expression: \(pattern)"
            case .ioError(let msg):
                return msg
            }
        }
    }

    // MARK: - Published State (UI integration)

    @Published public private(set) var isSearching: Bool = false
    @Published public private(set) var progress: Double = 0
    @Published public private(set) var results: [FileMatch] = []
    @Published public private(set) var lastError: String? = nil

    /// Most-recent-first history.
    @Published public private(set) var history: [SearchQuery] = []

    // MARK: - Config

    public var maxHistoryCount: Int = 30

    // MARK: - Private

    private var searchTask: Task<Void, Never>? = nil
    private let historyKey = "SearchManager.history.v1"

    // MARK: - Init

    public init() {
        loadHistory()
    }

    deinit {
        searchTask?.cancel()
    }

    // MARK: - History

    public func addToHistory(_ query: SearchQuery) {
        let trimmed = query.text.trimmingCharacters(in: .whitespacesAndNewlines)
        guard !trimmed.isEmpty else { return }

        var q = query
        q.text = trimmed

        history.removeAll(where: { $0 == q })
        history.insert(q, at: 0)
        if history.count > maxHistoryCount {
            history.removeLast(history.count - maxHistoryCount)
        }
        persistHistory()
    }

    public func clearHistory() {
        history = []
        persistHistory()
    }

    private func loadHistory() {
        guard let data = UserDefaults.standard.data(forKey: historyKey) else { return }
        if let decoded = try? JSONDecoder().decode([SearchQuery].self, from: data) {
            history = decoded
        }
    }

    private func persistHistory() {
        guard let data = try? JSONEncoder().encode(history) else { return }
        UserDefaults.standard.set(data, forKey: historyKey)
    }

    // MARK: - Search API

    /// Cancels any in-flight search.
    public func cancelSearch() {
        searchTask?.cancel()
        searchTask = nil
        isSearching = false
    }

    /// Search files under `rootURL`.
    /// - Parameters:
    ///   - rootURL: Directory to search.
    ///   - query: Query and options.
    ///   - fileURLs: Optional pre-resolved file list. If provided, include/exclude filtering is still applied.
    @MainActor
    public func search(in rootURL: URL,
                       query: SearchQuery,
                       fileURLs: [URL]? = nil) {
        lastError = nil
        results = []
        progress = 0

        let trimmed = query.text.trimmingCharacters(in: .whitespacesAndNewlines)
        guard !trimmed.isEmpty else {
            lastError = SearchError.emptyQuery.localizedDescription
            return
        }

        // update history immediately
        addToHistory(query)

        cancelSearch()
        isSearching = true

        let q = SearchQuery(text: trimmed,
                            options: query.options,
                            includeGlobs: query.includeGlobs,
                            excludeGlobs: query.excludeGlobs)

        searchTask = Task.detached(priority: .userInitiated) { [weak self] in
            guard let self else { return }
            do {
                let resolvedFiles = try self.resolveFiles(rootURL: rootURL, provided: fileURLs, query: q)
                let total = max(resolvedFiles.count, 1)

                var aggregated: [FileMatch] = []
                for (idx, url) in resolvedFiles.enumerated() {
                    try Task.checkCancellation()
                    if let match = try self.searchFile(url: url, rootURL: rootURL, query: q), !match.matches.isEmpty {
                        aggregated.append(match)
                    }
                    let p = Double(idx + 1) / Double(total)
                    await MainActor.run {
                        self.progress = p
                    }
                }

                await MainActor.run {
                    self.results = aggregated
                    self.isSearching = false
                    self.progress = 1
                }
            } catch is CancellationError {
                await MainActor.run {
                    self.isSearching = false
                }
            } catch {
                await MainActor.run {
                    self.lastError = error.localizedDescription
                    self.isSearching = false
                }
            }
        }
    }

    // MARK: - Replace in files

    /// Replace occurrences for `query` with `replacement` under `rootURL`.
    /// Returns counts per file.
    public func replace(in rootURL: URL,
                        query: SearchQuery,
                        replacement: String,
                        fileURLs: [URL]? = nil) async throws -> ReplaceResult {
        let trimmed = query.text.trimmingCharacters(in: .whitespacesAndNewlines)
        guard !trimmed.isEmpty else { throw SearchError.emptyQuery }

        let q = SearchQuery(text: trimmed,
                            options: query.options,
                            includeGlobs: query.includeGlobs,
                            excludeGlobs: query.excludeGlobs)

        // Pre-compile pattern.
        let compiled = try compilePattern(for: q)

        let resolvedFiles = try resolveFiles(rootURL: rootURL, provided: fileURLs, query: q)
        var perFile: [ReplaceResult.PerFile] = []
        perFile.reserveCapacity(resolvedFiles.count)

        var totalReplacements = 0
        var filesTouched = 0

        for url in resolvedFiles {
            try Task.checkCancellation()
            let (changed, reps) = try replaceInFile(url: url, compiled: compiled, replacement: replacement)
            if changed {
                filesTouched += 1
                totalReplacements += reps
                perFile.append(.init(filePath: url.path, replacements: reps))
            }
        }

        return ReplaceResult(filesTouched: filesTouched,
                             replacements: totalReplacements,
                             fileResults: perFile)
    }

    // MARK: - File enumeration + filtering

    private func resolveFiles(rootURL: URL, provided: [URL]?, query: SearchQuery) throws -> [URL] {
        let all: [URL]
        if let provided {
            all = provided
        } else {
            all = try enumerateFiles(rootURL: rootURL)
        }
        return all.filter { url in
            guard url.isFileURL else { return false }
            let path = url.path
            if matchesAnyGlob(path: path, globs: query.excludeGlobs) { return false }
            if query.includeGlobs.isEmpty { return true }
            return matchesAnyGlob(path: path, globs: query.includeGlobs)
        }
    }

    private func enumerateFiles(rootURL: URL) throws -> [URL] {
        let fm = FileManager.default
        guard let enumerator = fm.enumerator(at: rootURL,
                                            includingPropertiesForKeys: [.isRegularFileKey, .isDirectoryKey],
                                            options: [.skipsHiddenFiles],
                                            errorHandler: { _, _ in true }) else {
            return []
        }

        var urls: [URL] = []
        for case let url as URL in enumerator {
            let values = try? url.resourceValues(forKeys: [.isRegularFileKey, .isDirectoryKey])
            if values?.isDirectory == true { continue }
            if values?.isRegularFile == true {
                urls.append(url)
            }
        }
        return urls
    }

    // MARK: - Actual searching

    private struct CompiledPattern {
        enum Kind {
            case regex(NSRegularExpression)
            case literal(needle: String, compareLowercased: Bool, wholeWord: Bool)
        }
        let kind: Kind
    }

    private func compilePattern(for query: SearchQuery) throws -> CompiledPattern {
        if query.options.isRegex {
            let opts: NSRegularExpression.Options = query.options.isCaseSensitive ? [] : [.caseInsensitive]
            do {
                let re = try NSRegularExpression(pattern: query.text, options: opts)
                return CompiledPattern(kind: .regex(re))
            } catch {
                throw SearchError.invalidRegex(query.text)
            }
        } else {
            // Literal search.
            let compareLowercased = !query.options.isCaseSensitive
            return CompiledPattern(kind: .literal(needle: query.text,
                                                 compareLowercased: compareLowercased,
                                                 wholeWord: query.options.isWholeWord))
        }
    }

    private func searchFile(url: URL, rootURL: URL, query: SearchQuery) throws -> FileMatch? {
        let compiled = try compilePattern(for: query)
        let data: Data
        do {
            data = try Data(contentsOf: url)
        } catch {
            // ignore unreadable files
            return nil
        }
        // Try UTF-8 first. If it fails, ignore file (keeps implementation safe).
        guard let text = String(data: data, encoding: .utf8) else { return nil }

        let relPath: String
        if url.path.hasPrefix(rootURL.path) {
            relPath = String(url.path.dropFirst(rootURL.path.count)).trimmingCharacters(in: CharacterSet(charactersIn: "/"))
        } else {
            relPath = url.path
        }

        let matches = findMatches(in: text, compiled: compiled)
        if matches.isEmpty { return nil }

        return FileMatch(filePath: relPath, matches: matches)
    }

    private func findMatches(in text: String, compiled: CompiledPattern) -> [FileMatch.Match] {
        switch compiled.kind {
        case .regex(let re):
            return regexMatches(in: text, re: re)
        case .literal(let needle, let compareLowercased, let wholeWord):
            return literalMatches(in: text, needle: needle, compareLowercased: compareLowercased, wholeWord: wholeWord)
        }
    }

    private func regexMatches(in text: String, re: NSRegularExpression) -> [FileMatch.Match] {
        let ns = text as NSString
        let range = NSRange(location: 0, length: ns.length)
        let matches = re.matches(in: text, options: [], range: range)
        if matches.isEmpty { return [] }

        // Precompute line starts for fast conversion.
        let lineIndex = LineIndex(text)

        return matches.compactMap { m in
            guard m.range.location != NSNotFound, m.range.length > 0 else { return nil }
            let (line, col) = lineIndex.lineAndColumn(utf16Offset: m.range.location)
            let preview = lineIndex.lineText(line: line)
            return .init(location: .init(line: line, column: col, length: m.range.length), preview: preview)
        }
    }

    private func literalMatches(in text: String,
                               needle: String,
                               compareLowercased: Bool,
                               wholeWord: Bool) -> [FileMatch.Match] {
        guard !needle.isEmpty else { return [] }

        let haystack = compareLowercased ? text.lowercased() : text
        let n = compareLowercased ? needle.lowercased() : needle

        // Use NSString for UTF16 indexing.
        let nsHay = haystack as NSString
        let nsOrig = text as NSString

        let lineIndex = LineIndex(text)

        var results: [FileMatch.Match] = []
        var searchRange = NSRange(location: 0, length: nsHay.length)

        while true {
            let found = nsHay.range(of: n, options: [], range: searchRange)
            if found.location == NSNotFound { break }

            if wholeWord {
                if !isWholeWordMatch(in: nsHay, range: found) {
                    let nextLoc = found.location + max(found.length, 1)
                    if nextLoc >= nsHay.length { break }
                    searchRange = NSRange(location: nextLoc, length: nsHay.length - nextLoc)
                    continue
                }
            }

            let (line, col) = lineIndex.lineAndColumn(utf16Offset: found.location)
            let preview = lineIndex.lineText(line: line)

            // Use original needle length in UTF16 for accurate highlighting.
            let origLen = (needle as NSString).length
            results.append(.init(location: .init(line: line, column: col, length: origLen), preview: preview))

            let nextLoc = found.location + max(found.length, 1)
            if nextLoc >= nsHay.length { break }
            searchRange = NSRange(location: nextLoc, length: nsHay.length - nextLoc)
        }

        return results
    }

    private func isWholeWordMatch(in nsText: NSString, range: NSRange) -> Bool {
        // Word boundary definition: letters, numbers, underscore.
        func isWordChar(_ u: unichar) -> Bool {
            if u == 95 { return true } // '_'
            // ASCII letters/digits
            if (u >= 48 && u <= 57) || (u >= 65 && u <= 90) || (u >= 97 && u <= 122) { return true }
            return false
        }

        if range.location > 0 {
            let prev = nsText.character(at: range.location - 1)
            if isWordChar(prev) { return false }
        }
        let end = range.location + range.length
        if end < nsText.length {
            let next = nsText.character(at: end)
            if isWordChar(next) { return false }
        }
        return true
    }

    // MARK: - Replace implementation

    private func replaceInFile(url: URL,
                               compiled: CompiledPattern,
                               replacement: String) throws -> (changed: Bool, replacements: Int) {
        let data: Data
        do {
            data = try Data(contentsOf: url)
        } catch {
            return (false, 0)
        }
        guard let text = String(data: data, encoding: .utf8) else { return (false, 0) }

        let (newText, reps) = replaceAll(in: text, compiled: compiled, replacement: replacement)
        guard reps > 0 else { return (false, 0) }

        do {
            // Atomic write.
            try newText.data(using: .utf8)?.write(to: url, options: [.atomic])
        } catch {
            throw SearchError.ioError("Failed to write file: \(url.path)")
        }
        return (true, reps)
    }

    private func replaceAll(in text: String,
                            compiled: CompiledPattern,
                            replacement: String) -> (String, Int) {
        switch compiled.kind {
        case .regex(let re):
            let ns = text as NSString
            let range = NSRange(location: 0, length: ns.length)
            let matches = re.matches(in: text, options: [], range: range)
            if matches.isEmpty { return (text, 0) }
            let out = re.stringByReplacingMatches(in: text, options: [], range: range, withTemplate: replacement)
            return (out, matches.count)

        case .literal(let needle, let compareLowercased, let wholeWord):
            if needle.isEmpty { return (text, 0) }
            // For literal, we re-scan and build output to support whole-word.
            let haystack = compareLowercased ? text.lowercased() : text
            let n = compareLowercased ? needle.lowercased() : needle

            let nsHay = haystack as NSString
            let nsOrig = text as NSString
            let nsNeedle = n as NSString

            var out = ""
            out.reserveCapacity(text.count)

            var cursor = 0
            var reps = 0

            while cursor < nsHay.length {
                let searchRange = NSRange(location: cursor, length: nsHay.length - cursor)
                let found = nsHay.range(of: n, options: [], range: searchRange)
                if found.location == NSNotFound {
                    out += nsOrig.substring(with: NSRange(location: cursor, length: nsOrig.length - cursor))
                    break
                }

                // append leading segment
                out += nsOrig.substring(with: NSRange(location: cursor, length: found.location - cursor))

                if wholeWord && !isWholeWordMatch(in: nsHay, range: found) {
                    // not a whole-word match; append original matched text and continue
                    out += nsOrig.substring(with: found)
                    cursor = found.location + max(found.length, 1)
                    continue
                }

                out += replacement
                reps += 1

                cursor = found.location + max(nsNeedle.length, 1)
            }

            return (out, reps)
        }
    }

    // MARK: - Glob matching

    /// Very small glob matcher supporting '*', '**', and '?'.
    /// Matching is path-based (uses '/' as separator). Globs are compared against the full path.
    private func matchesAnyGlob(path: String, globs: [String]) -> Bool {
        guard !globs.isEmpty else { return false }
        for g in globs {
            if globMatch(path: path, pattern: g) { return true }
        }
        return false
    }

    private func globMatch(path: String, pattern: String) -> Bool {
        // Convert glob to regex.
        // - '**' => '.*'
        // - '*' => '[^/]*'
        // - '?' => '[^/]'
        var regex = "^"
        var i = pattern.startIndex
        while i < pattern.endIndex {
            let ch = pattern[i]
            if ch == "*" {
                let next = pattern.index(after: i)
                if next < pattern.endIndex && pattern[next] == "*" {
                    regex += ".*"
                    i = pattern.index(after: next)
                } else {
                    regex += "[^/]*"
                    i = next
                }
            } else if ch == "?" {
                regex += "[^/]"
                i = pattern.index(after: i)
            } else {
                // escape regex metacharacters
                if "\\.^$|()[]{}+".contains(ch) {
                    // Single backslash to escape the character in regex
                    // e.g., "." becomes "\." which matches literal dot
                    regex += "\\\(ch)"
                } else {
                    regex.append(ch)
                }
                i = pattern.index(after: i)
            }
        }
        regex += "$"

        let opts: NSRegularExpression.Options = []
        guard let re = try? NSRegularExpression(pattern: regex, options: opts) else { return false }
        let ns = path as NSString
        let r = NSRange(location: 0, length: ns.length)
        return re.firstMatch(in: path, options: [], range: r) != nil
    }

    // MARK: - Glob Pattern Testing

    /// Runs all glob pattern tests and returns results for verification
    /// - Returns: Tuple containing (passedCount, failedCount, [failureDetails])
    public func runGlobTests() -> (passed: Int, failed: Int, failures: [String]) {
        var passed = 0
        var failed = 0
        var failures: [String] = []

        func assert(_ condition: Bool, _ message: String) {
            if condition {
                passed += 1
            } else {
                failed += 1
                failures.append(message)
            }
        }

        // MARK: 1. testGlobStar - single * matches any chars except /
        
        // Single * should match any characters except path separator /
        assert(globMatch(path: "file.swift", pattern: "*.swift"), "testGlobStar: *.swift should match file.swift")
        assert(globMatch(path: "main.swift", pattern: "*.swift"), "testGlobStar: *.swift should match main.swift")
        assert(globMatch(path: "ViewController.swift", pattern: "*.swift"), "testGlobStar: *.swift should match ViewController.swift")
        assert(!globMatch(path: "src/file.swift", pattern: "*.swift"), "testGlobStar: *.swift should NOT match src/file.swift (contains /)")
        assert(!globMatch(path: "path/to/file.swift", pattern: "*.swift"), "testGlobStar: *.swift should NOT match path/to/file.swift (contains /)")
        
        // * in the middle
        assert(globMatch(path: "test-file.txt", pattern: "test-*.txt"), "testGlobStar: test-*.txt should match test-file.txt")
        assert(globMatch(path: "test-123.txt", pattern: "test-*.txt"), "testGlobStar: test-*.txt should match test-123.txt")
        assert(globMatch(path: "test-123-456.txt", pattern: "test-*.txt"), "testGlobStar: test-*.txt should match test-123-456.txt")
        
        // Multiple *
        assert(globMatch(path: "a.b.swift", pattern: "*.*.swift"), "testGlobStar: *.*.swift should match a.b.swift")
        assert(globMatch(path: "View.Controller.swift", pattern: "*.*.swift"), "testGlobStar: *.*.swift should match View.Controller.swift")
        assert(!globMatch(path: "file.swift", pattern: "*.*.swift"), "testGlobStar: *.*.swift should NOT match file.swift (no dot before .swift)")

        // MARK: 2. testGlobDoubleStar - ** matches any path including /
        
        // ** should match any characters including path separator /
        assert(globMatch(path: "file.swift", pattern: "**/*.swift"), "testGlobDoubleStar: **/*.swift should match file.swift")
        assert(globMatch(path: "src/file.swift", pattern: "**/*.swift"), "testGlobDoubleStar: **/*.swift should match src/file.swift")
        assert(globMatch(path: "path/to/file.swift", pattern: "**/*.swift"), "testGlobDoubleStar: **/*.swift should match path/to/file.swift")
        assert(globMatch(path: "very/deep/nested/path/file.swift", pattern: "**/*.swift"), "testGlobDoubleStar: **/*.swift should match very/deep/nested/path/file.swift")
        assert(!globMatch(path: "file.txt", pattern: "**/*.swift"), "testGlobDoubleStar: **/*.swift should NOT match file.txt (wrong extension)")
        assert(!globMatch(path: "src/file.txt", pattern: "**/*.swift"), "testGlobDoubleStar: **/*.swift should NOT match src/file.txt (wrong extension)")
        
        // ** at the start only
        assert(globMatch(path: "foo/bar/baz", pattern: "**/baz"), "testGlobDoubleStar: **/baz should match foo/bar/baz")
        assert(globMatch(path: "baz", pattern: "**/baz"), "testGlobDoubleStar: **/baz should match baz")
        assert(globMatch(path: "a/b/c/baz", pattern: "**/baz"), "testGlobDoubleStar: **/baz should match a/b/c/baz")
        
        // ** at the end
        assert(globMatch(path: "src/", pattern: "src/**"), "testGlobDoubleStar: src/** should match src/")
        assert(globMatch(path: "src/file.swift", pattern: "src/**"), "testGlobDoubleStar: src/** should match src/file.swift")
        assert(globMatch(path: "src/components/Button.swift", pattern: "src/**"), "testGlobDoubleStar: src/** should match src/components/Button.swift")

        // MARK: 3. testGlobQuestion - ? matches single char
        
        // ? should match exactly one character (any char except /)
        assert(globMatch(path: "file1.swift", pattern: "file?.swift"), "testGlobQuestion: file?.swift should match file1.swift")
        assert(globMatch(path: "fileA.swift", pattern: "file?.swift"), "testGlobQuestion: file?.swift should match fileA.swift")
        assert(globMatch(path: "file_.swift", pattern: "file?.swift"), "testGlobQuestion: file?.swift should match file_.swift")
        assert(!globMatch(path: "file12.swift", pattern: "file?.swift"), "testGlobQuestion: file?.swift should NOT match file12.swift (two chars)")
        assert(!globMatch(path: "file.swift", pattern: "file?.swift"), "testGlobQuestion: file?.swift should NOT match file.swift (no char before .swift)")
        assert(!globMatch(path: "file/1.swift", pattern: "file?.swift"), "testGlobQuestion: file?.swift should NOT match file/1.swift (? doesn't match /)")
        
        // Multiple ?
        assert(globMatch(path: "file01.txt", pattern: "file??.txt"), "testGlobQuestion: file??.txt should match file01.txt")
        assert(globMatch(path: "fileAB.txt", pattern: "file??.txt"), "testGlobQuestion: file??.txt should match fileAB.txt")
        assert(!globMatch(path: "file1.txt", pattern: "file??.txt"), "testGlobQuestion: file??.txt should NOT match file1.txt (only one char)")

        // MARK: 4. testGlobExactMatch - exact path matching
        
        // Exact path should match exactly
        assert(globMatch(path: "file.swift", pattern: "file.swift"), "testGlobExactMatch: exact match file.swift")
        assert(globMatch(path: "src/file.swift", pattern: "src/file.swift"), "testGlobExactMatch: exact match src/file.swift")
        assert(!globMatch(path: "File.swift", pattern: "file.swift"), "testGlobExactMatch: file.swift should NOT match File.swift (case sensitive)")
        assert(!globMatch(path: "file.swift", pattern: "file.txt"), "testGlobExactMatch: file.txt should NOT match file.swift")
        assert(!globMatch(path: "src/file.swift", pattern: "file.swift"), "testGlobExactMatch: file.swift should NOT match src/file.swift (different path)")
        
        // Empty pattern edge case
        assert(!globMatch(path: "file.swift", pattern: ""), "testGlobExactMatch: empty pattern should NOT match file.swift")
        assert(globMatch(path: "", pattern: ""), "testGlobExactMatch: empty pattern should match empty path")

        // MARK: 5. testGlobMultiplePatterns - test matchesAnyGlob with array
        
        // Test matchesAnyGlob with multiple patterns
        assert(matchesAnyGlob(path: "file.swift", globs: ["*.swift", "*.md"]), "testGlobMultiplePatterns: should match *.swift in array")
        assert(matchesAnyGlob(path: "README.md", globs: ["*.swift", "*.md"]), "testGlobMultiplePatterns: should match *.md in array")
        assert(!matchesAnyGlob(path: "file.txt", globs: ["*.swift", "*.md"]), "testGlobMultiplePatterns: should NOT match *.txt")
        
        assert(matchesAnyGlob(path: "src/main.swift", globs: ["**/*.swift", "**/*.h", "**/*.m"]), "testGlobMultiplePatterns: should match **/*.swift")
        assert(matchesAnyGlob(path: "headers/main.h", globs: ["**/*.swift", "**/*.h", "**/*.m"]), "testGlobMultiplePatterns: should match **/*.h")
        assert(matchesAnyGlob(path: "impl/main.m", globs: ["**/*.swift", "**/*.h", "**/*.m"]), "testGlobMultiplePatterns: should match **/*.m")
        assert(!matchesAnyGlob(path: "src/main.js", globs: ["**/*.swift", "**/*.h", "**/*.m"]), "testGlobMultiplePatterns: should NOT match **/*.js")
        
        // Empty globs array
        assert(!matchesAnyGlob(path: "file.swift", globs: []), "testGlobMultiplePatterns: empty globs should return false")
        
        // Single pattern in array
        assert(matchesAnyGlob(path: "file.swift", globs: ["*.swift"]), "testGlobMultiplePatterns: single pattern array should match")
        assert(!matchesAnyGlob(path: "file.txt", globs: ["*.swift"]), "testGlobMultiplePatterns: single pattern array should NOT match wrong extension")

        // MARK: 6. testGlobEdgeCases - empty patterns, special chars
        
        // Only wildcards
        assert(globMatch(path: "anything", pattern: "*"), "testGlobEdgeCases: * should match anything")
        assert(globMatch(path: "", pattern: "*"), "testGlobEdgeCases: * should match empty string")
        assert(globMatch(path: "a/b/c", pattern: "**"), "testGlobEdgeCases: ** should match a/b/c")
        
        // Special regex characters that should be escaped (treated as literals)
        assert(globMatch(path: "file.swift", pattern: "file.swift"), "testGlobEdgeCases: . should be literal, not regex wildcard")
        assert(!globMatch(path: "fileXswift", pattern: "file.swift"), "testGlobEdgeCases: . should NOT match X")
        assert(globMatch(path: "test+file.swift", pattern: "test+file.swift"), "testGlobEdgeCases: + should be literal")
        assert(globMatch(path: "(test).swift", pattern: "(test).swift"), "testGlobEdgeCases: () should be literal")
        assert(globMatch(path: "[test].swift", pattern: "[test].swift"), "testGlobEdgeCases: [] should be literal")
        
        // Escaped characters in pattern
        assert(globMatch(path: "file.swift", pattern: #"file\.swift"#), "testGlobEdgeCases: escaped dot should match literal dot")
        
        // Whitespace handling
        assert(globMatch(path: "file name.swift", pattern: "file*.swift"), "testGlobEdgeCases: should match with space in filename")
        assert(globMatch(path: "file name.swift", pattern: "file *.swift"), "testGlobEdgeCases: should match with space in pattern")

        // MARK: 7. testGlobSwiftFiles - **/*.swift pattern
        
        let swiftPattern = "**/*.swift"
        
        // Root level Swift files
        assert(globMatch(path: "main.swift", pattern: swiftPattern), "testGlobSwiftFiles: **/*.swift should match main.swift")
        assert(globMatch(path: "App.swift", pattern: swiftPattern), "testGlobSwiftFiles: **/*.swift should match App.swift")
        
        // Nested Swift files
        assert(globMatch(path: "Sources/main.swift", pattern: swiftPattern), "testGlobSwiftFiles: **/*.swift should match Sources/main.swift")
        assert(globMatch(path: "Sources/Models/User.swift", pattern: swiftPattern), "testGlobSwiftFiles: **/*.swift should match Sources/Models/User.swift")
        assert(globMatch(path: "Sources/Views/Buttons/PrimaryButton.swift", pattern: swiftPattern), "testGlobSwiftFiles: **/*.swift should match deep nested path")
        
        // Deep nesting
        assert(globMatch(path: "a/b/c/d/e/f/g/file.swift", pattern: swiftPattern), "testGlobSwiftFiles: **/*.swift should match very deep path")
        
        // Non-matching cases
        assert(!globMatch(path: "main.m", pattern: swiftPattern), "testGlobSwiftFiles: **/*.swift should NOT match main.m")
        assert(!globMatch(path: "Sources/main.m", pattern: swiftPattern), "testGlobSwiftFiles: **/*.swift should NOT match Sources/main.m")
        assert(!globMatch(path: "file.txt", pattern: swiftPattern), "testGlobSwiftFiles: **/*.swift should NOT match file.txt")
        assert(!globMatch(path: "Sources/file.h", pattern: swiftPattern), "testGlobSwiftFiles: **/*.swift should NOT match Sources/file.h")
        
        // Edge cases that look similar
        assert(!globMatch(path: "file.swift.txt", pattern: swiftPattern), "testGlobSwiftFiles: **/*.swift should NOT match file.swift.txt (ends with .txt)")
        assert(!globMatch(path: "file.swiftbackup", pattern: swiftPattern), "testGlobSwiftFiles: **/*.swift should NOT match file.swiftbackup (ends with backup)")

        // MARK: 8. testGlobExcludeNodeModules - **/node_modules/** pattern
        
        let nodeModulesPattern = "**/node_modules/**"
        
        // Should match node_modules at any level
        assert(globMatch(path: "node_modules/", pattern: nodeModulesPattern), "testGlobExcludeNodeModules: should match node_modules/")
        assert(globMatch(path: "node_modules/lodash", pattern: nodeModulesPattern), "testGlobExcludeNodeModules: should match node_modules/lodash")
        assert(globMatch(path: "node_modules/lodash/index.js", pattern: nodeModulesPattern), "testGlobExcludeNodeModules: should match node_modules/lodash/index.js")
        assert(globMatch(path: "client/node_modules/", pattern: nodeModulesPattern), "testGlobExcludeNodeModules: should match client/node_modules/")
        assert(globMatch(path: "client/node_modules/react", pattern: nodeModulesPattern), "testGlobExcludeNodeModules: should match client/node_modules/react")
        assert(globMatch(path: "client/node_modules/react/index.js", pattern: nodeModulesPattern), "testGlobExcludeNodeModules: should match client/node_modules/react/index.js")
        assert(globMatch(path: "src/client/node_modules/package/lib/file.js", pattern: nodeModulesPattern), "testGlobExcludeNodeModules: should match deeply nested node_modules")
        
        // Deep nesting
        assert(globMatch(path: "a/b/c/node_modules/package/file.js", pattern: nodeModulesPattern), "testGlobExcludeNodeModules: should match a/b/c/node_modules")
        
        // Should NOT match (not node_modules)
        assert(!globMatch(path: "src/main.js", pattern: nodeModulesPattern), "testGlobExcludeNodeModules: should NOT match src/main.js")
        assert(!globMatch(path: "node_modules_backup/file.js", pattern: nodeModulesPattern), "testGlobExcludeNodeModules: should NOT match node_modules_backup (not exact match)")
        assert(!globMatch(path: "src/node_modules_test/file.js", pattern: nodeModulesPattern), "testGlobExcludeNodeModules: should NOT match node_modules_test")
        assert(!globMatch(path: "mynode_modules/file.js", pattern: nodeModulesPattern), "testGlobExcludeNodeModules: should NOT match mynode_modules")

        // MARK: Additional Comprehensive Tests
        
        // Pattern with **, *, and ?
        assert(globMatch(path: "src/components/Button.swift", pattern: "**/*?utton.swift"), "testComplex: **/*?utton.swift should match src/components/Button.swift")
        assert(globMatch(path: "Button.swift", pattern: "**/*?utton.swift"), "testComplex: **/*?utton.swift should match Button.swift")
        assert(!globMatch(path: "src/components/Switch.swift", pattern: "**/*?utton.swift"), "testComplex: **/*?utton.swift should NOT match Switch.swift")
        
        // Multiple ** in pattern
        assert(globMatch(path: "a/b/c/d/e", pattern: "**/b/**/d/**"), "testComplex: **/b/**/d/** should match a/b/c/d/e")
        assert(globMatch(path: "src/test/unit/utils", pattern: "**/test/**/utils"), "testComplex: **/test/**/utils should match src/test/unit/utils")
        
        // Real-world patterns
        assert(globMatch(path: "Tests/Unit/Test.swift", pattern: "Tests/**/*.swift"), "testComplex: Tests/**/*.swift should match Tests/Unit/Test.swift")
        assert(globMatch(path: "Tests/Integration/UI/Test.swift", pattern: "Tests/**/*.swift"), "testComplex: Tests/**/*.swift should match deeply nested test")
        
        // Xcode project patterns
        assert(globMatch(path: "MyApp.xcodeproj/project.pbxproj", pattern: "*.xcodeproj/*.pbxproj"), "testComplex: *.xcodeproj/*.pbxproj should match")
        assert(!globMatch(path: "MyApp.xcodeproj/project.xcworkspace", pattern: "*.xcodeproj/*.pbxproj"), "testComplex: *.xcodeproj/*.pbxproj should NOT match .xcworkspace")

        // MARK: Dotfiles
        assert(globMatch(path: ".gitignore", pattern: ".gitignore"), "testDotFiles: .gitignore should match")
        assert(globMatch(path: ".env", pattern: ".*"), "testDotFiles: .* should match .env")
        assert(globMatch(path: ".swiftlint.yml", pattern: ".*"), "testDotFiles: .* should match .swiftlint.yml")
        assert(globMatch(path: ".github/workflows/ci.yml", pattern: ".github/**"), "testDotFiles: .github/** should match")
        assert(!globMatch(path: "gitignore", pattern: ".gitignore"), "testDotFiles: .gitignore should NOT match gitignore (no dot)")

        return (passed, failed, failures)
    }
}

// MARK: - Line indexing helper

/// LineIndex is internal to allow testing while being encapsulated within SearchManager
internal struct LineIndex {
    private let text: String
    private let nsText: NSString
    // line start offsets in UTF16
    private var lineStarts: [Int] = [0]
    private var lines: [String] = []

    init(_ text: String) {
        self.text = text
        self.nsText = text as NSString

        // Build lineStarts and cache line strings.
        // Use NSString lineRange(for:) to be safe with various newline types.
        var idx = 0
        var currentLine = 1
        while idx < nsText.length {
            let r = nsText.lineRange(for: NSRange(location: idx, length: 0))
            let lineStr = nsText.substring(with: r).trimmingCharacters(in: CharacterSet.newlines)
            if lines.count < currentLine { lines.append(lineStr) } else { lines[currentLine - 1] = lineStr }

            idx = NSMaxRange(r)
            if idx < nsText.length {
                lineStarts.append(idx)
                currentLine += 1
            }
        }
        if nsText.length == 0 {
            lines = [""]
            lineStarts = [0]
        } else if lines.isEmpty {
            // single line without newline
            lines = [text]
            lineStarts = [0]
        }
    }

    func lineAndColumn(utf16Offset: Int) -> (line: Int, column: Int) {
        // Binary search lineStarts to find last start <= offset.
        var lo = 0
        var hi = lineStarts.count - 1
        while lo <= hi {
            let mid = (lo + hi) / 2
            let v = lineStarts[mid]
            if v == utf16Offset {
                return (mid + 1, 1)
            } else if v < utf16Offset {
                lo = mid + 1
            } else {
                hi = mid - 1
            }
        }
        let lineIndex = max(hi, 0)
        let lineStart = lineStarts[lineIndex]
        let col = max(utf16Offset - lineStart, 0) + 1
        return (lineIndex + 1, col)
    }

    func lineText(line: Int) -> String {
        let i = max(1, line) - 1
        if i >= 0 && i < lines.count { return lines[i] }
        return ""
    }
    
    /// Internal accessor for testing binary search behavior
    internal var lineStartOffsets: [Int] { lineStarts }
    internal var lineCount: Int { lines.count }
    internal var allLines: [String] { lines }
}
