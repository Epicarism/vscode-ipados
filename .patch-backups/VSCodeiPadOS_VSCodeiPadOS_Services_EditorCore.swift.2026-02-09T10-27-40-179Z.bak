import SwiftUI
import UniformTypeIdentifiers

// MARK: - Editor Core (Central State Manager)
class EditorCore: ObservableObject {
    @Published var tabs: [Tab] = []
    @Published var activeTabId: UUID?
    @Published var showSidebar = true
    @Published var sidebarWidth: CGFloat = 250
    @Published var showFilePicker = false
    @Published var searchText = ""
    @Published var showSearch = false
    @Published var showCommandPalette = false
    @Published var showQuickOpen = false
    @Published var showAIAssistant = false
    @Published var showGoToLine = false
    
    // Cursor tracking
    @Published var cursorPosition = CursorPosition()
    
    // Multi-cursor support
    @Published var multiCursorState = MultiCursorState()
    @Published var currentSelection: String = ""
    @Published var currentSelectionRange: NSRange?
    
    var activeTab: Tab? {
        tabs.first { $0.id == activeTabId }
    }
    
    var activeTabIndex: Int? {
        tabs.firstIndex { $0.id == activeTabId }
    }
    
    init() {
        // Create a default welcome tab
        let defaultTab = Tab(
            fileName: "Welcome.swift",
            content: """
// Welcome to VS Code for iPadOS! ðŸŽ‰
//
// Features:
// â€¢ Syntax highlighting for Swift, JS, Python, and more
// â€¢ Multiple tabs with drag reordering
// â€¢ File explorer sidebar
// â€¢ Command palette (âŒ˜+Shift+P)
// â€¢ Quick open (âŒ˜+P)
// â€¢ Find & Replace (âŒ˜+F)
// â€¢ AI Assistant
// â€¢ Minimap navigation
// â€¢ Code folding
// â€¢ Go to line (âŒ˜+G)
//
// Start editing or open a file!

import SwiftUI

struct ContentView: View {
    var body: some View {
        Text("Hello, World!")
            .font(.largeTitle)
            .foregroundColor(.blue)
    }
}
""",
            language: "swift"
        )
        tabs.append(defaultTab)
        activeTabId = defaultTab.id
    }
    
    // MARK: - Tab Management
    
    func addTab(fileName: String = "Untitled.swift", content: String = "", url: URL? = nil) {
        // Check if file is already open
        if let url = url, let existingTab = tabs.first(where: { $0.url == url }) {
            activeTabId = existingTab.id
            return
        }
        
        let newTab = Tab(fileName: fileName, content: content, url: url)
        tabs.append(newTab)
        activeTabId = newTab.id
    }
    
    func closeTab(id: UUID) {
        guard let index = tabs.firstIndex(where: { $0.id == id }) else { return }
        
        tabs.remove(at: index)
        
        // Update active tab if we closed the active one
        if activeTabId == id {
            if tabs.isEmpty {
                activeTabId = nil
            } else if index >= tabs.count {
                activeTabId = tabs[tabs.count - 1].id
            } else {
                activeTabId = tabs[index].id
            }
        }
    }
    
    func closeAllTabs() {
        tabs.removeAll()
        activeTabId = nil
    }
    
    func closeOtherTabs(except id: UUID) {
        tabs.removeAll { $0.id != id }
        activeTabId = id
    }
    
    func selectTab(id: UUID) {
        activeTabId = id
    }
    
    func nextTab() {
        guard let currentIndex = activeTabIndex, tabs.count > 1 else { return }
        let nextIndex = (currentIndex + 1) % tabs.count
        activeTabId = tabs[nextIndex].id
    }
    
    func previousTab() {
        guard let currentIndex = activeTabIndex, tabs.count > 1 else { return }
        let prevIndex = currentIndex == 0 ? tabs.count - 1 : currentIndex - 1
        activeTabId = tabs[prevIndex].id
    }
    
    func moveTab(from source: IndexSet, to destination: Int) {
        tabs.move(fromOffsets: source, toOffset: destination)
    }
    
    // MARK: - Content Management
    
    func updateActiveTabContent(_ content: String) {
        guard let index = activeTabIndex else { return }
        tabs[index].content = content
        if tabs[index].url != nil {
            tabs[index].isUnsaved = true
        }
    }
    
    func saveActiveTab() {
        guard let index = activeTabIndex,
              let url = tabs[index].url else { return }
        
        do {
            try tabs[index].content.write(to: url, atomically: true, encoding: .utf8)
            tabs[index].isUnsaved = false
        } catch {
            print("Error saving file: \(error)")
        }
    }
    
    func saveAllTabs() {
        for index in tabs.indices {
            guard let url = tabs[index].url, tabs[index].isUnsaved else { continue }
            
            do {
                try tabs[index].content.write(to: url, atomically: true, encoding: .utf8)
                tabs[index].isUnsaved = false
            } catch {
                print("Error saving file: \(error)")
            }
        }
    }
    
    // MARK: - File Operations
    
    func openFile(from url: URL) {
        guard url.startAccessingSecurityScopedResource() else { return }
        defer { url.stopAccessingSecurityScopedResource() }
        
        do {
            let content = try String(contentsOf: url, encoding: .utf8)
            addTab(fileName: url.lastPathComponent, content: content, url: url)
        } catch {
            print("Error opening file: \(error)")
        }
    }
    
    func openFile(_ fileItem: FileItem) {
        guard let url = fileItem.url else {
            // Try path
            if !fileItem.path.isEmpty {
                let fileURL = URL(fileURLWithPath: fileItem.path)
                openFile(from: fileURL)
            }
            return
        }
        openFile(from: url)
    }
    
    // MARK: - UI Toggles
    
    func toggleSidebar() {
        withAnimation(.spring(response: 0.3)) {
            showSidebar.toggle()
        }
    }
    
    func toggleCommandPalette() {
        showCommandPalette.toggle()
    }
    
    func toggleQuickOpen() {
        showQuickOpen.toggle()
    }
    
    func toggleSearch() {
        showSearch.toggle()
    }
    
    func toggleAIAssistant() {
        showAIAssistant.toggle()
    }
}
