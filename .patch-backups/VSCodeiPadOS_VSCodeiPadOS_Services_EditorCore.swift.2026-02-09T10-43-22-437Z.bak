import SwiftUI
import UniformTypeIdentifiers

// MARK: - Editor Core (Central State Manager)
class EditorCore: ObservableObject {
    @Published var tabs: [Tab] = []
    @Published var activeTabId: UUID?
    @Published var showSidebar = true
    @Published var sidebarWidth: CGFloat = 250
    @Published var showFilePicker = false
    @Published var searchText = ""
    @Published var showSearch = false
    @Published var showCommandPalette = false
    @Published var showQuickOpen = false
    @Published var showAIAssistant = false
    @Published var showGoToLine = false
    @Published var showGoToSymbol = false
    
    // Cursor tracking
    @Published var cursorPosition = CursorPosition()
    
    // Multi-cursor support
    @Published var multiCursorState = MultiCursorState()
    @Published var currentSelection: String = ""
    @Published var currentSelectionRange: NSRange?
    
    /// Track active security-scoped URL access while files are open in tabs.
    /// This avoids losing access after opening a document (common on iPadOS).
    private var securityScopedAccessCounts: [URL: Int] = [:]
    
    var activeTab: Tab? {
        tabs.first { $0.id == activeTabId }
    }
    
    var activeTabIndex: Int? {
        tabs.firstIndex { $0.id == activeTabId }
    }
    
    init() {
        // Create a default welcome tab
        let defaultTab = Tab(
            fileName: "Welcome.swift",
            content: """
// Welcome to VS Code for iPadOS! ðŸŽ‰
//
// Features:
// â€¢ Syntax highlighting for Swift, JS, Python, and more
// â€¢ Multiple tabs with drag reordering
// â€¢ File explorer sidebar
// â€¢ Command palette (âŒ˜+Shift+P)
// â€¢ Quick open (âŒ˜+P)
// â€¢ Find & Replace (âŒ˜+F)
// â€¢ AI Assistant
// â€¢ Minimap navigation
// â€¢ Code folding
// â€¢ Go to line (âŒ˜+G)
//
// Start editing or open a file!

import SwiftUI

struct ContentView: View {
    var body: some View {
        Text("Hello, World!")
            .font(.largeTitle)
            .foregroundColor(.blue)
    }
}
""",
            language: "swift"
        )
        tabs.append(defaultTab)
        activeTabId = defaultTab.id
    }
    
    // MARK: - Tab Management
    
    func addTab(fileName: String = "Untitled.swift", content: String = "", url: URL? = nil) {
        // Check if file is already open
        if let url = url, let existingTab = tabs.first(where: { $0.url == url }) {
            activeTabId = existingTab.id
            return
        }
        
        let newTab = Tab(fileName: fileName, content: content, url: url)
        tabs.append(newTab)
        activeTabId = newTab.id
    }
    
    func closeTab(id: UUID) {
        guard let index = tabs.firstIndex(where: { $0.id == id }) else { return }
        
        // Release security-scoped access if this tab was holding it.
        if let url = tabs[index].url {
            releaseSecurityScopedAccess(to: url)
        }
        
        tabs.remove(at: index)
        
        // Update active tab if we closed the active one
        if activeTabId == id {
            if tabs.isEmpty {
                activeTabId = nil
            } else if index >= tabs.count {
                activeTabId = tabs[tabs.count - 1].id
            } else {
                activeTabId = tabs[index].id
            }
        }
    }
    
    func closeAllTabs() {
        tabs.removeAll()
        activeTabId = nil
    }
    
    func closeOtherTabs(except id: UUID) {
        tabs.removeAll { $0.id != id }
        activeTabId = id
    }
    
    func selectTab(id: UUID) {
        activeTabId = id
    }
    
    func nextTab() {
        guard let currentIndex = activeTabIndex, tabs.count > 1 else { return }
        let nextIndex = (currentIndex + 1) % tabs.count
        activeTabId = tabs[nextIndex].id
    }
    
    func previousTab() {
        guard let currentIndex = activeTabIndex, tabs.count > 1 else { return }
        let prevIndex = currentIndex == 0 ? tabs.count - 1 : currentIndex - 1
        activeTabId = tabs[prevIndex].id
    }
    
    func moveTab(from source: IndexSet, to destination: Int) {
        tabs.move(fromOffsets: source, toOffset: destination)
    }
    
    // MARK: - Content Management
    
    func updateActiveTabContent(_ content: String) {
        guard let index = activeTabIndex else { return }
        tabs[index].content = content
        if tabs[index].url != nil {
            tabs[index].isUnsaved = true
        }
    }
    
    func saveActiveTab() {
        guard let index = activeTabIndex,
              let url = tabs[index].url else { return }
        
        do {
            try tabs[index].content.write(to: url, atomically: true, encoding: .utf8)
            tabs[index].isUnsaved = false
        } catch {
            print("Error saving file: \(error)")
        }
    }
    
    func saveAllTabs() {
        for index in tabs.indices {
            guard let url = tabs[index].url, tabs[index].isUnsaved else { continue }
            
            do {
                try tabs[index].content.write(to: url, atomically: true, encoding: .utf8)
                tabs[index].isUnsaved = false
            } catch {
                print("Error saving file: \(error)")
            }
        }
    }
    
    // MARK: - File Operations
    
    func openFile(from url: URL) {
        guard url.startAccessingSecurityScopedResource() else { return }
        defer { url.stopAccessingSecurityScopedResource() }
        
        do {
            let content = try String(contentsOf: url, encoding: .utf8)
            addTab(fileName: url.lastPathComponent, content: content, url: url)
        } catch {
            print("Error opening file: \(error)")
        }
    }
    
    func openFile(_ fileItem: FileItem) {
        guard let url = fileItem.url else {
            // Try path
            if !fileItem.path.isEmpty {
                let fileURL = URL(fileURLWithPath: fileItem.path)
                openFile(from: fileURL)
            }
            return
        }
        openFile(from: url)
    }
    
    // MARK: - UI Toggles
    
    func toggleSidebar() {
        withAnimation(.spring(response: 0.3)) {
            showSidebar.toggle()
        }
    }
    
    func toggleCommandPalette() {
        showCommandPalette.toggle()
    }
    
    func toggleQuickOpen() {
        showQuickOpen.toggle()
    }
    
    func toggleSearch() {
        showSearch.toggle()
    }
    
    func toggleAIAssistant() {
        showAIAssistant.toggle()
    }
    
    func toggleGoToSymbol() {
        showGoToSymbol.toggle()
    }
    
    // MARK: - Multi-Cursor Operations
    
    /// Add cursor at a specific position (Option+Click)
    func addCursorAtPosition(_ position: Int) {
        multiCursorState.addCursor(at: position)
    }
    
    /// Add next occurrence of current selection (Cmd+D)
    func addNextOccurrence() {
        guard let index = activeTabIndex else { return }
        let content = tabs[index].content
        
        // Get the word/selection to search for
        let searchText: String
        let startPosition: Int
        
        if let range = currentSelectionRange, range.length > 0,
           let swiftRange = Range(range, in: content) {
            searchText = String(content[swiftRange])
            startPosition = range.location + range.length
        } else if let primary = multiCursorState.primaryCursor {
            // No selection - select the word under cursor
            let wordRange = findWordAtPosition(primary.position, in: content)
            if let range = wordRange, range.length > 0,
               let swiftRange = Range(range, in: content) {
                searchText = String(content[swiftRange])
                startPosition = range.location + range.length
                
                // First Cmd+D selects the word under cursor
                multiCursorState.cursors = [Cursor(position: range.location + range.length, anchor: range.location, isPrimary: true)]
                currentSelectionRange = range
                currentSelection = searchText
                return
            } else {
                return
            }
        } else {
            return
        }
        
        // Find next occurrence
        if let nextRange = content.findNextOccurrence(of: searchText, after: startPosition) {
            // Check if this occurrence is already selected
            let alreadySelected = multiCursorState.cursors.contains { cursor in
                if let selRange = cursor.selectionRange {
                    return selRange.location == nextRange.location
                }
                return false
            }
            
            if !alreadySelected {
                multiCursorState.addCursorWithSelection(
                    position: nextRange.location + nextRange.length,
                    anchor: nextRange.location
                )
            }
        }
    }
    
    /// Select all occurrences of current selection (Cmd+Shift+L)
    func selectAllOccurrences() {
        guard let index = activeTabIndex else { return }
        let content = tabs[index].content
        
        // Get the word/selection to search for
        let searchText: String
        
        if let range = currentSelectionRange, range.length > 0,
           let swiftRange = Range(range, in: content) {
            searchText = String(content[swiftRange])
        } else if let primary = multiCursorState.primaryCursor {
            // No selection - use word under cursor
            let wordRange = findWordAtPosition(primary.position, in: content)
            if let range = wordRange, range.length > 0,
               let swiftRange = Range(range, in: content) {
                searchText = String(content[swiftRange])
            } else {
                return
            }
        } else {
            return
        }
        
        // Find all occurrences
        let allRanges = content.findAllOccurrences(of: searchText)
        
        guard !allRanges.isEmpty else { return }
        
        // Create cursors for all occurrences
        multiCursorState.cursors = allRanges.enumerated().map { index, range in
            Cursor(
                position: range.location + range.length,
                anchor: range.location,
                isPrimary: index == 0
            )
        }
        
        currentSelection = searchText
    }
    
    /// Reset to single cursor
    func resetToSingleCursor(at position: Int) {
        multiCursorState.reset(to: position)
        currentSelectionRange = nil
        currentSelection = ""
    }
    
    /// Update selection from text view
    func updateSelection(range: NSRange?, text: String) {
        currentSelectionRange = range
        if let range = range, range.length > 0,
           let index = activeTabIndex {
            let content = tabs[index].content
            if let swiftRange = Range(range, in: content) {
                currentSelection = String(content[swiftRange])
            }
        } else {
            currentSelection = ""
        }
    }
    
    /// Find word boundaries at a given position
    private func findWordAtPosition(_ position: Int, in text: String) -> NSRange? {
        guard position >= 0 && position <= text.count else { return nil }
        
        let nsText = text as NSString
        let wordCharacters = CharacterSet.alphanumerics.union(CharacterSet(charactersIn: "_"))
        
        // Find start of word
        var start = position
        while start > 0 {
            let char = nsText.substring(with: NSRange(location: start - 1, length: 1))
            if char.unicodeScalars.allSatisfy({ wordCharacters.contains($0) }) {
                start -= 1
            } else {
                break
            }
        }
        
        // Find end of word
        var end = position
        while end < nsText.length {
            let char = nsText.substring(with: NSRange(location: end, length: 1))
            if char.unicodeScalars.allSatisfy({ wordCharacters.contains($0) }) {
                end += 1
            } else {
                break
            }
        }
        
        if start == end {
            return nil
        }
        
        return NSRange(location: start, length: end - start)
    }
    
    /// Escape multi-cursor mode
    func escapeMultiCursor() {
        if multiCursorState.isMultiCursor {
            if let primary = multiCursorState.primaryCursor {
                resetToSingleCursor(at: primary.position)
            }
        }
    }
}
