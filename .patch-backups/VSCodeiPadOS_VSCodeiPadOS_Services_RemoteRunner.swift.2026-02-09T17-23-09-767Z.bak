import Foundation

/// Errors that can occur during remote execution
enum RemoteRunnerError: Error {
    case connectionFailed(String)
    case fileCreationFailed(String)
    case executionFailed(String)
    case languageNotSupported(String)
    case invalidRemotePath
    case noOutput
}

/// Result of a remote execution
struct RemoteExecutionResult {
    let output: String
    let error: String?
    let exitCode: Int
    let executionTime: TimeInterval
}

/// Service for running code on remote servers
class RemoteRunner {
    
    // MARK: - Language Configuration
    
    /// Configuration for supported languages
    private struct LanguageConfig {
        let interpreter: String
        let fileExtension: String
        let shebang: String?
    }
    
    /// Supported language configurations
    private let languageConfigs: [String: LanguageConfig] = [
        "python": LanguageConfig(
            interpreter: "python3",
            fileExtension: "py",
            shebang: "#!/usr/bin/env python3"
        ),
        "javascript": LanguageConfig(
            interpreter: "node",
            fileExtension: "js",
            shebang: "#!/usr/bin/env node"
        ),
        "typescript": LanguageConfig(
            interpreter: "ts-node",
            fileExtension: "ts",
            shebang: nil
        ),
        "swift": LanguageConfig(
            interpreter: "swift",
            fileExtension: "swift",
            shebang: "#!/usr/bin/env swift"
        ),
        "ruby": LanguageConfig(
            interpreter: "ruby",
            fileExtension: "rb",
            shebang: "#!/usr/bin/env ruby"
        ),
        "bash": LanguageConfig(
            interpreter: "bash",
            fileExtension: "sh",
            shebang: "#!/bin/bash"
        )
    ]
    
    // MARK: - SSH Connection
    
    private var sshSession: SSHSession?
    private let tempDirectory: String
    
    init(tempDirectory: String = "/tmp/vscode-selection") {
        self.tempDirectory = tempDirectory
    }
    
    /// Establishes SSH connection to remote server
    func connect(host: String, port: Int = 22, username: String, password: String?) async throws {
        // SSH connection implementation would go here
        // This is a placeholder for the actual SSH implementation
        throw RemoteRunnerError.connectionFailed("SSH connection not yet implemented")
    }
    
    /// Establishes SSH connection using key-based authentication
    func connect(host: String, port: Int = 22, username: String, privateKey: String) async throws {
        // SSH key-based connection implementation would go here
        throw RemoteRunnerError.connectionFailed("SSH key-based connection not yet implemented")
    }
    
    // MARK: - Run Selection
    
    /// Runs a selected code snippet on the remote server
    /// - Parameters:
    ///   - code: The selected code to execute
    ///   - language: The programming language of the code (python, javascript, typescript, swift, ruby, bash)
    ///   - remotePath: Optional working directory on the remote server
    /// - Returns: The execution result containing output, errors, and exit code
    /// - Throws: RemoteRunnerError if the language is not supported or execution fails
    func runSelection(_ code: String, language: String, remotePath: String?) async throws -> RemoteExecutionResult {
        // Validate language is supported
        guard let config = languageConfigs[language.lowercased()] else {
            throw RemoteRunnerError.languageNotSupported("Language '\(language)' is not supported. Supported languages: \(languageConfigs.keys.joined(separator: ", "))")
        }
        
        // Generate unique temporary filename
        let timestamp = Int(Date().timeIntervalSince1970)
        let randomSuffix = String(format: "%04x", arc4random_uniform(65536))
        let tempFilename = "vscode_selection_\(timestamp)_\(randomSuffix).\(config.fileExtension)"
        
        // Determine the working directory
        let workingDir = remotePath ?? tempDirectory
        let remoteTempPath = "\(workingDir)/\(tempFilename)"
        
        // Ensure temp directory exists on remote
        try await ensureRemoteDirectory(workingDir)
        
        // Prepare code with appropriate shebang if needed
        let preparedCode = prepareCodeForExecution(code, config: config)
        
        // Create temporary file on remote server
        try await createRemoteFile(at: remoteTempPath, content: preparedCode)
        
        // Execute the code
        let startTime = Date()
        let result = try await executeRemoteCommand("\(config.interpreter) \(remoteTempPath)", workingDirectory: workingDir)
        let executionTime = Date().timeIntervalSince(startTime)
        
        // Clean up temporary file
        try? await deleteRemoteFile(at: remoteTempPath)
        
        return RemoteExecutionResult(
            output: result.output,
            error: result.error,
            exitCode: result.exitCode,
            executionTime: executionTime
        )
    }
    
    // MARK: - Helper Methods
    
    /// Prepares code by adding shebang if appropriate
    private func prepareCodeForExecution(_ code: String, config: LanguageConfig) -> String {
        var preparedCode = code
        
        // Add shebang for script-based languages if not already present
        if let shebang = config.shebang, !code.hasPrefix("#!/") {
            preparedCode = "\(shebang)\n\(code)"
        }
        
        return preparedCode
    }
    
    /// Ensures a directory exists on the remote server
    private func ensureRemoteDirectory(_ path: String) async throws {
        let command = "mkdir -p \(path)"
        let result = try await executeRemoteCommand(command, workingDirectory: nil)
        
        if result.exitCode != 0 {
            throw RemoteRunnerError.fileCreationFailed("Failed to create remote directory '\(path)': \(result.error ?? "Unknown error")")
        }
    }
    
    /// Creates a file on the remote server with the given content
    private func createRemoteFile(at path: String, content: String) async throws {
        // Escape special characters for shell
        let escapedContent = content
            .replacingOccurrences(of: "\\", with: "\\\\")
            .replacingOccurrences(of: "\"", with: "\\\"")
            .replacingOccurrences(of: "`", with: "\\`")
            .replacingOccurrences(of: "$", with: "\\$")
        
        // Use here-document to create file
        let command = """
        cat > "\(path)" << 'EOF'
        \(content)
        EOF
        """
        
        let result = try await executeRemoteCommand(command, workingDirectory: nil)
        
        if result.exitCode != 0 {
            throw RemoteRunnerError.fileCreationFailed("Failed to create remote file '\(path)': \(result.error ?? "Unknown error")")
        }
        
        // Make executable for script files
        if path.hasSuffix(".sh") || path.hasSuffix(".swift") {
            _ = try? await executeRemoteCommand("chmod +x \"\(path)\"", workingDirectory: nil)
        }
    }
    
    /// Deletes a file on the remote server
    private func deleteRemoteFile(at path: String) async throws {
        let command = "rm -f \"\(path)\""
        _ = try await executeRemoteCommand(command, workingDirectory: nil)
    }
    
    /// Executes a command on the remote server via SSH
    private func executeRemoteCommand(_ command: String, workingDirectory: String?) async throws -> (output: String, error: String?, exitCode: Int) {
        // This is a placeholder implementation
        // In a real implementation, this would use an SSH library to execute commands
        
        // Construct the full command with working directory if provided
        let fullCommand: String
        if let workingDir = workingDirectory {
            fullCommand = "cd \"\(workingDir)\" && \(command)"
        } else {
            fullCommand = command
        }
        
        // Placeholder for actual SSH execution
        // Real implementation would use libssh2 or similar
        throw RemoteRunnerError.executionFailed("SSH command execution not yet implemented. Command: \(fullCommand)")
    }
    
    // MARK: - Public Utility Methods
    
    /// Check if a language is supported
    func isLanguageSupported(_ language: String) -> Bool {
        return languageConfigs[language.lowercased()] != nil
    }
    
    /// Get list of supported languages
    var supportedLanguages: [String] {
        return Array(languageConfigs.keys).sorted()
    }
    
    /// Closes the SSH connection
    func disconnect() {
        sshSession?.close()
        sshSession = nil
    }
}

// MARK: - SSH Session Protocol

/// Protocol for SSH session operations
protocol SSHSession {
    func execute(_ command: String) async throws -> (output: String, error: String, exitCode: Int)
    func close()
}

// MARK: - Extension for common use cases

extension RemoteRunner {
    
    /// Convenience method to run Python code
    func runPython(_ code: String, remotePath: String? = nil) async throws -> RemoteExecutionResult {
        return try await runSelection(code, language: "python", remotePath: remotePath)
    }
    
    /// Convenience method to run JavaScript code
    func runJavaScript(_ code: String, remotePath: String? = nil) async throws -> RemoteExecutionResult {
        return try await runSelection(code, language: "javascript", remotePath: remotePath)
    }
    
    /// Convenience method to run TypeScript code
    func runTypeScript(_ code: String, remotePath: String? = nil) async throws -> RemoteExecutionResult {
        return try await runSelection(code, language: "typescript", remotePath: remotePath)
    }
    
    /// Convenience method to run Swift code
    func runSwift(_ code: String, remotePath: String? = nil) async throws -> RemoteExecutionResult {
        return try await runSelection(code, language: "swift", remotePath: remotePath)
    }
    
    /// Convenience method to run Ruby code
    func runRuby(_ code: String, remotePath: String? = nil) async throws -> RemoteExecutionResult {
        return try await runSelection(code, language: "ruby", remotePath: remotePath)
    }
    
    /// Convenience method to run Bash code
    func runBash(_ code: String, remotePath: String? = nil) async throws -> RemoteExecutionResult {
        return try await runSelection(code, language: "bash", remotePath: remotePath)
    }
}
