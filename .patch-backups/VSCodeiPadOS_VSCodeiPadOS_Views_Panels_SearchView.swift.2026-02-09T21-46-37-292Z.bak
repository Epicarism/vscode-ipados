import SwiftUI
import Combine

// MARK: - Notification Names for Search

extension NSNotification.Name {
    static let collapseAllSearchResults = NSNotification.Name("collapseAllSearchResults")
    static let expandAllSearchResults = NSNotification.Name("expandAllSearchResults")
}

enum SearchField: Hashable {
    case search
    case replace
    case filesToInclude
    case filesToExclude
}

// MARK: - Data Models

struct SearchResultLine: Identifiable, Hashable {
    let id = UUID()
    let lineNumber: Int
    let text: String
    let matches: [Range<String.Index>]
}

struct SearchNavigationItem: Identifiable, Hashable {
    let id = UUID()
    let fileIndex: Int
    let matchIndex: Int
    let fileID: UUID
    let matchID: UUID
}

struct FileSearchResult: Identifiable, Comparable {
    let id = UUID()
    let fileName: String
    let path: String
    let matches: [SearchResultLine]
    var isExpanded: Bool = true
    
    // Computed property for directory grouping
    var directory: String {
        let components = path.components(separatedBy: "/")
        return components.dropLast().joined(separator: "/")
    }
    
    // Comparable implementation for sorting
    static func < (lhs: FileSearchResult, rhs: FileSearchResult) -> Bool {
        lhs.fileName < rhs.fileName
    }
}

// MARK: - Sort Options

enum SortOption: String, CaseIterable, Identifiable {
    case fileName = "Filename"
    case path = "Path"
    case matches = "Matches"
    
    var id: String { self.rawValue }
    
    var icon: String {
        switch self {
        case .fileName: return "doc.text"
        case .path: return "folder"
        case .matches: return "number"
        }
    }
}

// MARK: - Result Limit

enum ResultLimit: String, CaseIterable, Identifiable {
    case top100 = "Top 100"
    case top500 = "Top 500"
    case all = "All"
    
    var id: String { self.rawValue }
    
    var maxCount: Int? {
        switch self {
        case .top100: return 100
        case .top500: return 500
        case .all: return nil
        }
    }
}

struct SearchView: View {
    var onResultSelected: ((String, Int) -> Void)?
    var rootURL: URL
    
    // MARK: - Search Manager
    @StateObject private var searchManager = SearchManager()
    
    // MARK: - Search State
    @State private var searchText: String = ""
    @State private var replaceText: String = ""
    @State private var filesToInclude: String = ""
    @State private var filesToExclude: String = ""
    
    // MARK: - Focus Management
    @FocusState private var focusedField: SearchField?
    
    // MARK: - Keyboard Navigation
    @State private var selectedNavigationItem: SearchNavigationItem?
    @State private var navigationItems: [SearchNavigationItem] = []
    
    // MARK: - Debounce & Search Task
    @State private var searchTask: Task<Void, Never>?
    @State private var debounceCancellable: AnyCancellable?
    private let debounceInterval: DispatchQueue.SchedulerTimeType.Stride = .milliseconds(400)
    
    @State private var showReplace: Bool = false
    @State private var showDetails: Bool = false
    @State private var showRegexHelp: Bool = false
    
    @State private var matchCase: Bool = false
    @State private var matchWholeWord: Bool = false
    @State private var useRegex: Bool = false
    
    // MARK: - Sort & Filter State
    @State private var sortOption: SortOption = .fileName
    @State private var sortAscending: Bool = true
    @State private var selectedExtensions: Set<String> = []
    @State private var groupByDirectory: Bool = false
    @State private var showFilePath: Bool = true
    @State private var resultLimit: ResultLimit = .all
    @State private var excludeBinaryFiles: Bool = true
    @State private var showFilters: Bool = false
    
    // Common file extensions for quick filtering
    private let commonExtensions = [".swift", ".md", ".json", ".txt", ".js", ".ts", ".html", ".css", ".py", ".rb"]
    
    // Binary file extensions to exclude
    private let binaryExtensions = [".jpg", ".jpeg", ".png", ".gif", ".bmp", ".ico", ".pdf", ".zip", ".tar", ".gz", ".mp3", ".mp4", ".avi", ".mov", ".exe", ".dll", ".so", ".dylib", ".app", ".ipa", ".ipa", ".dmg", ".pkg", ".deb", ".rpm", ".img", ".iso", ".bin", ".dat", ".db", ".sqlite", ".sqlite3", ".ttf", ".otf", ".woff", ".woff2", ".eot"]
    
    @State private var searchHistory: [String] = []
    @State private var showHistory: Bool = false
    
    // MARK: - Error State
    @State private var regexError: String? = nil
    
    // MARK: - Computed Properties
    
    /// Returns the filtered, sorted, and limited results
    var processedResults: [FileSearchResult] {
        var filtered = rawResults
        
        // 1. Filter by binary files
        if excludeBinaryFiles {
            filtered = filtered.filter { result in
                let ext = (result.fileName as NSString).pathExtension.lowercased()
                return !binaryExtensions.contains(where: { $0.lowercased().hasSuffix(ext) })
            }
        }
        
        // 2. Filter by selected extensions
        if !selectedExtensions.isEmpty {
            filtered = filtered.filter { result in
                let ext = (result.fileName as NSString).pathExtension.lowercased()
                return selectedExtensions.contains { $0.lowercased().dropFirst() == ext }
            }
        }
        
        // 3. Sort results
        filtered = filtered.sorted { lhs, rhs in
            switch sortOption {
            case .fileName:
                return sortAscending ? lhs.fileName < rhs.fileName : lhs.fileName > rhs.fileName
            case .path:
                return sortAscending ? lhs.path < rhs.path : lhs.path > rhs.path
            case .matches:
                return sortAscending ? lhs.matches.count < rhs.matches.count : lhs.matches.count > rhs.matches.count
            }
        }
        
        // 4. Apply result limit
        if let maxCount = resultLimit.maxCount, filtered.count > maxCount {
            filtered = Array(filtered.prefix(maxCount))
        }
        
        return filtered
    }
    
    /// Group results by directory if enabled
    var groupedResults: [(key: String, results: [FileSearchResult])] {
        if groupByDirectory {
            let grouped = Dictionary(grouping: processedResults) { $0.directory }
            return grouped.sorted { $0.key < $1.key }.map { (key: $0.key, results: $0.value) }
        } else {
            return [(key: "", results: processedResults)]
        }
    }
    
    /// All unique extensions from current results
    var availableExtensions: [String] {
        let extensions = rawResults.map { (result: FileSearchResult) -> String in
            let ext = (result.fileName as NSString).pathExtension
            return ext.isEmpty ? "noext" : ext.lowercased()
        }
        return Array(Set(extensions)).sorted()
    }
    
    // MARK: - Keyboard Navigation Functions
    
    /// Builds the flat list of navigation items from results
    private func buildNavigationItems() -> [SearchNavigationItem] {
        var items: [SearchNavigationItem] = []
        let results = processedResults
        for (fileIndex, fileResult) in results.enumerated() {
            for (matchIndex, match) in fileResult.matches.enumerated() {
                items.append(SearchNavigationItem(
                    fileIndex: fileIndex,
                    matchIndex: matchIndex,
                    fileID: fileResult.id,
                    matchID: match.id
                ))
            }
        }
        return items
    }
    
    /// Focuses the search field
    private func focusSearchField() {
        focusedField = .search
    }
    
    /// Clears search and closes results
    private func clearSearchAndClose() {
        searchText = ""
        replaceText = ""
        searchManager.clearResults()
        debounceCancellable?.cancel()
        searchTask?.cancel()
        navigationItems = []
        selectedNavigationItem = nil
        focusedField = nil
    }
    
    /// Toggles replace section visibility
    private func toggleReplaceSection() {
        withAnimation {
            showReplace.toggle()
            focusedField = showReplace ? .replace : .search
        }
    }
    
    /// Executes replace all operation
    private func replaceAll() {
        performReplace()
    }
    
    /// Navigates to next result
    private func navigateToNextResult() {
        guard !navigationItems.isEmpty else { return }
        
        if let current = selectedNavigationItem,
           let currentIndex = navigationItems.firstIndex(where: { $0.id == current.id }) {
            let nextIndex = (currentIndex + 1) % navigationItems.count
            selectedNavigationItem = navigationItems[nextIndex]
        } else {
            selectedNavigationItem = navigationItems.first
        }
    }
    
    /// Navigates to previous result
    private func navigateToPreviousResult() {
        guard !navigationItems.isEmpty else { return }
        
        if let current = selectedNavigationItem,
           let currentIndex = navigationItems.firstIndex(where: { $0.id == current.id }) {
            let prevIndex = (currentIndex - 1 + navigationItems.count) % navigationItems.count
            selectedNavigationItem = navigationItems[prevIndex]
        } else {
            selectedNavigationItem = navigationItems.last
        }
    }
    
    /// Opens the currently selected result
    private func openSelectedResult() {
        guard let selected = selectedNavigationItem else { return }
        let results = processedResults
        guard selected.fileIndex < results.count else { return }
        let fileResult = results[selected.fileIndex]
        guard selected.matchIndex < fileResult.matches.count else { return }
        let match = fileResult.matches[selected.matchIndex]
        onResultSelected?(fileResult.path, match.lineNumber)
    }

    // MARK: - Body (Refactored into smaller sections)
    
    var body: some View {
        VStack(spacing: 0) {
            searchHeader
            
            ScrollView {
                VStack(spacing: 12) {
                    searchInputsSection
                    Divider()
                    resultsSection
                }
                .padding(.bottom, 20)
            }
        }
        .background(Color(UIColor.systemBackground))
        .frame(maxWidth: .infinity, maxHeight: .infinity)
        .onAppear(perform: onAppear)
        .onDisappear(perform: onDisappear)
        .onChange(of: processedResults) { _ in
            navigationItems = buildNavigationItems()
        }
    }
    
    // MARK: - Search Header Section
    
    @ViewBuilder
    private var searchHeader: some View {
        HStack {
            Text("SEARCH")
                .font(.caption)
                .fontWeight(.medium)
                .foregroundColor(.secondary)
            Spacer()
            
            if useRegex {
                regexModeIndicator
            }
            
            Button(action: {
                searchText = ""
                searchManager.clearResults()
                debounceCancellable?.cancel()
                searchTask?.cancel()
            }) {
                Image(systemName: "arrow.counterclockwise")
                    .font(.caption)
                    .foregroundColor(.secondary)
            }
            .buttonStyle(.plain)
        }
        .padding(.horizontal)
        .padding(.vertical, 8)
        .background(Color(UIColor.secondarySystemBackground))
    }
    
    @ViewBuilder
    private var regexModeIndicator: some View {
        HStack(spacing: 2) {
            Image(systemName: "staroflife.fill")
                .font(.caption2)
                .foregroundColor(.accentColor)
            Text("REGEX")
                .font(.caption2)
                .fontWeight(.semibold)
                .foregroundColor(.accentColor)
        }
        .padding(.horizontal, 6)
        .padding(.vertical, 2)
        .background(Color.accentColor.opacity(0.15))
        .cornerRadius(4)
    }
    
    // MARK: - Search Inputs Section
    
    @ViewBuilder
    private var searchInputsSection: some View {
        VStack(spacing: 8) {
            searchInputRow
            
            if showRegexHelp {
                regexHelpView
            }
            
            if let error = searchManager.lastError {
                errorBannerView(error: error)
            }
            
            if useRegex {
                regexModeEnabledBanner
            }
            
            if showReplace {
                replaceInputRow
            }
            
            searchButtonRow
            
            if searchManager.isSearching {
                searchProgressSection
            }
            
            filesToIncludeExcludeSection
        }
        .padding(.horizontal)
    }
    
    @ViewBuilder
    private var searchInputRow: some View {
        HStack(spacing: 0) {
            Image(systemName: "chevron.right")
                .font(.caption)
                .foregroundColor(.secondary)
                .rotationEffect(showReplace ? .degrees(90) : .zero)
                .onTapGesture {
                    withAnimation {
                        showReplace.toggle()
                    }
                }
                .padding(.horizontal, 4)
            
            ZStack(alignment: .trailing) {
                TextField("Search", text: $searchText)
                    .textFieldStyle(PlainTextFieldStyle())
                    .focused($focusedField, equals: .search)
                    .padding(6)
                    .padding(.trailing, 60)
                    .background(Color(UIColor.secondarySystemBackground))
                    .cornerRadius(4)
                    .overlay(
                        RoundedRectangle(cornerRadius: 4)
                            .stroke(Color.secondary.opacity(0.3), lineWidth: 1)
                    )
                    .onSubmit {
                        debouncedSearch(immediate: true)
                    }
                    .accessibilityLabel("Search text field")
                    .accessibilityHint("Type search query and press Enter to search. Press Escape to clear.")
                
                searchToggleIcons
            }
        }
    }
    
    @ViewBuilder
    private var searchToggleIcons: some View {
        HStack(spacing: 2) {
            ToggleIcon(iconName: "textformat", isSelected: $matchCase, tooltip: "Match case")
            ToggleIcon(iconName: "underline", isSelected: $matchWholeWord, tooltip: "Match whole word")
            ToggleIcon(iconName: useRegex ? "staroflife.fill" : "staroflife", isSelected: $useRegex, tooltip: "Use regular expressions")
                .overlay(
                    Button(action: {
                        showRegexHelp.toggle()
                    }) {
                        Image(systemName: "questionmark.circle")
                            .font(.caption2)
                            .foregroundColor(useRegex ? .accentColor : .secondary)
                    }
                    .buttonStyle(.plain)
                    .offset(x: -8, y: -8)
                    .opacity(useRegex ? 1.0 : 0.3),
                    alignment: .topTrailing
                )
        }
        .padding(.trailing, 4)
    }
    
    @ViewBuilder
    private var regexHelpView: some View {
        VStack(alignment: .leading, spacing: 4) {
            Text("Regex Syntax Examples")
                .font(.caption)
                .fontWeight(.semibold)
            Text("• .  - Match any character")
            Text("• *  - Match 0 or more")
            Text("• +  - Match 1 or more")
            Text("• ?  - Match 0 or 1")
            Text("• ^  - Start of line")
            Text("• $  - End of line")
            Text("• [] - Character class")
            Text("• () - Capture group")
            Text("• \\d - Digit, \\w - Word char")
            Divider()
            Text("Example: func.*\\( matches 'func' followed by any chars and '('")
                .font(.caption2)
                .foregroundColor(.secondary)
        }
        .font(.caption2)
        .foregroundColor(.primary)
        .padding(8)
        .background(Color(UIColor.secondarySystemBackground))
        .cornerRadius(4)
        .overlay(
            RoundedRectangle(cornerRadius: 4)
                .stroke(Color.secondary.opacity(0.3), lineWidth: 1)
        )
        .padding(.leading, 20)
        .transition(.opacity.combined(with: .move(edge: .top)))
    }
    
    @ViewBuilder
    private func errorBannerView(error: String) -> some View {
        HStack(spacing: 4) {
            Image(systemName: "exclamationmark.triangle.fill")
                .font(.caption)
                .foregroundColor(.red)
            Text(error)
                .font(.caption)
                .foregroundColor(.red)
                .lineLimit(2)
            Spacer()
            Button(action: {
                searchManager.clearError()
            }) {
                Image(systemName: "xmark.circle.fill")
                    .font(.caption)
                    .foregroundColor(.red.opacity(0.7))
            }
            .buttonStyle(.plain)
        }
        .padding(.horizontal, 8)
        .padding(.vertical, 4)
        .background(Color.red.opacity(0.1))
        .cornerRadius(4)
        .padding(.leading, 20)
    }
    
    @ViewBuilder
    private var regexModeEnabledBanner: some View {
        HStack(spacing: 4) {
            Image(systemName: "staroflife.fill")
                .font(.caption2)
                .foregroundColor(.accentColor)
            Text("Regular expression mode enabled")
                .font(.caption2)
                .foregroundColor(.accentColor)
            Spacer()
        }
        .padding(.horizontal, 8)
        .padding(.vertical, 4)
        .background(Color.accentColor.opacity(0.1))
        .cornerRadius(4)
        .padding(.leading, 20)
    }
    
    @ViewBuilder
    private var replaceInputRow: some View {
        HStack(spacing: 0) {
            Spacer().frame(width: 20)
            ZStack(alignment: .trailing) {
                TextField("Replace", text: $replaceText)
                    .textFieldStyle(PlainTextFieldStyle())
                    .focused($focusedField, equals: .replace)
                    .padding(6)
                    .padding(.trailing, 24)
                    .background(Color(UIColor.secondarySystemBackground))
                    .cornerRadius(4)
                    .overlay(
                        RoundedRectangle(cornerRadius: 4)
                            .stroke(Color.secondary.opacity(0.3), lineWidth: 1)
                    )
                    .accessibilityLabel("Replace text field")
                    .accessibilityHint("Type replacement text. Press Command+Enter to replace all.")
                
                Button(action: { performReplace() }) {
                    Image(systemName: "arrow.triangle.2.circlepath")
                        .font(.caption)
                        .foregroundColor(.secondary)
                }
                .buttonStyle(.plain)
                .padding(.trailing, 6)
                .disabled(searchManager.isSearching || searchManager.results.isEmpty)
                .keyboardShortcut(.return, modifiers: [.command])
                .accessibilityLabel("Replace all button")
            }
        }
    }
    
    @ViewBuilder
    private var searchButtonRow: some View {
        HStack {
            Spacer().frame(width: 20)
            Button(action: {
                debouncedSearch(immediate: true)
            }) {
                HStack(spacing: 4) {
                    Image(systemName: "magnifyingglass")
                    Text("Search")
                }
                .font(.caption)
                .fontWeight(.medium)
            }
            .buttonStyle(.borderedProminent)
            .disabled(searchText.count < 2 || searchManager.isSearching)
            .controlSize(.small)
            
            Spacer()
            
            if !convertedResults.isEmpty && !searchManager.isSearching {
                Text("\(convertedResults.count) files, \(convertedResults.map { $0.matches.count }.reduce(0, +)) matches")
                    .font(.caption)
                    .foregroundColor(.secondary)
            }
        }
        .padding(.leading, 20)
    }
    
    @ViewBuilder
    private var searchProgressSection: some View {
        SearchProgressView(
            progress: searchManager.progress,
            currentFileIndex: searchManager.currentFileIndex,
            totalFileCount: searchManager.totalFileCount,
            currentFileName: searchManager.currentFileName,
            onCancel: {
                searchManager.cancelSearch()
            }
        )
        .padding(.leading, 20)
        .transition(.opacity.combined(with: .move(edge: .top)))
        .animation(.easeInOut(duration: 0.2), value: searchManager.isSearching)
    }
    
    @ViewBuilder
    private var filesToIncludeExcludeSection: some View {
        VStack(spacing: 8) {
            HStack {
                Spacer().frame(width: 20)
                Text("files to include/exclude")
                    .font(.caption)
                    .foregroundColor(.secondary)
                Spacer()
            }
            .onTapGesture {
                withAnimation {
                    showDetails.toggle()
                }
            }
            
            if showDetails {
                filesToIncludeExcludeInputs
            }
        }
    }
    
    @ViewBuilder
    private var filesToIncludeExcludeInputs: some View {
        VStack(spacing: 8) {
            TextField("files to include", text: $filesToInclude)
                .textFieldStyle(PlainTextFieldStyle())
                .padding(6)
                .background(Color(UIColor.secondarySystemBackground))
                .cornerRadius(4)
                .overlay(
                    RoundedRectangle(cornerRadius: 4)
                        .stroke(Color.secondary.opacity(0.3), lineWidth: 1)
                )
            
            TextField("files to exclude", text: $filesToExclude)
                .textFieldStyle(PlainTextFieldStyle())
                .padding(6)
                .background(Color(UIColor.secondarySystemBackground))
                .cornerRadius(4)
                .overlay(
                    RoundedRectangle(cornerRadius: 4)
                        .stroke(Color.secondary.opacity(0.3), lineWidth: 1)
                )
        }
        .padding(.leading, 20)
    }
    
    // MARK: - Results Section
    
    @ViewBuilder
    private var resultsSection: some View {
        if processedResults.isEmpty && !searchText.isEmpty && !searchManager.isSearching {
            noResultsView
        } else {
            resultsListSection
        }
    }
    
    @ViewBuilder
    private var noResultsView: some View {
        Text(searchText.count < 2 ? "Type at least 2 characters to search" : "No results found")
            .font(.caption)
            .foregroundColor(.secondary)
            .padding(.top, 20)
    }
    
    @ViewBuilder
    private var resultsListSection: some View {
        VStack(alignment: .leading, spacing: 0) {
            SearchResultsHeader(
                resultCount: processedResults.count,
                totalCount: rawResults.count,
                sortOption: $sortOption,
                sortAscending: $sortAscending,
                selectedExtensions: $selectedExtensions,
                groupByDirectory: $groupByDirectory,
                showFilePath: $showFilePath,
                resultLimit: $resultLimit,
                excludeBinaryFiles: $excludeBinaryFiles,
                showFilters: $showFilters,
                availableExtensions: availableExtensions,
                onCollapseAll: collapseAll,
                onExpandAll: expandAll
            )
            
            resultsLazyVStack
        }
    }
    
    @ViewBuilder
    private var resultsLazyVStack: some View {
        LazyVStack(alignment: .leading, spacing: 0) {
            if groupByDirectory {
                groupedResultsList
            } else {
                flatResultsList
            }
        }
    }
    
    @ViewBuilder
    private var groupedResultsList: some View {
        ForEach(Array(groupedResults.enumerated()), id: \.offset) { groupIndex, group in
            if !group.key.isEmpty {
                DirectoryGroupHeader(directory: group.key, count: group.results.count)
            }
            ForEach(Array(group.results.enumerated()), id: \.element.id) { fileIndex, fileResult in
                FileResultRow(
                    fileResult: fileResult,
                    fileIndex: fileIndex,
                    showPath: showFilePath,
                    selectedNavigationItem: $selectedNavigationItem,
                    onMatchSelected: onResultSelected,
                    onOpenResult: openSelectedResult
                )
            }
        }
    }
    
    @ViewBuilder
    private var flatResultsList: some View {
        ForEach(Array(processedResults.enumerated()), id: \.element.id) { fileIndex, fileResult in
            FileResultRow(
                fileResult: fileResult,
                fileIndex: fileIndex,
                showPath: showFilePath,
                selectedNavigationItem: $selectedNavigationItem,
                onMatchSelected: onResultSelected,
                onOpenResult: openSelectedResult
            )
        }
    }
    
    // MARK: - Lifecycle
    
    private func setupDebouncedSearch() {
        // Note: Debounced search is handled via onChange modifier and debouncedSearch() function
    }
    
    // MARK: - Debounced Search
    
    private func debouncedSearch(immediate: Bool = false) {
        debounceCancellable?.cancel()
        
        if immediate {
            performDebouncedSearch(query: searchText)
        } else {
            setupDebouncedSearch()
        }
    }
    
    private func performDebouncedSearch(query: String) {
        searchTask?.cancel()
        
        guard query.count >= 2 else { return }
        
        let options = SearchManager.SearchOptions(
            isCaseSensitive: matchCase,
            isWholeWord: matchWholeWord,
            isRegex: useRegex
        )
        
        let includeGlobs = filesToInclude
            .split(separator: ",")
            .map { $0.trimmingCharacters(in: .whitespaces) }
            .filter { !$0.isEmpty }
        
        let excludeGlobs = filesToExclude
            .split(separator: ",")
            .map { $0.trimmingCharacters(in: .whitespaces) }
            .filter { !$0.isEmpty }
        
        let searchQuery = SearchManager.SearchQuery(
            text: query,
            options: options,
            includeGlobs: includeGlobs,
            excludeGlobs: excludeGlobs
        )
        
        searchTask = Task { [weak searchManager] in
            guard let manager = searchManager else { return }
            guard !Task.isCancelled else { return }
            manager.search(in: rootURL, query: searchQuery)
        }
    }
    
    // MARK: - Helper Functions
    
    private func collapseAll() {
        NotificationCenter.default.post(name: .collapseAllSearchResults, object: nil)
    }
    
    private func expandAll() {
        NotificationCenter.default.post(name: .expandAllSearchResults, object: nil)
    }
    
    private func performSearch() {
        debouncedSearch(immediate: true)
    }
    
    private func performReplace() {
        guard !searchText.isEmpty && !replaceText.isEmpty else { return }
        
        let options = SearchManager.SearchOptions(
            isCaseSensitive: matchCase,
            isWholeWord: matchWholeWord,
            isRegex: useRegex
        )
        
        let includeGlobs = filesToInclude
            .split(separator: ",")
            .map { $0.trimmingCharacters(in: .whitespaces) }
            .filter { !$0.isEmpty }
        
        let excludeGlobs = filesToExclude
            .split(separator: ",")
            .map { $0.trimmingCharacters(in: .whitespaces) }
            .filter { !$0.isEmpty }
        
        let query = SearchManager.SearchQuery(
            text: searchText,
            options: options,
            includeGlobs: includeGlobs,
            excludeGlobs: excludeGlobs
        )
        
        Task {
            do {
                let result = try await searchManager.replace(in: rootURL, query: query, replacement: replaceText)
                print("Replace completed: \(result.replacements) replacements in \(result.filesTouched) files")
            } catch {
                print("Replace failed: \(error.localizedDescription)")
            }
        }
    }
    
    private func onAppear() {
        setupDebouncedSearch()
    }
    
    private func onDisappear() {
        debounceCancellable?.cancel()
        searchTask?.cancel()
    }
    
    // Convert SearchManager results to view model
    private var convertedResults: [FileSearchResult] {
        searchManager.results.map { fileMatch in
            let fileName = URL(fileURLWithPath: fileMatch.filePath).lastPathComponent
            let matches = fileMatch.matches.map { match in
                SearchResultLine(
                    lineNumber: match.location.line,
                    text: match.preview,
                    matches: []
                )
            }
            return FileSearchResult(
                fileName: fileName,
                path: fileMatch.filePath,
                matches: matches,
                isExpanded: true
            )
        }
    }
    
    private var rawResults: [FileSearchResult] {
        convertedResults
    }
}

// MARK: - Supporting Views

struct ToggleIcon: View {
    let iconName: String
    @Binding var isSelected: Bool
    var tooltip: String? = nil
    
    var body: some View {
        Button(action: {
            isSelected.toggle()
        }) {
            Image(systemName: iconName)
                .font(.caption2)
                .padding(4)
                .background(isSelected ? Color.accentColor.opacity(0.2) : Color.clear)
                .foregroundColor(isSelected ? .accentColor : .secondary)
                .cornerRadius(3)
        }
        .buttonStyle(.plain)
        .accessibilityHint(tooltip ?? "")
    }
}

struct FileResultRow: View {
    let fileResult: FileSearchResult
    let fileIndex: Int
    let showPath: Bool
    @Binding var selectedNavigationItem: SearchNavigationItem?
    let onMatchSelected: ((String, Int) -> Void)?
    let onOpenResult: () -> Void
    @State private var isExpanded: Bool = true
    @State private var hoveredMatchId: UUID?
    
    private var isAnyMatchSelected: Bool {
        guard let selected = selectedNavigationItem else { return false }
        return selected.fileID == fileResult.id
    }
    
    var body: some View {
        VStack(alignment: .leading, spacing: 0) {
            fileHeaderButton
            
            if isExpanded {
                matchesList
            }
        }
        .onReceive(NotificationCenter.default.publisher(for: .collapseAllSearchResults)) { _ in
            isExpanded = false
        }
        .onReceive(NotificationCenter.default.publisher(for: .expandAllSearchResults)) { _ in
            isExpanded = true
        }
    }
    
    @ViewBuilder
    private var fileHeaderButton: some View {
        Button(action: {
            withAnimation(.easeInOut(duration: 0.2)) {
                isExpanded.toggle()
            }
        }) {
            HStack(spacing: 4) {
                Image(systemName: isExpanded ? "chevron.down" : "chevron.right")
                    .font(.caption2)
                    .frame(width: 12)
                    .foregroundColor(.secondary)
                
                Image(systemName: "doc.text")
                    .font(.caption)
                    .foregroundColor(.secondary)
                
                Text(fileResult.fileName)
                    .font(.system(size: 13, weight: .semibold))
                    .foregroundColor(.primary)
                
                if showPath {
                    Text(fileResult.path)
                        .font(.caption)
                        .foregroundColor(.secondary)
                        .lineLimit(1)
                        .truncationMode(.middle)
                }
                
                Spacer()
                
                Text("\(fileResult.matches.count)")
                    .font(.caption)
                    .foregroundColor(.secondary)
                    .padding(.horizontal, 6)
                    .padding(.vertical, 2)
                    .background(Color.secondary.opacity(0.2))
                    .cornerRadius(4)
            }
            .padding(.horizontal, 8)
            .padding(.vertical, 4)
            .background(isAnyMatchSelected ? Color.accentColor.opacity(0.1) : Color.clear)
        }
        .buttonStyle(.plain)
    }
    
    @ViewBuilder
    private var matchesList: some View {
        ForEach(Array(fileResult.matches.enumerated()), id: \.element.id) { matchIndex, match in
            MatchRow(
                match: match,
                matchIndex: matchIndex,
                fileIndex: fileIndex,
                fileResult: fileResult,
                selectedNavigationItem: $selectedNavigationItem,
                hoveredMatchId: $hoveredMatchId,
                onMatchSelected: onMatchSelected,
                onOpenResult: onOpenResult
            )
        }
    }
}

struct MatchRow: View {
    let match: SearchResultLine
    let matchIndex: Int
    let fileIndex: Int
    let fileResult: FileSearchResult
    @Binding var selectedNavigationItem: SearchNavigationItem?
    @Binding var hoveredMatchId: UUID?
    let onMatchSelected: ((String, Int) -> Void)?
    let onOpenResult: () -> Void
    
    private var isSelected: Bool {
        guard let selected = selectedNavigationItem else { return false }
        return selected.fileID == fileResult.id && selected.matchID == match.id
    }
    
    var body: some View {
        Button(action: {
            selectedNavigationItem = SearchNavigationItem(
                fileIndex: fileIndex,
                matchIndex: matchIndex,
                fileID: fileResult.id,
                matchID: match.id
            )
            onMatchSelected?(fileResult.path, match.lineNumber)
        }) {
            HStack(spacing: 8) {
                Text("\(match.lineNumber)")
                    .font(.caption)
                    .foregroundColor(.secondary)
                    .frame(width: 40, alignment: .trailing)
                
                Text(match.text)
                    .font(.system(size: 12, design: .monospaced))
                    .foregroundColor(.primary)
                    .lineLimit(1)
                    .truncationMode(.tail)
                
                Spacer()
            }
            .padding(.horizontal, 12)
            .padding(.vertical, 2)
            .padding(.leading, 24)
            .background(isSelected ? Color.accentColor.opacity(0.2) : Color.clear)
        }
        .buttonStyle(.plain)
    }
}

struct DirectoryGroupHeader: View {
    let directory: String
    let count: Int
    
    var body: some View {
        HStack(spacing: 4) {
            Image(systemName: "folder")
                .font(.caption)
                .foregroundColor(.secondary)
            
            Text(directory)
                .font(.caption)
                .fontWeight(.medium)
                .foregroundColor(.secondary)
            
            Text("(\(count))")
                .font(.caption)
                .foregroundColor(.secondary.opacity(0.7))
            
            Spacer()
        }
        .padding(.horizontal, 8)
        .padding(.vertical, 6)
        .background(Color(UIColor.secondarySystemBackground).opacity(0.5))
    }
}

struct SearchResultsHeader: View {
    let resultCount: Int
    let totalCount: Int
    @Binding var sortOption: SortOption
    @Binding var sortAscending: Bool
    @Binding var selectedExtensions: Set<String>
    @Binding var groupByDirectory: Bool
    @Binding var showFilePath: Bool
    @Binding var resultLimit: ResultLimit
    @Binding var excludeBinaryFiles: Bool
    @Binding var showFilters: Bool
    let availableExtensions: [String]
    let onCollapseAll: () -> Void
    let onExpandAll: () -> Void
    
    var body: some View {
        VStack(spacing: 8) {
            mainHeaderRow
            
            if showFilters {
                filtersSection
            }
        }
        .padding(.horizontal, 8)
        .padding(.vertical, 6)
    }
    
    @ViewBuilder
    private var mainHeaderRow: some View {
        HStack {
            Text("\(resultCount) of \(totalCount) results")
                .font(.caption)
                .foregroundColor(.secondary)
            
            Spacer()
            
            Button(action: onCollapseAll) {
                Image(systemName: "arrow.down.right.and.arrow.up.left")
                    .font(.caption2)
            }
            .buttonStyle(.plain)
            .accessibilityLabel("Collapse All")
            
            Button(action: onExpandAll) {
                Image(systemName: "arrow.up.left.and.arrow.down.right")
                    .font(.caption2)
            }
            .buttonStyle(.plain)
            .accessibilityLabel("Expand All")
            
            Button(action: { showFilters.toggle() }) {
                Image(systemName: "line.3.horizontal.decrease.circle")
                    .font(.caption2)
                    .foregroundColor(showFilters ? .accentColor : .secondary)
            }
            .buttonStyle(.plain)
            .accessibilityLabel("Toggle Filters")
        }
    }
    
    @ViewBuilder
    private var filtersSection: some View {
        VStack(spacing: 8) {
            sortRow
            optionsRow
            limitRow
        }
        .padding(8)
        .background(Color(UIColor.secondarySystemBackground).opacity(0.5))
        .cornerRadius(6)
    }
    
    @ViewBuilder
    private var sortRow: some View {
        HStack {
            Text("Sort:")
                .font(.caption)
                .foregroundColor(.secondary)
            
            Picker("", selection: $sortOption) {
                ForEach(SortOption.allCases) { option in
                    Label(option.rawValue, systemImage: option.icon).tag(option)
                }
            }
            .pickerStyle(.menu)
            .controlSize(.small)
            
            Button(action: { sortAscending.toggle() }) {
                Image(systemName: sortAscending ? "arrow.up" : "arrow.down")
                    .font(.caption2)
            }
            .buttonStyle(.plain)
            .accessibilityLabel(sortAscending ? "Ascending" : "Descending")
            
            Spacer()
        }
    }
    
    @ViewBuilder
    private var optionsRow: some View {
        HStack {
            Toggle("Group by directory", isOn: $groupByDirectory)
                .toggleStyle(.automatic)
                .controlSize(.small)
            
            Toggle("Show path", isOn: $showFilePath)
                .toggleStyle(.automatic)
                .controlSize(.small)
            
            Toggle("Exclude binary", isOn: $excludeBinaryFiles)
                .toggleStyle(.automatic)
                .controlSize(.small)
            
            Spacer()
        }
        .font(.caption)
    }
    
    @ViewBuilder
    private var limitRow: some View {
        HStack {
            Text("Limit:")
                .font(.caption)
                .foregroundColor(.secondary)
            
            Picker("", selection: $resultLimit) {
                ForEach(ResultLimit.allCases) { limit in
                    Text(limit.rawValue).tag(limit)
                }
            }
            .pickerStyle(.menu)
            .controlSize(.small)
            
            Spacer()
        }
    }
}

struct SearchProgressView: View {
    let progress: Double
    let currentFileIndex: Int
    let totalFileCount: Int
    let currentFileName: String
    let onCancel: () -> Void
    
    var body: some View {
        VStack(spacing: 4) {
            HStack {
                ProgressView(value: progress)
                    .progressViewStyle(.linear)
                
                Button(action: onCancel) {
                    Image(systemName: "xmark.circle.fill")
                        .font(.caption)
                        .foregroundColor(.secondary)
                }
                .buttonStyle(.plain)
            }
            
            HStack {
                Text("Searching \(currentFileIndex)/\(totalFileCount)")
                    .font(.caption2)
                    .foregroundColor(.secondary)
                
                Text(currentFileName)
                    .font(.caption2)
                    .foregroundColor(.secondary)
                    .lineLimit(1)
                    .truncationMode(.middle)
                
                Spacer()
            }
        }
    }
}
