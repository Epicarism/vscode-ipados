//
//  SyntaxHighlightingTextView.swift
//  VSCodeiPadOS
//
//  Upgraded syntax highlighting with VSCode-like colors
//

import SwiftUI
import UIKit

/// UITextView wrapper with syntax highlighting support
struct SyntaxHighlightingTextView: UIViewRepresentable {
    @Binding var text: String
    let filename: String
    @Binding var scrollPosition: Int
    @Binding var totalLines: Int
    @Binding var visibleLines: Int
    @Binding var currentLineNumber: Int
    @Binding var currentColumn: Int
    @Binding var cursorIndex: Int
    @Binding var lineHeight: CGFloat
    @Binding var requestedLineSelection: Int?
    @Binding var requestedCursorIndex: Int?

    /// Autocomplete key handling hooks (return true if handled)
    let onAcceptAutocomplete: (() -> Bool)?
    let onDismissAutocomplete: (() -> Bool)?

    let isActive: Bool
    @ObservedObject var editorCore: EditorCore

    init(
        text: Binding<String>,
        filename: String,
        scrollPosition: Binding<Int>,
        totalLines: Binding<Int>,
        visibleLines: Binding<Int>,
        currentLineNumber: Binding<Int>,
        currentColumn: Binding<Int>,
        cursorIndex: Binding<Int>,
        lineHeight: Binding<CGFloat>,
        isActive: Bool,
        editorCore: EditorCore,
        requestedLineSelection: Binding<Int?> = .constant(nil),
        requestedCursorIndex: Binding<Int?> = .constant(nil),
        onAcceptAutocomplete: (() -> Bool)? = nil,
        onDismissAutocomplete: (() -> Bool)? = nil
    ) {
        self._text = text
        self.filename = filename
        self._scrollPosition = scrollPosition
        self._totalLines = totalLines
        self._visibleLines = visibleLines
        self._currentLineNumber = currentLineNumber
        self._currentColumn = currentColumn
        self._lineHeight = lineHeight
        self.isActive = isActive
        self.editorCore = editorCore
        self._requestedLineSelection = requestedLineSelection
        self._requestedCursorIndex = requestedCursorIndex
        self.onAcceptAutocomplete = onAcceptAutocomplete
        self.onDismissAutocomplete = onDismissAutocomplete
    }
    
    func makeCoordinator() -> Coordinator {
        Coordinator(self)
    }
    
    func makeUIView(context: Context) -> UITextView {
        let textView = EditorTextView()
        textView.delegate = context.coordinator

        // Autocomplete hooks
        textView.onAcceptAutocomplete = onAcceptAutocomplete
        textView.onDismissAutocomplete = onDismissAutocomplete

        textView.onPeekDefinition = {
            context.coordinator.handlePeekDefinition(in: textView)
        }

        textView.onEscape = {
            context.coordinator.handleEscape()
        }
        
        // Add pinch gesture for zoom
        let pinchGesture = UIPinchGestureRecognizer(target: context.coordinator, action: #selector(Coordinator.handlePinch(_:)))
        textView.addGestureRecognizer(pinchGesture)
        context.coordinator.pinchGesture = pinchGesture
        
        // Configure text view
        textView.isEditable = true
        textView.isSelectable = true
        textView.autocapitalizationType = .none
        textView.autocorrectionType = .no
        textView.smartDashesType = .no
        textView.smartQuotesType = .no
        textView.smartInsertDeleteType = .no
        textView.spellCheckingType = .no
        
        // Set font and appearance (use editorCore.editorFontSize)
        textView.font = UIFont.monospacedSystemFont(ofSize: editorCore.editorFontSize, weight: .regular)
        textView.textColor = UIColor(ThemeManager.shared.currentTheme.editorForeground)
        textView.backgroundColor = UIColor(ThemeManager.shared.currentTheme.editorBackground)
        textView.keyboardType = .default
        textView.textContainerInset = UIEdgeInsets(top: 8, left: 8, bottom: 8, right: 8)
        
        // Enable line wrapping
        textView.textContainer.lineBreakMode = .byCharWrapping
        textView.textContainer.widthTracksTextView = true
        
        // Calculate line height
        if let font = textView.font {
            DispatchQueue.main.async {
                self.lineHeight = font.lineHeight
            }
        }
        
        // Set initial text with syntax highlighting
        textView.text = text
        context.coordinator.applySyntaxHighlighting(to: textView)
        context.coordinator.updateLineCount(textView)
        
        return textView
    }
    
    func updateUIView(_ textView: UITextView, context: Context) {
        // Update colors when theme changes
        textView.backgroundColor = UIColor(ThemeManager.shared.currentTheme.editorBackground)
        textView.textColor = UIColor(ThemeManager.shared.currentTheme.editorForeground)
        textView.tintColor = UIColor(ThemeManager.shared.currentTheme.cursor)
        
        if let editorView = textView as? EditorTextView {
            editorView.updateThemeColors(theme: ThemeManager.shared.currentTheme)
        }
        
        // Update font size if changed
        if let currentFont = textView.font, currentFont.pointSize != editorCore.editorFontSize {
            let selectedRange = textView.selectedRange
            textView.font = UIFont.monospacedSystemFont(ofSize: editorCore.editorFontSize, weight: .regular)
            context.coordinator.applySyntaxHighlighting(to: textView)
            textView.selectedRange = selectedRange
            
            // Update line height
            if let font = textView.font {
                DispatchQueue.main.async {
                    self.lineHeight = font.lineHeight
                }
            }
        }
        
        // Update text if changed externally
        if textView.text != text {
            let selectedRange = textView.selectedRange
            textView.text = text
            context.coordinator.applySyntaxHighlighting(to: textView)
            textView.selectedRange = selectedRange
        } else if context.coordinator.lastThemeId != ThemeManager.shared.currentTheme.id {
            // Re-apply highlighting if theme changed
            context.coordinator.applySyntaxHighlighting(to: textView)
        }
        
        // Handle minimap scrolling
        if scrollPosition != context.coordinator.lastKnownScrollPosition && scrollPosition >= 0 {
            context.coordinator.scrollToLine(scrollPosition, in: textView)
        }

        // Handle line selection requests (e.g. tapping line numbers)
        if let requested = requestedLineSelection,
           requested != context.coordinator.lastRequestedLineSelection {
            context.coordinator.lastRequestedLineSelection = requested
            context.coordinator.scrollToAndSelectLine(requested, in: textView)
            requestedLineSelection = nil
        }

        // Handle cursor index requests (e.g. accepting autocomplete)
        if let requested = requestedCursorIndex,
           requested != context.coordinator.lastRequestedCursorIndex {
            context.coordinator.lastRequestedCursorIndex = requested
            textView.selectedRange = NSRange(location: max(0, requested), length: 0)
            requestedCursorIndex = nil

            // Update SwiftUI state
            context.coordinator.updateCursorPosition(textView)
            context.coordinator.updateScrollPosition(textView)
        }
        
        context.coordinator.updateLineCount(textView)
    }
    
    // MARK: - Coordinator
    
    class Coordinator: NSObject, UITextViewDelegate {
        var parent: SyntaxHighlightingTextView
        var lastKnownScrollPosition: Int = 0
        var lastThemeId: String = ""
        var lastRequestedLineSelection: Int? = nil
        var lastRequestedCursorIndex: Int? = nil
        private var isUpdatingFromMinimap = false
        private var highlightDebouncer: Timer?
        weak var pinchGesture: UIPinchGestureRecognizer?
        private var initialFontSize: CGFloat = 0
        
        init(_ parent: SyntaxHighlightingTextView) {
            self.parent = parent
        }
        
        func textViewDidChange(_ textView: UITextView) {
            // Update parent text
            parent.text = textView.text
            
            // Debounced syntax highlighting for performance
            highlightDebouncer?.invalidate()
            highlightDebouncer = Timer.scheduledTimer(withTimeInterval: 0.15, repeats: false) { [weak self] _ in
                DispatchQueue.main.async {
                    self?.applySyntaxHighlighting(to: textView)
                }
            }
            
            updateLineCount(textView)
            updateCursorPosition(textView)
        }
        
        func textViewDidChangeSelection(_ textView: UITextView) {
            if !isUpdatingFromMinimap {
                updateCursorPosition(textView)
                updateScrollPosition(textView)
                
                // Update selection in EditorCore for multi-cursor support
                let range = textView.selectedRange
                parent.editorCore.updateSelection(range: range, text: textView.text ?? "")
                
                // If user clicks elsewhere (not multi-cursor operation), reset to single cursor
                if !parent.editorCore.multiCursorState.isMultiCursor {
                    parent.editorCore.multiCursorState.reset(to: range.location + range.length)
                }
            }
        }
        
        func scrollViewDidScroll(_ scrollView: UIScrollView) {
            guard let textView = scrollView as? UITextView, !isUpdatingFromMinimap else { return }
            updateScrollPosition(textView)
        }
        
        func updateLineCount(_ textView: UITextView) {
            let lines = textView.text.components(separatedBy: .newlines)
            DispatchQueue.main.async {
                self.parent.totalLines = max(1, lines.count)
            }
        }
        
        func updateCursorPosition(_ textView: UITextView) {
            guard let selectedRange = textView.selectedTextRange else { return }
            let cursorPosition = textView.offset(from: textView.beginningOfDocument, to: selectedRange.start)
            
            let text = textView.text ?? ""
            let prefix = String(text.prefix(cursorPosition))
            let lines = prefix.components(separatedBy: .newlines)
            
            let lineNumber = lines.count
            let column = (lines.last?.count ?? 0) + 1
            
            DispatchQueue.main.async {
                self.parent.currentLineNumber = lineNumber
                self.parent.currentColumn = column
            }
        }
        
        func updateScrollPosition(_ textView: UITextView) {
            guard let font = textView.font else { return }
            let lineHeight = font.lineHeight
            let scrollOffset = textView.contentOffset.y
            let line = Int(scrollOffset / lineHeight)
            
            lastKnownScrollPosition = line
            DispatchQueue.main.async {
                self.parent.scrollPosition = line
            }
        }
        
        func scrollToLine(_ line: Int, in textView: UITextView) {
            guard !isUpdatingFromMinimap else { return }
            isUpdatingFromMinimap = true
            
            let lines = textView.text.components(separatedBy: .newlines)
            guard line >= 0 && line < lines.count else {
                isUpdatingFromMinimap = false
                return
            }
            
            var characterPosition = 0
            for i in 0..<line {
                characterPosition += lines[i].count + 1
            }
            
            if let position = textView.position(from: textView.beginningOfDocument, offset: characterPosition) {
                let rect = textView.caretRect(for: position)
                let targetY = max(0, rect.origin.y)
                textView.setContentOffset(CGPoint(x: 0, y: targetY), animated: true)
            }
            
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.3) {
                self.isUpdatingFromMinimap = false
            }
        }

        func scrollToAndSelectLine(_ line: Int, in textView: UITextView) {
            let lines = textView.text.components(separatedBy: .newlines)
            guard line >= 0 && line < lines.count else { return }

            var characterPosition = 0
            for i in 0..<line {
                characterPosition += lines[i].count + 1
            }

            // Set cursor to beginning of requested line
            let range = NSRange(location: characterPosition, length: 0)
            textView.selectedRange = range

            // Ensure it's visible
            scrollToLine(line, in: textView)

            // Update SwiftUI state
            updateCursorPosition(textView)
            updateScrollPosition(textView)
        }
        
        func applySyntaxHighlighting(to textView: UITextView) {
            let theme = ThemeManager.shared.currentTheme
            lastThemeId = theme.id
            
            let highlighter = VSCodeSyntaxHighlighter(theme: theme, fontSize: parent.editorCore.editorFontSize)
            let attributedText = highlighter.highlight(textView.text, filename: parent.filename)
            
            let selectedRange = textView.selectedRange
            textView.attributedText = attributedText
            textView.selectedRange = selectedRange
        }
        
        func handlePeekDefinition(in textView: UITextView) {
            guard let selectedRange = textView.selectedTextRange else { return }
            let text = textView.text ?? ""
            
            if let range = textView.tokenizer.rangeEnclosingPosition(selectedRange.start, with: .word, inDirection: 1) {
                 let location = textView.offset(from: textView.beginningOfDocument, to: range.start)
                 
                 let prefix = String(text.prefix(location))
                 let sourceLine = prefix.components(separatedBy: .newlines).count - 1
                 
                 parent.editorCore.triggerPeekDefinition(
                     file: parent.filename,
                     line: sourceLine,
                     content: text,
                     sourceLine: sourceLine
                 )
            }
        }
        
        func handleEscape() {
            if parent.editorCore.peekState != nil {
                parent.editorCore.closePeekDefinition()
            } else {
                parent.editorCore.escapeMultiCursor()
            }
        }
        
        @objc func handlePinch(_ gesture: UIPinchGestureRecognizer) {
            guard let textView = gesture.view as? UITextView else { return }
            
            switch gesture.state {
            case .began:
                // Store the initial font size when pinch begins
                initialFontSize = parent.editorCore.editorFontSize
                
            case .changed:
                // Calculate new font size based on pinch scale
                let newSize = initialFontSize * gesture.scale
                
                // Clamp font size between 8 and 32
                let clampedSize = min(max(newSize, 8), 32)
                
                // Update EditorCore's font size (this will trigger updateUIView)
                parent.editorCore.editorFontSize = clampedSize
                
            case .ended, .cancelled:
                // Optional: snap to nearest whole number or standard size
                let finalSize = round(parent.editorCore.editorFontSize)
                parent.editorCore.editorFontSize = min(max(finalSize, 8), 32)
                
            default:
                break
            }
        }
    }
}

// Custom text view to handle key commands, indent guides, and line highlighting
class EditorTextView: UITextView {
    var onPeekDefinition: (() -> Void)?
    var onEscape: (() -> Void)?

    // Autocomplete key handling hooks (return true if handled)
    var onAcceptAutocomplete: (() -> Bool)?
    var onDismissAutocomplete: (() -> Bool)?
    
    // FEAT-039 & FEAT-043
    private var indentGuideColor: UIColor = .separator
    private var activeIndentGuideColor: UIColor = .label
    private var currentLineHighlightColor: UIColor = .clear
    
    override init(frame: CGRect, textContainer: NSTextContainer?) {
        super.init(frame: frame, textContainer: textContainer)
        setup()
    }
    
    required init?(coder: NSCoder) {
        super.init(coder: coder)
        setup()
    }
    
    private func setup() {
        // Ensure we redraw when bounds/selection change
        contentMode = .redraw
    }
    
    func updateThemeColors(theme: Theme) {
        self.indentGuideColor = UIColor(theme.indentGuide)
        self.activeIndentGuideColor = UIColor(theme.indentGuideActive)
        self.currentLineHighlightColor = UIColor(theme.currentLineHighlight)
        setNeedsDisplay()
    }
    
    override func draw(_ rect: CGRect) {
        guard let context = UIGraphicsGetCurrentContext(), let font = self.font else {
            super.draw(rect)
            return
        }
        
        // 1. Draw Current Line Highlight (FEAT-043)
        if let selectedRange = selectedTextRange {
            // Get the line rect for the cursor position
            let caretRect = self.caretRect(for: selectedRange.start)
            let lineRect = CGRect(x: 0, y: caretRect.minY, width: bounds.width, height: caretRect.height)
            
            context.setFillColor(currentLineHighlightColor.cgColor)
            context.fill(lineRect)
        }
        
        // 2. Draw Text (super implementation)
        super.draw(rect)
        
        // 3. Draw Indent Guides (FEAT-039)
        // We iterate visible lines and draw vertical lines for indentation
        // Optimization: Only draw for visible range
        
        context.setStrokeColor(indentGuideColor.cgColor)
        context.setLineWidth(1.0)
        
        let tabSize = 4 // Assuming 4 spaces per tab/indent level
        let spaceWidth = " ".size(withAttributes: [.font: font]).width
        let indentWidth = spaceWidth * CGFloat(tabSize)
        
        // Iterate visible glyphs/lines
        let visibleRect = CGRect(origin: contentOffset, size: bounds.size)
        let glyphRange = layoutManager.glyphRange(forBoundingRect: visibleRect, in: textContainer)
        
        layoutManager.enumerateLineFragments(forGlyphRange: glyphRange) { (rect, usedRect, textContainer, glyphRange, stop) in
            // Get text for this line
            guard let range = self.layoutManager.characterRange(forGlyphRange: glyphRange, actualGlyphRange: nil) as NSRange?,
                  let text = self.text as NSString? else { return }
            
            let lineText = text.substring(with: range)
            
            // Calculate indentation level
            var spaces = 0
            for char in lineText {
                if char == " " { spaces += 1 }
                else if char == "\t" { spaces += tabSize } // Handle tabs if present
                else { break }
            }
            
            let indentLevel = spaces / tabSize
            if indentLevel > 0 {
                for i in 1...indentLevel {
                    let x = CGFloat(i) * indentWidth + textContainerInset.left
                    // Draw vertical line from top to bottom of line rect
                    let startPoint = CGPoint(x: x, y: rect.minY)
                    let endPoint = CGPoint(x: x, y: rect.maxY)
                    
                    context.move(to: startPoint)
                    context.addLine(to: endPoint)
                }
            }
        }
        
        context.strokePath()
    }
    
    override var keyCommands: [UIKeyCommand]? {
        var commands = super.keyCommands ?? []
        
        // Peek Definition: Alt+F12
        commands.append(UIKeyCommand(
            input: UIKeyCommand.inputF12,
            modifierFlags: .alternate,
            action: #selector(handlePeekDefinition)
        ))

        // Tab: accept autocomplete if visible, else insert tab
        commands.append(UIKeyCommand(
            input: "\t",
            modifierFlags: [],
            action: #selector(handleTab)
        ))
        
        // Escape: dismiss autocomplete if visible, else normal escape behavior
        commands.append(UIKeyCommand(
            input: UIKeyCommand.inputEscape,
            modifierFlags: [],
            action: #selector(handleEscape)
        ))
        
        return commands
    }
    
    @objc func handlePeekDefinition() {
        onPeekDefinition?()
    }

    @objc func handleTab() {
        if onAcceptAutocomplete?() == true {
            return
        }
        insertText("\t")
    }
    
    @objc func handleEscape() {
        if onDismissAutocomplete?() == true {
            return
        }
        onEscape?()
    }
}

// MARK: - VSCode-Style Syntax Highlighter

enum Language {
    case swift

    case javascript
    case typescript
    case jsx
    case tsx

    case python
    case ruby
    case go
    case rust
    case java
    case kotlin

    case c
    case cpp
    case objectiveC

    case html
    case css
    case scss
    case less
    case json
    case xml
    case yaml
    case sql

    case shell
    case dockerfile
    case graphql
    case markdown
    case php
    case env

    case plainText
}

struct VSCodeSyntaxHighlighter {
    private let baseFontSize: CGFloat
    let theme: Theme
    
    init(theme: Theme = ThemeManager.shared.currentTheme, fontSize: CGFloat = 14) {
        self.theme = theme
        self.baseFontSize = fontSize
    }
    
    func highlight(_ text: String, filename: String) -> NSAttributedString {
        let language = detectLanguage(from: filename)
        return highlight(text, language: language)
    }
    
    private func detectLanguage(from filename: String) -> Language {
        let lower = filename.lowercased()
        let ext = (filename as NSString).pathExtension.lowercased()

        // Special-case filenames without extensions
        if (filename as NSString).lastPathComponent.lowercased() == "dockerfile" { return .dockerfile }
        if (filename as NSString).lastPathComponent.lowercased() == ".env" { return .env }
        if lower.hasSuffix("/.env") { return .env }

        switch ext {
        case "swift": return .swift

        case "js", "mjs", "cjs": return .javascript
        case "jsx": return .jsx
        case "ts", "mts", "cts": return .typescript
        case "tsx": return .tsx

        case "py", "pyw": return .python
        case "rb", "ruby": return .ruby
        case "go": return .go
        case "rs": return .rust
        case "java": return .java
        case "kt", "kts": return .kotlin

        case "c", "h": return .c
        case "cpp", "cc", "cxx", "hpp", "hh", "hxx": return .cpp
        case "m", "mm": return .objectiveC

        case "html", "htm": return .html
        case "css": return .css
        case "scss", "sass": return .scss
        case "less": return .less
        case "json", "jsonc": return .json
        case "xml", "plist", "svg": return .xml
        case "yml", "yaml": return .yaml
        case "sql": return .sql

        case "sh", "bash", "zsh", "fish": return .shell
        case "dockerfile": return .dockerfile

        case "graphql", "gql": return .graphql

        case "md", "markdown": return .markdown
        case "php": return .php
        case "env": return .env

        default: return .plainText
        }
    }
    
    private func highlight(_ text: String, language: Language) -> NSAttributedString {
        let attributed = NSMutableAttributedString(string: text)
        let fullRange = NSRange(location: 0, length: text.utf16.count)
        
        // Base attributes
        let baseFont = UIFont.monospacedSystemFont(ofSize: baseFontSize, weight: .regular)
        attributed.addAttribute(.font, value: baseFont, range: fullRange)
        attributed.addAttribute(.foregroundColor, value: UIColor(theme.editorForeground), range: fullRange)
        
        // Apply language-specific highlighting
        switch language {
        case .swift: highlightSwift(attributed, text: text)
        case .javascript, .typescript: highlightJavaScript(attributed, text: text, isTS: language == .typescript)
        case .python: highlightPython(attributed, text: text)
        case .html, .xml: highlightHTML(attributed, text: text)
        case .css: highlightCSS(attributed, text: text)
        case .json: highlightJSON(attributed, text: text)
        case .markdown: highlightMarkdown(attributed, text: text)
        case .rust: highlightRust(attributed, text: text)
        case .go: highlightGo(attributed, text: text)
        case .java: highlightJava(attributed, text: text)
        case .cpp: highlightCpp(attributed, text: text)
        case .ruby: highlightRuby(attributed, text: text)
        case .php: highlightPHP(attributed, text: text)
        case .shell: highlightShell(attributed, text: text)
        case .yaml: highlightYAML(attributed, text: text)
        case .sql: highlightSQL(attributed, text: text)
        case .graphql: highlightGraphQL(attributed, text: text)
        case .plainText: break
        }
        
        // FEAT-038: Bracket Pair Colorization (applied last)
        highlightBracketPairs(attributed, text: text)
        
        return attributed
    }
    
    // MARK: - Bracket Pair Colorization
    
    private func highlightBracketPairs(_ attributed: NSMutableAttributedString, text: String) {
        let brackets: [Character] = ["{", "}", "[", "]", "(", ")"]
        let pairs: [Character: Character] = ["}": "{", "]": "[", ")": "("]
        
        var stack: [(char: Character, index: Int, depth: Int)] = []
        let colors = [
            UIColor(theme.bracketPair1),
            UIColor(theme.bracketPair2),
            UIColor(theme.bracketPair3),
            UIColor(theme.bracketPair4),
            UIColor(theme.bracketPair5),
            UIColor(theme.bracketPair6)
        ]
        
        // Scan text for brackets
        // Note: In a real implementation, we should skip brackets inside strings/comments
        // But since we apply this LAST, we can try to respect existing string/comment colors
        // OR implement a more robust parser. For now, simple scan.
        
        // Optimization: Use scanner or direct iteration
        let nsString = text as NSString
        var index = 0
        
        while index < text.utf16.count {
            let char = nsString.character(at: index)
            if let scalar = UnicodeScalar(char) {
                let c = Character(scalar)
                
                if brackets.contains(c) {
                    // Check if it's already colored as string/comment (heuristic)
                    // If color is string/comment, skip
                    // (Requires iterating attributes, which is slow. We'll just apply on top for now)
                    
                    if let open = pairs[c] { // Closing bracket
                        if let last = stack.last, last.char == open {
                            // Match found
                            let depth = last.depth
                            let color = colors[depth % colors.count]
                            
                            attributed.addAttribute(.foregroundColor, value: color, range: NSRange(location: index, length: 1))
                            attributed.addAttribute(.foregroundColor, value: color, range: NSRange(location: last.index, length: 1))
                            
                            stack.removeLast()
                        } else {
                            // Mismatched or extra closing bracket - unexpected
                            // Keep default color or mark red? Default for now.
                        }
                    } else { // Opening bracket
                        let depth = stack.count
                        stack.append((c, index, depth))
                        
                        // We'll color it when (and if) we find the match, or here?
                        // Better to color here tentatively, but matching is better.
                        // Let's color tentatively based on depth.
                        let color = colors[depth % colors.count]
                        attributed.addAttribute(.foregroundColor, value: color, range: NSRange(location: index, length: 1))
                    }
                }
            }
            index += 1
        }
    }
    
    // MARK: - Swift Highlighting
    
    private func highlightSwift(_ attributed: NSMutableAttributedString, text: String) {
        // Keywords (purple/pink)
        let keywords = ["func", "var", "let", "if", "else", "for", "while", "return",
                       "class", "struct", "enum", "protocol", "extension", "import",
                       "private", "public", "internal", "fileprivate", "open",
                       "static", "final", "override", "mutating", "nonmutating",
                       "init", "deinit", "subscript", "typealias", "associatedtype",
                       "where", "throws", "rethrows", "async", "await", "actor",
                       "guard", "defer", "do", "try", "catch", "throw",
                       "switch", "case", "default", "break", "continue", "fallthrough",
                       "in", "is", "as", "inout", "some", "any", "Self",
                       "get", "set", "willSet", "didSet", "lazy", "weak", "unowned",
                       "@State", "@Binding", "@Published", "@ObservedObject", "@StateObject",
                       "@Environment", "@EnvironmentObject", "@ViewBuilder", "@MainActor",
                       "@escaping", "@autoclosure", "@available", "@objc", "@discardableResult"]
        highlightKeywords(attributed, keywords: keywords, color: UIColor(theme.keyword), text: text)
        
        // Types (teal) - CamelCase words that aren't keywords
        let typePattern = "\\b[A-Z][a-zA-Z0-9]*\\b"
        highlightPattern(attributed, pattern: typePattern, color: UIColor(theme.type), text: text)
        
        // Function calls (yellow)
        let funcCallPattern = "\\b([a-z][a-zA-Z0-9]*)\\s*\\("
        highlightPattern(attributed, pattern: funcCallPattern, color: UIColor(theme.function), text: text, captureGroup: 1)
        
        // Constants (blue)
        let constants = ["true", "false", "nil", "self", "super"]
        highlightKeywords(attributed, keywords: constants, color: UIColor(theme.variable), text: text)
        
        // Comments MUST come late (green) - they override everything
        highlightComments(attributed, text: text, singleLine: "//", multiLineStart: "/*", multiLineEnd: "*/")
        
        // Strings AFTER comments (orange)
        highlightStrings(attributed, text: text)
        
        // Numbers (light green)
        highlightNumbers(attributed, text: text)
    }
    
    // MARK: - JavaScript/TypeScript Highlighting
    
    private func highlightJavaScript(_ attributed: NSMutableAttributedString, text: String, isTS: Bool) {
        var keywords = ["function", "var", "let", "const", "if", "else", "for", "while",
                       "return", "class", "extends", "new", "this", "super", "import",
                       "export", "default", "from", "as", "async", "await", "yield",
                       "try", "catch", "finally", "throw", "typeof", "instanceof",
                       "switch", "case", "break", "continue", "do", "in", "of",
                       "get", "set", "static", "constructor", "delete", "void",
                       "with", "debugger"]
        
        if isTS {
            keywords += ["interface", "type", "enum", "namespace", "module", "declare",
                        "implements", "public", "private", "protected", "readonly",
                        "abstract", "override", "keyof", "infer", "never", "unknown",
                        "any", "asserts", "is"]
        }
        
        highlightKeywords(attributed, keywords: keywords, color: UIColor(theme.keyword), text: text)
        
        // Constants
        let constants = ["true", "false", "null", "undefined", "NaN", "Infinity"]
        highlightKeywords(attributed, keywords: constants, color: UIColor(theme.variable), text: text)
        
        // Function names (yellow) - regular calls + arrow functions
        let funcNamePattern = "\\b([a-zA-Z_$][a-zA-Z0-9_$]*)\\b(?=\\s*(?:\\(|=>))"
        highlightPattern(attributed, pattern: funcNamePattern, color: UIColor(theme.function), text: text, captureGroup: 1)
        
        // Types (teal)
        let typePattern = "\\b[A-Z][a-zA-Z0-9]*\\b"
        highlightPattern(attributed, pattern: typePattern, color: UIColor(theme.type), text: text)
        
        highlightComments(attributed, text: text, singleLine: "//", multiLineStart: "/*", multiLineEnd: "*/")
        highlightStrings(attributed, text: text)
        highlightJSTemplateLiterals(attributed, text: text)
        highlightNumbers(attributed, text: text)
    }
    
    // MARK: - Python Highlighting
    
    private func highlightPython(_ attributed: NSMutableAttributedString, text: String) {
        let keywords = ["def", "class", "if", "elif", "else", "for", "while", "return",
                       "import", "from", "as", "try", "except", "finally", "raise",
                       "with", "assert", "yield", "lambda", "pass", "break", "continue",
                       "global", "nonlocal", "del", "in", "not", "and", "or", "is",
                       "async", "await", "match", "case"]
        highlightKeywords(attributed, keywords: keywords, color: UIColor(theme.keyword), text: text)
        
        let constants = ["True", "False", "None", "self", "cls"]
        highlightKeywords(attributed, keywords: constants, color: UIColor(theme.variable), text: text)
        
        // Decorators (yellow)
        let decoratorPattern = "@[a-zA-Z_][a-zA-Z0-9_\\.]*"
        highlightPattern(attributed, pattern: decoratorPattern, color: UIColor(theme.function), text: text)
        
        // Function definitions (yellow)
        let funcDefPattern = "(?<=def\\s)[a-zA-Z_][a-zA-Z0-9_]*"
        highlightPattern(attributed, pattern: funcDefPattern, color: UIColor(theme.function), text: text)
        
        // Class names (teal)
        let classPattern = "(?<=class\\s)[a-zA-Z_][a-zA-Z0-9_]*"
        highlightPattern(attributed, pattern: classPattern, color: UIColor(theme.type), text: text)
        
        // Built-in functions (yellow)
        let builtins = ["print", "len", "range", "str", "int", "float", "list", "dict", "set",
                       "tuple", "bool", "type", "isinstance", "hasattr", "getattr", "setattr",
                       "open", "input", "map", "filter", "reduce", "zip", "enumerate",
                       "sorted", "reversed", "min", "max", "sum", "abs", "round",
                       "super", "object", "Exception", "ValueError", "TypeError"]
        highlightKeywords(attributed, keywords: builtins, color: UIColor(theme.function), text: text)
        
        highlightComments(attributed, text: text, singleLine: "#", multiLineStart: nil, multiLineEnd: nil)
        highlightPythonStrings(attributed, text: text)
        highlightNumbers(attributed, text: text)
    }
    
    // MARK: - HTML Highlighting
    
    private func highlightHTML(_ attributed: NSMutableAttributedString, text: String) {
        // Tags (blue)
        let tagPattern = "</?\\s*([a-zA-Z][a-zA-Z0-9-]*)(?=[\\s>])"
        highlightPattern(attributed, pattern: tagPattern, color: UIColor(theme.keyword), text: text)
        
        // Attributes (light blue)
        let attrPattern = "\\s([a-zA-Z][a-zA-Z0-9-]*)\\s*="
        highlightPattern(attributed, pattern: attrPattern, color: UIColor(theme.variable), text: text, captureGroup: 1)
        
        // Angle brackets
        let bracketPattern = "[<>/?]"
        highlightPattern(attributed, pattern: bracketPattern, color: UIColor.gray, text: text)
        
        // Comments
        highlightHTMLComments(attributed, text: text)
        
        // Strings
        highlightStrings(attributed, text: text)
    }
    
    // MARK: - CSS Highlighting
    
    private func highlightCSS(_ attributed: NSMutableAttributedString, text: String) {
        // Selectors (yellow)
        let selectorPattern = "([.#]?[a-zA-Z][a-zA-Z0-9_-]*)\\s*\\{"
        highlightPattern(attributed, pattern: selectorPattern, color: UIColor(theme.function), text: text, captureGroup: 1)
        
        // Properties (light blue)
        let propertyPattern = "([a-zA-Z-]+)\\s*:"
        highlightPattern(attributed, pattern: propertyPattern, color: UIColor(theme.variable), text: text, captureGroup: 1)
        
        // Values with units
        let unitPattern = "\\b(\\d+)(px|em|rem|%|vh|vw|pt|cm|mm|in)\\b"
        highlightPattern(attributed, pattern: unitPattern, color: UIColor(theme.number), text: text)
        
        // Colors
        let hexPattern = "#[0-9a-fA-F]{3,8}\\b"
        highlightPattern(attributed, pattern: hexPattern, color: UIColor(theme.number), text: text)
        
        // Keywords
        let keywords = ["important", "inherit", "initial", "unset", "none", "auto",
                       "block", "inline", "flex", "grid", "absolute", "relative", "fixed"]
        highlightKeywords(attributed, keywords: keywords, color: UIColor(theme.keyword), text: text)
        
        highlightComments(attributed, text: text, singleLine: nil, multiLineStart: "/*", multiLineEnd: "*/")
        highlightStrings(attributed, text: text)
        highlightNumbers(attributed, text: text)
    }
    
    // MARK: - JSON Highlighting
    
    private func highlightJSON(_ attributed: NSMutableAttributedString, text: String) {
        // Keys (light blue)
        let keyPattern = "\"([^\"]+)\"\\s*:"
        highlightPattern(attributed, pattern: keyPattern, color: UIColor(theme.variable), text: text, captureGroup: 1)
        
        // String values (orange)
        highlightStrings(attributed, text: text)
        
        // Numbers (light green)
        highlightNumbers(attributed, text: text)
        
        // Booleans and null (use keyword color)
        let constants = ["true", "false", "null"]
        highlightKeywords(attributed, keywords: constants, color: UIColor(theme.keyword), text: text)
    }
    
    // MARK: - Markdown Highlighting
    
    private func highlightMarkdown(_ attributed: NSMutableAttributedString, text: String) {
        // Headers (blue + bold)
        let headerPattern = "^#{1,6}\\s+.+$"
        highlightPattern(attributed, pattern: headerPattern, color: UIColor(theme.keyword), text: text, options: .anchorsMatchLines)
        
        // Bold (orange)
        let boldPattern = "\\*\\*[^*]+\\*\\*|__[^_]+__"
        highlightPattern(attributed, pattern: boldPattern, color: UIColor(theme.string), text: text)
        
        // Italic
        let italicPattern = "(?<!\\*)\\*[^*]+\\*(?!\\*)|(?<!_)_[^_]+_(?!_)"
        highlightPattern(attributed, pattern: italicPattern, color: UIColor.secondaryLabel, text: text)
        
        // Code blocks (green)
        let codeBlockPattern = "```[\\s\\S]*?```|`[^`]+`"
        highlightPattern(attributed, pattern: codeBlockPattern, color: UIColor(theme.comment), text: text)
        
        // Links (light blue)
        let linkPattern = "\\[[^\\]]+\\]\\([^)]+\\)"
        highlightPattern(attributed, pattern: linkPattern, color: UIColor(theme.variable), text: text)
        
        // Lists
        let listPattern = "^\\s*[-*+]\\s"
        highlightPattern(attributed, pattern: listPattern, color: UIColor(theme.keyword), text: text, options: .anchorsMatchLines)
    }
    
    // MARK: - Rust Highlighting
    
    private func highlightRust(_ attributed: NSMutableAttributedString, text: String) {
        let keywords = ["fn", "let", "mut", "const", "if", "else", "match", "loop", "while", "for",
                       "return", "struct", "enum", "impl", "trait", "type", "use", "mod", "pub",
                       "self", "Self", "super", "crate", "as", "in", "ref", "move", "async", "await",
                       "where", "unsafe", "extern", "dyn", "static", "break", "continue"]
        highlightKeywords(attributed, keywords: keywords, color: UIColor(theme.keyword), text: text)
        
        let types = ["i8", "i16", "i32", "i64", "i128", "isize", "u8", "u16", "u32", "u64", "u128", "usize",
                    "f32", "f64", "bool", "char", "str", "String", "Vec", "Option", "Result", "Box"]
        highlightKeywords(attributed, keywords: types, color: UIColor(theme.type), text: text)
        
        let constants = ["true", "false", "None", "Some", "Ok", "Err"]
        highlightKeywords(attributed, keywords: constants, color: UIColor(theme.variable), text: text)
        
        // Macros (yellow)
        let macroPattern = "[a-zA-Z_][a-zA-Z0-9_]*!"
        highlightPattern(attributed, pattern: macroPattern, color: UIColor(theme.function), text: text)
        
        // Lifetimes (orange)
        let lifetimePattern = "'[a-zA-Z_][a-zA-Z0-9_]*"
        highlightPattern(attributed, pattern: lifetimePattern, color: UIColor(theme.string), text: text)
        
        highlightComments(attributed, text: text, singleLine: "//", multiLineStart: "/*", multiLineEnd: "*/")
        highlightStrings(attributed, text: text)
        highlightNumbers(attributed, text: text)
    }
    
    // MARK: - Go Highlighting
    
    private func highlightGo(_ attributed: NSMutableAttributedString, text: String) {
        let keywords = ["func", "var", "const", "type", "struct", "interface", "map", "chan",
                       "if", "else", "for", "range", "switch", "case", "default", "select",
                       "return", "break", "continue", "goto", "fallthrough", "defer", "go",
                       "package", "import"]
        highlightKeywords(attributed, keywords: keywords, color: UIColor(theme.keyword), text: text)
        
        let types = ["int", "int8", "int16", "int32", "int64", "uint", "uint8", "uint16", "uint32", "uint64",
                    "float32", "float64", "complex64", "complex128", "byte", "rune", "string", "bool", "error"]
        highlightKeywords(attributed, keywords: types, color: UIColor(theme.type), text: text)
        
        let constants = ["true", "false", "nil", "iota"]
        highlightKeywords(attributed, keywords: constants, color: UIColor(theme.variable), text: text)
        
        highlightComments(attributed, text: text, singleLine: "//", multiLineStart: "/*", multiLineEnd: "*/")
        highlightStrings(attributed, text: text)
        highlightNumbers(attributed, text: text)
    }
    
    // MARK: - Java Highlighting
    
    private func highlightJava(_ attributed: NSMutableAttributedString, text: String) {
        let keywords = ["public", "private", "protected", "class", "interface", "extends", "implements",
                       "static", "final", "abstract", "native", "synchronized", "volatile", "transient",
                       "if", "else", "for", "while", "do", "switch", "case", "default", "break", "continue",
                       "return", "throw", "throws", "try", "catch", "finally", "new", "this", "super",
                       "import", "package", "instanceof", "assert", "enum", "void"]
        highlightKeywords(attributed, keywords: keywords, color: UIColor(theme.keyword), text: text)
        
        let types = ["int", "long", "short", "byte", "float", "double", "char", "boolean",
                    "String", "Integer", "Long", "Double", "Boolean", "Object", "List", "Map", "Set"]
        highlightKeywords(attributed, keywords: types, color: UIColor(theme.type), text: text)
        
        let constants = ["true", "false", "null"]
        highlightKeywords(attributed, keywords: constants, color: UIColor(theme.variable), text: text)
        
        // Annotations
        let annotationPattern = "@[a-zA-Z][a-zA-Z0-9]*"
        highlightPattern(attributed, pattern: annotationPattern, color: UIColor(theme.function), text: text)
        
        highlightComments(attributed, text: text, singleLine: "//", multiLineStart: "/*", multiLineEnd: "*/")
        highlightStrings(attributed, text: text)
        highlightNumbers(attributed, text: text)
    }
    
    // MARK: - C/C++ Highlighting
    
    private func highlightCpp(_ attributed: NSMutableAttributedString, text: String) {
        let keywords = ["auto", "break", "case", "catch", "class", "const", "continue", "default",
                       "delete", "do", "else", "enum", "explicit", "extern", "for", "friend", "goto",
                       "if", "inline", "mutable", "namespace", "new", "operator", "private", "protected",
                       "public", "register", "return", "sizeof", "static", "struct", "switch", "template",
                       "this", "throw", "try", "typedef", "typename", "union", "using", "virtual",
                       "volatile", "while", "constexpr", "nullptr", "override", "final", "noexcept"]
        highlightKeywords(attributed, keywords: keywords, color: UIColor(theme.keyword), text: text)
        
        let types = ["void", "int", "long", "short", "char", "float", "double", "bool", "signed", "unsigned",
                    "int8_t", "int16_t", "int32_t", "int64_t", "uint8_t", "uint16_t", "uint32_t", "uint64_t",
                    "size_t", "string", "vector", "map", "set", "unique_ptr", "shared_ptr"]
        highlightKeywords(attributed, keywords: types, color: UIColor(theme.type), text: text)
        
        let constants = ["true", "false", "NULL", "nullptr"]
        highlightKeywords(attributed, keywords: constants, color: UIColor(theme.variable), text: text)
        
        // Preprocessor directives
        let preprocPattern = "^\\s*#\\s*(include|define|ifdef|ifndef|endif|if|else|elif|pragma|error|warning).*$"
        highlightPattern(attributed, pattern: preprocPattern, color: UIColor(theme.keyword), text: text, options: .anchorsMatchLines)
        
        highlightComments(attributed, text: text, singleLine: "//", multiLineStart: "/*", multiLineEnd: "*/")
        highlightStrings(attributed, text: text)
        highlightNumbers(attributed, text: text)
    }
    
    // MARK: - Ruby Highlighting
    
    private func highlightRuby(_ attributed: NSMutableAttributedString, text: String) {
        let keywords = ["def", "class", "module", "if", "elsif", "else", "unless", "case", "when",
                       "while", "until", "for", "do", "end", "begin", "rescue", "ensure", "raise",
                       "return", "yield", "break", "next", "redo", "retry", "self", "super",
                       "require", "require_relative", "include", "extend", "attr_reader", "attr_writer", "attr_accessor",
                       "public", "private", "protected", "alias", "and", "or", "not", "in"]
        highlightKeywords(attributed, keywords: keywords, color: UIColor(theme.keyword), text: text)
        
        let constants = ["true", "false", "nil"]
        highlightKeywords(attributed, keywords: constants, color: UIColor(theme.variable), text: text)
        
        // Symbols (orange)
        let symbolPattern = ":[a-zA-Z_][a-zA-Z0-9_]*"
        highlightPattern(attributed, pattern: symbolPattern, color: UIColor(theme.string), text: text)
        
        // Instance variables (light blue)
        let ivarPattern = "@[a-zA-Z_][a-zA-Z0-9_]*"
        highlightPattern(attributed, pattern: ivarPattern, color: UIColor(theme.variable), text: text)
        
        highlightComments(attributed, text: text, singleLine: "#", multiLineStart: "=begin", multiLineEnd: "=end")
        highlightStrings(attributed, text: text)
        highlightNumbers(attributed, text: text)
    }
    
    // MARK: - PHP Highlighting
    
    private func highlightPHP(_ attributed: NSMutableAttributedString, text: String) {
        let keywords = ["function", "class", "interface", "trait", "extends", "implements", "use",
                       "public", "private", "protected", "static", "final", "abstract", "const",
                       "if", "else", "elseif", "switch", "case", "default", "for", "foreach", "while", "do",
                       "return", "break", "continue", "throw", "try", "catch", "finally",
                       "new", "clone", "instanceof", "echo", "print", "die", "exit",
                       "require", "require_once", "include", "include_once", "namespace"]
        highlightKeywords(attributed, keywords: keywords, color: UIColor(theme.keyword), text: text)
        
        let constants = ["true", "false", "null", "TRUE", "FALSE", "NULL"]
        highlightKeywords(attributed, keywords: constants, color: UIColor(theme.variable), text: text)
        
        // Variables (light blue)
        let varPattern = "\\$[a-zA-Z_][a-zA-Z0-9_]*"
        highlightPattern(attributed, pattern: varPattern, color: UIColor(theme.variable), text: text)
        
        highlightComments(attributed, text: text, singleLine: "//", multiLineStart: "/*", multiLineEnd: "*/")
        highlightStrings(attributed, text: text)
        highlightNumbers(attributed, text: text)
    }
    
    // MARK: - Shell Highlighting
    
    private func highlightShell(_ attributed: NSMutableAttributedString, text: String) {
        let keywords = ["if", "then", "else", "elif", "fi", "for", "while", "do", "done", "case", "esac",
                       "function", "return", "exit", "break", "continue", "local", "export", "readonly",
                       "source", "alias", "unalias", "set", "unset", "shift", "eval", "exec",
                       "echo", "printf", "read", "cd", "pwd", "ls", "mkdir", "rm", "cp", "mv"]
        highlightKeywords(attributed, keywords: keywords, color: UIColor(theme.keyword), text: text)
        
        // Variables (light blue)
        let varPattern = "\\$[a-zA-Z_][a-zA-Z0-9_]*|\\$\\{[^}]+\\}"
        highlightPattern(attributed, pattern: varPattern, color: UIColor(theme.variable), text: text)
        
        highlightComments(attributed, text: text, singleLine: "#", multiLineStart: nil, multiLineEnd: nil)
        highlightStrings(attributed, text: text)
        highlightNumbers(attributed, text: text)
    }
    
    // MARK: - YAML Highlighting
    
    private func highlightYAML(_ attributed: NSMutableAttributedString, text: String) {
        // Keys (light blue)
        let keyPattern = "^\\s*([a-zA-Z_][a-zA-Z0-9_-]*)\\s*:"
        highlightPattern(attributed, pattern: keyPattern, color: UIColor(theme.variable), text: text, options: .anchorsMatchLines, captureGroup: 1)
        
        // Booleans and null
        let constants = ["true", "false", "yes", "no", "on", "off", "null", "~"]
        highlightKeywords(attributed, keywords: constants, color: UIColor(theme.variable), text: text)
        
        highlightComments(attributed, text: text, singleLine: "#", multiLineStart: nil, multiLineEnd: nil)
        highlightStrings(attributed, text: text)
        highlightNumbers(attributed, text: text)
    }
    
    // MARK: - SQL Highlighting
    
    private func highlightSQL(_ attributed: NSMutableAttributedString, text: String) {
        let keywords = ["SELECT", "FROM", "WHERE", "AND", "OR", "NOT", "IN", "LIKE", "BETWEEN",
                       "INSERT", "INTO", "VALUES", "UPDATE", "SET", "DELETE", "CREATE", "ALTER", "DROP",
                       "TABLE", "INDEX", "VIEW", "DATABASE", "SCHEMA", "PRIMARY", "KEY", "FOREIGN", "REFERENCES",
                       "JOIN", "INNER", "LEFT", "RIGHT", "OUTER", "FULL", "ON", "AS", "DISTINCT",
                       "ORDER", "BY", "ASC", "DESC", "GROUP", "HAVING", "LIMIT", "OFFSET", "UNION",
                       "NULL", "IS", "TRUE", "FALSE", "CASE", "WHEN", "THEN", "ELSE", "END",
                       "COUNT", "SUM", "AVG", "MIN", "MAX", "COALESCE", "CAST",
                       "select", "from", "where", "and", "or", "not", "in", "like", "between",
                       "insert", "into", "values", "update", "set", "delete", "create", "alter", "drop",
                       "table", "index", "view", "database", "schema", "primary", "key", "foreign", "references",
                       "join", "inner", "left", "right", "outer", "full", "on", "as", "distinct",
                       "order", "by", "asc", "desc", "group", "having", "limit", "offset", "union",
                       "null", "is", "true", "false", "case", "when", "then", "else", "end"]
        highlightKeywords(attributed, keywords: keywords, color: UIColor(theme.keyword), text: text)
        
        let types = ["INT", "INTEGER", "BIGINT", "SMALLINT", "TINYINT", "FLOAT", "DOUBLE", "DECIMAL",
                    "VARCHAR", "CHAR", "TEXT", "BLOB", "DATE", "TIME", "DATETIME", "TIMESTAMP", "BOOLEAN",
                    "int", "integer", "bigint", "smallint", "tinyint", "float", "double", "decimal",
                    "varchar", "char", "text", "blob", "date", "time", "datetime", "timestamp", "boolean"]
        highlightKeywords(attributed, keywords: types, color: UIColor(theme.type), text: text)
        
        highlightComments(attributed, text: text, singleLine: "--", multiLineStart: "/*", multiLineEnd: "*/")
        highlightStrings(attributed, text: text)
        highlightNumbers(attributed, text: text)
    }
    
    // MARK: - GraphQL Highlighting
    
    private func highlightGraphQL(_ attributed: NSMutableAttributedString, text: String) {
        // Keywords
        let keywords = ["query", "mutation", "subscription", "fragment", "on", "type", 
                       "interface", "union", "enum", "scalar", "input", "extend", 
                       "directive", "schema", "implements"]
        highlightKeywords(attributed, keywords: keywords, color: UIColor(theme.keyword), text: text)
        
        // Built-in scalar types
        let types = ["Int", "Float", "String", "Boolean", "ID"]
        highlightKeywords(attributed, keywords: types, color: UIColor(theme.type), text: text)
        
        // Variables ($name)
        let variablePattern = "\\$[a-zA-Z_][a-zA-Z0-9_]*"
        highlightPattern(attributed, pattern: variablePattern, color: UIColor(theme.variable), text: text)
        
        // Directives (@deprecated, @skip, @include, etc.)
        let directivePattern = "@[a-zA-Z_][a-zA-Z0-9_]*"
        highlightPattern(attributed, pattern: directivePattern, color: UIColor(theme.function), text: text)
        
        // Comments (# single line)
        highlightComments(attributed, text: text, singleLine: "#", multiLineStart: nil, multiLineEnd: nil)
        
        // Strings
        highlightStrings(attributed, text: text)
        
        // Numbers
        highlightNumbers(attributed, text: text)
    }
    
    // MARK: - Helper Methods
    
    private func highlightKeywords(_ attributed: NSMutableAttributedString, keywords: [String], color: UIColor, text: String) {
        for keyword in keywords {
            let pattern = "\\b\(NSRegularExpression.escapedPattern(for: keyword))\\b"
            highlightPattern(attributed, pattern: pattern, color: color, text: text)
        }
    }
    
    private func highlightPattern(_ attributed: NSMutableAttributedString, pattern: String, color: UIColor, text: String, options: NSRegularExpression.Options = [], captureGroup: Int = 0) {
        guard let regex = try? NSRegularExpression(pattern: pattern, options: options) else { return }
        let range = NSRange(location: 0, length: text.utf16.count)
        
        regex.enumerateMatches(in: text, options: [], range: range) { match, _, _ in
            guard let match = match else { return }
            let matchRange = captureGroup > 0 && match.numberOfRanges > captureGroup
                ? match.range(at: captureGroup)
                : match.range
            if matchRange.location != NSNotFound {
                attributed.addAttribute(.foregroundColor, value: color, range: matchRange)
            }
        }
    }
    
    private func highlightStrings(_ attributed: NSMutableAttributedString, text: String) {
        // Double-quoted strings
        let doublePattern = "\"(?:[^\"\\\\]|\\\\.)*\""
        highlightPattern(attributed, pattern: doublePattern, color: UIColor(theme.string), text: text)
        
        // Single-quoted strings
        let singlePattern = "'(?:[^'\\\\]|\\\\.)*'"
        highlightPattern(attributed, pattern: singlePattern, color: UIColor(theme.string), text: text)
    }
    
    private func highlightPythonStrings(_ attributed: NSMutableAttributedString, text: String) {
        // Triple-quoted strings first
        let tripleDoublePattern = "\"\"\"[\\s\\S]*?\"\"\""
        highlightPattern(attributed, pattern: tripleDoublePattern, color: UIColor(theme.string), text: text)
        
        let tripleSinglePattern = "'''[\\s\\S]*?'''"
        highlightPattern(attributed, pattern: tripleSinglePattern, color: UIColor(theme.string), text: text)
        
        // Then regular strings
        highlightStrings(attributed, text: text)
        
        // F-strings (with expressions highlighted differently)
        let fstringPattern = "f\"[^\"]*\"|f'[^']*'"
        highlightPattern(attributed, pattern: fstringPattern, color: UIColor(theme.string), text: text)
    }
    
    private func highlightJSTemplateLiterals(_ attributed: NSMutableAttributedString, text: String) {
        // Template literals
        let templatePattern = "`[^`]*`"
        highlightPattern(attributed, pattern: templatePattern, color: UIColor(theme.string), text: text)
    }
    
    private func highlightComments(_ attributed: NSMutableAttributedString, text: String, singleLine: String?, multiLineStart: String?, multiLineEnd: String?) {
        // Single-line comments
        if let single = singleLine {
            let pattern = "\(NSRegularExpression.escapedPattern(for: single)).*$"
            highlightPattern(attributed, pattern: pattern, color: UIColor(theme.comment), text: text, options: .anchorsMatchLines)
        }
        
        // Multi-line comments
        if let start = multiLineStart, let end = multiLineEnd {
            let pattern = "\(NSRegularExpression.escapedPattern(for: start))[\\s\\S]*?\(NSRegularExpression.escapedPattern(for: end))"
            highlightPattern(attributed, pattern: pattern, color: UIColor(theme.comment), text: text)
        }
    }
    
    private func highlightHTMLComments(_ attributed: NSMutableAttributedString, text: String) {
        let pattern = "<!--[\\s\\S]*?-->"
        highlightPattern(attributed, pattern: pattern, color: UIColor(theme.comment), text: text)
    }
    
    private func highlightNumbers(_ attributed: NSMutableAttributedString, text: String) {
        // Hex numbers
        let hexPattern = "\\b0[xX][0-9a-fA-F]+\\b"
        highlightPattern(attributed, pattern: hexPattern, color: UIColor(theme.number), text: text)
        
        // Binary numbers
        let binPattern = "\\b0[bB][01]+\\b"
        highlightPattern(attributed, pattern: binPattern, color: UIColor(theme.number), text: text)
        
        // Octal numbers
        let octPattern = "\\b0[oO][0-7]+\\b"
        highlightPattern(attributed, pattern: octPattern, color: UIColor(theme.number), text: text)
        
        // Decimal numbers (including floats and scientific notation)
        let decPattern = "\\b\\d+\\.?\\d*([eE][+-]?\\d+)?\\b"
        highlightPattern(attributed, pattern: decPattern, color: UIColor(theme.number), text: text)
    }
}