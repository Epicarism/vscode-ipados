import SwiftUI
import SwiftUI
import UIKit
import Network
import Foundation

// MARK: - Terminal View (Main Container)

struct TerminalView: View {
    @StateObject private var workspace = TerminalWorkspace.shared
    @ObservedObject private var themeManager = ThemeManager.shared
    @State private var showConnectionSheet = false
    
    var body: some View {
        VStack(spacing: 0) {
            // MARK: Top Toolbar
            HStack {
                Text("TERMINAL")
                    .font(.caption)
                    .fontWeight(.bold)
                    .foregroundColor(themeManager.currentTheme.tabActiveForeground)
                    .padding(.horizontal)
                
                Spacer()
                
                // Terminal Selector Dropdown
                Menu {
                    ForEach(workspace.terminals) { terminal in
                        Button(action: {
                            workspace.activeTerminalId = terminal.id
                        }) {
                            HStack {
                                Text(terminal.title)
                                if workspace.activeTerminalId == terminal.id {
                                    Image(systemName: "checkmark")
                                }
                            }
                        }
                    }
                } label: {
                    HStack(spacing: 4) {
                        Image(systemName: "terminal")
                        Text(workspace.activeTerminal?.title ?? "No Terminal")
                            .lineLimit(1)
                            .frame(maxWidth: 150)
                        Image(systemName: "chevron.down")
                            .font(.caption2)
                    }
                    .font(.caption)
                    .padding(.horizontal, 8)
                    .padding(.vertical, 4)
                    .background(themeManager.currentTheme.editorForeground.opacity(0.1))
                    .cornerRadius(4)
                }
                .disabled(workspace.terminals.isEmpty)
                
                Divider()
                    .frame(height: 16)
                
                // Actions
                HStack(spacing: 12) {
                    Button(action: { workspace.addTerminal() }) {
                        Image(systemName: "plus")
                    }
                    .help("New Terminal")
                    
                    Button(action: { workspace.splitTerminal() }) {
                        Image(systemName: "square.split.2x1")
                    }
                    .disabled(workspace.terminals.isEmpty)
                    .help("Split Terminal")
                    
                    Button(action: { 
                        if let active = workspace.activeTerminal {
                             active.clear()
                        }
                    }) {
                        Image(systemName: "trash")
                    }
                    .disabled(workspace.terminals.isEmpty)
                    .help("Clear Terminal")
                    
                    Button(action: {
                         if let id = workspace.activeTerminalId {
                             workspace.removeTerminal(id: id)
                         }
                    }) {
                        Image(systemName: "xmark")
                    }
                    .disabled(workspace.terminals.isEmpty)
                    .help("Kill Terminal")
                    
                    Button(action: { showConnectionSheet = true }) {
                        Image(systemName: "network")
                    }
                    .help("SSH Connect")
                }
                .font(.caption)
                .foregroundColor(themeManager.currentTheme.editorForeground)
            }
            .padding(8)
            .background(themeManager.currentTheme.editorBackground)
            .overlay(Rectangle().frame(height: 1).foregroundColor(themeManager.currentTheme.editorForeground.opacity(0.2)), alignment: .bottom)
            
            // MARK: Terminal Content
            if workspace.terminals.isEmpty {
                VStack(spacing: 12) {
                    Text("No Open Terminals")
                        .foregroundColor(themeManager.currentTheme.editorForeground.opacity(0.5))
                    Button("Create New Terminal") {
                        workspace.addTerminal()
                    }
                }
                .frame(maxWidth: .infinity, maxHeight: .infinity)
                .background(themeManager.currentTheme.editorBackground)
            } else if let activeTerminal = workspace.activeTerminal {
                // Check for splits
                // Simplified split view: just two terminals side by side if split is active for this ID
                // Real implementation would need a tree structure. 
                // For now, we just show the active terminal.
                SingleTerminalView(terminal: activeTerminal)
            }
        }
        .background(themeManager.currentTheme.editorBackground)
        .sheet(isPresented: $showConnectionSheet) {
            if let active = workspace.activeTerminal {
                SSHConnectionView(terminal: active, isPresented: $showConnectionSheet)
            }
        }
    }
}

// MARK: - Single Terminal View

struct SingleTerminalView: View {
    @ObservedObject var terminal: TerminalManager
    @ObservedObject private var themeManager = ThemeManager.shared
    @State private var currentCommand = ""
    @FocusState private var isInputFocused: Bool
    
    var body: some View {
        VStack(spacing: 0) {
            // Terminal Output
            ScrollViewReader { proxy in
                ScrollView {
                    VStack(alignment: .leading, spacing: 2) {
                        ForEach(terminal.output) { line in
                            TerminalLineView(line: line)
                                .id(line.id)
                        }
                    }
                    .frame(maxWidth: .infinity, alignment: .leading)
                    .padding(8)
                }
                .onChange(of: terminal.output.count) { _ in
                    withAnimation(.easeOut(duration: 0.1)) {
                        proxy.scrollTo(terminal.output.last?.id, anchor: .bottom)
                    }
                }
            }
            .onTapGesture {
                isInputFocused = true
            }
            
            // Input Area
            HStack(spacing: 0) {
                Text(terminal.promptString)
                    .font(.system(.body, design: .monospaced))
                    .foregroundColor(themeManager.currentTheme.type) // Use a theme color
                    .padding(.leading, 8)
                
                TextField("", text: $currentCommand)
                    .font(.system(.body, design: .monospaced))
                    .foregroundColor(themeManager.currentTheme.editorForeground)
                    .accentColor(themeManager.currentTheme.cursor)
                    .autocapitalization(.none)
                    .disableAutocorrection(true)
                    .focused($isInputFocused)
                    .onSubmit {
                        executeCommand()
                    }
                    .padding(8)
            }
            .background(themeManager.currentTheme.editorBackground)
            
            // Mobile Helper Bar (optional)
            if isInputFocused {
                HStack(spacing: 12) {
                     Button("Tab") { terminal.sendTab() }
                     Button("Esc") { /* handle esc */ }
                     Button("Ctrl+C") { terminal.sendInterrupt() }.foregroundColor(.red)
                     Spacer()
                     Button("ls") { currentCommand = "ls -la" }
                     Button("git status") { currentCommand = "git status" }
                }
                .font(.caption)
                .padding(.horizontal)
                .padding(.vertical, 6)
                .background(themeManager.currentTheme.editorForeground.opacity(0.1))
            }
        }
        .background(themeManager.currentTheme.editorBackground)
        .onAppear {
            isInputFocused = true
        }
    }
    
    private func executeCommand() {
        guard !currentCommand.isEmpty else { return }
        terminal.executeCommand(currentCommand)
        currentCommand = ""
    }
}

struct TerminalLineView: View {
    let line: TerminalLine
    @ObservedObject private var themeManager = ThemeManager.shared
    
    var body: some View {
        if line.isANSI {
            ANSIText(line.text)
        } else {
            Text(line.text)
                .font(.system(.body, design: .monospaced))
                .foregroundColor(colorForType(line.type))
                .textSelection(.enabled)
        }
    }
    
    func colorForType(_ type: LineType) -> Color {
        switch type {
        case .command: return themeManager.currentTheme.editorForeground
        case .output: return themeManager.currentTheme.editorForeground.opacity(0.9)
        case .error: return Color.red // Could use theme error color if available
        case .system: return themeManager.currentTheme.comment
        case .prompt: return themeManager.currentTheme.type
        }
    }
}

// MARK: - Terminal Workspace Manager

class TerminalWorkspace: ObservableObject {
    static let shared = TerminalWorkspace()
    
    @Published var terminals: [TerminalManager] = []
    @Published var activeTerminalId: UUID? {
        didSet {
            objectWillChange.send()
        }
    }
    
    var activeTerminal: TerminalManager? {
        guard let id = activeTerminalId else { return nil }
        return terminals.first { $0.id == id }
    }
    
    init() {
        addTerminal() // Start with one
    }
    
    func addTerminal() {
        let newTerm = TerminalManager()
        newTerm.title = "Terminal \(terminals.count + 1)"
        terminals.append(newTerm)
        activeTerminalId = newTerm.id
    }
    
    func removeTerminal(id: UUID) {
        if let term = terminals.first(where: { $0.id == id }) {
            term.disconnect()
        }
        terminals.removeAll { $0.id == id }
        if activeTerminalId == id {
            activeTerminalId = terminals.last?.id
        }
    }
    
    func splitTerminal() {
        // For now, simpler implementation: just add a terminal
        // A real split needs a more complex UI layout engine
        addTerminal()
    }
}

// MARK: - Terminal Manager

class TerminalManager: ObservableObject, Identifiable {
    let id = UUID()
    @Published var title: String = "Terminal"
    
    @Published var output: [TerminalLine] = [
        TerminalLine(text: "VSCode iPadOS Terminal v1.1", type: .system),
        TerminalLine(text: "Type 'help' for commands or connect via SSH.", type: .system),
        TerminalLine(text: "", type: .output)
    ]
    @Published var isConnected = false
    @Published var isConnecting = false
    @Published var connectionStatus = "Not connected"
    @Published var promptString = "$ "
    
    private var sshClient: SSHClient?
    private var currentConnection: SSHConnection?
    private var commandHistory: [String] = []
    private var historyIndex = 0
    
    func clear() {
        output = []
    }
    
    func connect(to connection: SSHConnection) {
        currentConnection = connection
        isConnecting = true
        connectionStatus = "Connecting to \(connection.host)..."
        title = "\(connection.username)@\(connection.host)"
        
        appendOutput("Connecting to \(connection.username)@\(connection.host):\(connection.port)...", type: .system)
        
        sshClient = SSHClient(connection: connection)
        sshClient?.delegate = self
        sshClient?.connect()
    }
    
    func disconnect() {
        sshClient?.disconnect()
        sshClient = nil
        isConnected = false
        isConnecting = false
        connectionStatus = "Disconnected"
        promptString = "$ "
        title = "Terminal (Disconnected)"
        appendOutput("Disconnected from server.", type: .system)
    }
    
    func executeCommand(_ command: String) {
        commandHistory.append(command)
        historyIndex = commandHistory.count
        
        appendOutput(promptString + command, type: .command)
        
        if isConnected {
            sshClient?.send(command: command)
        } else {
            processLocalCommand(command)
        }
    }
    
    func sendInterrupt() {
        if isConnected {
            sshClient?.sendInterrupt()
        }
        appendOutput("^C", type: .system)
    }
    
    func sendTab() {
        if isConnected {
            sshClient?.sendTab()
        }
    }
    
    // ... (Previous command history methods preserved but omitted for brevity if unused)
    
    private func processLocalCommand(_ command: String) {
        let parts = command.split(separator: " ", maxSplits: 1)
        guard let cmd = parts.first?.lowercased() else { return }
        
        switch cmd {
        case "help":
            appendOutput("""
            Local Commands:
              help              - Show this help
              clear             - Clear terminal
              echo <text>       - Echo text
              date              - Show current date
              whoami            - Show current user
              history           - Show command history
            """, type: .output)
            
        case "clear":
            clear()
            
        case "echo":
            let text = parts.count > 1 ? String(parts[1]) : ""
            appendOutput(text, type: .output)
            
        case "date":
             appendOutput(Date().description, type: .output)
            
        case "whoami":
            appendOutput("ipad-user", type: .output)
            
        case "history":
            for (index, cmd) in commandHistory.enumerated() {
                appendOutput("  \(index + 1)  \(cmd)", type: .output)
            }
            
        default:
            appendOutput("\(cmd): command not found (local mode)", type: .error)
        }
    }
    
    func appendOutput(_ text: String, type: LineType, isANSI: Bool = false) {
        DispatchQueue.main.async {
            self.output.append(TerminalLine(text: text, type: type, isANSI: isANSI))
        }
    }
}

// MARK: - SSH Client Delegate
extension TerminalManager: SSHClientDelegate {
    func sshClientDidConnect(_ client: SSHClient) {
        DispatchQueue.main.async {
            self.isConnected = true
            self.isConnecting = false
            self.connectionStatus = "Connected"
            self.promptString = "\(self.currentConnection?.username ?? "user")@\(self.currentConnection?.host ?? "host"):~$ "
            self.appendOutput("Connected successfully!", type: .system)
        }
    }
    
    func sshClientDidDisconnect(_ client: SSHClient, error: Error?) {
        DispatchQueue.main.async {
            self.isConnected = false
            self.isConnecting = false
            self.connectionStatus = "Disconnected"
            self.promptString = "$ "
            if let error = error {
                self.appendOutput("Connection error: \(error.localizedDescription)", type: .error)
            }
        }
    }
    
    func sshClient(_ client: SSHClient, didReceiveOutput text: String) {
        appendOutput(text, type: .output, isANSI: text.contains("\u{1B}"))
    }
    
    func sshClient(_ client: SSHClient, didReceiveError text: String) {
        appendOutput(text, type: .error)
    }
}

// MARK: - SSH Connection View (Preserved)

struct SSHConnectionView: View {
    @ObservedObject var terminal: TerminalManager
    @Binding var isPresented: Bool
    
    @State private var host = ""
    @State private var port = "22"
    @State private var username = ""
    @State private var password = ""
    @State private var useKey = false
    @State private var privateKey = ""
    
    var body: some View {
        NavigationView {
            Form {
                Section(header: Text("Connection Details")) {
                    TextField("Host", text: $host)
                        .autocapitalization(.none)
                        .disableAutocorrection(true)
                    TextField("Port", text: $port)
                        .keyboardType(.numberPad)
                    TextField("Username", text: $username)
                        .autocapitalization(.none)
                        .disableAutocorrection(true)
                }
                
                Section(header: Text("Authentication")) {
                    Toggle("Use SSH Key", isOn: $useKey)
                    if useKey {
                        TextEditor(text: $privateKey)
                            .frame(height: 100)
                    } else {
                        SecureField("Password", text: $password)
                    }
                }
                
                Button(action: connect) {
                     if terminal.isConnecting {
                         ProgressView()
                     } else {
                         Text("Connect")
                     }
                }
                .disabled(host.isEmpty || username.isEmpty)
            }
            .navigationTitle("SSH Connection")
            .toolbar {
                ToolbarItem(placement: .cancellationAction) {
                    Button("Cancel") { isPresented = false }
                }
            }
        }
    }
    
    private func connect() {
        let connection = SSHConnection(
            host: host,
            port: Int(port) ?? 22,
            username: username,
            password: useKey ? nil : password,
            privateKey: useKey ? privateKey : nil
        )
        terminal.connect(to: connection)
        isPresented = false
    }
}

// MARK: - Models & Helpers

struct SSHConnection {
    let host: String
    let port: Int
    let username: String
    let password: String?
    let privateKey: String?
}

struct TerminalLine: Identifiable {
    let id = UUID()
    let text: String
    let type: LineType
    var isANSI: Bool = false
}

enum LineType {
    case command
    case output
    case error
    case system
    case prompt
}

struct ANSIText: View {
    let text: String
    @ObservedObject private var themeManager = ThemeManager.shared
    
    init(_ text: String) {
        self.text = text
    }
    
    var body: some View {
        Text(stripANSI(text))
            .font(.system(.body, design: .monospaced))
            .foregroundColor(themeManager.currentTheme.editorForeground)
            .textSelection(.enabled)
    }
    
    private func stripANSI(_ text: String) -> String {
        let pattern = "\u{1B}\\[[0-9;]*[a-zA-Z]"
        guard let regex = try? NSRegularExpression(pattern: pattern) else { return text }
        let range = NSRange(text.startIndex..., in: text)
        return regex.stringByReplacingMatches(in: text, range: range, withTemplate: "")
    }
}

// MARK: - SSH Client (Stub implementation for demo)
protocol SSHClientDelegate: AnyObject {
    func sshClientDidConnect(_ client: SSHClient)
    func sshClientDidDisconnect(_ client: SSHClient, error: Error?)
    func sshClient(_ client: SSHClient, didReceiveOutput text: String)
    func sshClient(_ client: SSHClient, didReceiveError text: String)
}

class SSHClient {
    weak var delegate: SSHClientDelegate?
    private let connection: SSHConnection
    private var nwConnection: NWConnection?
    
    init(connection: SSHConnection) {
        self.connection = connection
    }
    
    func connect() {
        let host = NWEndpoint.Host(connection.host)
        let port = NWEndpoint.Port(integerLiteral: UInt16(connection.port))
        nwConnection = NWConnection(host: host, port: port, using: .tcp)
        
        nwConnection?.stateUpdateHandler = { [weak self] state in
            guard let self = self else { return }
            if case .ready = state {
                self.delegate?.sshClientDidConnect(self)
            }
        }
        nwConnection?.start(queue: .global())
    }
    
    func disconnect() {
        nwConnection?.cancel()
        nwConnection = nil
    }
    
    func send(command: String) {
         let data = (command + "\n").data(using: .utf8)!
         nwConnection?.send(content: data, completion: .contentProcessed { error in
             if let error = error { print(error) }
         })
    }
    
    func sendInterrupt() {}
    func sendTab() {}
}
