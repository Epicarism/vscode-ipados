import Foundation
import Combine

/// Manages inline code suggestions with debouncing, throttling, and cancellation support.
/// Tracks text changes and cursor position to provide context-aware completions.
@MainActor
class InlineSuggestionManager: ObservableObject {
    
    // MARK: - Published Properties
    
    /// The current inline suggestion text to display, if any.
    @Published var currentSuggestion: String?
    
    /// The current cursor position in the document.
    @Published var cursorPosition: CursorPosition = CursorPosition(line: 0, column: 0)
    
    // MARK: - Private Properties
    
    /// Debounce timer for text change detection.
    private var debounceTimer: Timer?
    
    /// Throttle timestamp for rate limiting requests.
    private var lastRequestTime: Date?
    
    /// Minimum interval between requests (throttling).
    private let throttleInterval: TimeInterval = 0.5
    
    /// Debounce delay before triggering suggestion request.
    private let debounceDelay: TimeInterval = 0.3
    
    /// Task handle for the current pending suggestion request.
    private var pendingRequestTask: Task<Void, Never>?
    
    // MARK: - Partial Accept State
    
    /// Tracks the current position within a partially accepted suggestion.
    /// This is the offset into `currentSuggestion` that has already been accepted.
    @Published var partialAcceptPosition: Int = 0
    
    /// The text that has been partially accepted so far.
    var acceptedText: String {
        guard let suggestion = currentSuggestion,
              partialAcceptPosition > 0,
              partialAcceptPosition <= suggestion.count else {
            return ""
        }
        let endIndex = suggestion.index(suggestion.startIndex, offsetBy: partialAcceptPosition)
        return String(suggestion[..<endIndex])
    }
    
    /// The remaining unaccepted portion of the suggestion.
    var remainingSuggestionText: String {
        guard let suggestion = currentSuggestion,
              partialAcceptPosition < suggestion.count else {
            return ""
        }
        let startIndex = suggestion.index(suggestion.startIndex, offsetBy: partialAcceptPosition)
        return String(suggestion[startIndex...])
    }
    
    /// Set to store Combine cancellables.
    private var cancellables = Set<AnyCancellable>()
    
    /// Subject for text change events.
    private let textChangeSubject = PassthroughSubject<TextChangeEvent, Never>()
    
    // MARK: - Types
    
    /// Represents a cursor position in the editor.
    struct CursorPosition: Equatable {
        let line: Int
        let column: Int
        
        var isValid: Bool {
            return line >= 0 && column >= 0
        }
    }
    
    /// Represents a text change event.
    struct TextChangeEvent {
        let content: String
        let position: CursorPosition
        let timestamp: Date
    }
    
    /// Extracted context for suggestion requests.
    struct SuggestionContext {
        let currentLine: String
        let precedingCode: String
        let cursorPosition: CursorPosition
        let language: String?
    }
    
    // MARK: - Initialization
    
    init() {
        setupDebouncePipeline()
    }
    
    deinit {
        debounceTimer?.invalidate()
        pendingRequestTask?.cancel()
    }
    
    // MARK: - Public Methods
    
    /// Requests a suggestion for the given content at the current cursor position.
    /// This method applies debouncing and throttling automatically.
    /// - Parameters:
    ///   - content: The full text content of the document.
    ///   - position: The current cursor position.
    func requestSuggestion(for content: String, at position: CursorPosition) {
        // Update cursor position
        self.cursorPosition = position
        
        // Create text change event
        let event = TextChangeEvent(
            content: content,
            position: position,
            timestamp: Date()
        )
        
        // Send to debounce pipeline
        textChangeSubject.send(event)
    }
    
    /// Cancels any pending suggestion request.
    func cancelPendingRequest() {
        pendingRequestTask?.cancel()
        pendingRequestTask = nil
        debounceTimer?.invalidate()
        debounceTimer = nil
    }
    
    /// Clears the current suggestion.
    func clearSuggestion() {
        currentSuggestion = nil
        partialAcceptPosition = 0
    }
    
    /// Accepts the next word of the current inline suggestion.
    /// This allows word-by-word acceptance of suggestions, bound to Ctrl+Right Arrow or Option+Right Arrow.
    /// Subsequent calls continue from the last accepted position until the full suggestion is accepted.
    /// - Returns: The text that was accepted in this call, or nil if no suggestion is active
    @discardableResult
    func partialAccept() -> String? {
        guard let suggestion = currentSuggestion else {
            return nil
        }
        
        // Check if we've already fully accepted the suggestion
        guard partialAcceptPosition < suggestion.count else {
            clearSuggestion()
            return nil
        }
        
        // Find the next word boundary from current position
        let remainingText = remainingSuggestionText
        let charsToAccept = findNextWordEnd(in: remainingText)
        
        // Get the text to accept
        let startIndex = suggestion.index(suggestion.startIndex, offsetBy: partialAcceptPosition)
        let endIndex = suggestion.index(startIndex, offsetBy: charsToAccept)
        let textToAccept = String(suggestion[startIndex..<endIndex])
        
        // Update the partial accept position
        partialAcceptPosition += charsToAccept
        
        // If we've accepted the entire suggestion, clear it
        if partialAcceptPosition >= suggestion.count {
            // Keep the suggestion visible but mark as fully accepted
            // The caller should handle inserting the accepted text
        }
        
        return textToAccept
    }
    
    /// Resets the partial accept state to start from the beginning.
    /// Call this when showing a new suggestion or when user dismisses and re-triggers.
    func resetPartialAcceptState() {
        partialAcceptPosition = 0
    }
    
    /// Checks if the suggestion has been fully accepted.
    var isSuggestionFullyAccepted: Bool {
        guard let suggestion = currentSuggestion else { return false }
        return partialAcceptPosition >= suggestion.count
    }
    
    /// Returns the ghost text to display (remaining unaccepted portion).
    /// This updates as the user partially accepts words.
    var ghostText: String {
        return remainingSuggestionText
    }
    
    /// Updates the cursor position without triggering a suggestion request.
    /// - Parameter position: The new cursor position.
    func updateCursorPosition(_ position: CursorPosition) {
        self.cursorPosition = position
    }
    
    // MARK: - Private Methods
    
    /// Sets up the Combine pipeline for debounced text change processing.
    private func setupDebouncePipeline() {
        textChangeSubject
            .debounce(for: .seconds(debounceDelay), scheduler: DispatchQueue.main)
            .sink { [weak self] event in
                self?.processDebouncedTextChange(event)
            }
            .store(in: &cancellables)
    }
    
    /// Processes a debounced text change event.
    private func processDebouncedTextChange(_ event: TextChangeEvent) {
        // Check throttling
        if let lastTime = lastRequestTime,
           Date().timeIntervalSince(lastTime) < throttleInterval {
            // Too soon, skip this request
            return
        }
        
        // Extract context
        let context = extractContext(from: event.content, at: event.position)
        
        // Perform the suggestion request
        performSuggestionRequest(context: context)
    }
    
    /// Performs the actual suggestion request with cancellation support.
    private func performSuggestionRequest(context: SuggestionContext) {
        // Cancel any existing request
        pendingRequestTask?.cancel()
        
        // Reset partial accept state for new suggestion
        resetPartialAcceptState()
        
        // Update throttle timestamp
        lastRequestTime = Date()
        
        // Create new request task
        pendingRequestTask = Task { [weak self] in
            guard let self = self else { return }
            
            do {
                let suggestion = try await fetchSuggestion(for: context)
                
                // Check if task was cancelled
                guard !Task.isCancelled else { return }
                
                // Update suggestion on main actor
                await MainActor.run {
                    self.currentSuggestion = suggestion
                    // Reset partial accept position when showing new suggestion
                    self.partialAcceptPosition = 0
                }
            } catch {
                // Handle errors - clear suggestion on failure
                if !Task.isCancelled {
                    await MainActor.run {
                        self.currentSuggestion = nil
                        self.partialAcceptPosition = 0
                    }
                }
            }
        }
    }
    
    /// Fetches a suggestion from the completion service.
    /// This is a placeholder that should be replaced with actual implementation.
    private func fetchSuggestion(for context: SuggestionContext) async throws -> String? {
        // Simulate network delay - replace with actual API call
        try await Task.sleep(nanoseconds: 100_000_000) // 0.1 seconds
        
        // Check for cancellation
        try Task.checkCancellation()
        
        // Placeholder: Return nil or mock suggestion based on context
        // This should be replaced with actual LLM or completion service integration
        return nil
    }
    
    /// Extracts context information from the content at the given position.
    private func extractContext(from content: String, at position: CursorPosition) -> SuggestionContext {
        let lines = content.components(separatedBy: .newlines)
        
        // Get current line
        let currentLineIndex = min(position.line, max(0, lines.count - 1))
        let currentLine = lines.indices.contains(currentLineIndex) ? lines[currentLineIndex] : ""
        
        // Get preceding code (all lines before current)
        let precedingLines = lines.prefix(currentLineIndex)
        let precedingCode = precedingLines.joined(separator: "\n")
        
        // Detect language from file extension or content (placeholder)
        let language = detectLanguage(from: content)
        
        return SuggestionContext(
            currentLine: currentLine,
            precedingCode: precedingCode,
            cursorPosition: position,
            language: language
        )
    }
    
    /// Detects the programming language from content.
    /// This is a simple placeholder implementation.
    private func detectLanguage(from content: String) -> String? {
        // Basic heuristics for language detection
        // In a real implementation, this would use file extension or more sophisticated detection
        
        if content.contains("import Swift") || content.contains("func ") && content.contains("->") {
            return "swift"
        } else if content.contains("function") || content.contains("const ") || content.contains("let ") {
            return "javascript"
        } else if content.contains("def ") || content.contains("import ") && content.contains("print(") {
            return "python"
        }
        
        return nil
    }
    
    /// Determines if a suggestion should be requested based on context.
    /// This can be used to avoid requesting suggestions in inappropriate contexts.
    private func shouldRequestSuggestion(context: SuggestionContext) -> Bool {
        // Don't suggest on empty lines unless there's preceding context
        if context.currentLine.trimmingCharacters(in: .whitespaces).isEmpty {
            return !context.precedingCode.isEmpty
        }
        
        // Minimum content length to trigger suggestions
        let minContextLength = 10
        let totalContextLength = context.precedingCode.count + context.currentLine.count
        
        return totalContextLength >= minContextLength
    }
    
    // MARK: - Word Boundary Helpers for Partial Accept
    
    /// Finds the end position of the next word in the given text.
    /// A word is defined as a sequence of characters up to and including:
    /// - The next whitespace character (space, tab, newline)
    /// - The end of the punctuation after a word
    /// - The next punctuation boundary
    private func findNextWordEnd(in text: String) -> Int {
        guard !text.isEmpty else { return 0 }
        
        let characters = Array(text)
        var position = 0
        
        // Skip leading whitespace (accept it as part of the word if present)
        var leadingWhitespaceCount = 0
        while position < characters.count && characters[position].isWhitespace {
            position += 1
            leadingWhitespaceCount += 1
        }
        
        // If we only had whitespace, return that
        if position >= characters.count {
            return position
        }
        
        // Get the current character type
        let firstChar = characters[position]
        
        if firstChar.isLetter || firstChar.isNumber {
            // Word character: consume all word characters
            while position < characters.count && (characters[position].isLetter || characters[position].isNumber) {
                position += 1
            }
            
            // Also consume any trailing punctuation attached to the word (like "word.")
            while position < characters.count && isWordPunctuation(characters[position]) {
                position += 1
            }
            
            // Include trailing whitespace after the word (just one space)
            if position < characters.count && characters[position].isWhitespace {
                position += 1
            }
        } else if isPunctuation(firstChar) {
            // Punctuation: consume all consecutive punctuation
            while position < characters.count && isPunctuation(characters[position]) {
                position += 1
            }
            
            // Include trailing whitespace (just one space)
            if position < characters.count && characters[position].isWhitespace {
                position += 1
            }
        } else if firstChar.isWhitespace {
            // Multiple whitespace: accept all consecutive whitespace
            while position < characters.count && characters[position].isWhitespace {
                position += 1
            }
        } else {
            // Other characters: just consume one character
            position += 1
        }
        
        // Ensure we always accept at least one non-whitespace character
        // or all leading whitespace if that's all there is
        return max(position, leadingWhitespaceCount > 0 ? leadingWhitespaceCount : 1)
    }
    
    /// Checks if a character is punctuation that can be part of a word (like period, comma, etc.)
    private func isWordPunctuation(_ char: Character) -> Bool {
        let wordPunctuation = CharacterSet(charactersIn: ".,;:!?-_'")
        guard let scalar = char.unicodeScalars.first else { return false }
        return wordPunctuation.contains(scalar)
    }
    
    /// Checks if a character is general punctuation or symbol
    private func isPunctuation(_ char: Character) -> Bool {
        return char.isPunctuation || char.isSymbol
    }
}

// MARK: - Error Types

enum InlineSuggestionError: Error {
    case requestThrottled
    case noContextAvailable
    case serviceUnavailable
    case cancelled
}

// MARK: - UIKeyCommand Extensions for Partial Accept

/// Extension to provide keyboard shortcut bindings for partial accept functionality.
/// Bind to Ctrl+Right Arrow or Option+Right Arrow.
extension UIResponder {
    
    /// Registers keyboard commands for inline suggestions partial accept.
    /// Call this from your editor view controller to enable Ctrl+Right and Option+Right shortcuts.
    static func registerInlineSuggestionKeyCommands() -> [UIKeyCommand] {
        // Ctrl+Right Arrow for partial accept
        let ctrlRightCommand = UIKeyCommand(
            input: UIKeyCommand.inputRightArrow,
            modifierFlags: .control,
            action: #selector(performPartialAccept(_:))
        )
        ctrlRightCommand.wantsPriorityOverSystemBehavior = true
        
        // Option+Right Arrow for partial accept (alternative binding)
        let optRightCommand = UIKeyCommand(
            input: UIKeyCommand.inputRightArrow,
            modifierFlags: .alternate,
            action: #selector(performPartialAccept(_:))
        )
        optRightCommand.wantsPriorityOverSystemBehavior = true
        
        return [ctrlRightCommand, optRightCommand]
    }
    
    @objc private func performPartialAccept(_ sender: UIKeyCommand) {
        // Access the shared manager and perform partial accept
        // This requires the editor to insert the accepted text at cursor position
        NotificationCenter.default.post(
            name: .inlineSuggestionPartialAccept,
            object: nil
        )
    }
}

// MARK: - Notification Names

extension Notification.Name {
    /// Posted when partial accept should be performed.
    /// Bind your editor's insert method to this notification.
    static let inlineSuggestionPartialAccept = Notification.Name("inlineSuggestionPartialAccept")
}
