import XCTest

final class CommandSearchUITests: XCTestCase {

    override func setUp() {
        super.setUp()
        continueAfterFailure = false
    }

    // Keep this list aligned with the appâ€™s accessibility identifiers.
    private let preferredIdentifiers = [
        "commandSearchInput",
        "command-search-input",
        "CommandSearchInput",
        "commandPaletteSearchField",
        "command-palette-search",
        "Command Palette",
        "Command Search"
    ]

    private func findCommandSearchElement(in app: XCUIApplication) -> XCUIElement {
        for id in preferredIdentifiers {
            let tf = app.textFields[id]
            if tf.exists { return tf }
            let sf = app.searchFields[id]
            if sf.exists { return sf }
        }

        // Fallback: first visible searchField/textField.
        if app.searchFields.count > 0 {
            return app.searchFields.element(boundBy: 0)
        }
        return app.textFields.element(boundBy: 0)
    }

    private func openGlobalSearch(in app: XCUIApplication, timeout: TimeInterval = 10) {
        // Primary: keyboard shortcut (common in VS Code): Cmd+Shift+F.
        app.typeKey("f", modifierFlags: [.command, .shift])

        let searchField = findGlobalSearchField(in: app)
        if searchField.waitForExistence(timeout: timeout) {
            return
        }

        // Fallback: try a visible Search/Find button.
        let likelyButtons = [
            "Search",
            "Find",
            "Find in Files",
            "Search in Files"
        ]

        for label in likelyButtons {
            let b = app.buttons[label]
            if b.waitForExistence(timeout: 2) {
                b.tap()
                if findGlobalSearchField(in: app).waitForExistence(timeout: timeout) {
                    return
                }
            }
        }

        XCTFail("Unable to open global search UI")
    }

    private func findGlobalSearchField(in app: XCUIApplication) -> XCUIElement {
        let likelyLabels = [
            "Search",
            "Find",
            "Find in Files",
            "Search in Files",
            "Search Files",
            "Search query",
            "SearchQuery",
            "searchQuery",
            "globalSearchInput"
        ]

        for label in likelyLabels {
            let sf = app.searchFields[label]
            if sf.exists { return sf }
            let tf = app.textFields[label]
            if tf.exists { return tf }
        }

        if app.searchFields.count > 0 { return app.searchFields.element(boundBy: 0) }
        return app.textFields.element(boundBy: 0)
    }

    private func waitForAnyElementToExist(_ elements: [XCUIElement], timeout: TimeInterval) -> Bool {
        let deadline = Date().addingTimeInterval(timeout)
        while Date() < deadline {
            if elements.contains(where: { $0.exists }) { return true }
            RunLoop.current.run(until: Date().addingTimeInterval(0.1))
        }
        return false
    }

    private func findSearchResultElement(in app: XCUIApplication, fileName: String) -> XCUIElement {
        // Prefer tapping a cell (common for result lists).
        let cell = app.cells.containing(NSPredicate(format: "label CONTAINS[c] %@", fileName)).firstMatch
        if cell.exists { return cell }

        // Fallbacks.
        let button = app.buttons.containing(NSPredicate(format: "label CONTAINS[c] %@", fileName)).firstMatch
        if button.exists { return button }

        let staticText = app.staticTexts.containing(NSPredicate(format: "label CONTAINS[c] %@", fileName)).firstMatch
        if staticText.exists { return staticText }

        return app.cells.firstMatch
    }

    func testCmdShiftPOpensCommandPalette() {
        let app = XCUIApplication()
        app.launch()

        XCTAssertTrue(app.wait(for: .runningForeground, timeout: 10))

        // Cmd+Shift+P should open the command palette.
        app.typeKey("p", modifierFlags: [.command, .shift])

        let commandSearchElement = findCommandSearchElement(in: app)
        XCTAssertTrue(
            commandSearchElement.waitForExistence(timeout: 10),
            "Expected command palette search input to appear after Cmd+Shift+P"
        )
    }

    func testEnteringTextIntoSearchInputWorks() {
        let app = XCUIApplication()
        app.launch()

        let searchElement = findCommandSearchElement(in: app)
        XCTAssertTrue(searchElement.waitForExistence(timeout: 10), "Expected a command search input to exist")

        searchElement.tap()

        let textToEnter = "format"
        searchElement.typeText(textToEnter)

        // Validate the entered text is reflected in the field.
        // Some UIKit controls expose their content via `value`.
        let valueString = (searchElement.value as? String) ?? ""
        XCTAssertTrue(valueString.contains(textToEnter), "Expected search input value to contain '\(textToEnter)'. Actual value: '\(valueString)'.")
    }

    func testRecentCommandsAppearFirstInCommandPalette() {
        let app = XCUIApplication()
        app.launch()

        // Wait for app to be running
        XCTAssertTrue(app.wait(for: .runningForeground, timeout: 10))

        // Open command palette with Cmd+Shift+P
        app.typeKey("p", modifierFlags: [.command, .shift])

        let searchElement = findCommandSearchElement(in: app)
        XCTAssertTrue(searchElement.waitForExistence(timeout: 10), "Expected command palette search input to appear")

        // Search for and select a specific command (e.g., "Format Document")
        let commandToRun = "Format Document"
        searchElement.tap()
        searchElement.typeText(commandToRun)

        // Wait for command results to appear and select the first matching command
        let firstCommand = app.cells.containing(NSPredicate(format: "label CONTAINS[c] %@", commandToRun)).element(boundBy: 0)
        XCTAssertTrue(firstCommand.waitForExistence(timeout: 5), "Expected to find '\(commandToRun)' command")

        // Store the full label of the command we're about to run
        let commandLabel = firstCommand.label

        // Execute the command by tapping it
        firstCommand.tap()

        // Wait a moment for command to execute and command palette to close
        sleep(1)

        // Reopen command palette - recent commands should appear at the top when reopened with empty search
        app.typeKey("p", modifierFlags: [.command, .shift])

        let secondSearchElement = findCommandSearchElement(in: app)
        XCTAssertTrue(secondSearchElement.waitForExistence(timeout: 10), "Expected command palette to reopen")

        // Wait a moment for the command list to populate with recent commands
        sleep(1)

        // Get all command cells - recent commands should appear first in the list
        let allCells = app.cells.allElementsBoundByIndex
        XCTAssertGreaterThan(allCells.count, 0, "Expected at least one command in palette")

        // When command palette is reopened, recent commands should appear at the top
        // The most recently executed command should be first (or very prominent) in the list
        let firstCell = allCells[0]
        let firstCellLabel = firstCell.label

        // Verify that the recently run command appears at the very top of the list
        // This validates the "recent commands appear first" requirement
        XCTAssertTrue(
            firstCellLabel.contains(commandLabel) || firstCellLabel.contains(commandToRun),
            "Expected recent command '\(commandLabel)' to appear first in command palette, but first item was '\(firstCellLabel)'"
        )

        // Additional verification: search for the command again and verify it still appears
        // This ensures the command is still available and the palette is functioning correctly
        secondSearchElement.tap()
        secondSearchElement.typeText(commandToRun)

        let recentCommandInSearch = app.cells.containing(NSPredicate(format: "label CONTAINS[c] %@", commandToRun)).element(boundBy: 0)
        XCTAssertTrue(recentCommandInSearch.waitForExistence(timeout: 5), "Expected '\(commandToRun)' to still be searchable after running it")
    }

    func testTappingSearchResultNavigatesToFileInEditor() {
        let app = XCUIApplication()
        app.launch()

        XCTAssertTrue(app.wait(for: .runningForeground, timeout: 10))

        openGlobalSearch(in: app)

        let searchField = findGlobalSearchField(in: app)
        XCTAssertTrue(searchField.waitForExistence(timeout: 10), "Expected global search field to exist")

        searchField.tap()
        let query = "hello"
        searchField.typeText(query)

        // Wait for results and tap one.
        let fileName = "ContentView.swift"
        let result = findSearchResultElement(in: app, fileName: fileName)
        XCTAssertTrue(result.waitForExistence(timeout: 10), "Expected a search result for '\(fileName)' to appear")
        result.tap()

        // Verify navigation occurred by checking for an editor and/or visible file title.
        let editor = app.textViews["Editor"]
        let fileTitleStaticText = app.staticTexts.matching(NSPredicate(format: "label CONTAINS[c] %@", fileName)).firstMatch
        let fileTitleButton = app.buttons.matching(NSPredicate(format: "label CONTAINS[c] %@", fileName)).firstMatch
        let fileTitleNavBar = app.navigationBars.matching(NSPredicate(format: "identifier CONTAINS[c] %@ OR label CONTAINS[c] %@", fileName, fileName)).firstMatch

        XCTAssertTrue(
            waitForAnyElementToExist([editor, fileTitleStaticText, fileTitleButton, fileTitleNavBar], timeout: 10),
            "Expected tapping a search result to navigate to an editor location for '\(fileName)'"
        )

        // If the editor exposes text, ensure the query appears somewhere (best-effort assertion).
        if editor.exists {
            let editorValue = (editor.value as? String) ?? ""
            XCTAssertTrue(
                editorValue.isEmpty || editorValue.localizedCaseInsensitiveContains(query),
                "Expected editor text to contain query '\(query)' (if exposed). Actual value: '\(editorValue)'"
            )
        }
    }
}
