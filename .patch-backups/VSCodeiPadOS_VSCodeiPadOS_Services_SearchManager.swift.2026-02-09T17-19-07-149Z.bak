import Foundation
import Combine

// SearchManager
// Implements find-in-files style searching with options (case sensitivity, whole word, regex),
// include/exclude glob patterns, query history, and replace-in-files.
//
// NOTE: This file is intentionally self-contained so it can integrate with varying app models.

public final class SearchManager: ObservableObject {

    // MARK: - Types

    public struct SearchOptions: Codable, Hashable, Sendable {
        public var isCaseSensitive: Bool
        public var isWholeWord: Bool
        public var isRegex: Bool

        public init(isCaseSensitive: Bool = false,
                    isWholeWord: Bool = false,
                    isRegex: Bool = false) {
            self.isCaseSensitive = isCaseSensitive
            self.isWholeWord = isWholeWord
            self.isRegex = isRegex
        }
    }

    public struct SearchQuery: Codable, Hashable, Sendable {
        public var text: String
        public var options: SearchOptions
        /// Include file globs (e.g. ["**/*.swift", "**/*.md"]) - empty means include all.
        public var includeGlobs: [String]
        /// Exclude file globs (e.g. ["**/.git/**", "**/DerivedData/**"]).
        public var excludeGlobs: [String]

        public init(text: String,
                    options: SearchOptions = .init(),
                    includeGlobs: [String] = [],
                    excludeGlobs: [String] = []) {
            self.text = text
            self.options = options
            self.includeGlobs = includeGlobs
            self.excludeGlobs = excludeGlobs
        }
    }

    public struct MatchLocation: Codable, Hashable, Sendable {
        public var line: Int
        public var column: Int
        public var length: Int

        public init(line: Int, column: Int, length: Int) {
            self.line = line
            self.column = column
            self.length = length
        }
    }

    public struct FileMatch: Codable, Hashable, Sendable, Identifiable {
        public var id: String { filePath }
        public var filePath: String
        public var matches: [Match]

        public init(filePath: String, matches: [Match]) {
            self.filePath = filePath
            self.matches = matches
        }

        public struct Match: Codable, Hashable, Sendable, Identifiable {
            public var id: String { "\(location.line):\(location.column):\(location.length):\(preview)" }
            public var location: MatchLocation
            public var preview: String

            public init(location: MatchLocation, preview: String) {
                self.location = location
                self.preview = preview
            }
        }
    }

    public struct ReplaceResult: Codable, Hashable, Sendable {
        public var filesTouched: Int
        public var replacements: Int
        public var fileResults: [PerFile]

        public init(filesTouched: Int, replacements: Int, fileResults: [PerFile]) {
            self.filesTouched = filesTouched
            self.replacements = replacements
            self.fileResults = fileResults
        }

        public struct PerFile: Codable, Hashable, Sendable {
            public var filePath: String
            public var replacements: Int
            public init(filePath: String, replacements: Int) {
                self.filePath = filePath
                self.replacements = replacements
            }
        }
    }

    public enum SearchError: Error, LocalizedError {
        case emptyQuery
        case invalidRegex(String)
        case ioError(String)

        public var errorDescription: String? {
            switch self {
            case .emptyQuery:
                return "Search query is empty."
            case .invalidRegex(let pattern):
                return "Invalid regular expression: \(pattern)"
            case .ioError(let msg):
                return msg
            }
        }
    }

    // MARK: - Published State (UI integration)

    @Published public private(set) var isSearching: Bool = false
    @Published public private(set) var progress: Double = 0
    @Published public private(set) var results: [FileMatch] = []
    @Published public private(set) var lastError: String? = nil

    /// Most-recent-first history.
    @Published public private(set) var history: [SearchQuery] = []

    // MARK: - Config

    public var maxHistoryCount: Int = 30

    // MARK: - Private

    private var searchTask: Task<Void, Never>? = nil
    private let historyKey = "SearchManager.history.v1"

    // MARK: - Init

    public init() {
        loadHistory()
    }

    deinit {
        searchTask?.cancel()
    }

    // MARK: - History

    public func addToHistory(_ query: SearchQuery) {
        let trimmed = query.text.trimmingCharacters(in: .whitespacesAndNewlines)
        guard !trimmed.isEmpty else { return }

        var q = query
        q.text = trimmed

        history.removeAll(where: { $0 == q })
        history.insert(q, at: 0)
        if history.count > maxHistoryCount {
            history.removeLast(history.count - maxHistoryCount)
        }
        persistHistory()
    }

    public func clearHistory() {
        history = []
        persistHistory()
    }

    private func loadHistory() {
        guard let data = UserDefaults.standard.data(forKey: historyKey) else { return }
        if let decoded = try? JSONDecoder().decode([SearchQuery].self, from: data) {
            history = decoded
        }
    }

    private func persistHistory() {
        guard let data = try? JSONEncoder().encode(history) else { return }
        UserDefaults.standard.set(data, forKey: historyKey)
    }

    // MARK: - Search API

    /// Cancels any in-flight search.
    public func cancelSearch() {
        searchTask?.cancel()
        searchTask = nil
        isSearching = false
    }

    /// Search files under `rootURL`.
    /// - Parameters:
    ///   - rootURL: Directory to search.
    ///   - query: Query and options.
    ///   - fileURLs: Optional pre-resolved file list. If provided, include/exclude filtering is still applied.
    @MainActor
    public func search(in rootURL: URL,
                       query: SearchQuery,
                       fileURLs: [URL]? = nil) {
        lastError = nil
        results = []
        progress = 0

        let trimmed = query.text.trimmingCharacters(in: .whitespacesAndNewlines)
        guard !trimmed.isEmpty else {
            lastError = SearchError.emptyQuery.localizedDescription
            return
        }

        // update history immediately
        addToHistory(query)

        cancelSearch()
        isSearching = true

        let q = SearchQuery(text: trimmed,
                            options: query.options,
                            includeGlobs: query.includeGlobs,
                            excludeGlobs: query.excludeGlobs)

        searchTask = Task.detached(priority: .userInitiated) { [weak self] in
            guard let self else { return }
            do {
                let resolvedFiles = try self.resolveFiles(rootURL: rootURL, provided: fileURLs, query: q)
                let total = max(resolvedFiles.count, 1)

                var aggregated: [FileMatch] = []
                for (idx, url) in resolvedFiles.enumerated() {
                    try Task.checkCancellation()
                    if let match = try self.searchFile(url: url, rootURL: rootURL, query: q), !match.matches.isEmpty {
                        aggregated.append(match)
                    }
                    let p = Double(idx + 1) / Double(total)
                    await MainActor.run {
                        self.progress = p
                    }
                }

                await MainActor.run {
                    self.results = aggregated
                    self.isSearching = false
                    self.progress = 1
                }
            } catch is CancellationError {
                await MainActor.run {
                    self.isSearching = false
                }
            } catch {
                await MainActor.run {
                    self.lastError = error.localizedDescription
                    self.isSearching = false
                }
            }
        }
    }

    // MARK: - Replace in files

    /// Replace occurrences for `query` with `replacement` under `rootURL`.
    /// Returns counts per file.
    public func replace(in rootURL: URL,
                        query: SearchQuery,
                        replacement: String,
                        fileURLs: [URL]? = nil) async throws -> ReplaceResult {
        let trimmed = query.text.trimmingCharacters(in: .whitespacesAndNewlines)
        guard !trimmed.isEmpty else { throw SearchError.emptyQuery }

        let q = SearchQuery(text: trimmed,
                            options: query.options,
                            includeGlobs: query.includeGlobs,
                            excludeGlobs: query.excludeGlobs)

        // Pre-compile pattern.
        let compiled = try compilePattern(for: q)

        let resolvedFiles = try resolveFiles(rootURL: rootURL, provided: fileURLs, query: q)
        var perFile: [ReplaceResult.PerFile] = []
        perFile.reserveCapacity(resolvedFiles.count)

        var totalReplacements = 0
        var filesTouched = 0

        for url in resolvedFiles {
            try Task.checkCancellation()
            let (changed, reps) = try replaceInFile(url: url, compiled: compiled, replacement: replacement)
            if changed {
                filesTouched += 1
                totalReplacements += reps
                perFile.append(.init(filePath: url.path, replacements: reps))
            }
        }

        return ReplaceResult(filesTouched: filesTouched,
                             replacements: totalReplacements,
                             fileResults: perFile)
    }

    // MARK: - File enumeration + filtering

    private func resolveFiles(rootURL: URL, provided: [URL]?, query: SearchQuery) throws -> [URL] {
        let all: [URL]
        if let provided {
            all = provided
        } else {
            all = try enumerateFiles(rootURL: rootURL)
        }
        return all.filter { url in
            guard url.isFileURL else { return false }
            let path = url.path
            if matchesAnyGlob(path: path, globs: query.excludeGlobs) { return false }
            if query.includeGlobs.isEmpty { return true }
            return matchesAnyGlob(path: path, globs: query.includeGlobs)
        }
    }

    private func enumerateFiles(rootURL: URL) throws -> [URL] {
        let fm = FileManager.default
        guard let enumerator = fm.enumerator(at: rootURL,
                                            includingPropertiesForKeys: [.isRegularFileKey, .isDirectoryKey],
                                            options: [.skipsHiddenFiles],
                                            errorHandler: { _, _ in true }) else {
            return []
        }

        var urls: [URL] = []
        for case let url as URL in enumerator {
            let values = try? url.resourceValues(forKeys: [.isRegularFileKey, .isDirectoryKey])
            if values?.isDirectory == true { continue }
            if values?.isRegularFile == true {
                urls.append(url)
            }
        }
        return urls
    }

    // MARK: - Actual searching

    private struct CompiledPattern {
        enum Kind {
            case regex(NSRegularExpression)
            case literal(needle: String, compareLowercased: Bool, wholeWord: Bool)
        }
        let kind: Kind
    }

    private func compilePattern(for query: SearchQuery) throws -> CompiledPattern {
        if query.options.isRegex {
            let opts: NSRegularExpression.Options = query.options.isCaseSensitive ? [] : [.caseInsensitive]
            do {
                let re = try NSRegularExpression(pattern: query.text, options: opts)
                return CompiledPattern(kind: .regex(re))
            } catch {
                throw SearchError.invalidRegex(query.text)
            }
        } else {
            // Literal search.
            let compareLowercased = !query.options.isCaseSensitive
            return CompiledPattern(kind: .literal(needle: query.text,
                                                 compareLowercased: compareLowercased,
                                                 wholeWord: query.options.isWholeWord))
        }
    }

    private func searchFile(url: URL, rootURL: URL, query: SearchQuery) throws -> FileMatch? {
        let compiled = try compilePattern(for: query)
        let data: Data
        do {
            data = try Data(contentsOf: url)
        } catch {
            // ignore unreadable files
            return nil
        }
        // Try UTF-8 first. If it fails, ignore file (keeps implementation safe).
        guard let text = String(data: data, encoding: .utf8) else { return nil }

        let relPath: String
        if url.path.hasPrefix(rootURL.path) {
            relPath = String(url.path.dropFirst(rootURL.path.count)).trimmingCharacters(in: CharacterSet(charactersIn: "/"))
        } else {
            relPath = url.path
        }

        let matches = findMatches(in: text, compiled: compiled)
        if matches.isEmpty { return nil }

        return FileMatch(filePath: relPath, matches: matches)
    }

    private func findMatches(in text: String, compiled: CompiledPattern) -> [FileMatch.Match] {
        switch compiled.kind {
        case .regex(let re):
            return regexMatches(in: text, re: re)
        case .literal(let needle, let compareLowercased, let wholeWord):
            return literalMatches(in: text, needle: needle, compareLowercased: compareLowercased, wholeWord: wholeWord)
        }
    }

    private func regexMatches(in text: String, re: NSRegularExpression) -> [FileMatch.Match] {
        let ns = text as NSString
        let range = NSRange(location: 0, length: ns.length)
        let matches = re.matches(in: text, options: [], range: range)
        if matches.isEmpty { return [] }

        // Precompute line starts for fast conversion.
        let lineIndex = LineIndex(text)

        return matches.compactMap { m in
            guard m.range.location != NSNotFound, m.range.length > 0 else { return nil }
            let (line, col) = lineIndex.lineAndColumn(utf16Offset: m.range.location)
            let preview = lineIndex.lineText(line: line)
            return .init(location: .init(line: line, column: col, length: m.range.length), preview: preview)
        }
    }

    private func literalMatches(in text: String,
                               needle: String,
                               compareLowercased: Bool,
                               wholeWord: Bool) -> [FileMatch.Match] {
        guard !needle.isEmpty else { return [] }

        let haystack = compareLowercased ? text.lowercased() : text
        let n = compareLowercased ? needle.lowercased() : needle

        // Use NSString for UTF16 indexing.
        let nsHay = haystack as NSString
        let nsOrig = text as NSString

        let lineIndex = LineIndex(text)

        var results: [FileMatch.Match] = []
        var searchRange = NSRange(location: 0, length: nsHay.length)

        while true {
            let found = nsHay.range(of: n, options: [], range: searchRange)
            if found.location == NSNotFound { break }

            if wholeWord {
                if !isWholeWordMatch(in: nsHay, range: found) {
                    let nextLoc = found.location + max(found.length, 1)
                    if nextLoc >= nsHay.length { break }
                    searchRange = NSRange(location: nextLoc, length: nsHay.length - nextLoc)
                    continue
                }
            }

            let (line, col) = lineIndex.lineAndColumn(utf16Offset: found.location)
            let preview = lineIndex.lineText(line: line)

            // Use original needle length in UTF16 for accurate highlighting.
            let origLen = (needle as NSString).length
            results.append(.init(location: .init(line: line, column: col, length: origLen), preview: preview))

            let nextLoc = found.location + max(found.length, 1)
            if nextLoc >= nsHay.length { break }
            searchRange = NSRange(location: nextLoc, length: nsHay.length - nextLoc)
        }

        return results
    }

    private func isWholeWordMatch(in nsText: NSString, range: NSRange) -> Bool {
        // Word boundary definition: letters, numbers, underscore.
        func isWordChar(_ u: unichar) -> Bool {
            if u == 95 { return true } // '_'
            // ASCII letters/digits
            if (u >= 48 && u <= 57) || (u >= 65 && u <= 90) || (u >= 97 && u <= 122) { return true }
            return false
        }

        if range.location > 0 {
            let prev = nsText.character(at: range.location - 1)
            if isWordChar(prev) { return false }
        }
        let end = range.location + range.length
        if end < nsText.length {
            let next = nsText.character(at: end)
            if isWordChar(next) { return false }
        }
        return true
    }

    // MARK: - Replace implementation

    private func replaceInFile(url: URL,
                               compiled: CompiledPattern,
                               replacement: String) throws -> (changed: Bool, replacements: Int) {
        let data: Data
        do {
            data = try Data(contentsOf: url)
        } catch {
            return (false, 0)
        }
        guard let text = String(data: data, encoding: .utf8) else { return (false, 0) }

        let (newText, reps) = replaceAll(in: text, compiled: compiled, replacement: replacement)
        guard reps > 0 else { return (false, 0) }

        do {
            // Atomic write.
            try newText.data(using: .utf8)?.write(to: url, options: [.atomic])
        } catch {
            throw SearchError.ioError("Failed to write file: \(url.path)")
        }
        return (true, reps)
    }

    private func replaceAll(in text: String,
                            compiled: CompiledPattern,
                            replacement: String) -> (String, Int) {
        switch compiled.kind {
        case .regex(let re):
            let ns = text as NSString
            let range = NSRange(location: 0, length: ns.length)
            let matches = re.matches(in: text, options: [], range: range)
            if matches.isEmpty { return (text, 0) }
            let out = re.stringByReplacingMatches(in: text, options: [], range: range, withTemplate: replacement)
            return (out, matches.count)

        case .literal(let needle, let compareLowercased, let wholeWord):
            if needle.isEmpty { return (text, 0) }
            // For literal, we re-scan and build output to support whole-word.
            let haystack = compareLowercased ? text.lowercased() : text
            let n = compareLowercased ? needle.lowercased() : needle

            let nsHay = haystack as NSString
            let nsOrig = text as NSString
            let nsNeedle = n as NSString

            var out = ""
            out.reserveCapacity(text.count)

            var cursor = 0
            var reps = 0

            while cursor < nsHay.length {
                let searchRange = NSRange(location: cursor, length: nsHay.length - cursor)
                let found = nsHay.range(of: n, options: [], range: searchRange)
                if found.location == NSNotFound {
                    out += nsOrig.substring(with: NSRange(location: cursor, length: nsOrig.length - cursor))
                    break
                }

                // append leading segment
                out += nsOrig.substring(with: NSRange(location: cursor, length: found.location - cursor))

                if wholeWord && !isWholeWordMatch(in: nsHay, range: found) {
                    // not a whole-word match; append original matched text and continue
                    out += nsOrig.substring(with: found)
                    cursor = found.location + max(found.length, 1)
                    continue
                }

                out += replacement
                reps += 1

                cursor = found.location + max(nsNeedle.length, 1)
            }

            return (out, reps)
        }
    }

    // MARK: - Glob matching

    /// Very small glob matcher supporting '*', '**', and '?'.
    /// Matching is path-based (uses '/' as separator). Globs are compared against the full path.
    private func matchesAnyGlob(path: String, globs: [String]) -> Bool {
        guard !globs.isEmpty else { return false }
        for g in globs {
            if globMatch(path: path, pattern: g) { return true }
        }
        return false
    }

    private func globMatch(path: String, pattern: String) -> Bool {
        // Convert glob to regex.
        // - '**' => '.*'
        // - '*' => '[^/]*'
        // - '?' => '[^/]'
        var regex = "^"
        var i = pattern.startIndex
        while i < pattern.endIndex {
            let ch = pattern[i]
            if ch == "*" {
                let next = pattern.index(after: i)
                if next < pattern.endIndex && pattern[next] == "*" {
                    regex += ".*"
                    i = pattern.index(after: next)
                } else {
                    regex += "[^/]*"
                    i = next
                }
            } else if ch == "?" {
                regex += "[^/]"
                i = pattern.index(after: i)
            } else {
                // escape regex metacharacters
                if "\\.^$|()[]{}+".contains(ch) {
                    regex += "\\\\\(ch)"
                } else {
                    regex.append(ch)
                }
                i = pattern.index(after: i)
            }
        }
        regex += "$"

        let opts: NSRegularExpression.Options = []
        guard let re = try? NSRegularExpression(pattern: regex, options: opts) else { return false }
        let ns = path as NSString
        let r = NSRange(location: 0, length: ns.length)
        return re.firstMatch(in: path, options: [], range: r) != nil
    }
}

// MARK: - Line indexing helper

private struct LineIndex {
    private let text: String
    private let nsText: NSString
    // line start offsets in UTF16
    private var lineStarts: [Int] = [0]
    private var lines: [String] = []

    init(_ text: String) {
        self.text = text
        self.nsText = text as NSString

        // Build lineStarts and cache line strings.
        // Use NSString lineRange(for:) to be safe with various newline types.
        var idx = 0
        var currentLine = 1
        while idx < nsText.length {
            let r = nsText.lineRange(for: NSRange(location: idx, length: 0))
            let lineStr = nsText.substring(with: r).trimmingCharacters(in: CharacterSet.newlines)
            if lines.count < currentLine { lines.append(lineStr) } else { lines[currentLine - 1] = lineStr }

            idx = NSMaxRange(r)
            if idx < nsText.length {
                lineStarts.append(idx)
                currentLine += 1
            }
        }
        if nsText.length == 0 {
            lines = [""]
            lineStarts = [0]
        } else if lines.isEmpty {
            // single line without newline
            lines = [text]
            lineStarts = [0]
        }
    }

    func lineAndColumn(utf16Offset: Int) -> (line: Int, column: Int) {
        // Binary search lineStarts to find last start <= offset.
        var lo = 0
        var hi = lineStarts.count - 1
        while lo <= hi {
            let mid = (lo + hi) / 2
            let v = lineStarts[mid]
            if v == utf16Offset {
                return (mid + 1, 1)
            } else if v < utf16Offset {
                lo = mid + 1
            } else {
                hi = mid - 1
            }
        }
        let lineIndex = max(hi, 0)
        let lineStart = lineStarts[lineIndex]
        let col = max(utf16Offset - lineStart, 0) + 1
        return (lineIndex + 1, col)
    }

    func lineText(line: Int) -> String {
        let i = max(1, line) - 1
        if i >= 0 && i < lines.count { return lines[i] }
        return ""
    }
}
