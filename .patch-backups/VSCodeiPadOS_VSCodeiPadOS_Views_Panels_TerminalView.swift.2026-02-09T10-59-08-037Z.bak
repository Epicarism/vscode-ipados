import SwiftUI
import SwiftUI
import UIKit
import Network
import Foundation

// MARK: - Terminal View (Main Container)

struct TerminalView: View {
    @StateObject private var workspace = TerminalWorkspace.shared
    @ObservedObject private var themeManager = ThemeManager.shared
    @State private var showConnectionSheet = false

    var body: some View {
        VStack(spacing: 0) {
            // MARK: Top Toolbar
            HStack(spacing: 10) {
                Text("TERMINAL")
                    .font(.caption)
                    .fontWeight(.bold)
                    .foregroundColor(themeManager.currentTheme.tabActiveForeground)
                    .padding(.horizontal, 8)

                Spacer()

                HStack(spacing: 12) {
                    Button(action: { workspace.addTab() }) {
                        Image(systemName: "plus")
                    }
                    .help("New Terminal")

                    Button(action: { workspace.toggleSplitActiveTab() }) {
                        Image(systemName: "square.split.2x1")
                    }
                    .disabled(workspace.tabs.isEmpty)
                    .help("Split Terminal")

                    Button(action: copyActiveTerminalToClipboard) {
                        Image(systemName: "doc.on.doc")
                    }
                    .disabled(workspace.activePane == nil)
                    .help("Copy Terminal Output")

                    Button(action: pasteClipboardToActiveTerminal) {
                        Image(systemName: "doc.on.clipboard")
                    }
                    .disabled(workspace.activePane == nil)
                    .help("Paste")

                    Button(action: { workspace.activePane?.clear() }) {
                        Image(systemName: "trash")
                    }
                    .disabled(workspace.activePane == nil)
                    .help("Clear Terminal")

                    Button(action: { workspace.killActive() }) {
                        Image(systemName: "xmark")
                    }
                    .disabled(workspace.activePane == nil)
                    .help("Kill Terminal")

                    Button(action: { showConnectionSheet = true }) {
                        Image(systemName: "network")
                    }
                    .disabled(workspace.activePane == nil)
                    .help("SSH Connect")
                }
                .font(.caption)
                .foregroundColor(themeManager.currentTheme.editorForeground)
            }
            .padding(8)
            .background(themeManager.currentTheme.editorBackground)
            .overlay(
                Rectangle()
                    .frame(height: 1)
                    .foregroundColor(themeManager.currentTheme.editorForeground.opacity(0.2)),
                alignment: .bottom
            )

            // MARK: Tab Strip
            ScrollView(.horizontal, showsIndicators: false) {
                HStack(spacing: 6) {
                    ForEach(workspace.tabs) { tab in
                        let isActive = workspace.activeTabId == tab.id
                        Button(action: { workspace.activeTabId = tab.id }) {
                            HStack(spacing: 6) {
                                Image(systemName: "terminal")
                                    .font(.caption2)

                                Text(tab.title)
                                    .font(.caption)
                                    .lineLimit(1)
                                    .frame(maxWidth: 200, alignment: .leading)

                                Button(action: { workspace.closeTab(id: tab.id) }) {
                                    Image(systemName: "xmark")
                                        .font(.caption2)
                                }
                                .buttonStyle(.plain)
                            }
                            .padding(.horizontal, 10)
                            .padding(.vertical, 6)
                            .background(
                                RoundedRectangle(cornerRadius: 6)
                                    .fill(isActive ? themeManager.currentTheme.editorForeground.opacity(0.15) : themeManager.currentTheme.editorForeground.opacity(0.08))
                            )
                            .overlay(
                                RoundedRectangle(cornerRadius: 6)
                                    .stroke(isActive ? themeManager.currentTheme.tabActiveForeground.opacity(0.5) : .clear, lineWidth: 1)
                            )
                        }
                        .buttonStyle(.plain)
                    }

                    Button(action: { workspace.addTab() }) {
                        Image(systemName: "plus")
                            .font(.caption)
                            .padding(.horizontal, 10)
                            .padding(.vertical, 6)
                            .background(
                                RoundedRectangle(cornerRadius: 6)
                                    .fill(themeManager.currentTheme.editorForeground.opacity(0.08))
                            )
                    }
                    .buttonStyle(.plain)
                    .help("New Terminal")
                }
                .padding(.horizontal, 8)
                .padding(.vertical, 6)
            }
            .background(themeManager.currentTheme.editorBackground)
            .overlay(
                Rectangle()
                    .frame(height: 1)
                    .foregroundColor(themeManager.currentTheme.editorForeground.opacity(0.12)),
                alignment: .bottom
            )

            // MARK: Terminal Content
            Group {
                if let tab = workspace.activeTab {
                    if tab.panes.count <= 1, let terminal = tab.panes.first {
                        SingleTerminalView(
                            terminal: terminal,
                            isActive: true,
                            onActivate: { workspace.setActivePane(terminal.id, in: tab.id) }
                        )
                    } else {
                        HStack(spacing: 0) {
                            ForEach(tab.panes) { pane in
                                SingleTerminalView(
                                    terminal: pane,
                                    isActive: tab.activePaneId == pane.id,
                                    onActivate: { workspace.setActivePane(pane.id, in: tab.id) }
                                )
                                .frame(maxWidth: .infinity, maxHeight: .infinity)

                                if pane.id != tab.panes.last?.id {
                                    Divider()
                                        .background(themeManager.currentTheme.editorForeground.opacity(0.2))
                                }
                            }
                        }
                    }
                } else {
                    VStack(spacing: 12) {
                        Text("No Open Terminals")
                            .foregroundColor(themeManager.currentTheme.editorForeground.opacity(0.5))
                        Button("Create New Terminal") {
                            workspace.addTab()
                        }
                    }
                    .frame(maxWidth: .infinity, maxHeight: .infinity)
                    .background(themeManager.currentTheme.editorBackground)
                }
            }
        }
        .background(themeManager.currentTheme.editorBackground)
        .sheet(isPresented: $showConnectionSheet) {
            if let active = workspace.activePane {
                SSHConnectionView(terminal: active, isPresented: $showConnectionSheet)
            }
        }
    }

    private func copyActiveTerminalToClipboard() {
        guard let terminal = workspace.activePane else { return }
        let text = terminal.output.map(\.text).joined(separator: "\n")
        UIPasteboard.general.string = text
    }

    private func pasteClipboardToActiveTerminal() {
        guard let terminal = workspace.activePane else { return }
        guard let clip = UIPasteboard.general.string, !clip.isEmpty else { return }
        terminal.draftCommand.append(contentsOf: clip)
    }
}

// MARK: - Single Terminal View

struct SingleTerminalView: View {
    @ObservedObject var terminal: TerminalManager
    var isActive: Bool
    var onActivate: () -> Void

    @ObservedObject private var themeManager = ThemeManager.shared
    @FocusState private var isInputFocused: Bool

    var body: some View {
        VStack(spacing: 0) {
            // Terminal Output
            ScrollViewReader { proxy in
                ScrollView {
                    VStack(alignment: .leading, spacing: 2) {
                        ForEach(terminal.output) { line in
                            TerminalLineView(line: line)
                                .id(line.id)
                        }
                    }
                    .frame(maxWidth: .infinity, alignment: .leading)
                    .padding(8)
                }
                .onChange(of: terminal.output.count) { _ in
                    withAnimation(.easeOut(duration: 0.1)) {
                        proxy.scrollTo(terminal.output.last?.id, anchor: .bottom)
                    }
                }
            }
            .contentShape(Rectangle())
            .contextMenu {
                Button("Copy All") {
                    UIPasteboard.general.string = terminal.output.map(\.text).joined(separator: "\n")
                }
                Button("Clear") {
                    terminal.clear()
                }
            }
            .onTapGesture {
                onActivate()
                isInputFocused = true
            }

            // Input Area
            HStack(spacing: 0) {
                Text(terminal.promptString)
                    .font(.system(.body, design: .monospaced))
                    .foregroundColor(themeManager.currentTheme.type)
                    .padding(.leading, 8)

                TextField("", text: $terminal.draftCommand)
                    .font(.system(.body, design: .monospaced))
                    .foregroundColor(themeManager.currentTheme.editorForeground)
                    .accentColor(themeManager.currentTheme.cursor)
                    .autocapitalization(.none)
                    .disableAutocorrection(true)
                    .focused($isInputFocused)
                    .onSubmit { executeCommand() }
                    .padding(8)
            }
            .background(themeManager.currentTheme.editorBackground)

            // Mobile Helper Bar (optional)
            if isInputFocused {
                HStack(spacing: 12) {
                    Button("Tab") { terminal.sendTab() }
                    Button("Esc") { /* handle esc */ }
                    Button("Ctrl+C") { terminal.sendInterrupt() }
                        .foregroundColor(.red)
                    Spacer()
                    Button("ls") { terminal.draftCommand = "ls -la" }
                    Button("git status") { terminal.draftCommand = "git status" }
                }
                .font(.caption)
                .padding(.horizontal)
                .padding(.vertical, 6)
                .background(themeManager.currentTheme.editorForeground.opacity(0.1))
            }
        }
        .background(themeManager.currentTheme.editorBackground)
        .overlay(
            RoundedRectangle(cornerRadius: 0)
                .stroke(isActive ? themeManager.currentTheme.tabActiveForeground.opacity(0.35) : .clear, lineWidth: 1)
        )
        .onAppear {
            if isActive {
                isInputFocused = true
            }
        }
    }

    private func executeCommand() {
        let command = terminal.draftCommand.trimmingCharacters(in: .whitespacesAndNewlines)
        guard !command.isEmpty else { return }
        terminal.executeCommand(command)
        terminal.draftCommand = ""
    }
}

struct TerminalLineView: View {
    let line: TerminalLine
    @ObservedObject private var themeManager = ThemeManager.shared
    
    var body: some View {
        if line.isANSI {
            ANSIText(line.text)
        } else {
            Text(line.text)
                .font(.system(.body, design: .monospaced))
                .foregroundColor(colorForType(line.type))
                .textSelection(.enabled)
        }
    }
    
    func colorForType(_ type: LineType) -> Color {
        switch type {
        case .command: return themeManager.currentTheme.editorForeground
        case .output: return themeManager.currentTheme.editorForeground.opacity(0.9)
        case .error: return Color.red // Could use theme error color if available
        case .system: return themeManager.currentTheme.comment
        case .prompt: return themeManager.currentTheme.type
        }
    }
}

// MARK: - Terminal Workspace Manager

struct TerminalTab: Identifiable, Equatable {
    let id: UUID
    var panes: [TerminalManager]
    var activePaneId: UUID

    init(panes: [TerminalManager]) {
        self.id = UUID()
        self.panes = panes
        self.activePaneId = panes.first?.id ?? UUID()
    }

    var title: String {
        panes.first?.title ?? "Terminal"
    }

    static func == (lhs: TerminalTab, rhs: TerminalTab) -> Bool {
        lhs.id == rhs.id
    }
}

class TerminalWorkspace: ObservableObject {
    static let shared = TerminalWorkspace()

    @Published var tabs: [TerminalTab] = []
    @Published var activeTabId: UUID?

    var activeTabIndex: Int? {
        guard let id = activeTabId else { return nil }
        return tabs.firstIndex(where: { $0.id == id })
    }

    var activeTab: TerminalTab? {
        guard let idx = activeTabIndex else { return nil }
        return tabs[idx]
    }

    var activePane: TerminalManager? {
        guard let tab = activeTab else { return nil }
        return tab.panes.first(where: { $0.id == tab.activePaneId }) ?? tab.panes.first
    }

    init() {
        addTab() // start with one
    }

    func addTab() {
        let term = TerminalManager()
        term.title = "Terminal \(tabs.count + 1)"
        let tab = TerminalTab(panes: [term])
        tabs.append(tab)
        activeTabId = tab.id
    }

    func closeTab(id: UUID) {
        guard let idx = tabs.firstIndex(where: { $0.id == id }) else { return }
        for pane in tabs[idx].panes {
            pane.disconnect()
        }
        tabs.remove(at: idx)
        if activeTabId == id {
            activeTabId = tabs.last?.id
        }
    }

    func setActivePane(_ paneId: UUID, in tabId: UUID) {
        guard let tabIndex = tabs.firstIndex(where: { $0.id == tabId }) else { return }
        tabs[tabIndex].activePaneId = paneId
    }

    func toggleSplitActiveTab() {
        guard let tabId = activeTabId else { return }
        guard let idx = tabs.firstIndex(where: { $0.id == tabId }) else { return }

        if tabs[idx].panes.count <= 1 {
            // Split: add a second pane (max 2 panes for now)
            let newPane = TerminalManager()
            newPane.title = "Terminal \(tabs.count).2"
            tabs[idx].panes.append(newPane)
            tabs[idx].activePaneId = newPane.id
        } else {
            // Unsplit: remove all panes except the first
            let extraPanes = tabs[idx].panes.dropFirst()
            for pane in extraPanes {
                pane.disconnect()
            }
            tabs[idx].panes = Array(tabs[idx].panes.prefix(1))
            tabs[idx].activePaneId = tabs[idx].panes.first?.id ?? tabs[idx].activePaneId
        }
    }

    func killActive() {
        guard let tabId = activeTabId else { return }
        guard let tabIndex = tabs.firstIndex(where: { $0.id == tabId }) else { return }

        let paneId = tabs[tabIndex].activePaneId
        if tabs[tabIndex].panes.count > 1 {
            // If split, kill the active pane only.
            if let paneIndex = tabs[tabIndex].panes.firstIndex(where: { $0.id == paneId }) {
                tabs[tabIndex].panes[paneIndex].disconnect()
                tabs[tabIndex].panes.remove(at: paneIndex)
            }
            tabs[tabIndex].activePaneId = tabs[tabIndex].panes.first?.id ?? tabs[tabIndex].activePaneId

            if tabs[tabIndex].panes.isEmpty {
                closeTab(id: tabId)
            }
        } else {
            // If not split, kill the tab.
            closeTab(id: tabId)
        }
    }
}

// MARK: - Terminal Manager

class TerminalManager: ObservableObject, Identifiable {
    let id = UUID()
    @Published var title: String = "Terminal"
    
    @Published var output: [TerminalLine] = [
        TerminalLine(text: "VSCode iPadOS Terminal v1.1", type: .system),
        TerminalLine(text: "Type 'help' for commands or connect via SSH.", type: .system),
        TerminalLine(text: "", type: .output)
    ]
    @Published var isConnected = false
    @Published var isConnecting = false
    @Published var connectionStatus = "Not connected"
    @Published var promptString = "$ "
    
    private var sshClient: SSHClient?
    private var currentConnection: SSHConnection?
    private var commandHistory: [String] = []
    private var historyIndex = 0
    
    func clear() {
        output = []
    }
    
    func connect(to connection: SSHConnection) {
        currentConnection = connection
        isConnecting = true
        connectionStatus = "Connecting to \(connection.host)..."
        title = "\(connection.username)@\(connection.host)"
        
        appendOutput("Connecting to \(connection.username)@\(connection.host):\(connection.port)...", type: .system)
        
        sshClient = SSHClient(connection: connection)
        sshClient?.delegate = self
        sshClient?.connect()
    }
    
    func disconnect() {
        sshClient?.disconnect()
        sshClient = nil
        isConnected = false
        isConnecting = false
        connectionStatus = "Disconnected"
        promptString = "$ "
        title = "Terminal (Disconnected)"
        appendOutput("Disconnected from server.", type: .system)
    }
    
    func executeCommand(_ command: String) {
        commandHistory.append(command)
        historyIndex = commandHistory.count
        
        appendOutput(promptString + command, type: .command)
        
        if isConnected {
            sshClient?.send(command: command)
        } else {
            processLocalCommand(command)
        }
    }
    
    func sendInterrupt() {
        if isConnected {
            sshClient?.sendInterrupt()
        }
        appendOutput("^C", type: .system)
    }
    
    func sendTab() {
        if isConnected {
            sshClient?.sendTab()
        }
    }
    
    // ... (Previous command history methods preserved but omitted for brevity if unused)
    
    private func processLocalCommand(_ command: String) {
        let parts = command.split(separator: " ", maxSplits: 1)
        guard let cmd = parts.first?.lowercased() else { return }
        
        switch cmd {
        case "help":
            appendOutput("""
            Local Commands:
              help              - Show this help
              clear             - Clear terminal
              echo <text>       - Echo text
              date              - Show current date
              whoami            - Show current user
              history           - Show command history
            """, type: .output)
            
        case "clear":
            clear()
            
        case "echo":
            let text = parts.count > 1 ? String(parts[1]) : ""
            appendOutput(text, type: .output)
            
        case "date":
             appendOutput(Date().description, type: .output)
            
        case "whoami":
            appendOutput("ipad-user", type: .output)
            
        case "history":
            for (index, cmd) in commandHistory.enumerated() {
                appendOutput("  \(index + 1)  \(cmd)", type: .output)
            }
            
        default:
            appendOutput("\(cmd): command not found (local mode)", type: .error)
        }
    }
    
    func appendOutput(_ text: String, type: LineType, isANSI: Bool = false) {
        DispatchQueue.main.async {
            self.output.append(TerminalLine(text: text, type: type, isANSI: isANSI))
        }
    }
}

// MARK: - SSH Client Delegate
extension TerminalManager: SSHClientDelegate {
    func sshClientDidConnect(_ client: SSHClient) {
        DispatchQueue.main.async {
            self.isConnected = true
            self.isConnecting = false
            self.connectionStatus = "Connected"
            self.promptString = "\(self.currentConnection?.username ?? "user")@\(self.currentConnection?.host ?? "host"):~$ "
            self.appendOutput("Connected successfully!", type: .system)
        }
    }
    
    func sshClientDidDisconnect(_ client: SSHClient, error: Error?) {
        DispatchQueue.main.async {
            self.isConnected = false
            self.isConnecting = false
            self.connectionStatus = "Disconnected"
            self.promptString = "$ "
            if let error = error {
                self.appendOutput("Connection error: \(error.localizedDescription)", type: .error)
            }
        }
    }
    
    func sshClient(_ client: SSHClient, didReceiveOutput text: String) {
        appendOutput(text, type: .output, isANSI: text.contains("\u{1B}"))
    }
    
    func sshClient(_ client: SSHClient, didReceiveError text: String) {
        appendOutput(text, type: .error)
    }
}

// MARK: - SSH Connection View (Preserved)

struct SSHConnectionView: View {
    @ObservedObject var terminal: TerminalManager
    @Binding var isPresented: Bool
    
    @State private var host = ""
    @State private var port = "22"
    @State private var username = ""
    @State private var password = ""
    @State private var useKey = false
    @State private var privateKey = ""
    
    var body: some View {
        NavigationView {
            Form {
                Section(header: Text("Connection Details")) {
                    TextField("Host", text: $host)
                        .autocapitalization(.none)
                        .disableAutocorrection(true)
                    TextField("Port", text: $port)
                        .keyboardType(.numberPad)
                    TextField("Username", text: $username)
                        .autocapitalization(.none)
                        .disableAutocorrection(true)
                }
                
                Section(header: Text("Authentication")) {
                    Toggle("Use SSH Key", isOn: $useKey)
                    if useKey {
                        TextEditor(text: $privateKey)
                            .frame(height: 100)
                    } else {
                        SecureField("Password", text: $password)
                    }
                }
                
                Button(action: connect) {
                     if terminal.isConnecting {
                         ProgressView()
                     } else {
                         Text("Connect")
                     }
                }
                .disabled(host.isEmpty || username.isEmpty)
            }
            .navigationTitle("SSH Connection")
            .toolbar {
                ToolbarItem(placement: .cancellationAction) {
                    Button("Cancel") { isPresented = false }
                }
            }
        }
    }
    
    private func connect() {
        let connection = SSHConnection(
            host: host,
            port: Int(port) ?? 22,
            username: username,
            password: useKey ? nil : password,
            privateKey: useKey ? privateKey : nil
        )
        terminal.connect(to: connection)
        isPresented = false
    }
}

// MARK: - Models & Helpers

struct SSHConnection {
    let host: String
    let port: Int
    let username: String
    let password: String?
    let privateKey: String?
}

struct TerminalLine: Identifiable {
    let id = UUID()
    let text: String
    let type: LineType
    var isANSI: Bool = false
}

enum LineType {
    case command
    case output
    case error
    case system
    case prompt
}

struct ANSIText: View {
    let text: String
    @ObservedObject private var themeManager = ThemeManager.shared
    
    init(_ text: String) {
        self.text = text
    }
    
    var body: some View {
        Text(stripANSI(text))
            .font(.system(.body, design: .monospaced))
            .foregroundColor(themeManager.currentTheme.editorForeground)
            .textSelection(.enabled)
    }
    
    private func stripANSI(_ text: String) -> String {
        let pattern = "\u{1B}\\[[0-9;]*[a-zA-Z]"
        guard let regex = try? NSRegularExpression(pattern: pattern) else { return text }
        let range = NSRange(text.startIndex..., in: text)
        return regex.stringByReplacingMatches(in: text, range: range, withTemplate: "")
    }
}

// MARK: - SSH Client (Stub implementation for demo)
protocol SSHClientDelegate: AnyObject {
    func sshClientDidConnect(_ client: SSHClient)
    func sshClientDidDisconnect(_ client: SSHClient, error: Error?)
    func sshClient(_ client: SSHClient, didReceiveOutput text: String)
    func sshClient(_ client: SSHClient, didReceiveError text: String)
}

class SSHClient {
    weak var delegate: SSHClientDelegate?
    private let connection: SSHConnection
    private var nwConnection: NWConnection?
    
    init(connection: SSHConnection) {
        self.connection = connection
    }
    
    func connect() {
        let host = NWEndpoint.Host(connection.host)
        let port = NWEndpoint.Port(integerLiteral: UInt16(connection.port))
        nwConnection = NWConnection(host: host, port: port, using: .tcp)
        
        nwConnection?.stateUpdateHandler = { [weak self] state in
            guard let self = self else { return }
            if case .ready = state {
                self.delegate?.sshClientDidConnect(self)
            }
        }
        nwConnection?.start(queue: .global())
    }
    
    func disconnect() {
        nwConnection?.cancel()
        nwConnection = nil
    }
    
    func send(command: String) {
         let data = (command + "\n").data(using: .utf8)!
         nwConnection?.send(content: data, completion: .contentProcessed { error in
             if let error = error { print(error) }
         })
    }
    
    func sendInterrupt() {}
    func sendTab() {}
}
