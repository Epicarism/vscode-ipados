//
//  NavigationManager.swift
//  VSCodeiPadOS
//
//  Go to Definition support - simplified for iOS 15+
//

import Foundation
import SwiftUI

// MARK: - Symbol Location Model

/// Represents a location in a source file
struct SymbolLocation: Identifiable, Equatable, Hashable {
    let id = UUID()
    let file: String
    let fileName: String
    let line: Int
    let column: Int
    let endLine: Int?
    let endColumn: Int?
    
    init(file: String, line: Int, column: Int = 1, endLine: Int? = nil, endColumn: Int? = nil) {
        self.file = file
        self.fileName = (file as NSString).lastPathComponent
        self.line = line
        self.column = column
        self.endLine = endLine
        self.endColumn = endColumn
    }
    
    var displayString: String {
        "\(fileName):\(line):\(column)"
    }
}

// MARK: - Symbol Definition Model

struct SymbolDefinition: Identifiable, Equatable {
    let id = UUID()
    let name: String
    let kind: SymbolKind
    let location: SymbolLocation
    let signature: String?
    let documentation: String?
    let containerName: String?
    
    static func == (lhs: SymbolDefinition, rhs: SymbolDefinition) -> Bool {
        lhs.name == rhs.name && lhs.location == rhs.location
    }
}

// MARK: - Symbol Kind

enum SymbolKind: String, CaseIterable {
    case function = "function"
    case method = "method"
    case property = "property"
    case variable = "variable"
    case constant = "constant"
    case `class` = "class"
    case `struct` = "struct"
    case `enum` = "enum"
    case enumCase = "enumCase"
    case `protocol` = "protocol"
    case interface = "interface"
    case type = "type"
    case namespace = "namespace"
    case module = "module"
    case field = "field"
    case constructor = "constructor"
    case parameter = "parameter"
    case typeParameter = "typeParameter"
    case unknown = "unknown"
    
    var icon: String {
        switch self {
        case .function, .method: return "f.square"
        case .property, .field: return "p.square"
        case .variable: return "v.square"
        case .constant: return "c.square"
        case .class: return "c.square.fill"
        case .struct: return "s.square.fill"
        case .enum, .enumCase: return "e.square.fill"
        case .protocol, .interface: return "i.square"
        case .type, .typeParameter: return "t.square"
        case .namespace, .module: return "n.square"
        case .constructor: return "hammer"
        case .parameter: return "arrow.right"
        case .unknown: return "questionmark.square"
        }
    }
    
    var color: Color {
        switch self {
        case .function, .method: return .purple
        case .property, .field, .variable: return .blue
        case .constant: return .cyan
        case .class, .struct: return .orange
        case .enum, .enumCase: return .yellow
        case .protocol, .interface: return .green
        case .type, .typeParameter: return .teal
        case .namespace, .module: return .indigo
        case .constructor: return .pink
        case .parameter: return .gray
        case .unknown: return .secondary
        }
    }
}

// MARK: - Navigation History

struct NavigationHistoryEntry: Equatable {
    let location: SymbolLocation
    let timestamp: Date
    
    init(location: SymbolLocation) {
        self.location = location
        self.timestamp = Date()
    }
}

// MARK: - Navigation Manager

class NavigationManager: ObservableObject {
    static let shared = NavigationManager()
    
    @Published var symbolTable: [String: [SymbolDefinition]] = [:]
    @Published var currentFileSymbols: [SymbolDefinition] = []
    @Published var isShowingDefinitions = false
    @Published var definitionsToShow: [SymbolDefinition] = []
    @Published var peekLocation: SymbolLocation? = nil
    
    private var navigationHistory: [NavigationHistoryEntry] = []
    private var historyIndex: Int = -1
    private let maxHistorySize = 50
    
    private init() {}
    
    // MARK: - Symbol Indexing
    
    func parseAndIndexFile(content: String, file: String, language: String) {
        var symbols: [SymbolDefinition] = []
        let lines = content.components(separatedBy: .newlines)
        
        // Simple regex-based symbol extraction
        for (lineIndex, line) in lines.enumerated() {
            let lineNum = lineIndex + 1
            
            // Function detection
            if let match = line.range(of: "func\\s+(\\w+)", options: .regularExpression) {
                let funcName = String(line[match]).replacingOccurrences(of: "func ", with: "")
                let location = SymbolLocation(file: file, line: lineNum, column: 1)
                let def = SymbolDefinition(name: funcName, kind: .function, location: location, signature: String(line), documentation: nil, containerName: nil)
                symbols.append(def)
            }
            
            // Class detection
            if let match = line.range(of: "class\\s+(\\w+)", options: .regularExpression) {
                let className = String(line[match]).replacingOccurrences(of: "class ", with: "")
                let location = SymbolLocation(file: file, line: lineNum, column: 1)
                let def = SymbolDefinition(name: className, kind: .class, location: location, signature: String(line), documentation: nil, containerName: nil)
                symbols.append(def)
            }
            
            // Struct detection
            if let match = line.range(of: "struct\\s+(\\w+)", options: .regularExpression) {
                let structName = String(line[match]).replacingOccurrences(of: "struct ", with: "")
                let location = SymbolLocation(file: file, line: lineNum, column: 1)
                let def = SymbolDefinition(name: structName, kind: .struct, location: location, signature: String(line), documentation: nil, containerName: nil)
                symbols.append(def)
            }
            
            // Enum detection
            if let match = line.range(of: "enum\\s+(\\w+)", options: .regularExpression) {
                let enumName = String(line[match]).replacingOccurrences(of: "enum ", with: "")
                let location = SymbolLocation(file: file, line: lineNum, column: 1)
                let def = SymbolDefinition(name: enumName, kind: .enum, location: location, signature: String(line), documentation: nil, containerName: nil)
                symbols.append(def)
            }
        }
        
        symbolTable[file] = symbols
        if file == currentFileSymbols.first?.location.file || currentFileSymbols.isEmpty {
            currentFileSymbols = symbols
        }
    }
    
    // MARK: - Navigation
    
    func goToDefinition(for symbol: String, in file: String) -> SymbolLocation? {
        // Search in current file first
        if let symbols = symbolTable[file] {
            if let def = symbols.first(where: { $0.name == symbol }) {
                return def.location
            }
        }
        
        // Search in all files
        for (_, symbols) in symbolTable {
            if let def = symbols.first(where: { $0.name == symbol }) {
                return def.location
            }
        }
        
        return nil
    }
    
    func findDefinitions(for symbol: String) -> [SymbolDefinition] {
        var results: [SymbolDefinition] = []
        
        for (_, symbols) in symbolTable {
            let matches = symbols.filter { $0.name == symbol }
            results.append(contentsOf: matches)
        }
        
        return results
    }
    
    func showDefinitions(_ definitions: [SymbolDefinition]) {
        definitionsToShow = definitions
        isShowingDefinitions = true
    }
    
    // MARK: - History Navigation
    
    func pushLocation(_ location: SymbolLocation) {
        // Remove any forward history
        if historyIndex < navigationHistory.count - 1 {
            navigationHistory = Array(navigationHistory.prefix(historyIndex + 1))
        }
        
        // Add new entry
        let entry = NavigationHistoryEntry(location: location)
        navigationHistory.append(entry)
        historyIndex = navigationHistory.count - 1
        
        // Trim if too large
        if navigationHistory.count > maxHistorySize {
            navigationHistory.removeFirst()
            historyIndex -= 1
        }
    }
    
    func goBack() -> SymbolLocation? {
        guard historyIndex > 0 else { return nil }
        historyIndex -= 1
        return navigationHistory[historyIndex].location
    }
    
    func goForward() -> SymbolLocation? {
        guard historyIndex < navigationHistory.count - 1 else { return nil }
        historyIndex += 1
        return navigationHistory[historyIndex].location
    }
    
    var canNavigateBack: Bool {
        historyIndex > 0
    }
    
    var canNavigateForward: Bool {
        historyIndex < navigationHistory.count - 1
    }
}

// MARK: - EditorCore Extension

extension EditorCore {
    func navigateBack() {
        if let location = NavigationManager.shared.goBack() {
            navigateToLocation(location)
        }
    }
    
    func navigateForward() {
        if let location = NavigationManager.shared.goForward() {
            navigateToLocation(location)
        }
    }
    
    func goToDefinitionAtCursor() {
        guard let tab = activeTab else { return }
        
        // Get word at cursor
        let content = tab.content
        let lines = content.components(separatedBy: .newlines)
        guard cursorPosition.line < lines.count else { return }
        
        let line = lines[cursorPosition.line]
        guard let word = extractWordAtColumn(line: line, column: cursorPosition.column) else { return }
        
        // Find definitions
        let definitions = NavigationManager.shared.findDefinitions(for: word)
        
        if definitions.count == 1, let def = definitions.first {
            // Navigate directly
            NavigationManager.shared.pushLocation(SymbolLocation(file: tab.fileName, line: cursorPosition.line + 1, column: cursorPosition.column + 1))
            navigateToLocation(def.location)
        } else if definitions.count > 1 {
            // Show picker
            NavigationManager.shared.showDefinitions(definitions)
        }
    }
    
    func peekDefinitionAtCursor() {
        guard let tab = activeTab else { return }
        
        let content = tab.content
        let lines = content.components(separatedBy: .newlines)
        guard cursorPosition.line < lines.count else { return }
        
        let line = lines[cursorPosition.line]
        guard let word = extractWordAtColumn(line: line, column: cursorPosition.column) else { return }
        
        if let location = NavigationManager.shared.goToDefinition(for: word, in: tab.fileName) {
            NavigationManager.shared.peekLocation = location
        }
    }
    
    func navigateToLocation(_ location: SymbolLocation) {
        // Find or open the file
        if let tab = tabs.first(where: { $0.fileName == location.fileName }) {
            activeTabId = tab.id
        } else {
            // File not open, try to open it
            let url = URL(fileURLWithPath: location.file)
            if FileManager.default.fileExists(atPath: url.path) {
                openFile(from: url)
            }
        }
        
        // Move cursor
        cursorPosition = CursorPosition(line: location.line - 1, column: location.column - 1)
    }
    
    private func extractWordAtColumn(line: String, column: Int) -> String? {
        let chars = Array(line)
        guard column >= 0 && column <= chars.count else { return nil }
        
        var start = column
        var end = column
        
        let wordChars = CharacterSet.alphanumerics.union(CharacterSet(charactersIn: "_"))
        
        while start > 0 && chars[start - 1].unicodeScalars.allSatisfy({ wordChars.contains($0) }) {
            start -= 1
        }
        
        while end < chars.count && chars[end].unicodeScalars.allSatisfy({ wordChars.contains($0) }) {
            end += 1
        }
        
        guard start < end else { return nil }
        
        return String(chars[start..<end])
    }
}
